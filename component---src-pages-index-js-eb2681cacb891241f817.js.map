{"version":3,"sources":["webpack:///component---src-pages-index-js-eb2681cacb891241f817.js","webpack:///./~/lodash/_root.js","webpack:///./~/lodash/isArray.js","webpack:///./~/lodash/_getNative.js","webpack:///./~/lodash/_baseGetTag.js","webpack:///./~/lodash/isObjectLike.js","webpack:///./~/process/browser.js","webpack:///./~/lodash/_ListCache.js","webpack:///./~/lodash/_Symbol.js","webpack:///./~/lodash/_assocIndexOf.js","webpack:///./~/lodash/_getMapData.js","webpack:///./~/lodash/_nativeCreate.js","webpack:///./~/lodash/_toKey.js","webpack:///./~/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js","webpack:///./~/lodash/_Map.js","webpack:///./~/lodash/_MapCache.js","webpack:///./~/lodash/_baseIsEqual.js","webpack:///./~/lodash/_isKey.js","webpack:///./~/lodash/isLength.js","webpack:///./~/lodash/isObject.js","webpack:///./~/lodash/isSymbol.js","webpack:///./~/lodash/keys.js","webpack:///./~/tiny-invariant/dist/tiny-invariant.cjs.js","webpack:///./~/tiny-warning/dist/tiny-warning.cjs.js","webpack:///(webpack)/buildin/module.js","webpack:///./~/lodash/_Stack.js","webpack:///./~/lodash/_baseGet.js","webpack:///./~/lodash/_castPath.js","webpack:///./~/lodash/_equalArrays.js","webpack:///./~/lodash/_freeGlobal.js","webpack:///./~/lodash/_isIndex.js","webpack:///./~/lodash/_isStrictComparable.js","webpack:///./~/lodash/_matchesStrictComparable.js","webpack:///./~/lodash/_toSource.js","webpack:///./~/lodash/eq.js","webpack:///./~/lodash/isArguments.js","webpack:///./~/lodash/isArrayLike.js","webpack:///./~/lodash/isBuffer.js","webpack:///./~/lodash/isFunction.js","webpack:///./~/lodash/isTypedArray.js","webpack:///./src/pages/index.js","webpack:///./~/chart.js/dist/Chart.js","webpack:///./~/lodash/_DataView.js","webpack:///./~/lodash/_Hash.js","webpack:///./~/lodash/_Promise.js","webpack:///./~/lodash/_Set.js","webpack:///./~/lodash/_SetCache.js","webpack:///./~/lodash/_Uint8Array.js","webpack:///./~/lodash/_WeakMap.js","webpack:///./~/lodash/_arrayAggregator.js","webpack:///./~/lodash/_arrayFilter.js","webpack:///./~/lodash/_arrayLikeKeys.js","webpack:///./~/lodash/_arrayMap.js","webpack:///./~/lodash/_arrayPush.js","webpack:///./~/lodash/_arraySome.js","webpack:///./~/lodash/_baseAggregator.js","webpack:///./~/lodash/_baseAssignValue.js","webpack:///./~/lodash/_baseEach.js","webpack:///./~/lodash/_baseFor.js","webpack:///./~/lodash/_baseForOwn.js","webpack:///./~/lodash/_baseGetAllKeys.js","webpack:///./~/lodash/_baseHasIn.js","webpack:///./~/lodash/_baseIsArguments.js","webpack:///./~/lodash/_baseIsEqualDeep.js","webpack:///./~/lodash/_baseIsMatch.js","webpack:///./~/lodash/_baseIsNative.js","webpack:///./~/lodash/_baseIsTypedArray.js","webpack:///./~/lodash/_baseIteratee.js","webpack:///./~/lodash/_baseKeys.js","webpack:///./~/lodash/_baseMatches.js","webpack:///./~/lodash/_baseMatchesProperty.js","webpack:///./~/lodash/_baseProperty.js","webpack:///./~/lodash/_basePropertyDeep.js","webpack:///./~/lodash/_baseTimes.js","webpack:///./~/lodash/_baseToString.js","webpack:///./~/lodash/_baseUnary.js","webpack:///./~/lodash/_cacheHas.js","webpack:///./~/lodash/_coreJsData.js","webpack:///./~/lodash/_createAggregator.js","webpack:///./~/lodash/_createBaseEach.js","webpack:///./~/lodash/_createBaseFor.js","webpack:///./~/lodash/_defineProperty.js","webpack:///./~/lodash/_equalByTag.js","webpack:///./~/lodash/_equalObjects.js","webpack:///./~/lodash/_getAllKeys.js","webpack:///./~/lodash/_getMatchData.js","webpack:///./~/lodash/_getRawTag.js","webpack:///./~/lodash/_getSymbols.js","webpack:///./~/lodash/_getTag.js","webpack:///./~/lodash/_getValue.js","webpack:///./~/lodash/_hasPath.js","webpack:///./~/lodash/_hashClear.js","webpack:///./~/lodash/_hashDelete.js","webpack:///./~/lodash/_hashGet.js","webpack:///./~/lodash/_hashHas.js","webpack:///./~/lodash/_hashSet.js","webpack:///./~/lodash/_isKeyable.js","webpack:///./~/lodash/_isMasked.js","webpack:///./~/lodash/_isPrototype.js","webpack:///./~/lodash/_listCacheClear.js","webpack:///./~/lodash/_listCacheDelete.js","webpack:///./~/lodash/_listCacheGet.js","webpack:///./~/lodash/_listCacheHas.js","webpack:///./~/lodash/_listCacheSet.js","webpack:///./~/lodash/_mapCacheClear.js","webpack:///./~/lodash/_mapCacheDelete.js","webpack:///./~/lodash/_mapCacheGet.js","webpack:///./~/lodash/_mapCacheHas.js","webpack:///./~/lodash/_mapCacheSet.js","webpack:///./~/lodash/_mapToArray.js","webpack:///./~/lodash/_memoizeCapped.js","webpack:///./~/lodash/_nativeKeys.js","webpack:///./~/lodash/_nodeUtil.js","webpack:///./~/lodash/_objectToString.js","webpack:///./~/lodash/_overArg.js","webpack:///./~/lodash/_setCacheAdd.js","webpack:///./~/lodash/_setCacheHas.js","webpack:///./~/lodash/_setToArray.js","webpack:///./~/lodash/_stackClear.js","webpack:///./~/lodash/_stackDelete.js","webpack:///./~/lodash/_stackGet.js","webpack:///./~/lodash/_stackHas.js","webpack:///./~/lodash/_stackSet.js","webpack:///./~/lodash/_stringToPath.js","webpack:///./~/lodash/get.js","webpack:///./~/lodash/hasIn.js","webpack:///./~/lodash/identity.js","webpack:///./~/lodash/isEqual.js","webpack:///./~/lodash/keyBy.js","webpack:///./~/lodash/memoize.js","webpack:///./~/lodash/property.js","webpack:///./~/lodash/stubArray.js","webpack:///./~/lodash/stubFalse.js","webpack:///./~/lodash/toString.js","webpack:///./~/moment/moment.js","webpack:///./~/react-chartjs-2/lib/index.js"],"names":["webpackJsonp","module","exports","__webpack_require__","freeGlobal","freeSelf","self","Object","root","Function","isArray","Array","getNative","object","key","value","getValue","baseIsNative","undefined","baseGetTag","undefinedTag","nullTag","symToStringTag","getRawTag","objectToString","Symbol","toStringTag","isObjectLike","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","e","call","this","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","length","queue","concat","queueIndex","drainQueue","timeout","len","run","Item","array","noop","process","nextTick","args","arguments","i","push","prototype","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","ListCache","entries","index","clear","entry","set","listCacheClear","listCacheDelete","listCacheGet","listCacheHas","listCacheSet","get","has","assocIndexOf","eq","getMapData","map","data","__data__","isKeyable","nativeCreate","toKey","isSymbol","result","INFINITY","hoistNonReactStatics","targetComponent","sourceComponent","blacklist","objectPrototype","inheritedComponent","getPrototypeOf","keys","getOwnPropertyNames","getOwnPropertySymbols","REACT_STATICS","KNOWN_STATICS","descriptor","getOwnPropertyDescriptor","defineProperty","childContextTypes","contextTypes","defaultProps","displayName","getDefaultProps","getDerivedStateFromProps","mixins","propTypes","type","caller","callee","arity","Map","MapCache","mapCacheClear","mapCacheDelete","mapCacheGet","mapCacheHas","mapCacheSet","baseIsEqual","other","bitmask","customizer","stack","baseIsEqualDeep","isKey","reIsPlainProp","test","reIsDeepProp","isLength","MAX_SAFE_INTEGER","isObject","symbolTag","isArrayLike","arrayLikeKeys","baseKeys","invariant","condition","message","isProduction","prefix","warning","text","console","warn","x","webpackPolyfill","deprecate","paths","children","Stack","size","stackClear","stackDelete","stackGet","stackHas","stackSet","baseGet","path","castPath","stringToPath","toString","equalArrays","equalFunc","isPartial","COMPARE_PARTIAL_FLAG","arrLength","othLength","stacked","seen","COMPARE_UNORDERED_FLAG","SetCache","arrValue","othValue","compared","arraySome","othIndex","cacheHas","global","isIndex","reIsUint","isStrictComparable","matchesStrictComparable","srcValue","toSource","func","funcToString","funcProto","baseIsArguments","objectProto","hasOwnProperty","propertyIsEnumerable","isArguments","isFunction","stubFalse","freeExports","nodeType","freeModule","moduleExports","Buffer","nativeIsBuffer","isBuffer","tag","funcTag","genTag","asyncTag","proxyTag","baseIsTypedArray","baseUnary","nodeUtil","nodeIsTypedArray","isTypedArray","_interopRequireDefault","obj","__esModule","default","_react","_react2","_gatsbyLink","_reactChartjs","_reactChartjs2","chartOptions","responsive","legend","display","animation","duration","easing","labels","layout","padding","top","bottom","tooltips","callbacks","label","tooltipItem","total","datasets","reduce","a","b","datasetIndex","Math","abs","round","pieceLabel","render","fontFamily","fontSize","position","textMargin","chartData","backgroundColor","IndexPage","createElement","options","factory","moment","rgb2hsl","rgb","h","s","l","r","g","min","max","delta","rgb2hsv","v","rgb2hwb","w","rgb2cmyk","c","m","y","k","rgb2keyword","reverseKeywords","JSON","stringify","rgb2xyz","pow","z","rgb2lab","xyz","rgb2lch","lab2lch","hsl2rgb","hsl","t1","t2","t3","val","hsl2hsv","sv","hsl2hwb","hsl2cmyk","hsl2keyword","hsv2rgb","hsv","hi","floor","f","p","q","t","hsv2hsl","sl","hsv2hwb","hsv2cmyk","hsv2keyword","hwb2rgb","hwb","n","wh","bl","ratio","hwb2hsl","hwb2hsv","hwb2cmyk","hwb2keyword","cmyk2rgb","cmyk","cmyk2hsl","cmyk2hsv","cmyk2hwb","cmyk2keyword","xyz2rgb","xyz2lab","xyz2lch","lab2xyz","lab","y2","hr","atan2","PI","sqrt","lab2rgb","lch2lab","lch","cos","sin","lch2xyz","lch2rgb","keyword2rgb","keyword","cssKeywords","keyword2hsl","keyword2hsv","keyword2hwb","keyword2cmyk","keyword2lab","keyword2xyz","getRgba","string","abbr","hex","rgba","per","match","hexAlpha","parseInt","slice","parseFloat","colorName","scale","getHsla","alpha","isNaN","getHwb","getRgb","getHsl","hsla","getAlpha","vals","hexString","hexDouble","rgbString","rgbaString","percentString","percentaString","hslString","hslaString","hwbString","reverseNames","num","str","toUpperCase","toFontString","font","helpers_core","isNullOrUndef","family","style","weight","interpolate","start","view","model","ease","ilen","actual","origin","target","c0","c1","chartjsColor","valid","mix","helpers$1","isFinite","listenArrayEvents","listener","_chartjs","configurable","enumerable","arrayEvents","forEach","method","charAt","base","res","each","unlistenArrayEvents","stub","indexOf","splice","xRange","mouseX","vm","_view","radius","hitRadius","yRange","mouseY","isVertical","width","getBarBounds","x1","x2","y1","half","height","left","right","swap","orig","v1","v2","parseBorderSkipped","edge","borderSkipped","horizontal","parseBorderWidth","maxW","maxH","borderWidth","skip","boundingRects","bounds","border","outer","inner","inRange","skipX","skipY","computeMinSampleSize","pixels","prev","curr","isHorizontal","ticks","getTicks","getPixelForTick","computeFitCategoryTraits","ruler","thickness","barThickness","count","stackCount","categoryPercentage","barPercentage","chunk","computeFlexCategoryTraits","next","percent","end","lineEnabled","dataset","valueOrDefault$5","showLine","showLines","getRelativePosition","chart","native","parseVisibleItems","handler","meta","j","jlen","isDatasetVisible","getDatasetMeta","element","getIntersectItems","elements","getNearestItems","intersect","distanceMetric","minDistance","Number","POSITIVE_INFINITY","nearestItems","center","getCenterPoint","distance","getDistanceMetricForAxis","axis","useX","useY","pt1","pt2","deltaX","deltaY","indexMode","items","_index","filterByPosition","where","sortByWeight","reverse","_tmpIndex_","sort","v0","findMaxPadding","boxes","box","getPadding","boxPadding","addSizeByPosition","getCjsExportFromNamespace","readUsedSize","property","getStyle","matches","initCanvas","canvas","config","renderHeight","getAttribute","renderWidth","EXPANDO_KEY","initial","displayWidth","aspectRatio","displayHeight","node","addEventListener","eventListenerOptions","removeEventListener","createEvent","nativeEvent","fromNativeEvent","event","EVENT_TYPES","pos","throttled","fn","thisArg","ticking","requestAnimFrame","window","createDiv","cls","el","document","className","createResizer","maxSize","resizer","CSS_SIZE_MONITOR","expand","shrink","appendChild","_reset","scrollLeft","scrollTop","onScroll","bind","watchForRender","expando","proxy","renderProxy","animationName","CSS_RENDER_ANIMATION","ANIMATION_START_EVENTS","reflow","offsetParent","classList","add","CSS_RENDER_MONITOR","unwatchForRender","remove","addResizeListener","container","maintainAspectRatio","parentNode","clientWidth","insertBefore","firstChild","removeResizeListener","removeChild","injectCSS","platform","css","_style","setAttribute","getElementsByTagName","createTextNode","pushOrConcat","toPush","splitNewlines","String","split","createTooltipItem","xScale","_xScale","yScale","_yScale","_scale","_datasetIndex","controller","_chart","indexScale","_getIndexScale","valueScale","_getValueScale","xLabel","getLabelForIndex","yLabel","_model","getBaseModel","tooltipOpts","globalDefaults","core_defaults","xPadding","yPadding","xAlign","yAlign","bodyFontColor","_bodyFontFamily","valueOrDefault$7","bodyFontFamily","defaultFontFamily","_bodyFontStyle","bodyFontStyle","defaultFontStyle","_bodyAlign","bodyAlign","bodyFontSize","defaultFontSize","bodySpacing","titleFontColor","_titleFontFamily","titleFontFamily","_titleFontStyle","titleFontStyle","titleFontSize","_titleAlign","titleAlign","titleSpacing","titleMarginBottom","footerFontColor","_footerFontFamily","footerFontFamily","_footerFontStyle","footerFontStyle","footerFontSize","_footerAlign","footerAlign","footerSpacing","footerMarginTop","caretSize","cornerRadius","opacity","legendColorBackground","multiKeyBackground","displayColors","borderColor","getTooltipSize","tooltip","ctx","body","combinedBodyLength","bodyItem","before","lines","after","beforeBody","afterBody","titleLineCount","footerLineCount","footer","widthPadding","maxLineWidth","line","measureText","fontString","determineAlignment","chartArea","lf","rf","olf","orf","yf","midX","midY","caretPadding","opts","_options","getBackgroundPoint","alignment","paddingAndSize","radiusAndPadding","getAlignedX","align","getBeforeAfterBodyLines","callback","mergeScaleConfig","merge","merger","source","slen","valueOrDefault$8","core_scaleService","getScaleDefaults","_merger","mergeConfig","tval","sval","initConfig","updateConfig","newOptions","scales","core_layouts","removeBox","ensureScalesHaveIDs","buildOrUpdateScales","initialize","positionIsHorizontal","abstract","DateAdapter","labelsFromTicks","getPixelForGridLine","offsetGridLines","lineValue","computeTextSize","context","tick","longestText","generateTicks","generationOptions","dataRange","factor","niceMin","niceMax","numSpaces","MIN_SPACING","stepSize","unit","maxNumSpaces","maxTicks","precision","rmin","rmax","spacing","niceNum","ceil","_decimalPlaces","almostWhole","almostEquals","generateTicks$1","exp","significand","tickVal","valueOrDefault$a","log10","endExp","endSignificand","minNotZero","lastTick","nonNegativeOrDefault","defaultValue","getValueCount","angleLines","pointLabels","getTickBackdropHeight","tickOpts","valueOrDefault$b","backdropPaddingY","measureLabelSize","lineHeight","determineLimits","angle","fitWithPointLabels","textSize","pointPosition","plFont","_parseFont","furthestLimits","paddingTop","furthestAngles","_pointLabelSizes","valueCount","getPointPosition","drawingArea","angleRadians","getIndexAngle","toDegrees","hLimits","vLimits","setReductions","getTextAlignForAngle","fillText","adjustPointPositionForLabelHeight","drawPointLabels","angleLineOpts","gridLineOpts","gridLines","pointLabelOpts","lineWidth","lineColor","color","tickBackdropHeight","save","strokeStyle","setLineDash","resolve$7","borderDash","lineDashOffset","borderDashOffset","outerDistance","getDistanceFromCenterForValue","textBaseline","outerPosition","beginPath","moveTo","xCenter","yCenter","lineTo","stroke","extra","pointLabelPosition","pointLabelFontColor","valueAtIndexOrDefault$1","fontColor","defaultFontColor","fillStyle","textAlign","restore","drawRadiusLine","circular","arc","closePath","numberOrZero","param","isNumber","sorter","arrayUnique","item","hash","out","buildLookupTable","timestamps","distribution","time","table","lookup","mid","i0","i1","lo","interpolate$1","skey","tkey","range","span","offset","toTimestamp","input","adapter","_adapter","parser","format","parse","getRightValue","startOf","determineStepSize","capacity","interval","INTERVALS","milliseconds","steps","determineUnitForAutoTicks","minUnit","UNITS","MAX_INTEGER","common","determineUnitForFormatting","diff","determineMajorUnit","generate","timeOpts","minor","major","valueOrDefault$c","unitStepSize","weekday","isoWeekday","majorTicksEnabled","enabled","first","last","computeOffsets","ticksFromTimestamps","values","majorUnit","decodeFill","fill","computeBoundary","scaleBottom","scaleTop","scaleZero","getBasePosition","getBasePixel","resolveTarget","sources","propagate","visited","visible","createMapper","mappers","isDrawable","point","drawArea","curve0","curve1","len0","len1","doFill","points","mapper","loop","p0","p1","d0","d1","spanGaps","getBoxWidth","labelOpts","usePointStyle","boxWidth","createNewLegendAndAttach","legendOpts","Legend","configure","addBox","createNewTitleBlockAndAttach","titleOpts","Title","titleBlock","conversions","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","convert","Converter","arg","pair","exec","from","to","convs","routeSpace","space","getValues","setValues","fspace","colorConvert","colorString","Color","lightness","whiteness","isValid","setSpace","rgbArray","hslArray","hsvArray","hwbArray","cmykArray","rgbaArray","hslaArray","setChannel","hue","saturation","saturationv","blackness","rgbNumber","luminosity","lum","chan","contrast","color2","lum1","lum2","level","contrastRatio","dark","yiq","light","negate","lighten","darken","saturate","desaturate","whiten","blacken","greyscale","clearer","opaquer","rotate","degrees","mixinColor","color1","w1","w2","toJSON","clone","prop","error","spaces","maxes","chans","capped","sname","svalues","helpers","uid","id","substr","valueOrDefault","valueAtIndexOrDefault","loopable","arrayEquals","a0","a1","klen","_mergerIf","mergeIf","extend","setFn","inherits","extensions","me","ChartElement","constructor","Surrogate","__super__","callCallback","fromIndex","getValueOrDefault","getValueAtIndexOrDefault","effects","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","asin","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","helpers_easing","easingEffects","RAD_PER_DEG","DOUBLE_PI","HALF_PI","QUARTER_PI","TWO_THIRDS_PI","exports$1","clearRect","roundedRect","rect","drawPoint","rotation","xOffset","yOffset","rad","drawImage","SQRT1_2","_isPointInArea","area","epsilon","clipArea","clip","unclipArea","previous","flip","stepped","steppedLine","midpoint","tension","bezierCurveTo","controlPointPreviousX","controlPointNextX","controlPointPreviousY","controlPointNextY","helpers_canvas","drawRoundedRectangle","defaults","_set","scope","defaultColor","defaultLineHeight","helpers_options","toLineHeight","toPadding","fontStyle","resolve","inputs","Element","configuration","hidden","pivot","_start","transition","tooltipPosition","hasValue","core_element","exports$2","currentStep","numSteps","onAnimationProgress","onAnimationComplete","core_animation","onProgress","onComplete","core_animations","animations","request","addAnimation","lazy","startTime","Date","now","animating","requestAnimationFrame","cancelAnimation","findIndex","startDigest","advance","nextStep","DatasetController","datasetElementType","dataElementType","linkScales","addElements","updateIndex","getMeta","getDataset","xAxisID","xAxes","yAxisID","yAxes","getScaleForId","scaleID","_getValueScaleId","_getIndexScaleId","reset","update","destroy","_data","createMetaDataset","createMetaData","metaData","addElementAndReset","updateElement","buildOrUpdateElements","isExtensible","resyncElements","easingValue","draw","removeHoverStyle","$previousStyle","setHoverStyle","custom","getHoverColor","hoverBackgroundColor","hoverBorderColor","hoverBorderWidth","numMeta","numData","insertElements","onDataPush","onDataPop","pop","onDataShift","shift","onDataSplice","onDataUnshift","core_datasetController","borderAlign","element_arc","inLabelRange","hoverRadius","chartX","chartY","pointRelativePosition","getAngleFromPoint","startAngle","endAngle","betweenAngles","withinRadius","innerRadius","outerRadius","halfAngle","halfRadius","getArea","centreAngle","rangeFromCentre","angleMargin","sA","eA","pixelMargin","lineJoin","valueOrDefault$1","borderCapStyle","borderJoinStyle","capBezierPoints","element_line","current","currentVM","_children","globalOptionLineElements","lastDrawnIndex","_loop","lineCap","previousItem","valueOrDefault$2","defaultColor$1","pointStyle","element_point","inXRange","inYRange","defaultColor$2","rectangle","element_rectangle","rects","fillRect","Arc","Line","Point","Rectangle","resolve$1","hover","mode","controller_bar","bar","_ruler","getRuler","_resolveElementOptions","datasetLabel","_updateElementGeometry","vscale","vpixels","calculateBarValuePixels","ipixels","calculateBarIndexPixels","head","_getStacks","stacks","getStackCount","getStackIndex","getPixelForValue","imeta","ivalue","minBarLength","stackIndex","maxBarThickness","Infinity","dataIndex","valueOrDefault$3","resolve$2","dataPoint","controller_bubble","dsIndex","getPixelForDecimal","NaN","resolve$3","valueOrDefault$4","animateRotate","animateScale","legendCallback","join","generateLabels","ds","arcOpts","bw","onClick","legendItem","cutoutPercentage","circumference","dataLabel","controller_doughnut","getRingIndex","ringIndex","availableWidth","availableHeight","minSize","arcs","chartWeight","_getRingWeight","contains0","contains90","contains180","contains270","cutout","getMaxBorderWidth","radiusLength","_getVisibleDatasetWeightTotal","offsetX","offsetY","calculateTotal","_getRingWeightOffset","animationOpts","centerX","centerY","calculateCircumference","hoverWidth","ringWeightOffset","dataSetIndex","controller_horizontalBar","resolve$4","isPointInArea","controller_line","lineTension","_resolveLineOptions","updateBezierControlPoints","lineModel","_resolvePointOptions","calculatePointY","ELEMENT_OPTIONS","elementOptions","dsMeta","sumPos","sumNeg","stackedRightValue","rightValue","capControlPoint","pt","controlPoints","filter","cubicInterpolationMode","splineCurveMonotone","splineCurve","nextItem","halfBorderWidth","resolve$5","beginAtZero","controller_polarArea","starts","_starts","angles","_angles","_updateRadius","countVisibleElements","_computeAngle","getVisibleDatasetCount","datasetStartAngle","resetRadius","doughnut","controller_pie","valueOrDefault$6","resolve$6","controller_radar","getPointPositionForValue","controller_scatter","controllers","bubble","horizontalBar","polarArea","pie","radar","scatter","core_interaction","modes","single","x-axis","nearest","intersectsItem","fullWidth","layoutItem","props","getMinimumBoxSize","chartWidth","maxChartAreaWidth","chartHeight","maxChartAreaHeight","verticalBoxWidth","minBoxSizes","fitBox","minBoxSize","findNextWhere","minBox","scaleMargin","outerBoxSizes","maxPadding","finalFitVerticalBox","placeBox","leftPadding","rightPadding","layoutOptions","topPadding","bottomPadding","leftBoxes","rightBoxes","topBoxes","bottomBoxes","chartAreaBoxes","verticalBoxes","horizontalBoxes","outerBoxes","chartAreaWidth","leftPaddingAddition","topPaddingAddition","newMaxChartAreaHeight","newMaxChartAreaWidth","platform_basic","acquireContext","getContext","platform_dom","platform_dom$1","freeze","stylesheet","CSS_PREFIX","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","supportsEventListenerOptions","supports","passive","platform_dom$2","disableCSSInjection","_enabled","_ensureLoaded","_loaded","getElementById","releaseContext","removeAttribute","proxies","addEvent","removeEvent","implementation","plugins","core_plugins","_plugins","_cacheId","register","plugin","unregister","idx","getAll","notify","hook","params","descriptors","cache","$plugins","_invalidate","constructors","registerScaleType","scaleConstructor","scaleDefaults","getScaleConstructor","updateScaleDefaults","additions","addScalesToLayout","beforeTitle","tooltipItems","labelCount","afterTitle","beforeLabel","labelColor","activeElement","labelTextColor","afterLabel","beforeFooter","afterFooter","positioners","average","eventPosition","nearestElement","d","distanceBetweenPoints","tp","exports$3","_lastActive","getTitle","getBeforeBody","getBody","bodyItems","getAfterBody","getFooter","changed","existingModel","active","_active","backgroundPoint","tooltipSize","caretX","caretY","labelColors","labelTextColors","_eventPosition","itemSort","dataPoints","drawCaret","tooltipPoint","caretPosition","getCaretPosition","x3","y3","ptX","ptY","tmp","drawTitle","drawBody","textColor","drawColorBoxes","xLinePadding","colorX","fillLineOfText","strokeRect","drawFooter","drawBackground","quadraticCurveTo","hasTooltipContent","globalAlpha","handleEvent","getElementsAtEventForMode","positioners_1","core_tooltip","events","onHover","animationDuration","responsiveAnimationDuration","Chart","construct","_bufferedRender","instances","retinaScale","devicePixelRatio","bindEvents","resize","initToolTip","stop","silent","newWidth","getMaximumWidth","newHeight","getMaximumHeight","newSize","onResize","scalesOptions","scaleOptions","xAxisOptions","yAxisOptions","updated","dtype","dposition","isDefault","scaleType","scaleClass","mergeTicksOptions","hasUpdated","buildOrUpdateControllers","newControllers","destroyDatasetMeta","ControllerClass","resetElements","updateLayout","updateDatasets","lastActive","_bufferedRequest","updateDataset","animationOptions","animationObject","easingFunction","stepDecimal","drawDatasets","_drawTooltip","drawDataset","getElementAtEvent","getElementsAtEvent","getElementsAtXAxis","getDatasetAtEvent","_meta","generateLegend","unbindEvents","toBase64Image","toDataURL","_chartInstance","_listeners","eventHandler","updateHoverStyle","bufferedRequest","hoverOptions","core_controller","Controller","types","configMerge","scaleMerge","core_helpers","parseMaxStyle","styleValue","parentProperty","valueInPixels","isConstrainedValue","getConstraintDimension","domNode","maxStyle","percentageProperty","defaultView","_getParentNode","constrainedNode","getComputedStyle","constrainedContainer","hasCNode","hasCContainer","infinity","collection","filterCallback","filtered","arrayToSearch","startIndex","currentItem","findPreviousWhere","rounded","NEGATIVE_INFINITY","sign","exponent","log","LOG10E","powerOf10","isPowerOf10","toRadians","radians","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","aliasPixel","pixelWidth","_alignPixel","pixel","currentDevicePixelRatio","halfWidth","firstPoint","middlePoint","afterPoint","d01","d12","s01","s12","fa","fb","EPSILON","pointBefore","pointCurrent","pointAfter","pointsWithTangents","deltaK","mK","pointsLen","slopeDeltaX","alphaK","betaK","tauK","squaredMagnitude","niceFraction","fraction","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","evt","originalEvent","srcElement","boundingRect","getBoundingClientRect","touches","clientX","clientY","paddingLeft","paddingRight","paddingBottom","getConstraintWidth","getConstraintHeight","_calculatePadding","parentDimension","parent","host","cw","clientHeight","ch","currentStyle","getPropertyValue","forceRatio","pixelRatio","pixelSize","arrayOfThings","gc","garbageCollect","longest","thing","nestedThing","gcLen","textWidth","numberOfLabelLines","numberOfLines","CanvasGradient","colorValue","CanvasPattern","formats","endOf","_create","override","members","_date","core_adapters","core_ticks","formatters","tickValue","logDelta","tickString","maxTick","logTick","toExponential","numDecimal","toFixed","logarithmic","remain","valueOrDefault$9","drawBorder","drawOnChartArea","drawTicks","tickMarkLength","zeroLineWidth","zeroLineColor","zeroLineBorderDash","zeroLineBorderDashOffset","scaleLabel","labelString","minRotation","maxRotation","mirror","autoSkip","autoSkipPadding","labelOffset","core_scale","_ticks","beforeUpdate","maxWidth","maxHeight","margins","_maxLabelLines","longestLabelWidth","longestTextCache","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","beforeTickToLabelConversion","convertTicksToLabels","afterTickToLabelConversion","beforeCalculateTickRotation","calculateTickRotation","afterCalculateTickRotation","beforeFit","fit","afterFit","afterUpdate","userCallback","tickFont","labelRotation","cosRotation","sinRotation","originalLabelWidth","labelWidth","tickWidth","scaleLabelOpts","_isVisible","parseFont","isFullWidth","scaleLabelFont","scaleLabelPadding","deltaHeight","largestTextWidth","tallestLabelHeightInLines","lineSpace","tickPadding","labelHeight","firstLabelWidth","lastLabelWidth","offsetLeft","offsetRight","handleMargins","rawValue","getValueForPixel","innerWidth","finalVal","innerHeight","decimal","valueOffset","getBaseValue","_autoSkip","optionTicks","tickCount","skipRatio","maxTicksLimit","ticksLength","_tickSize","axisLength","PaddingBottom","rot","borderValue","tickStart","tickEnd","optionMajorTicks","isRotated","isMirrored","tickFontColor","majorTickFontColor","majorTickFont","tl","scaleLabelFontColor","labelRotationRadians","itemsToDraw","axisWidth","alignPixel","zeroLineIndex","tx1","ty1","tx2","ty2","labelX","labelY","textOffset","labelYOffset","labelXOffset","glWidth","glColor","glBorderDash","glBorderDashOffset","itemToDraw","translate","scaleLabelX","scaleLabelY","halfLineHeight","isLeft","firstLineWidth","lastLineWidth","defaultConfig","scale_category","getLabels","xLabels","yLabels","minIndex","maxIndex","valueCategory","offsetAmt","valueWidth","widthOffset","valueHeight","heightOffset","horz","valueDimension","_defaults","scale_linearbase","handleTickRangeOptions","minSign","maxSign","setMin","suggestedMin","setMax","suggestedMax","getTickLimit","_computeTickLimit","handleDirectionalChanges","numericGeneratorOptions","fixedStepSize","ticksAsNumbers","defaultConfig$1","scale_linear","IDMatches","DEFAULT_MIN","DEFAULT_MAX","hasStacks","valuesPerStack","positiveValues","negativeValues","relativePoints","valuesForType","minVal","maxVal","innerDimension","_defaults$1","defaultConfig$2","scale_logarithmic","tickValues","_getFirstTickValue","firstTickValue","_defaults$2","defaultConfig$3","animate","showLabelBackdrop","backdropColor","backdropPaddingX","scale_radialLinear","setCenterPoint","largestPossibleRadius","radiusReductionLeft","radiusReductionRight","radiusReductionTop","radiusReductionBottom","leftMovement","rightMovement","topMovement","bottomMovement","maxRight","maxLeft","maxTop","maxBottom","angleMultiplier","startAngleRadians","scalingFactor","distanceFromCenter","thisAngle","yCenterOffset","_defaults$3","MIN_INTEGER","MIN_SAFE_INTEGER","millisecond","second","minute","hour","day","week","month","quarter","year","defaultConfig$4","adapters","displayFormat","displayFormats","scale_time","date","timestamp","dataLabels","_horizontal","_table","_timestamps","getLabelCapacity","_unit","_majorUnit","_offsets","tooltipFormat","datetime","tickFormatFunction","minorFormat","majorFormat","majorTime","majorTickOpts","formatter","getPixelForOffset","isReverse","getLabelWidth","ticksOpts","tickLabelWidth","tickFontSize","exampleTime","exampleLabel","_defaults$4","category","radialLinear","FORMATS","_id","valueOf","amount","as","filler","boundary","plugin_filler","afterDatasetsUpdate","$filler","beforeDatasetDraw","noop$1","valueOrDefault$d","ci","onLeave","lineDash","legendHitBoxes","_hoveredItem","doughnutMode","beforeBuildLabels","buildLabels","afterBuildLabels","legendItems","labelFont","hitboxes","lineWidths","totalHeight","vPadding","columnWidths","totalWidth","currentColWidth","currentColHeight","itemHeight","itemWidth","lineDefault","legendWidth","cursor","drawLegendBox","SQRT2","halfFontSize","xLeft","yMiddle","_getLegendItemAt","hitBox","lh","hoveredItem","plugin_legend","_element","beforeInit","afterEvent","noop$2","lineCount","fontOpts","titleX","titleY","plugin_title","_adapters","Animation","animationService","Interaction","layouts","Scale","scaleService","Ticks","Tooltip","src","pluginService","PluginBase","canvasHelpers","layoutService","LinearScaleBase","klass","cfg","toLowerCase","DataView","Hash","hashClear","hashDelete","hashGet","hashHas","hashSet","Promise","Set","setCacheAdd","setCacheHas","Uint8Array","WeakMap","arrayAggregator","setter","iteratee","accumulator","arrayFilter","predicate","resIndex","inherited","isArr","isArg","isBuff","isType","skipIndexes","baseTimes","arrayMap","arrayPush","baseAggregator","baseEach","baseAssignValue","writable","baseForOwn","createBaseEach","createBaseFor","baseFor","baseGetAllKeys","keysFunc","symbolsFunc","baseHasIn","argsTag","objIsArr","othIsArr","objTag","arrayTag","getTag","othTag","objectTag","objIsObj","othIsObj","isSameTag","equalByTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","equalObjects","baseIsMatch","matchData","noCustomizer","objValue","isMasked","pattern","reIsNative","reIsHostCtor","reRegExpChar","RegExp","replace","typedArrayTags","boolTag","dateTag","errorTag","mapTag","numberTag","regexpTag","setTag","stringTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","baseIteratee","identity","baseMatchesProperty","baseMatches","isPrototype","nativeKeys","getMatchData","hasIn","baseProperty","basePropertyDeep","baseToString","symbolToString","symbolProto","coreJsData","createAggregator","initializer","eachFunc","fromRight","iterable","byteLength","byteOffset","buffer","mapToArray","setToArray","symbolValueOf","objProps","getAllKeys","objLength","othProps","skipCtor","objCtor","othCtor","getSymbols","isOwn","unmasked","nativeObjectToString","stubArray","nativeGetSymbols","symbol","promiseTag","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","ArrayBuffer","Ctor","ctorString","hasPath","hasFunc","HASH_UNDEFINED","maskSrcKey","IE_PROTO","proto","lastIndex","arrayProto","memoizeCapped","memoize","MAX_MEMOIZE_SIZE","overArg","freeProcess","require","transform","pairs","LARGE_ARRAY_SIZE","rePropName","reEscapeChar","charCodeAt","number","quote","subString","isEqual","keyBy","resolver","TypeError","FUNC_ERROR_TEXT","memoized","Cache","hooks","hookCallback","setHookCallback","isObjectEmpty","isUndefined","isDate","arr","hasOwnProp","createUTC","locale","strict","createLocalOrUTC","utc","defaultParsingFlags","empty","unusedTokens","unusedInput","overflow","charsLeftOver","nullInput","invalidMonth","invalidFormat","userInvalidated","iso","parsedDateParts","meridiem","rfc2822","weekdayMismatch","getParsingFlags","_pf","_isValid","flags","parsedParts","some","isNowValid","_d","getTime","invalidWeekday","_strict","bigHour","isFrozen","createInvalid","copyConfig","_isAMomentObject","_i","_f","_l","_tzm","_isUTC","_offset","_locale","momentProperties","Moment","updateInProgress","updateOffset","isMoment","absFloor","toInt","argumentForCoercion","coercedNumber","compareArrays","array1","array2","dontConvert","lengthDiff","diffs","msg","suppressDeprecationWarnings","firstTime","deprecationHandler","deprecateSimple","deprecations","_config","_dayOfMonthOrdinalParseLenient","_dayOfMonthOrdinalParse","_ordinalParse","mergeConfigs","parentConfig","childConfig","Locale","calendar","mom","output","_calendar","longDateFormat","_longDateFormat","formatUpper","invalidDate","_invalidDate","ordinal","_ordinal","relativeTime","withoutSuffix","isFuture","_relativeTime","pastFuture","addUnitAlias","shorthand","lowerCase","aliases","normalizeUnits","units","normalizeObjectUnits","inputObject","normalizedProp","normalizedInput","addUnitPriority","priority","priorities","getPrioritizedUnits","unitsObj","u","zeroFill","targetLength","forceSign","absNumber","zerosToFill","addFormatToken","token","padded","formatTokenFunctions","localeData","removeFormattingTokens","makeFormatFunction","formattingTokens","formatMoment","expandFormat","formatFunctions","replaceLongDateFormatTokens","localFormattingTokens","addRegexToken","regex","strictRegex","regexes","isStrict","getParseRegexForToken","unescapeFormat","regexEscape","matched","p2","p3","p4","addParseToken","tokens","addWeekParseToken","_w","addTimeToArrayFromToken","_a","daysInYear","isLeapYear","getIsLeapYear","makeGetSet","keepTime","set$1","daysInMonth","stringGet","stringSet","prioritized","mod","modMonth","localeMonths","_months","isFormat","MONTHS_IN_FORMAT","localeMonthsShort","_monthsShort","handleStrictParse","monthName","ii","llc","toLocaleLowerCase","_monthsParse","_longMonthsParse","_shortMonthsParse","monthsShort","months","localeMonthsParse","_monthsParseExact","setMonth","dayOfMonth","monthsParse","getSetMonth","getDaysInMonth","monthsShortRegex","computeMonthsParse","_monthsShortStrictRegex","_monthsShortRegex","defaultMonthsShortRegex","monthsRegex","_monthsStrictRegex","_monthsRegex","defaultMonthsRegex","cmpLenRev","shortPieces","longPieces","mixedPieces","createDate","M","ms","getFullYear","setFullYear","createUTCDate","UTC","getUTCFullYear","setUTCFullYear","firstWeekOffset","dow","doy","fwd","fwdlw","getUTCDay","dayOfYearFromWeeks","resYear","resDayOfYear","localWeekday","weekOffset","dayOfYear","weekOfYear","resWeek","weeksInYear","weekOffsetNext","localeWeek","_week","localeFirstDayOfWeek","localeFirstDayOfYear","getSetWeek","getSetISOWeek","parseWeekday","weekdaysParse","parseIsoWeekday","shiftWeekdays","ws","localeWeekdays","weekdays","_weekdays","localeWeekdaysShort","_weekdaysShort","localeWeekdaysMin","_weekdaysMin","handleStrictParse$1","weekdayName","_weekdaysParse","_shortWeekdaysParse","_minWeekdaysParse","weekdaysMin","weekdaysShort","localeWeekdaysParse","_weekdaysParseExact","_fullWeekdaysParse","getSetDayOfWeek","getDay","getSetLocaleDayOfWeek","getSetISODayOfWeek","weekdaysRegex","computeWeekdaysParse","_weekdaysStrictRegex","_weekdaysRegex","defaultWeekdaysRegex","weekdaysShortRegex","_weekdaysShortStrictRegex","_weekdaysShortRegex","defaultWeekdaysShortRegex","weekdaysMinRegex","_weekdaysMinStrictRegex","_weekdaysMinRegex","defaultWeekdaysMinRegex","minp","shortp","longp","minPieces","hFormat","hours","kFormat","lowercase","minutes","matchMeridiem","_meridiemParse","localeIsPM","localeMeridiem","isLower","normalizeLocale","chooseLocale","names","loadLocale","globalLocale","oldLocale","locales","_abbr","code","getSetGlobalLocale","getLocale","defineLocale","baseConfig","parentLocale","localeFamilies","updateLocale","tmpLocale","listLocales","checkOverflow","MONTH","DATE","YEAR","HOUR","MINUTE","SECOND","MILLISECOND","_overflowDayOfYear","_overflowWeeks","WEEK","_overflowWeekday","WEEKDAY","currentDateArray","nowValue","_useUTC","getUTCMonth","getUTCDate","getMonth","getDate","configFromArray","currentDate","expectedWeekday","yearToUse","dayOfYearFromWeekInfo","_dayOfYear","_nextDay","setUTCMinutes","getUTCMinutes","weekYear","temp","weekdayOverflow","GG","W","E","createLocal","curWeek","gg","configFromISO","allowTime","dateFormat","timeFormat","tzFormat","extendedIsoRegex","basicIsoRegex","isoDates","isoTimes","tzRegex","configFromStringAndFormat","extractFromRFC2822Strings","yearStr","monthStr","dayStr","hourStr","minuteStr","secondStr","untruncateYear","defaultLocaleMonthsShort","preprocessRFC2822","checkWeekday","weekdayStr","parsedInput","weekdayProvided","defaultLocaleWeekdaysShort","weekdayActual","calculateOffset","obsOffset","militaryOffset","numOffset","obsOffsets","hm","configFromRFC2822","parsedArray","configFromString","aspNetJsonRegex","createFromInputFallback","ISO_8601","RFC_2822","skipped","stringLength","totalParsedInputLength","_meridiem","meridiemFixWrap","isPm","meridiemHour","isPM","configFromStringAndArray","tempConfig","bestMoment","scoreToBeat","currentScore","score","configFromObject","createFromConfig","prepareConfig","preparse","configFromInput","isUTC","pickBy","moments","isDurationValid","ordering","unitHasDecimal","isValid$1","createInvalid$1","createDuration","Duration","years","quarters","weeks","isoWeek","days","seconds","_milliseconds","_days","_bubble","isDuration","absRound","separator","utcOffset","offsetFromString","matcher","parts","chunkOffset","cloneWithOffset","setTime","local","getDateOffset","getTimezoneOffset","getSetOffset","keepLocalTime","keepMinutes","localAdjust","matchShortOffset","_changeInProgress","addSubtract","getSetZone","setOffsetToUTC","setOffsetToLocal","subtract","setOffsetToParsedOffset","tZone","matchOffset","hasAlignedHourOffset","isDaylightSavingTime","isDaylightSavingTimeShifted","_isDSTShifted","toArray","isLocal","isUtcOffset","isUtc","ret","diffRes","aspNetRegex","isoRegex","parseIso","momentsDifference","inp","positiveMomentsDifference","isAfter","isBefore","createAdder","direction","period","dur","isAdding","getCalendarFormat","myMoment","calendar$1","sod","calendarFormat","localInput","isBetween","inclusivity","localFrom","localTo","isSame","inputMs","isSameOrAfter","isSameOrBefore","asFloat","that","zoneDelta","monthDiff","anchor2","adjust","wholeMonthDiff","anchor","toISOString","keepOffset","toDate","inspect","zone","suffix","inputString","defaultFormatUtc","defaultFormat","postformat","humanize","fromNow","toNow","newLocaleData","mod$1","dividend","divisor","localStartOfDate","MS_PER_400_YEARS","utcStartOfDate","startOfDate","MS_PER_MINUTE","MS_PER_HOUR","MS_PER_SECOND","unix","toObject","isValid$2","parsingFlags","invalidAt","creationData","addWeekYearFormatToken","getter","getSetWeekYear","getSetWeekYearHelper","getSetISOWeekYear","getISOWeeksInYear","getWeeksInYear","weekInfo","weeksTarget","setWeekAll","dayOfYearData","getSetQuarter","getSetDayOfYear","parseMs","getZoneAbbr","getZoneName","createUnix","createInZone","parseZone","preParsePostFormat","get$1","field","listMonthsImpl","listWeekdaysImpl","localeSorted","listMonths","listMonthsShort","listWeekdays","listWeekdaysShort","listWeekdaysMin","mathAbs","addSubtract$1","add$1","subtract$1","absCeil","monthsFromDays","monthsToDays","daysToMonths","valueOf$1","makeAs","alias","clone$1","get$2","makeGetter","substituteTimeAgo","relativeTime$1","posNegDuration","thresholds","ss","getSetRelativeTimeRounding","roundingFunction","getSetRelativeTimeThreshold","threshold","limit","withSuffix","toISOString$1","abs$1","Y","D","asSeconds","totalSign","ymSign","daysSign","hmsSign","defaultCalendar","sameDay","nextDay","nextWeek","lastDay","lastWeek","sameElse","defaultLongDateFormat","LTS","LT","L","LL","LLL","LLLL","defaultInvalidDate","defaultOrdinal","defaultDayOfMonthOrdinalParse","defaultRelativeTime","future","past","mm","hh","dd","MM","yy","match1","match2","match3","match4","match6","match1to2","match3to4","match5to6","match1to3","match1to4","match1to6","matchUnsigned","matchSigned","matchTimestamp","matchWord","parseTwoDigitYear","getSetYear","o","defaultLocaleMonths","defaultLocaleWeek","defaultLocaleWeekdays","defaultLocaleWeekdaysMin","kInput","_isPm","pos1","pos2","defaultLocaleMeridiemParse","getSetHour","dayOfMonthOrdinalParse","meridiemParse","UT","GMT","EDT","EST","CDT","CST","MDT","MST","PDT","PST","prototypeMin","prototypeMax","invalid","lang","isoWeekYear","getSetDayOfMonth","getSetMinute","getSetSecond","getSetMillisecond","isoWeeks","isoWeeksInYear","isDST","zoneAbbr","zoneName","dates","isDSTShifted","proto$1","firstDayOfYear","firstDayOfWeek","langData","asMilliseconds","asMinutes","asHours","asDays","asWeeks","asMonths","asQuarters","asYears","proto$2","toIsoString","relativeTimeRounding","relativeTimeThreshold","HTML5_FMT","DATETIME_LOCAL","DATETIME_LOCAL_SECONDS","DATETIME_LOCAL_MS","TIME","TIME_SECONDS","TIME_MS","_objectWithoutProperties","_classCallCheck","instance","Constructor","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","setPrototypeOf","__proto__","Scatter","Bubble","Polar","Radar","HorizontalBar","Bar","Pie","Doughnut","_extends","assign","_propTypes","_propTypes2","_chart2","_isEqual","_isEqual2","_keyBy","_keyBy2","NODE_ENV","PUBLIC_DIR","ChartComponent","_React$Component","_temp","_this","_ret","_len","_key","handleOnClick","chartInstance","_this$props","onElementsClick","ref","componentWillMount","componentDidMount","renderChart","componentDidUpdate","redraw","destroyChart","updateChart","shouldComponentUpdate","nextProps","_props","nextData","transformDataProp","shadowDataProp","componentWillUnmount","memoizeDataProps","saveCurrentDatasets","checkDatasets","isDev","usingCustomKeyProvider","datasetKeyProvider","getLabelAsKey","multipleDatasets","shouldWarn","getCurrentDatasets","_this2","currentDatasets","_this3","nextDatasets","currentDatasetsIndexed","pid","otherProps","rest","_props2","_props3","Component","oneOfType","isRequired","arrayOf","bool","propName","componentName","_React$Component2","_this5","_ref","_React$Component3","_this7","_ref2","_React$Component4","_this9","_ref3","_React$Component5","_this11","_ref4","_React$Component6","_this13","_ref5","_React$Component7","_this15","_ref6","_React$Component8","_this17","_ref7","_React$Component9","_this19","_ref8","_React$Component10","_this21","_ref9"],"mappings":"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C,SAAAuI,YAEA,IAAAo9C,IAAAjc,EAyGA,OAxGA,mBAAApsC,UACAA,OAAAuoC,MAAA6D,IAYAA,GAAA7D,MAAA6D,GASAA,GAAA3zB,OAAAiqB,GAAAv4C,OAAAg9D,SASA/a,GAAAtzB,MAAA4pB,GAAAhkD,MAAAyoE,SASA/a,GAAAkc,cAAAlc,GAAA1J,QAUA0J,GAAAmc,WAAAnc,GAAA7e,QAAA9F,WASA2kB,GAAAoc,cAAApc,GAAAxlB,QAAAroB,OASA6tC,GAAAqc,cAAArc,GAAA4b,QASA5b,GAAAsc,gBAAAjL,GAQArR,GAAAxlB,QAAAhwB,MAEA,MACA,SACA,WACA,OACA,YACA,QACA,WAEA,SAAA+xD,GACAvc,GAAAuc,GAAA,SAAAnhD,EAAAohD,GACA,UAAAxc,IAAA5kC,EAAA4kC,GAAAxlB,QAAA9c,MAAA8+C,OACA5lE,KAAA2lE,EAAAlyD,OAAA,GAAAoyD,cAAAF,EAAA31D,MAAA,SAMAq1D,MzCmtDS,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CACA,CAEH,SAAU1tE,EAAQC,EAASC,G0C3pgBjC,GAAAS,GAAAT,EAAA,IACAK,EAAAL,EAAA,IAGAiuE,EAAAxtE,E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","file":"component---src-pages-index-js-eb2681cacb891241f817.js","sourcesContent":["webpackJsonp([35783957827783],[\n/* 0 */,\n/* 1 */,\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */,\n/* 6 */,\n/* 7 */,\n/* 8 */,\n/* 9 */,\n/* 10 */,\n/* 11 */,\n/* 12 */,\n/* 13 */,\n/* 14 */,\n/* 15 */,\n/* 16 */,\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar freeGlobal = __webpack_require__(177);\n\t\n\t/** Detect free variable `self`. */\n\tvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\t\n\t/** Used as a reference to the global object. */\n\tvar root = freeGlobal || freeSelf || Function('return this')();\n\t\n\tmodule.exports = root;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Checks if `value` is classified as an `Array` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n\t * @example\n\t *\n\t * _.isArray([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isArray(document.body.children);\n\t * // => false\n\t *\n\t * _.isArray('abc');\n\t * // => false\n\t *\n\t * _.isArray(_.noop);\n\t * // => false\n\t */\n\tvar isArray = Array.isArray;\n\t\n\tmodule.exports = isArray;\n\n\n/***/ }),\n/* 19 */,\n/* 20 */,\n/* 21 */,\n/* 22 */,\n/* 23 */,\n/* 24 */,\n/* 25 */,\n/* 26 */,\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseIsNative = __webpack_require__(383),\n\t    getValue = __webpack_require__(407);\n\t\n\t/**\n\t * Gets the native function at `key` of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {string} key The key of the method to get.\n\t * @returns {*} Returns the function if it's native, else `undefined`.\n\t */\n\tfunction getNative(object, key) {\n\t  var value = getValue(object, key);\n\t  return baseIsNative(value) ? value : undefined;\n\t}\n\t\n\tmodule.exports = getNative;\n\n\n/***/ }),\n/* 28 */,\n/* 29 */,\n/* 30 */,\n/* 31 */,\n/* 32 */,\n/* 33 */,\n/* 34 */,\n/* 35 */,\n/* 36 */,\n/* 37 */,\n/* 38 */,\n/* 39 */,\n/* 40 */,\n/* 41 */,\n/* 42 */,\n/* 43 */,\n/* 44 */,\n/* 45 */,\n/* 46 */,\n/* 47 */,\n/* 48 */,\n/* 49 */,\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(73),\n\t    getRawTag = __webpack_require__(404),\n\t    objectToString = __webpack_require__(431);\n\t\n\t/** `Object#toString` result references. */\n\tvar nullTag = '[object Null]',\n\t    undefinedTag = '[object Undefined]';\n\t\n\t/** Built-in value references. */\n\tvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\t\n\t/**\n\t * The base implementation of `getTag` without fallbacks for buggy environments.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the `toStringTag`.\n\t */\n\tfunction baseGetTag(value) {\n\t  if (value == null) {\n\t    return value === undefined ? undefinedTag : nullTag;\n\t  }\n\t  return (symToStringTag && symToStringTag in Object(value))\n\t    ? getRawTag(value)\n\t    : objectToString(value);\n\t}\n\t\n\tmodule.exports = baseGetTag;\n\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Checks if `value` is object-like. A value is object-like if it's not `null`\n\t * and has a `typeof` result of \"object\".\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t * @example\n\t *\n\t * _.isObjectLike({});\n\t * // => true\n\t *\n\t * _.isObjectLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObjectLike(_.noop);\n\t * // => false\n\t *\n\t * _.isObjectLike(null);\n\t * // => false\n\t */\n\tfunction isObjectLike(value) {\n\t  return value != null && typeof value == 'object';\n\t}\n\t\n\tmodule.exports = isObjectLike;\n\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\tprocess.prependListener = noop;\n\tprocess.prependOnceListener = noop;\n\t\n\tprocess.listeners = function (name) { return [] }\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 53 */,\n/* 54 */,\n/* 55 */,\n/* 56 */,\n/* 57 */,\n/* 58 */,\n/* 59 */,\n/* 60 */,\n/* 61 */,\n/* 62 */,\n/* 63 */,\n/* 64 */,\n/* 65 */,\n/* 66 */,\n/* 67 */,\n/* 68 */,\n/* 69 */,\n/* 70 */,\n/* 71 */,\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar listCacheClear = __webpack_require__(417),\n\t    listCacheDelete = __webpack_require__(418),\n\t    listCacheGet = __webpack_require__(419),\n\t    listCacheHas = __webpack_require__(420),\n\t    listCacheSet = __webpack_require__(421);\n\t\n\t/**\n\t * Creates an list cache object.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */\n\tfunction ListCache(entries) {\n\t  var index = -1,\n\t      length = entries == null ? 0 : entries.length;\n\t\n\t  this.clear();\n\t  while (++index < length) {\n\t    var entry = entries[index];\n\t    this.set(entry[0], entry[1]);\n\t  }\n\t}\n\t\n\t// Add methods to `ListCache`.\n\tListCache.prototype.clear = listCacheClear;\n\tListCache.prototype['delete'] = listCacheDelete;\n\tListCache.prototype.get = listCacheGet;\n\tListCache.prototype.has = listCacheHas;\n\tListCache.prototype.set = listCacheSet;\n\t\n\tmodule.exports = ListCache;\n\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar root = __webpack_require__(17);\n\t\n\t/** Built-in value references. */\n\tvar Symbol = root.Symbol;\n\t\n\tmodule.exports = Symbol;\n\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar eq = __webpack_require__(182);\n\t\n\t/**\n\t * Gets the index at which the `key` is found in `array` of key-value pairs.\n\t *\n\t * @private\n\t * @param {Array} array The array to inspect.\n\t * @param {*} key The key to search for.\n\t * @returns {number} Returns the index of the matched value, else `-1`.\n\t */\n\tfunction assocIndexOf(array, key) {\n\t  var length = array.length;\n\t  while (length--) {\n\t    if (eq(array[length][0], key)) {\n\t      return length;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\t\n\tmodule.exports = assocIndexOf;\n\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar isKeyable = __webpack_require__(414);\n\t\n\t/**\n\t * Gets the data for `map`.\n\t *\n\t * @private\n\t * @param {Object} map The map to query.\n\t * @param {string} key The reference key.\n\t * @returns {*} Returns the map data.\n\t */\n\tfunction getMapData(map, key) {\n\t  var data = map.__data__;\n\t  return isKeyable(key)\n\t    ? data[typeof key == 'string' ? 'string' : 'hash']\n\t    : data.map;\n\t}\n\t\n\tmodule.exports = getMapData;\n\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar getNative = __webpack_require__(27);\n\t\n\t/* Built-in method references that are verified to be native. */\n\tvar nativeCreate = getNative(Object, 'create');\n\t\n\tmodule.exports = nativeCreate;\n\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar isSymbol = __webpack_require__(121);\n\t\n\t/** Used as references for various `Number` constants. */\n\tvar INFINITY = 1 / 0;\n\t\n\t/**\n\t * Converts `value` to a string key if it's not a string or symbol.\n\t *\n\t * @private\n\t * @param {*} value The value to inspect.\n\t * @returns {string|symbol} Returns the key.\n\t */\n\tfunction toKey(value) {\n\t  if (typeof value == 'string' || isSymbol(value)) {\n\t    return value;\n\t  }\n\t  var result = (value + '');\n\t  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n\t}\n\t\n\tmodule.exports = toKey;\n\n\n/***/ }),\n/* 78 */,\n/* 79 */,\n/* 80 */,\n/* 81 */,\n/* 82 */,\n/* 83 */,\n/* 84 */,\n/* 85 */,\n/* 86 */,\n/* 87 */,\n/* 88 */,\n/* 89 */,\n/* 90 */,\n/* 91 */,\n/* 92 */,\n/* 93 */,\n/* 94 */,\n/* 95 */,\n/* 96 */,\n/* 97 */,\n/* 98 */,\n/* 99 */,\n/* 100 */,\n/* 101 */,\n/* 102 */,\n/* 103 */,\n/* 104 */,\n/* 105 */,\n/* 106 */,\n/* 107 */,\n/* 108 */,\n/* 109 */,\n/* 110 */,\n/* 111 */,\n/* 112 */,\n/* 113 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Copyright 2015, Yahoo! Inc.\n\t * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n\t */\n\tvar REACT_STATICS = {\n\t    childContextTypes: true,\n\t    contextTypes: true,\n\t    defaultProps: true,\n\t    displayName: true,\n\t    getDefaultProps: true,\n\t    getDerivedStateFromProps: true,\n\t    mixins: true,\n\t    propTypes: true,\n\t    type: true\n\t};\n\t\n\tvar KNOWN_STATICS = {\n\t    name: true,\n\t    length: true,\n\t    prototype: true,\n\t    caller: true,\n\t    callee: true,\n\t    arguments: true,\n\t    arity: true\n\t};\n\t\n\tvar defineProperty = Object.defineProperty;\n\tvar getOwnPropertyNames = Object.getOwnPropertyNames;\n\tvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\n\tvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\tvar getPrototypeOf = Object.getPrototypeOf;\n\tvar objectPrototype = getPrototypeOf && getPrototypeOf(Object);\n\t\n\tfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n\t    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n\t\n\t        if (objectPrototype) {\n\t            var inheritedComponent = getPrototypeOf(sourceComponent);\n\t            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n\t                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n\t            }\n\t        }\n\t\n\t        var keys = getOwnPropertyNames(sourceComponent);\n\t\n\t        if (getOwnPropertySymbols) {\n\t            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n\t        }\n\t\n\t        for (var i = 0; i < keys.length; ++i) {\n\t            var key = keys[i];\n\t            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {\n\t                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n\t                try { // Avoid failures from read-only properties\n\t                    defineProperty(targetComponent, key, descriptor);\n\t                } catch (e) {}\n\t            }\n\t        }\n\t\n\t        return targetComponent;\n\t    }\n\t\n\t    return targetComponent;\n\t}\n\t\n\tmodule.exports = hoistNonReactStatics;\n\n\n/***/ }),\n/* 114 */,\n/* 115 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar getNative = __webpack_require__(27),\n\t    root = __webpack_require__(17);\n\t\n\t/* Built-in method references that are verified to be native. */\n\tvar Map = getNative(root, 'Map');\n\t\n\tmodule.exports = Map;\n\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar mapCacheClear = __webpack_require__(422),\n\t    mapCacheDelete = __webpack_require__(423),\n\t    mapCacheGet = __webpack_require__(424),\n\t    mapCacheHas = __webpack_require__(425),\n\t    mapCacheSet = __webpack_require__(426);\n\t\n\t/**\n\t * Creates a map cache object to store key-value pairs.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */\n\tfunction MapCache(entries) {\n\t  var index = -1,\n\t      length = entries == null ? 0 : entries.length;\n\t\n\t  this.clear();\n\t  while (++index < length) {\n\t    var entry = entries[index];\n\t    this.set(entry[0], entry[1]);\n\t  }\n\t}\n\t\n\t// Add methods to `MapCache`.\n\tMapCache.prototype.clear = mapCacheClear;\n\tMapCache.prototype['delete'] = mapCacheDelete;\n\tMapCache.prototype.get = mapCacheGet;\n\tMapCache.prototype.has = mapCacheHas;\n\tMapCache.prototype.set = mapCacheSet;\n\t\n\tmodule.exports = MapCache;\n\n\n/***/ }),\n/* 117 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseIsEqualDeep = __webpack_require__(381),\n\t    isObjectLike = __webpack_require__(51);\n\t\n\t/**\n\t * The base implementation of `_.isEqual` which supports partial comparisons\n\t * and tracks traversed objects.\n\t *\n\t * @private\n\t * @param {*} value The value to compare.\n\t * @param {*} other The other value to compare.\n\t * @param {boolean} bitmask The bitmask flags.\n\t *  1 - Unordered comparison\n\t *  2 - Partial comparison\n\t * @param {Function} [customizer] The function to customize comparisons.\n\t * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n\t * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t */\n\tfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n\t  if (value === other) {\n\t    return true;\n\t  }\n\t  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n\t    return value !== value && other !== other;\n\t  }\n\t  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n\t}\n\t\n\tmodule.exports = baseIsEqual;\n\n\n/***/ }),\n/* 118 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar isArray = __webpack_require__(18),\n\t    isSymbol = __webpack_require__(121);\n\t\n\t/** Used to match property names within property paths. */\n\tvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n\t    reIsPlainProp = /^\\w*$/;\n\t\n\t/**\n\t * Checks if `value` is a property name and not a property path.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @param {Object} [object] The object to query keys on.\n\t * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n\t */\n\tfunction isKey(value, object) {\n\t  if (isArray(value)) {\n\t    return false;\n\t  }\n\t  var type = typeof value;\n\t  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n\t      value == null || isSymbol(value)) {\n\t    return true;\n\t  }\n\t  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n\t    (object != null && value in Object(object));\n\t}\n\t\n\tmodule.exports = isKey;\n\n\n/***/ }),\n/* 119 */\n/***/ (function(module, exports) {\n\n\t/** Used as references for various `Number` constants. */\n\tvar MAX_SAFE_INTEGER = 9007199254740991;\n\t\n\t/**\n\t * Checks if `value` is a valid array-like length.\n\t *\n\t * **Note:** This method is loosely based on\n\t * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t * @example\n\t *\n\t * _.isLength(3);\n\t * // => true\n\t *\n\t * _.isLength(Number.MIN_VALUE);\n\t * // => false\n\t *\n\t * _.isLength(Infinity);\n\t * // => false\n\t *\n\t * _.isLength('3');\n\t * // => false\n\t */\n\tfunction isLength(value) {\n\t  return typeof value == 'number' &&\n\t    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t}\n\t\n\tmodule.exports = isLength;\n\n\n/***/ }),\n/* 120 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Checks if `value` is the\n\t * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n\t * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t * @example\n\t *\n\t * _.isObject({});\n\t * // => true\n\t *\n\t * _.isObject([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isObject(_.noop);\n\t * // => true\n\t *\n\t * _.isObject(null);\n\t * // => false\n\t */\n\tfunction isObject(value) {\n\t  var type = typeof value;\n\t  return value != null && (type == 'object' || type == 'function');\n\t}\n\t\n\tmodule.exports = isObject;\n\n\n/***/ }),\n/* 121 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseGetTag = __webpack_require__(50),\n\t    isObjectLike = __webpack_require__(51);\n\t\n\t/** `Object#toString` result references. */\n\tvar symbolTag = '[object Symbol]';\n\t\n\t/**\n\t * Checks if `value` is classified as a `Symbol` primitive or object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n\t * @example\n\t *\n\t * _.isSymbol(Symbol.iterator);\n\t * // => true\n\t *\n\t * _.isSymbol('abc');\n\t * // => false\n\t */\n\tfunction isSymbol(value) {\n\t  return typeof value == 'symbol' ||\n\t    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n\t}\n\t\n\tmodule.exports = isSymbol;\n\n\n/***/ }),\n/* 122 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar arrayLikeKeys = __webpack_require__(369),\n\t    baseKeys = __webpack_require__(386),\n\t    isArrayLike = __webpack_require__(184);\n\t\n\t/**\n\t * Creates an array of the own enumerable property names of `object`.\n\t *\n\t * **Note:** Non-object values are coerced to objects. See the\n\t * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n\t * for more details.\n\t *\n\t * @static\n\t * @since 0.1.0\n\t * @memberOf _\n\t * @category Object\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t * @example\n\t *\n\t * function Foo() {\n\t *   this.a = 1;\n\t *   this.b = 2;\n\t * }\n\t *\n\t * Foo.prototype.c = 3;\n\t *\n\t * _.keys(new Foo);\n\t * // => ['a', 'b'] (iteration order is not guaranteed)\n\t *\n\t * _.keys('hi');\n\t * // => ['0', '1']\n\t */\n\tfunction keys(object) {\n\t  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n\t}\n\t\n\tmodule.exports = keys;\n\n\n/***/ }),\n/* 123 */,\n/* 124 */,\n/* 125 */,\n/* 126 */,\n/* 127 */,\n/* 128 */,\n/* 129 */,\n/* 130 */,\n/* 131 */,\n/* 132 */,\n/* 133 */,\n/* 134 */,\n/* 135 */,\n/* 136 */,\n/* 137 */,\n/* 138 */,\n/* 139 */,\n/* 140 */,\n/* 141 */,\n/* 142 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar isProduction = (\"production\") === 'production';\n\tvar prefix = 'Invariant failed';\n\tfunction invariant(condition, message) {\n\t  if (condition) {\n\t    return;\n\t  }\n\t\n\t  if (isProduction) {\n\t    throw new Error(prefix);\n\t  } else {\n\t    throw new Error(prefix + \": \" + (message || ''));\n\t  }\n\t}\n\t\n\tmodule.exports = invariant;\n\n\n/***/ }),\n/* 143 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar isProduction = (\"production\") === 'production';\n\tfunction warning(condition, message) {\n\t  if (!isProduction) {\n\t    if (condition) {\n\t      return;\n\t    }\n\t\n\t    var text = \"Warning: \" + message;\n\t\n\t    if (typeof console !== 'undefined') {\n\t      console.warn(text);\n\t    }\n\t\n\t    try {\n\t      throw Error(text);\n\t    } catch (x) {}\n\t  }\n\t}\n\t\n\tmodule.exports = warning;\n\n\n/***/ }),\n/* 144 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ }),\n/* 145 */,\n/* 146 */,\n/* 147 */,\n/* 148 */,\n/* 149 */,\n/* 150 */,\n/* 151 */,\n/* 152 */,\n/* 153 */,\n/* 154 */,\n/* 155 */,\n/* 156 */,\n/* 157 */,\n/* 158 */,\n/* 159 */,\n/* 160 */,\n/* 161 */,\n/* 162 */,\n/* 163 */,\n/* 164 */,\n/* 165 */,\n/* 166 */,\n/* 167 */,\n/* 168 */,\n/* 169 */,\n/* 170 */,\n/* 171 */,\n/* 172 */,\n/* 173 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar ListCache = __webpack_require__(72),\n\t    stackClear = __webpack_require__(436),\n\t    stackDelete = __webpack_require__(437),\n\t    stackGet = __webpack_require__(438),\n\t    stackHas = __webpack_require__(439),\n\t    stackSet = __webpack_require__(440);\n\t\n\t/**\n\t * Creates a stack cache object to store key-value pairs.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */\n\tfunction Stack(entries) {\n\t  var data = this.__data__ = new ListCache(entries);\n\t  this.size = data.size;\n\t}\n\t\n\t// Add methods to `Stack`.\n\tStack.prototype.clear = stackClear;\n\tStack.prototype['delete'] = stackDelete;\n\tStack.prototype.get = stackGet;\n\tStack.prototype.has = stackHas;\n\tStack.prototype.set = stackSet;\n\t\n\tmodule.exports = Stack;\n\n\n/***/ }),\n/* 174 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar castPath = __webpack_require__(175),\n\t    toKey = __webpack_require__(77);\n\t\n\t/**\n\t * The base implementation of `_.get` without support for default values.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {Array|string} path The path of the property to get.\n\t * @returns {*} Returns the resolved value.\n\t */\n\tfunction baseGet(object, path) {\n\t  path = castPath(path, object);\n\t\n\t  var index = 0,\n\t      length = path.length;\n\t\n\t  while (object != null && index < length) {\n\t    object = object[toKey(path[index++])];\n\t  }\n\t  return (index && index == length) ? object : undefined;\n\t}\n\t\n\tmodule.exports = baseGet;\n\n\n/***/ }),\n/* 175 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar isArray = __webpack_require__(18),\n\t    isKey = __webpack_require__(118),\n\t    stringToPath = __webpack_require__(441),\n\t    toString = __webpack_require__(451);\n\t\n\t/**\n\t * Casts `value` to a path array if it's not one.\n\t *\n\t * @private\n\t * @param {*} value The value to inspect.\n\t * @param {Object} [object] The object to query keys on.\n\t * @returns {Array} Returns the cast property path array.\n\t */\n\tfunction castPath(value, object) {\n\t  if (isArray(value)) {\n\t    return value;\n\t  }\n\t  return isKey(value, object) ? [value] : stringToPath(toString(value));\n\t}\n\t\n\tmodule.exports = castPath;\n\n\n/***/ }),\n/* 176 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar SetCache = __webpack_require__(364),\n\t    arraySome = __webpack_require__(372),\n\t    cacheHas = __webpack_require__(394);\n\t\n\t/** Used to compose bitmasks for value comparisons. */\n\tvar COMPARE_PARTIAL_FLAG = 1,\n\t    COMPARE_UNORDERED_FLAG = 2;\n\t\n\t/**\n\t * A specialized version of `baseIsEqualDeep` for arrays with support for\n\t * partial deep comparisons.\n\t *\n\t * @private\n\t * @param {Array} array The array to compare.\n\t * @param {Array} other The other array to compare.\n\t * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n\t * @param {Function} customizer The function to customize comparisons.\n\t * @param {Function} equalFunc The function to determine equivalents of values.\n\t * @param {Object} stack Tracks traversed `array` and `other` objects.\n\t * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n\t */\n\tfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n\t  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n\t      arrLength = array.length,\n\t      othLength = other.length;\n\t\n\t  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n\t    return false;\n\t  }\n\t  // Assume cyclic values are equal.\n\t  var stacked = stack.get(array);\n\t  if (stacked && stack.get(other)) {\n\t    return stacked == other;\n\t  }\n\t  var index = -1,\n\t      result = true,\n\t      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\t\n\t  stack.set(array, other);\n\t  stack.set(other, array);\n\t\n\t  // Ignore non-index properties.\n\t  while (++index < arrLength) {\n\t    var arrValue = array[index],\n\t        othValue = other[index];\n\t\n\t    if (customizer) {\n\t      var compared = isPartial\n\t        ? customizer(othValue, arrValue, index, other, array, stack)\n\t        : customizer(arrValue, othValue, index, array, other, stack);\n\t    }\n\t    if (compared !== undefined) {\n\t      if (compared) {\n\t        continue;\n\t      }\n\t      result = false;\n\t      break;\n\t    }\n\t    // Recursively compare arrays (susceptible to call stack limits).\n\t    if (seen) {\n\t      if (!arraySome(other, function(othValue, othIndex) {\n\t            if (!cacheHas(seen, othIndex) &&\n\t                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n\t              return seen.push(othIndex);\n\t            }\n\t          })) {\n\t        result = false;\n\t        break;\n\t      }\n\t    } else if (!(\n\t          arrValue === othValue ||\n\t            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n\t        )) {\n\t      result = false;\n\t      break;\n\t    }\n\t  }\n\t  stack['delete'](array);\n\t  stack['delete'](other);\n\t  return result;\n\t}\n\t\n\tmodule.exports = equalArrays;\n\n\n/***/ }),\n/* 177 */\n/***/ (function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */\n\tvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\t\n\tmodule.exports = freeGlobal;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 178 */\n/***/ (function(module, exports) {\n\n\t/** Used as references for various `Number` constants. */\n\tvar MAX_SAFE_INTEGER = 9007199254740991;\n\t\n\t/** Used to detect unsigned integer values. */\n\tvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\t\n\t/**\n\t * Checks if `value` is a valid array-like index.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t */\n\tfunction isIndex(value, length) {\n\t  var type = typeof value;\n\t  length = length == null ? MAX_SAFE_INTEGER : length;\n\t\n\t  return !!length &&\n\t    (type == 'number' ||\n\t      (type != 'symbol' && reIsUint.test(value))) &&\n\t        (value > -1 && value % 1 == 0 && value < length);\n\t}\n\t\n\tmodule.exports = isIndex;\n\n\n/***/ }),\n/* 179 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(120);\n\t\n\t/**\n\t * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` if suitable for strict\n\t *  equality comparisons, else `false`.\n\t */\n\tfunction isStrictComparable(value) {\n\t  return value === value && !isObject(value);\n\t}\n\t\n\tmodule.exports = isStrictComparable;\n\n\n/***/ }),\n/* 180 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * A specialized version of `matchesProperty` for source values suitable\n\t * for strict equality comparisons, i.e. `===`.\n\t *\n\t * @private\n\t * @param {string} key The key of the property to get.\n\t * @param {*} srcValue The value to match.\n\t * @returns {Function} Returns the new spec function.\n\t */\n\tfunction matchesStrictComparable(key, srcValue) {\n\t  return function(object) {\n\t    if (object == null) {\n\t      return false;\n\t    }\n\t    return object[key] === srcValue &&\n\t      (srcValue !== undefined || (key in Object(object)));\n\t  };\n\t}\n\t\n\tmodule.exports = matchesStrictComparable;\n\n\n/***/ }),\n/* 181 */\n/***/ (function(module, exports) {\n\n\t/** Used for built-in method references. */\n\tvar funcProto = Function.prototype;\n\t\n\t/** Used to resolve the decompiled source of functions. */\n\tvar funcToString = funcProto.toString;\n\t\n\t/**\n\t * Converts `func` to its source code.\n\t *\n\t * @private\n\t * @param {Function} func The function to convert.\n\t * @returns {string} Returns the source code.\n\t */\n\tfunction toSource(func) {\n\t  if (func != null) {\n\t    try {\n\t      return funcToString.call(func);\n\t    } catch (e) {}\n\t    try {\n\t      return (func + '');\n\t    } catch (e) {}\n\t  }\n\t  return '';\n\t}\n\t\n\tmodule.exports = toSource;\n\n\n/***/ }),\n/* 182 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Performs a\n\t * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t * comparison between two values to determine if they are equivalent.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to compare.\n\t * @param {*} other The other value to compare.\n\t * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t * @example\n\t *\n\t * var object = { 'a': 1 };\n\t * var other = { 'a': 1 };\n\t *\n\t * _.eq(object, object);\n\t * // => true\n\t *\n\t * _.eq(object, other);\n\t * // => false\n\t *\n\t * _.eq('a', 'a');\n\t * // => true\n\t *\n\t * _.eq('a', Object('a'));\n\t * // => false\n\t *\n\t * _.eq(NaN, NaN);\n\t * // => true\n\t */\n\tfunction eq(value, other) {\n\t  return value === other || (value !== value && other !== other);\n\t}\n\t\n\tmodule.exports = eq;\n\n\n/***/ }),\n/* 183 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseIsArguments = __webpack_require__(380),\n\t    isObjectLike = __webpack_require__(51);\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/** Built-in value references. */\n\tvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\t\n\t/**\n\t * Checks if `value` is likely an `arguments` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n\t *  else `false`.\n\t * @example\n\t *\n\t * _.isArguments(function() { return arguments; }());\n\t * // => true\n\t *\n\t * _.isArguments([1, 2, 3]);\n\t * // => false\n\t */\n\tvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n\t  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n\t    !propertyIsEnumerable.call(value, 'callee');\n\t};\n\t\n\tmodule.exports = isArguments;\n\n\n/***/ }),\n/* 184 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar isFunction = __webpack_require__(186),\n\t    isLength = __webpack_require__(119);\n\t\n\t/**\n\t * Checks if `value` is array-like. A value is considered array-like if it's\n\t * not a function and has a `value.length` that's an integer greater than or\n\t * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n\t * @example\n\t *\n\t * _.isArrayLike([1, 2, 3]);\n\t * // => true\n\t *\n\t * _.isArrayLike(document.body.children);\n\t * // => true\n\t *\n\t * _.isArrayLike('abc');\n\t * // => true\n\t *\n\t * _.isArrayLike(_.noop);\n\t * // => false\n\t */\n\tfunction isArrayLike(value) {\n\t  return value != null && isLength(value.length) && !isFunction(value);\n\t}\n\t\n\tmodule.exports = isArrayLike;\n\n\n/***/ }),\n/* 185 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(17),\n\t    stubFalse = __webpack_require__(450);\n\t\n\t/** Detect free variable `exports`. */\n\tvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\t\n\t/** Detect free variable `module`. */\n\tvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\t\n\t/** Detect the popular CommonJS extension `module.exports`. */\n\tvar moduleExports = freeModule && freeModule.exports === freeExports;\n\t\n\t/** Built-in value references. */\n\tvar Buffer = moduleExports ? root.Buffer : undefined;\n\t\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\t\n\t/**\n\t * Checks if `value` is a buffer.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.3.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n\t * @example\n\t *\n\t * _.isBuffer(new Buffer(2));\n\t * // => true\n\t *\n\t * _.isBuffer(new Uint8Array(2));\n\t * // => false\n\t */\n\tvar isBuffer = nativeIsBuffer || stubFalse;\n\t\n\tmodule.exports = isBuffer;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(144)(module)))\n\n/***/ }),\n/* 186 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseGetTag = __webpack_require__(50),\n\t    isObject = __webpack_require__(120);\n\t\n\t/** `Object#toString` result references. */\n\tvar asyncTag = '[object AsyncFunction]',\n\t    funcTag = '[object Function]',\n\t    genTag = '[object GeneratorFunction]',\n\t    proxyTag = '[object Proxy]';\n\t\n\t/**\n\t * Checks if `value` is classified as a `Function` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n\t * @example\n\t *\n\t * _.isFunction(_);\n\t * // => true\n\t *\n\t * _.isFunction(/abc/);\n\t * // => false\n\t */\n\tfunction isFunction(value) {\n\t  if (!isObject(value)) {\n\t    return false;\n\t  }\n\t  // The use of `Object#toString` avoids issues with the `typeof` operator\n\t  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n\t  var tag = baseGetTag(value);\n\t  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n\t}\n\t\n\tmodule.exports = isFunction;\n\n\n/***/ }),\n/* 187 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseIsTypedArray = __webpack_require__(384),\n\t    baseUnary = __webpack_require__(393),\n\t    nodeUtil = __webpack_require__(430);\n\t\n\t/* Node.js helper references. */\n\tvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\t\n\t/**\n\t * Checks if `value` is classified as a typed array.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n\t * @example\n\t *\n\t * _.isTypedArray(new Uint8Array);\n\t * // => true\n\t *\n\t * _.isTypedArray([]);\n\t * // => false\n\t */\n\tvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\t\n\tmodule.exports = isTypedArray;\n\n\n/***/ }),\n/* 188 */,\n/* 189 */,\n/* 190 */,\n/* 191 */,\n/* 192 */,\n/* 193 */,\n/* 194 */,\n/* 195 */,\n/* 196 */,\n/* 197 */,\n/* 198 */,\n/* 199 */,\n/* 200 */,\n/* 201 */,\n/* 202 */,\n/* 203 */,\n/* 204 */,\n/* 205 */,\n/* 206 */,\n/* 207 */,\n/* 208 */,\n/* 209 */,\n/* 210 */,\n/* 211 */,\n/* 212 */,\n/* 213 */,\n/* 214 */,\n/* 215 */,\n/* 216 */,\n/* 217 */,\n/* 218 */,\n/* 219 */,\n/* 220 */,\n/* 221 */,\n/* 222 */,\n/* 223 */,\n/* 224 */,\n/* 225 */,\n/* 226 */,\n/* 227 */,\n/* 228 */,\n/* 229 */,\n/* 230 */,\n/* 231 */,\n/* 232 */,\n/* 233 */,\n/* 234 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _react = __webpack_require__(4);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _gatsbyLink = __webpack_require__(112);\n\t\n\tvar _gatsbyLink2 = _interopRequireDefault(_gatsbyLink);\n\t\n\tvar _reactChartjs = __webpack_require__(457);\n\t\n\tvar _reactChartjs2 = _interopRequireDefault(_reactChartjs);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar chartOptions = {\n\t  responsive: true,\n\t  legend: {\n\t    display: true\n\t  },\n\t  animation: {\n\t    duration: 1200,\n\t    easing: 'easeOutBack'\n\t  },\n\t  labels: {\n\t    display: true\n\t  },\n\t  layout: {\n\t    padding: {\n\t      top: 20,\n\t      bottom: 30\n\t    }\n\t  },\n\t  tooltips: {\n\t    callbacks: {\n\t      label: function label(tooltipItem, data) {\n\t        var total = data.datasets[0].data.reduce(function (a, b) {\n\t          return a + b;\n\t        }, 0);\n\t        var label = data.labels[tooltipItem.index] || '';\n\t        label += ' : $' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\t        label += ' : ' + Math.abs(Math.round(data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index] / total * 100));\n\t        label += '%';\n\t        label += '\\n';\n\t        label += 'Number of cans : ' + Math.round(data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index] * 10);\n\t        return label;\n\t      }\n\t    }\n\t  },\n\t  pieceLabel: {\n\t    render: function render(args) {\n\t      // args will be something like:\n\t      // { label: 'Label', value: 123, percentage: 50, index: 0, dataset: {...} }\n\t      return args.label + '\\n';\n\t\n\t      // return object if it is image\n\t      // return { src: 'image.png', width: 16, height: 16 };\n\t    },\n\t    fontFamily: 'Helvetica Neue',\n\t    fontSize: 14,\n\t    position: 'outside',\n\t    textMargin: 10\n\t  }\n\t};\n\tvar chartData = {\n\t  labels: [\"Team Matt\", \"Radon Canyon\", \"Total\", \"Goal\"],\n\t  datasets: [{\n\t    data: [114.40, 185.60, 300.00, 50.00],\n\t    backgroundColor: [\"#0ad1bf\", \"#ff7e22\", \"green\", \"#b0bec5\"]\n\t\n\t  }] };\n\t\n\tvar IndexPage = function IndexPage() {\n\t  return _react2.default.createElement(\n\t    'div',\n\t    null,\n\t    _react2.default.createElement(\n\t      'p',\n\t      null,\n\t      'Welcome to our can collection counter.'\n\t    ),\n\t    _react2.default.createElement(\n\t      'p',\n\t      null,\n\t      'A group of friends and I are collecting cans for whimsical things to make our lives more vibrant. Here I will document our process:'\n\t    ),\n\t    _react2.default.createElement('div', null),\n\t    _react2.default.createElement(_reactChartjs2.default, { data: chartData, options: chartOptions })\n\t  );\n\t};\n\t\n\texports.default = IndexPage;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 235 */,\n/* 236 */,\n/* 237 */,\n/* 238 */,\n/* 239 */,\n/* 240 */,\n/* 241 */,\n/* 242 */,\n/* 243 */,\n/* 244 */,\n/* 245 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * Chart.js v2.8.0\n\t * https://www.chartjs.org\n\t * (c) 2019 Chart.js Contributors\n\t * Released under the MIT License\n\t */\n\t(function (global, factory) {\n\t true ? module.exports = factory(function() { try { return __webpack_require__(453); } catch(e) { } }()) :\n\ttypeof define === 'function' && define.amd ? define(['require'], function(require) { return factory(function() { try { return require('moment'); } catch(e) { } }()); }) :\n\t(global.Chart = factory(global.moment));\n\t}(this, (function (moment) { 'use strict';\n\t\n\tmoment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;\n\t\n\t/* MIT license */\n\t\n\tvar conversions = {\n\t  rgb2hsl: rgb2hsl,\n\t  rgb2hsv: rgb2hsv,\n\t  rgb2hwb: rgb2hwb,\n\t  rgb2cmyk: rgb2cmyk,\n\t  rgb2keyword: rgb2keyword,\n\t  rgb2xyz: rgb2xyz,\n\t  rgb2lab: rgb2lab,\n\t  rgb2lch: rgb2lch,\n\t\n\t  hsl2rgb: hsl2rgb,\n\t  hsl2hsv: hsl2hsv,\n\t  hsl2hwb: hsl2hwb,\n\t  hsl2cmyk: hsl2cmyk,\n\t  hsl2keyword: hsl2keyword,\n\t\n\t  hsv2rgb: hsv2rgb,\n\t  hsv2hsl: hsv2hsl,\n\t  hsv2hwb: hsv2hwb,\n\t  hsv2cmyk: hsv2cmyk,\n\t  hsv2keyword: hsv2keyword,\n\t\n\t  hwb2rgb: hwb2rgb,\n\t  hwb2hsl: hwb2hsl,\n\t  hwb2hsv: hwb2hsv,\n\t  hwb2cmyk: hwb2cmyk,\n\t  hwb2keyword: hwb2keyword,\n\t\n\t  cmyk2rgb: cmyk2rgb,\n\t  cmyk2hsl: cmyk2hsl,\n\t  cmyk2hsv: cmyk2hsv,\n\t  cmyk2hwb: cmyk2hwb,\n\t  cmyk2keyword: cmyk2keyword,\n\t\n\t  keyword2rgb: keyword2rgb,\n\t  keyword2hsl: keyword2hsl,\n\t  keyword2hsv: keyword2hsv,\n\t  keyword2hwb: keyword2hwb,\n\t  keyword2cmyk: keyword2cmyk,\n\t  keyword2lab: keyword2lab,\n\t  keyword2xyz: keyword2xyz,\n\t\n\t  xyz2rgb: xyz2rgb,\n\t  xyz2lab: xyz2lab,\n\t  xyz2lch: xyz2lch,\n\t\n\t  lab2xyz: lab2xyz,\n\t  lab2rgb: lab2rgb,\n\t  lab2lch: lab2lch,\n\t\n\t  lch2lab: lch2lab,\n\t  lch2xyz: lch2xyz,\n\t  lch2rgb: lch2rgb\n\t};\n\t\n\t\n\tfunction rgb2hsl(rgb) {\n\t  var r = rgb[0]/255,\n\t      g = rgb[1]/255,\n\t      b = rgb[2]/255,\n\t      min = Math.min(r, g, b),\n\t      max = Math.max(r, g, b),\n\t      delta = max - min,\n\t      h, s, l;\n\t\n\t  if (max == min)\n\t    h = 0;\n\t  else if (r == max)\n\t    h = (g - b) / delta;\n\t  else if (g == max)\n\t    h = 2 + (b - r) / delta;\n\t  else if (b == max)\n\t    h = 4 + (r - g)/ delta;\n\t\n\t  h = Math.min(h * 60, 360);\n\t\n\t  if (h < 0)\n\t    h += 360;\n\t\n\t  l = (min + max) / 2;\n\t\n\t  if (max == min)\n\t    s = 0;\n\t  else if (l <= 0.5)\n\t    s = delta / (max + min);\n\t  else\n\t    s = delta / (2 - max - min);\n\t\n\t  return [h, s * 100, l * 100];\n\t}\n\t\n\tfunction rgb2hsv(rgb) {\n\t  var r = rgb[0],\n\t      g = rgb[1],\n\t      b = rgb[2],\n\t      min = Math.min(r, g, b),\n\t      max = Math.max(r, g, b),\n\t      delta = max - min,\n\t      h, s, v;\n\t\n\t  if (max == 0)\n\t    s = 0;\n\t  else\n\t    s = (delta/max * 1000)/10;\n\t\n\t  if (max == min)\n\t    h = 0;\n\t  else if (r == max)\n\t    h = (g - b) / delta;\n\t  else if (g == max)\n\t    h = 2 + (b - r) / delta;\n\t  else if (b == max)\n\t    h = 4 + (r - g) / delta;\n\t\n\t  h = Math.min(h * 60, 360);\n\t\n\t  if (h < 0)\n\t    h += 360;\n\t\n\t  v = ((max / 255) * 1000) / 10;\n\t\n\t  return [h, s, v];\n\t}\n\t\n\tfunction rgb2hwb(rgb) {\n\t  var r = rgb[0],\n\t      g = rgb[1],\n\t      b = rgb[2],\n\t      h = rgb2hsl(rgb)[0],\n\t      w = 1/255 * Math.min(r, Math.min(g, b)),\n\t      b = 1 - 1/255 * Math.max(r, Math.max(g, b));\n\t\n\t  return [h, w * 100, b * 100];\n\t}\n\t\n\tfunction rgb2cmyk(rgb) {\n\t  var r = rgb[0] / 255,\n\t      g = rgb[1] / 255,\n\t      b = rgb[2] / 255,\n\t      c, m, y, k;\n\t\n\t  k = Math.min(1 - r, 1 - g, 1 - b);\n\t  c = (1 - r - k) / (1 - k) || 0;\n\t  m = (1 - g - k) / (1 - k) || 0;\n\t  y = (1 - b - k) / (1 - k) || 0;\n\t  return [c * 100, m * 100, y * 100, k * 100];\n\t}\n\t\n\tfunction rgb2keyword(rgb) {\n\t  return reverseKeywords[JSON.stringify(rgb)];\n\t}\n\t\n\tfunction rgb2xyz(rgb) {\n\t  var r = rgb[0] / 255,\n\t      g = rgb[1] / 255,\n\t      b = rgb[2] / 255;\n\t\n\t  // assume sRGB\n\t  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\t  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\t  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\t\n\t  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\t  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\t  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\t\n\t  return [x * 100, y *100, z * 100];\n\t}\n\t\n\tfunction rgb2lab(rgb) {\n\t  var xyz = rgb2xyz(rgb),\n\t        x = xyz[0],\n\t        y = xyz[1],\n\t        z = xyz[2],\n\t        l, a, b;\n\t\n\t  x /= 95.047;\n\t  y /= 100;\n\t  z /= 108.883;\n\t\n\t  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n\t  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n\t  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\t\n\t  l = (116 * y) - 16;\n\t  a = 500 * (x - y);\n\t  b = 200 * (y - z);\n\t\n\t  return [l, a, b];\n\t}\n\t\n\tfunction rgb2lch(args) {\n\t  return lab2lch(rgb2lab(args));\n\t}\n\t\n\tfunction hsl2rgb(hsl) {\n\t  var h = hsl[0] / 360,\n\t      s = hsl[1] / 100,\n\t      l = hsl[2] / 100,\n\t      t1, t2, t3, rgb, val;\n\t\n\t  if (s == 0) {\n\t    val = l * 255;\n\t    return [val, val, val];\n\t  }\n\t\n\t  if (l < 0.5)\n\t    t2 = l * (1 + s);\n\t  else\n\t    t2 = l + s - l * s;\n\t  t1 = 2 * l - t2;\n\t\n\t  rgb = [0, 0, 0];\n\t  for (var i = 0; i < 3; i++) {\n\t    t3 = h + 1 / 3 * - (i - 1);\n\t    t3 < 0 && t3++;\n\t    t3 > 1 && t3--;\n\t\n\t    if (6 * t3 < 1)\n\t      val = t1 + (t2 - t1) * 6 * t3;\n\t    else if (2 * t3 < 1)\n\t      val = t2;\n\t    else if (3 * t3 < 2)\n\t      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t    else\n\t      val = t1;\n\t\n\t    rgb[i] = val * 255;\n\t  }\n\t\n\t  return rgb;\n\t}\n\t\n\tfunction hsl2hsv(hsl) {\n\t  var h = hsl[0],\n\t      s = hsl[1] / 100,\n\t      l = hsl[2] / 100,\n\t      sv, v;\n\t\n\t  if(l === 0) {\n\t      // no need to do calc on black\n\t      // also avoids divide by 0 error\n\t      return [0, 0, 0];\n\t  }\n\t\n\t  l *= 2;\n\t  s *= (l <= 1) ? l : 2 - l;\n\t  v = (l + s) / 2;\n\t  sv = (2 * s) / (l + s);\n\t  return [h, sv * 100, v * 100];\n\t}\n\t\n\tfunction hsl2hwb(args) {\n\t  return rgb2hwb(hsl2rgb(args));\n\t}\n\t\n\tfunction hsl2cmyk(args) {\n\t  return rgb2cmyk(hsl2rgb(args));\n\t}\n\t\n\tfunction hsl2keyword(args) {\n\t  return rgb2keyword(hsl2rgb(args));\n\t}\n\t\n\t\n\tfunction hsv2rgb(hsv) {\n\t  var h = hsv[0] / 60,\n\t      s = hsv[1] / 100,\n\t      v = hsv[2] / 100,\n\t      hi = Math.floor(h) % 6;\n\t\n\t  var f = h - Math.floor(h),\n\t      p = 255 * v * (1 - s),\n\t      q = 255 * v * (1 - (s * f)),\n\t      t = 255 * v * (1 - (s * (1 - f))),\n\t      v = 255 * v;\n\t\n\t  switch(hi) {\n\t    case 0:\n\t      return [v, t, p];\n\t    case 1:\n\t      return [q, v, p];\n\t    case 2:\n\t      return [p, v, t];\n\t    case 3:\n\t      return [p, q, v];\n\t    case 4:\n\t      return [t, p, v];\n\t    case 5:\n\t      return [v, p, q];\n\t  }\n\t}\n\t\n\tfunction hsv2hsl(hsv) {\n\t  var h = hsv[0],\n\t      s = hsv[1] / 100,\n\t      v = hsv[2] / 100,\n\t      sl, l;\n\t\n\t  l = (2 - s) * v;\n\t  sl = s * v;\n\t  sl /= (l <= 1) ? l : 2 - l;\n\t  sl = sl || 0;\n\t  l /= 2;\n\t  return [h, sl * 100, l * 100];\n\t}\n\t\n\tfunction hsv2hwb(args) {\n\t  return rgb2hwb(hsv2rgb(args))\n\t}\n\t\n\tfunction hsv2cmyk(args) {\n\t  return rgb2cmyk(hsv2rgb(args));\n\t}\n\t\n\tfunction hsv2keyword(args) {\n\t  return rgb2keyword(hsv2rgb(args));\n\t}\n\t\n\t// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\n\tfunction hwb2rgb(hwb) {\n\t  var h = hwb[0] / 360,\n\t      wh = hwb[1] / 100,\n\t      bl = hwb[2] / 100,\n\t      ratio = wh + bl,\n\t      i, v, f, n;\n\t\n\t  // wh + bl cant be > 1\n\t  if (ratio > 1) {\n\t    wh /= ratio;\n\t    bl /= ratio;\n\t  }\n\t\n\t  i = Math.floor(6 * h);\n\t  v = 1 - bl;\n\t  f = 6 * h - i;\n\t  if ((i & 0x01) != 0) {\n\t    f = 1 - f;\n\t  }\n\t  n = wh + f * (v - wh);  // linear interpolation\n\t\n\t  switch (i) {\n\t    default:\n\t    case 6:\n\t    case 0: r = v; g = n; b = wh; break;\n\t    case 1: r = n; g = v; b = wh; break;\n\t    case 2: r = wh; g = v; b = n; break;\n\t    case 3: r = wh; g = n; b = v; break;\n\t    case 4: r = n; g = wh; b = v; break;\n\t    case 5: r = v; g = wh; b = n; break;\n\t  }\n\t\n\t  return [r * 255, g * 255, b * 255];\n\t}\n\t\n\tfunction hwb2hsl(args) {\n\t  return rgb2hsl(hwb2rgb(args));\n\t}\n\t\n\tfunction hwb2hsv(args) {\n\t  return rgb2hsv(hwb2rgb(args));\n\t}\n\t\n\tfunction hwb2cmyk(args) {\n\t  return rgb2cmyk(hwb2rgb(args));\n\t}\n\t\n\tfunction hwb2keyword(args) {\n\t  return rgb2keyword(hwb2rgb(args));\n\t}\n\t\n\tfunction cmyk2rgb(cmyk) {\n\t  var c = cmyk[0] / 100,\n\t      m = cmyk[1] / 100,\n\t      y = cmyk[2] / 100,\n\t      k = cmyk[3] / 100,\n\t      r, g, b;\n\t\n\t  r = 1 - Math.min(1, c * (1 - k) + k);\n\t  g = 1 - Math.min(1, m * (1 - k) + k);\n\t  b = 1 - Math.min(1, y * (1 - k) + k);\n\t  return [r * 255, g * 255, b * 255];\n\t}\n\t\n\tfunction cmyk2hsl(args) {\n\t  return rgb2hsl(cmyk2rgb(args));\n\t}\n\t\n\tfunction cmyk2hsv(args) {\n\t  return rgb2hsv(cmyk2rgb(args));\n\t}\n\t\n\tfunction cmyk2hwb(args) {\n\t  return rgb2hwb(cmyk2rgb(args));\n\t}\n\t\n\tfunction cmyk2keyword(args) {\n\t  return rgb2keyword(cmyk2rgb(args));\n\t}\n\t\n\t\n\tfunction xyz2rgb(xyz) {\n\t  var x = xyz[0] / 100,\n\t      y = xyz[1] / 100,\n\t      z = xyz[2] / 100,\n\t      r, g, b;\n\t\n\t  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\t  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\t  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\t\n\t  // assume sRGB\n\t  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n\t    : r = (r * 12.92);\n\t\n\t  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n\t    : g = (g * 12.92);\n\t\n\t  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n\t    : b = (b * 12.92);\n\t\n\t  r = Math.min(Math.max(0, r), 1);\n\t  g = Math.min(Math.max(0, g), 1);\n\t  b = Math.min(Math.max(0, b), 1);\n\t\n\t  return [r * 255, g * 255, b * 255];\n\t}\n\t\n\tfunction xyz2lab(xyz) {\n\t  var x = xyz[0],\n\t      y = xyz[1],\n\t      z = xyz[2],\n\t      l, a, b;\n\t\n\t  x /= 95.047;\n\t  y /= 100;\n\t  z /= 108.883;\n\t\n\t  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n\t  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n\t  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\t\n\t  l = (116 * y) - 16;\n\t  a = 500 * (x - y);\n\t  b = 200 * (y - z);\n\t\n\t  return [l, a, b];\n\t}\n\t\n\tfunction xyz2lch(args) {\n\t  return lab2lch(xyz2lab(args));\n\t}\n\t\n\tfunction lab2xyz(lab) {\n\t  var l = lab[0],\n\t      a = lab[1],\n\t      b = lab[2],\n\t      x, y, z, y2;\n\t\n\t  if (l <= 8) {\n\t    y = (l * 100) / 903.3;\n\t    y2 = (7.787 * (y / 100)) + (16 / 116);\n\t  } else {\n\t    y = 100 * Math.pow((l + 16) / 116, 3);\n\t    y2 = Math.pow(y / 100, 1/3);\n\t  }\n\t\n\t  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\n\t\n\t  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\n\t\n\t  return [x, y, z];\n\t}\n\t\n\tfunction lab2lch(lab) {\n\t  var l = lab[0],\n\t      a = lab[1],\n\t      b = lab[2],\n\t      hr, h, c;\n\t\n\t  hr = Math.atan2(b, a);\n\t  h = hr * 360 / 2 / Math.PI;\n\t  if (h < 0) {\n\t    h += 360;\n\t  }\n\t  c = Math.sqrt(a * a + b * b);\n\t  return [l, c, h];\n\t}\n\t\n\tfunction lab2rgb(args) {\n\t  return xyz2rgb(lab2xyz(args));\n\t}\n\t\n\tfunction lch2lab(lch) {\n\t  var l = lch[0],\n\t      c = lch[1],\n\t      h = lch[2],\n\t      a, b, hr;\n\t\n\t  hr = h / 360 * 2 * Math.PI;\n\t  a = c * Math.cos(hr);\n\t  b = c * Math.sin(hr);\n\t  return [l, a, b];\n\t}\n\t\n\tfunction lch2xyz(args) {\n\t  return lab2xyz(lch2lab(args));\n\t}\n\t\n\tfunction lch2rgb(args) {\n\t  return lab2rgb(lch2lab(args));\n\t}\n\t\n\tfunction keyword2rgb(keyword) {\n\t  return cssKeywords[keyword];\n\t}\n\t\n\tfunction keyword2hsl(args) {\n\t  return rgb2hsl(keyword2rgb(args));\n\t}\n\t\n\tfunction keyword2hsv(args) {\n\t  return rgb2hsv(keyword2rgb(args));\n\t}\n\t\n\tfunction keyword2hwb(args) {\n\t  return rgb2hwb(keyword2rgb(args));\n\t}\n\t\n\tfunction keyword2cmyk(args) {\n\t  return rgb2cmyk(keyword2rgb(args));\n\t}\n\t\n\tfunction keyword2lab(args) {\n\t  return rgb2lab(keyword2rgb(args));\n\t}\n\t\n\tfunction keyword2xyz(args) {\n\t  return rgb2xyz(keyword2rgb(args));\n\t}\n\t\n\tvar cssKeywords = {\n\t  aliceblue:  [240,248,255],\n\t  antiquewhite: [250,235,215],\n\t  aqua: [0,255,255],\n\t  aquamarine: [127,255,212],\n\t  azure:  [240,255,255],\n\t  beige:  [245,245,220],\n\t  bisque: [255,228,196],\n\t  black:  [0,0,0],\n\t  blanchedalmond: [255,235,205],\n\t  blue: [0,0,255],\n\t  blueviolet: [138,43,226],\n\t  brown:  [165,42,42],\n\t  burlywood:  [222,184,135],\n\t  cadetblue:  [95,158,160],\n\t  chartreuse: [127,255,0],\n\t  chocolate:  [210,105,30],\n\t  coral:  [255,127,80],\n\t  cornflowerblue: [100,149,237],\n\t  cornsilk: [255,248,220],\n\t  crimson:  [220,20,60],\n\t  cyan: [0,255,255],\n\t  darkblue: [0,0,139],\n\t  darkcyan: [0,139,139],\n\t  darkgoldenrod:  [184,134,11],\n\t  darkgray: [169,169,169],\n\t  darkgreen:  [0,100,0],\n\t  darkgrey: [169,169,169],\n\t  darkkhaki:  [189,183,107],\n\t  darkmagenta:  [139,0,139],\n\t  darkolivegreen: [85,107,47],\n\t  darkorange: [255,140,0],\n\t  darkorchid: [153,50,204],\n\t  darkred:  [139,0,0],\n\t  darksalmon: [233,150,122],\n\t  darkseagreen: [143,188,143],\n\t  darkslateblue:  [72,61,139],\n\t  darkslategray:  [47,79,79],\n\t  darkslategrey:  [47,79,79],\n\t  darkturquoise:  [0,206,209],\n\t  darkviolet: [148,0,211],\n\t  deeppink: [255,20,147],\n\t  deepskyblue:  [0,191,255],\n\t  dimgray:  [105,105,105],\n\t  dimgrey:  [105,105,105],\n\t  dodgerblue: [30,144,255],\n\t  firebrick:  [178,34,34],\n\t  floralwhite:  [255,250,240],\n\t  forestgreen:  [34,139,34],\n\t  fuchsia:  [255,0,255],\n\t  gainsboro:  [220,220,220],\n\t  ghostwhite: [248,248,255],\n\t  gold: [255,215,0],\n\t  goldenrod:  [218,165,32],\n\t  gray: [128,128,128],\n\t  green:  [0,128,0],\n\t  greenyellow:  [173,255,47],\n\t  grey: [128,128,128],\n\t  honeydew: [240,255,240],\n\t  hotpink:  [255,105,180],\n\t  indianred:  [205,92,92],\n\t  indigo: [75,0,130],\n\t  ivory:  [255,255,240],\n\t  khaki:  [240,230,140],\n\t  lavender: [230,230,250],\n\t  lavenderblush:  [255,240,245],\n\t  lawngreen:  [124,252,0],\n\t  lemonchiffon: [255,250,205],\n\t  lightblue:  [173,216,230],\n\t  lightcoral: [240,128,128],\n\t  lightcyan:  [224,255,255],\n\t  lightgoldenrodyellow: [250,250,210],\n\t  lightgray:  [211,211,211],\n\t  lightgreen: [144,238,144],\n\t  lightgrey:  [211,211,211],\n\t  lightpink:  [255,182,193],\n\t  lightsalmon:  [255,160,122],\n\t  lightseagreen:  [32,178,170],\n\t  lightskyblue: [135,206,250],\n\t  lightslategray: [119,136,153],\n\t  lightslategrey: [119,136,153],\n\t  lightsteelblue: [176,196,222],\n\t  lightyellow:  [255,255,224],\n\t  lime: [0,255,0],\n\t  limegreen:  [50,205,50],\n\t  linen:  [250,240,230],\n\t  magenta:  [255,0,255],\n\t  maroon: [128,0,0],\n\t  mediumaquamarine: [102,205,170],\n\t  mediumblue: [0,0,205],\n\t  mediumorchid: [186,85,211],\n\t  mediumpurple: [147,112,219],\n\t  mediumseagreen: [60,179,113],\n\t  mediumslateblue:  [123,104,238],\n\t  mediumspringgreen:  [0,250,154],\n\t  mediumturquoise:  [72,209,204],\n\t  mediumvioletred:  [199,21,133],\n\t  midnightblue: [25,25,112],\n\t  mintcream:  [245,255,250],\n\t  mistyrose:  [255,228,225],\n\t  moccasin: [255,228,181],\n\t  navajowhite:  [255,222,173],\n\t  navy: [0,0,128],\n\t  oldlace:  [253,245,230],\n\t  olive:  [128,128,0],\n\t  olivedrab:  [107,142,35],\n\t  orange: [255,165,0],\n\t  orangered:  [255,69,0],\n\t  orchid: [218,112,214],\n\t  palegoldenrod:  [238,232,170],\n\t  palegreen:  [152,251,152],\n\t  paleturquoise:  [175,238,238],\n\t  palevioletred:  [219,112,147],\n\t  papayawhip: [255,239,213],\n\t  peachpuff:  [255,218,185],\n\t  peru: [205,133,63],\n\t  pink: [255,192,203],\n\t  plum: [221,160,221],\n\t  powderblue: [176,224,230],\n\t  purple: [128,0,128],\n\t  rebeccapurple: [102, 51, 153],\n\t  red:  [255,0,0],\n\t  rosybrown:  [188,143,143],\n\t  royalblue:  [65,105,225],\n\t  saddlebrown:  [139,69,19],\n\t  salmon: [250,128,114],\n\t  sandybrown: [244,164,96],\n\t  seagreen: [46,139,87],\n\t  seashell: [255,245,238],\n\t  sienna: [160,82,45],\n\t  silver: [192,192,192],\n\t  skyblue:  [135,206,235],\n\t  slateblue:  [106,90,205],\n\t  slategray:  [112,128,144],\n\t  slategrey:  [112,128,144],\n\t  snow: [255,250,250],\n\t  springgreen:  [0,255,127],\n\t  steelblue:  [70,130,180],\n\t  tan:  [210,180,140],\n\t  teal: [0,128,128],\n\t  thistle:  [216,191,216],\n\t  tomato: [255,99,71],\n\t  turquoise:  [64,224,208],\n\t  violet: [238,130,238],\n\t  wheat:  [245,222,179],\n\t  white:  [255,255,255],\n\t  whitesmoke: [245,245,245],\n\t  yellow: [255,255,0],\n\t  yellowgreen:  [154,205,50]\n\t};\n\t\n\tvar reverseKeywords = {};\n\tfor (var key in cssKeywords) {\n\t  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;\n\t}\n\t\n\tvar convert = function() {\n\t   return new Converter();\n\t};\n\t\n\tfor (var func in conversions) {\n\t  // export Raw versions\n\t  convert[func + \"Raw\"] =  (function(func) {\n\t    // accept array or plain args\n\t    return function(arg) {\n\t      if (typeof arg == \"number\")\n\t        arg = Array.prototype.slice.call(arguments);\n\t      return conversions[func](arg);\n\t    }\n\t  })(func);\n\t\n\t  var pair = /(\\w+)2(\\w+)/.exec(func),\n\t      from = pair[1],\n\t      to = pair[2];\n\t\n\t  // export rgb2hsl and [\"rgb\"][\"hsl\"]\n\t  convert[from] = convert[from] || {};\n\t\n\t  convert[from][to] = convert[func] = (function(func) { \n\t    return function(arg) {\n\t      if (typeof arg == \"number\")\n\t        arg = Array.prototype.slice.call(arguments);\n\t      \n\t      var val = conversions[func](arg);\n\t      if (typeof val == \"string\" || val === undefined)\n\t        return val; // keyword\n\t\n\t      for (var i = 0; i < val.length; i++)\n\t        val[i] = Math.round(val[i]);\n\t      return val;\n\t    }\n\t  })(func);\n\t}\n\t\n\t\n\t/* Converter does lazy conversion and caching */\n\tvar Converter = function() {\n\t   this.convs = {};\n\t};\n\t\n\t/* Either get the values for a space or\n\t  set the values for a space, depending on args */\n\tConverter.prototype.routeSpace = function(space, args) {\n\t   var values = args[0];\n\t   if (values === undefined) {\n\t      // color.rgb()\n\t      return this.getValues(space);\n\t   }\n\t   // color.rgb(10, 10, 10)\n\t   if (typeof values == \"number\") {\n\t      values = Array.prototype.slice.call(args);        \n\t   }\n\t\n\t   return this.setValues(space, values);\n\t};\n\t  \n\t/* Set the values for a space, invalidating cache */\n\tConverter.prototype.setValues = function(space, values) {\n\t   this.space = space;\n\t   this.convs = {};\n\t   this.convs[space] = values;\n\t   return this;\n\t};\n\t\n\t/* Get the values for a space. If there's already\n\t  a conversion for the space, fetch it, otherwise\n\t  compute it */\n\tConverter.prototype.getValues = function(space) {\n\t   var vals = this.convs[space];\n\t   if (!vals) {\n\t      var fspace = this.space,\n\t          from = this.convs[fspace];\n\t      vals = convert[fspace][space](from);\n\t\n\t      this.convs[space] = vals;\n\t   }\n\t  return vals;\n\t};\n\t\n\t[\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function(space) {\n\t   Converter.prototype[space] = function(vals) {\n\t      return this.routeSpace(space, arguments);\n\t   };\n\t});\n\t\n\tvar colorConvert = convert;\n\t\n\tvar colorName = {\r\n\t\t\"aliceblue\": [240, 248, 255],\r\n\t\t\"antiquewhite\": [250, 235, 215],\r\n\t\t\"aqua\": [0, 255, 255],\r\n\t\t\"aquamarine\": [127, 255, 212],\r\n\t\t\"azure\": [240, 255, 255],\r\n\t\t\"beige\": [245, 245, 220],\r\n\t\t\"bisque\": [255, 228, 196],\r\n\t\t\"black\": [0, 0, 0],\r\n\t\t\"blanchedalmond\": [255, 235, 205],\r\n\t\t\"blue\": [0, 0, 255],\r\n\t\t\"blueviolet\": [138, 43, 226],\r\n\t\t\"brown\": [165, 42, 42],\r\n\t\t\"burlywood\": [222, 184, 135],\r\n\t\t\"cadetblue\": [95, 158, 160],\r\n\t\t\"chartreuse\": [127, 255, 0],\r\n\t\t\"chocolate\": [210, 105, 30],\r\n\t\t\"coral\": [255, 127, 80],\r\n\t\t\"cornflowerblue\": [100, 149, 237],\r\n\t\t\"cornsilk\": [255, 248, 220],\r\n\t\t\"crimson\": [220, 20, 60],\r\n\t\t\"cyan\": [0, 255, 255],\r\n\t\t\"darkblue\": [0, 0, 139],\r\n\t\t\"darkcyan\": [0, 139, 139],\r\n\t\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\t\"darkgray\": [169, 169, 169],\r\n\t\t\"darkgreen\": [0, 100, 0],\r\n\t\t\"darkgrey\": [169, 169, 169],\r\n\t\t\"darkkhaki\": [189, 183, 107],\r\n\t\t\"darkmagenta\": [139, 0, 139],\r\n\t\t\"darkolivegreen\": [85, 107, 47],\r\n\t\t\"darkorange\": [255, 140, 0],\r\n\t\t\"darkorchid\": [153, 50, 204],\r\n\t\t\"darkred\": [139, 0, 0],\r\n\t\t\"darksalmon\": [233, 150, 122],\r\n\t\t\"darkseagreen\": [143, 188, 143],\r\n\t\t\"darkslateblue\": [72, 61, 139],\r\n\t\t\"darkslategray\": [47, 79, 79],\r\n\t\t\"darkslategrey\": [47, 79, 79],\r\n\t\t\"darkturquoise\": [0, 206, 209],\r\n\t\t\"darkviolet\": [148, 0, 211],\r\n\t\t\"deeppink\": [255, 20, 147],\r\n\t\t\"deepskyblue\": [0, 191, 255],\r\n\t\t\"dimgray\": [105, 105, 105],\r\n\t\t\"dimgrey\": [105, 105, 105],\r\n\t\t\"dodgerblue\": [30, 144, 255],\r\n\t\t\"firebrick\": [178, 34, 34],\r\n\t\t\"floralwhite\": [255, 250, 240],\r\n\t\t\"forestgreen\": [34, 139, 34],\r\n\t\t\"fuchsia\": [255, 0, 255],\r\n\t\t\"gainsboro\": [220, 220, 220],\r\n\t\t\"ghostwhite\": [248, 248, 255],\r\n\t\t\"gold\": [255, 215, 0],\r\n\t\t\"goldenrod\": [218, 165, 32],\r\n\t\t\"gray\": [128, 128, 128],\r\n\t\t\"green\": [0, 128, 0],\r\n\t\t\"greenyellow\": [173, 255, 47],\r\n\t\t\"grey\": [128, 128, 128],\r\n\t\t\"honeydew\": [240, 255, 240],\r\n\t\t\"hotpink\": [255, 105, 180],\r\n\t\t\"indianred\": [205, 92, 92],\r\n\t\t\"indigo\": [75, 0, 130],\r\n\t\t\"ivory\": [255, 255, 240],\r\n\t\t\"khaki\": [240, 230, 140],\r\n\t\t\"lavender\": [230, 230, 250],\r\n\t\t\"lavenderblush\": [255, 240, 245],\r\n\t\t\"lawngreen\": [124, 252, 0],\r\n\t\t\"lemonchiffon\": [255, 250, 205],\r\n\t\t\"lightblue\": [173, 216, 230],\r\n\t\t\"lightcoral\": [240, 128, 128],\r\n\t\t\"lightcyan\": [224, 255, 255],\r\n\t\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\t\"lightgray\": [211, 211, 211],\r\n\t\t\"lightgreen\": [144, 238, 144],\r\n\t\t\"lightgrey\": [211, 211, 211],\r\n\t\t\"lightpink\": [255, 182, 193],\r\n\t\t\"lightsalmon\": [255, 160, 122],\r\n\t\t\"lightseagreen\": [32, 178, 170],\r\n\t\t\"lightskyblue\": [135, 206, 250],\r\n\t\t\"lightslategray\": [119, 136, 153],\r\n\t\t\"lightslategrey\": [119, 136, 153],\r\n\t\t\"lightsteelblue\": [176, 196, 222],\r\n\t\t\"lightyellow\": [255, 255, 224],\r\n\t\t\"lime\": [0, 255, 0],\r\n\t\t\"limegreen\": [50, 205, 50],\r\n\t\t\"linen\": [250, 240, 230],\r\n\t\t\"magenta\": [255, 0, 255],\r\n\t\t\"maroon\": [128, 0, 0],\r\n\t\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\t\"mediumblue\": [0, 0, 205],\r\n\t\t\"mediumorchid\": [186, 85, 211],\r\n\t\t\"mediumpurple\": [147, 112, 219],\r\n\t\t\"mediumseagreen\": [60, 179, 113],\r\n\t\t\"mediumslateblue\": [123, 104, 238],\r\n\t\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\t\"mediumturquoise\": [72, 209, 204],\r\n\t\t\"mediumvioletred\": [199, 21, 133],\r\n\t\t\"midnightblue\": [25, 25, 112],\r\n\t\t\"mintcream\": [245, 255, 250],\r\n\t\t\"mistyrose\": [255, 228, 225],\r\n\t\t\"moccasin\": [255, 228, 181],\r\n\t\t\"navajowhite\": [255, 222, 173],\r\n\t\t\"navy\": [0, 0, 128],\r\n\t\t\"oldlace\": [253, 245, 230],\r\n\t\t\"olive\": [128, 128, 0],\r\n\t\t\"olivedrab\": [107, 142, 35],\r\n\t\t\"orange\": [255, 165, 0],\r\n\t\t\"orangered\": [255, 69, 0],\r\n\t\t\"orchid\": [218, 112, 214],\r\n\t\t\"palegoldenrod\": [238, 232, 170],\r\n\t\t\"palegreen\": [152, 251, 152],\r\n\t\t\"paleturquoise\": [175, 238, 238],\r\n\t\t\"palevioletred\": [219, 112, 147],\r\n\t\t\"papayawhip\": [255, 239, 213],\r\n\t\t\"peachpuff\": [255, 218, 185],\r\n\t\t\"peru\": [205, 133, 63],\r\n\t\t\"pink\": [255, 192, 203],\r\n\t\t\"plum\": [221, 160, 221],\r\n\t\t\"powderblue\": [176, 224, 230],\r\n\t\t\"purple\": [128, 0, 128],\r\n\t\t\"rebeccapurple\": [102, 51, 153],\r\n\t\t\"red\": [255, 0, 0],\r\n\t\t\"rosybrown\": [188, 143, 143],\r\n\t\t\"royalblue\": [65, 105, 225],\r\n\t\t\"saddlebrown\": [139, 69, 19],\r\n\t\t\"salmon\": [250, 128, 114],\r\n\t\t\"sandybrown\": [244, 164, 96],\r\n\t\t\"seagreen\": [46, 139, 87],\r\n\t\t\"seashell\": [255, 245, 238],\r\n\t\t\"sienna\": [160, 82, 45],\r\n\t\t\"silver\": [192, 192, 192],\r\n\t\t\"skyblue\": [135, 206, 235],\r\n\t\t\"slateblue\": [106, 90, 205],\r\n\t\t\"slategray\": [112, 128, 144],\r\n\t\t\"slategrey\": [112, 128, 144],\r\n\t\t\"snow\": [255, 250, 250],\r\n\t\t\"springgreen\": [0, 255, 127],\r\n\t\t\"steelblue\": [70, 130, 180],\r\n\t\t\"tan\": [210, 180, 140],\r\n\t\t\"teal\": [0, 128, 128],\r\n\t\t\"thistle\": [216, 191, 216],\r\n\t\t\"tomato\": [255, 99, 71],\r\n\t\t\"turquoise\": [64, 224, 208],\r\n\t\t\"violet\": [238, 130, 238],\r\n\t\t\"wheat\": [245, 222, 179],\r\n\t\t\"white\": [255, 255, 255],\r\n\t\t\"whitesmoke\": [245, 245, 245],\r\n\t\t\"yellow\": [255, 255, 0],\r\n\t\t\"yellowgreen\": [154, 205, 50]\r\n\t};\n\t\n\t/* MIT license */\n\t\n\t\n\tvar colorString = {\n\t   getRgba: getRgba,\n\t   getHsla: getHsla,\n\t   getRgb: getRgb,\n\t   getHsl: getHsl,\n\t   getHwb: getHwb,\n\t   getAlpha: getAlpha,\n\t\n\t   hexString: hexString,\n\t   rgbString: rgbString,\n\t   rgbaString: rgbaString,\n\t   percentString: percentString,\n\t   percentaString: percentaString,\n\t   hslString: hslString,\n\t   hslaString: hslaString,\n\t   hwbString: hwbString,\n\t   keyword: keyword\n\t};\n\t\n\tfunction getRgba(string) {\n\t   if (!string) {\n\t      return;\n\t   }\n\t   var abbr =  /^#([a-fA-F0-9]{3,4})$/i,\n\t       hex =  /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,\n\t       rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n\t       per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n\t       keyword = /(\\w+)/;\n\t\n\t   var rgb = [0, 0, 0],\n\t       a = 1,\n\t       match = string.match(abbr),\n\t       hexAlpha = \"\";\n\t   if (match) {\n\t      match = match[1];\n\t      hexAlpha = match[3];\n\t      for (var i = 0; i < rgb.length; i++) {\n\t         rgb[i] = parseInt(match[i] + match[i], 16);\n\t      }\n\t      if (hexAlpha) {\n\t         a = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;\n\t      }\n\t   }\n\t   else if (match = string.match(hex)) {\n\t      hexAlpha = match[2];\n\t      match = match[1];\n\t      for (var i = 0; i < rgb.length; i++) {\n\t         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\n\t      }\n\t      if (hexAlpha) {\n\t         a = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;\n\t      }\n\t   }\n\t   else if (match = string.match(rgba)) {\n\t      for (var i = 0; i < rgb.length; i++) {\n\t         rgb[i] = parseInt(match[i + 1]);\n\t      }\n\t      a = parseFloat(match[4]);\n\t   }\n\t   else if (match = string.match(per)) {\n\t      for (var i = 0; i < rgb.length; i++) {\n\t         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n\t      }\n\t      a = parseFloat(match[4]);\n\t   }\n\t   else if (match = string.match(keyword)) {\n\t      if (match[1] == \"transparent\") {\n\t         return [0, 0, 0, 0];\n\t      }\n\t      rgb = colorName[match[1]];\n\t      if (!rgb) {\n\t         return;\n\t      }\n\t   }\n\t\n\t   for (var i = 0; i < rgb.length; i++) {\n\t      rgb[i] = scale(rgb[i], 0, 255);\n\t   }\n\t   if (!a && a != 0) {\n\t      a = 1;\n\t   }\n\t   else {\n\t      a = scale(a, 0, 1);\n\t   }\n\t   rgb[3] = a;\n\t   return rgb;\n\t}\n\t\n\tfunction getHsla(string) {\n\t   if (!string) {\n\t      return;\n\t   }\n\t   var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n\t   var match = string.match(hsl);\n\t   if (match) {\n\t      var alpha = parseFloat(match[4]);\n\t      var h = scale(parseInt(match[1]), 0, 360),\n\t          s = scale(parseFloat(match[2]), 0, 100),\n\t          l = scale(parseFloat(match[3]), 0, 100),\n\t          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n\t      return [h, s, l, a];\n\t   }\n\t}\n\t\n\tfunction getHwb(string) {\n\t   if (!string) {\n\t      return;\n\t   }\n\t   var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n\t   var match = string.match(hwb);\n\t   if (match) {\n\t    var alpha = parseFloat(match[4]);\n\t      var h = scale(parseInt(match[1]), 0, 360),\n\t          w = scale(parseFloat(match[2]), 0, 100),\n\t          b = scale(parseFloat(match[3]), 0, 100),\n\t          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n\t      return [h, w, b, a];\n\t   }\n\t}\n\t\n\tfunction getRgb(string) {\n\t   var rgba = getRgba(string);\n\t   return rgba && rgba.slice(0, 3);\n\t}\n\t\n\tfunction getHsl(string) {\n\t  var hsla = getHsla(string);\n\t  return hsla && hsla.slice(0, 3);\n\t}\n\t\n\tfunction getAlpha(string) {\n\t   var vals = getRgba(string);\n\t   if (vals) {\n\t      return vals[3];\n\t   }\n\t   else if (vals = getHsla(string)) {\n\t      return vals[3];\n\t   }\n\t   else if (vals = getHwb(string)) {\n\t      return vals[3];\n\t   }\n\t}\n\t\n\t// generators\n\tfunction hexString(rgba, a) {\n\t   var a = (a !== undefined && rgba.length === 3) ? a : rgba[3];\n\t   return \"#\" + hexDouble(rgba[0]) \n\t              + hexDouble(rgba[1])\n\t              + hexDouble(rgba[2])\n\t              + (\n\t                 (a >= 0 && a < 1)\n\t                 ? hexDouble(Math.round(a * 255))\n\t                 : \"\"\n\t              );\n\t}\n\t\n\tfunction rgbString(rgba, alpha) {\n\t   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n\t      return rgbaString(rgba, alpha);\n\t   }\n\t   return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\n\t}\n\t\n\tfunction rgbaString(rgba, alpha) {\n\t   if (alpha === undefined) {\n\t      alpha = (rgba[3] !== undefined ? rgba[3] : 1);\n\t   }\n\t   return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]\n\t           + \", \" + alpha + \")\";\n\t}\n\t\n\tfunction percentString(rgba, alpha) {\n\t   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n\t      return percentaString(rgba, alpha);\n\t   }\n\t   var r = Math.round(rgba[0]/255 * 100),\n\t       g = Math.round(rgba[1]/255 * 100),\n\t       b = Math.round(rgba[2]/255 * 100);\n\t\n\t   return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\n\t}\n\t\n\tfunction percentaString(rgba, alpha) {\n\t   var r = Math.round(rgba[0]/255 * 100),\n\t       g = Math.round(rgba[1]/255 * 100),\n\t       b = Math.round(rgba[2]/255 * 100);\n\t   return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\n\t}\n\t\n\tfunction hslString(hsla, alpha) {\n\t   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\n\t      return hslaString(hsla, alpha);\n\t   }\n\t   return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\n\t}\n\t\n\tfunction hslaString(hsla, alpha) {\n\t   if (alpha === undefined) {\n\t      alpha = (hsla[3] !== undefined ? hsla[3] : 1);\n\t   }\n\t   return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"\n\t           + alpha + \")\";\n\t}\n\t\n\t// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n\t// (hwb have alpha optional & 1 is default value)\n\tfunction hwbString(hwb, alpha) {\n\t   if (alpha === undefined) {\n\t      alpha = (hwb[3] !== undefined ? hwb[3] : 1);\n\t   }\n\t   return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\"\n\t           + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\n\t}\n\t\n\tfunction keyword(rgb) {\n\t  return reverseNames[rgb.slice(0, 3)];\n\t}\n\t\n\t// helpers\n\tfunction scale(num, min, max) {\n\t   return Math.min(Math.max(min, num), max);\n\t}\n\t\n\tfunction hexDouble(num) {\n\t  var str = num.toString(16).toUpperCase();\n\t  return (str.length < 2) ? \"0\" + str : str;\n\t}\n\t\n\t\n\t//create a list of reverse color names\n\tvar reverseNames = {};\n\tfor (var name in colorName) {\n\t   reverseNames[colorName[name]] = name;\n\t}\n\t\n\t/* MIT license */\n\t\n\t\n\t\n\tvar Color = function (obj) {\n\t\tif (obj instanceof Color) {\n\t\t\treturn obj;\n\t\t}\n\t\tif (!(this instanceof Color)) {\n\t\t\treturn new Color(obj);\n\t\t}\n\t\n\t\tthis.valid = false;\n\t\tthis.values = {\n\t\t\trgb: [0, 0, 0],\n\t\t\thsl: [0, 0, 0],\n\t\t\thsv: [0, 0, 0],\n\t\t\thwb: [0, 0, 0],\n\t\t\tcmyk: [0, 0, 0, 0],\n\t\t\talpha: 1\n\t\t};\n\t\n\t\t// parse Color() argument\n\t\tvar vals;\n\t\tif (typeof obj === 'string') {\n\t\t\tvals = colorString.getRgba(obj);\n\t\t\tif (vals) {\n\t\t\t\tthis.setValues('rgb', vals);\n\t\t\t} else if (vals = colorString.getHsla(obj)) {\n\t\t\t\tthis.setValues('hsl', vals);\n\t\t\t} else if (vals = colorString.getHwb(obj)) {\n\t\t\t\tthis.setValues('hwb', vals);\n\t\t\t}\n\t\t} else if (typeof obj === 'object') {\n\t\t\tvals = obj;\n\t\t\tif (vals.r !== undefined || vals.red !== undefined) {\n\t\t\t\tthis.setValues('rgb', vals);\n\t\t\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\n\t\t\t\tthis.setValues('hsl', vals);\n\t\t\t} else if (vals.v !== undefined || vals.value !== undefined) {\n\t\t\t\tthis.setValues('hsv', vals);\n\t\t\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\n\t\t\t\tthis.setValues('hwb', vals);\n\t\t\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\n\t\t\t\tthis.setValues('cmyk', vals);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tColor.prototype = {\n\t\tisValid: function () {\n\t\t\treturn this.valid;\n\t\t},\n\t\trgb: function () {\n\t\t\treturn this.setSpace('rgb', arguments);\n\t\t},\n\t\thsl: function () {\n\t\t\treturn this.setSpace('hsl', arguments);\n\t\t},\n\t\thsv: function () {\n\t\t\treturn this.setSpace('hsv', arguments);\n\t\t},\n\t\thwb: function () {\n\t\t\treturn this.setSpace('hwb', arguments);\n\t\t},\n\t\tcmyk: function () {\n\t\t\treturn this.setSpace('cmyk', arguments);\n\t\t},\n\t\n\t\trgbArray: function () {\n\t\t\treturn this.values.rgb;\n\t\t},\n\t\thslArray: function () {\n\t\t\treturn this.values.hsl;\n\t\t},\n\t\thsvArray: function () {\n\t\t\treturn this.values.hsv;\n\t\t},\n\t\thwbArray: function () {\n\t\t\tvar values = this.values;\n\t\t\tif (values.alpha !== 1) {\n\t\t\t\treturn values.hwb.concat([values.alpha]);\n\t\t\t}\n\t\t\treturn values.hwb;\n\t\t},\n\t\tcmykArray: function () {\n\t\t\treturn this.values.cmyk;\n\t\t},\n\t\trgbaArray: function () {\n\t\t\tvar values = this.values;\n\t\t\treturn values.rgb.concat([values.alpha]);\n\t\t},\n\t\thslaArray: function () {\n\t\t\tvar values = this.values;\n\t\t\treturn values.hsl.concat([values.alpha]);\n\t\t},\n\t\talpha: function (val) {\n\t\t\tif (val === undefined) {\n\t\t\t\treturn this.values.alpha;\n\t\t\t}\n\t\t\tthis.setValues('alpha', val);\n\t\t\treturn this;\n\t\t},\n\t\n\t\tred: function (val) {\n\t\t\treturn this.setChannel('rgb', 0, val);\n\t\t},\n\t\tgreen: function (val) {\n\t\t\treturn this.setChannel('rgb', 1, val);\n\t\t},\n\t\tblue: function (val) {\n\t\t\treturn this.setChannel('rgb', 2, val);\n\t\t},\n\t\thue: function (val) {\n\t\t\tif (val) {\n\t\t\t\tval %= 360;\n\t\t\t\tval = val < 0 ? 360 + val : val;\n\t\t\t}\n\t\t\treturn this.setChannel('hsl', 0, val);\n\t\t},\n\t\tsaturation: function (val) {\n\t\t\treturn this.setChannel('hsl', 1, val);\n\t\t},\n\t\tlightness: function (val) {\n\t\t\treturn this.setChannel('hsl', 2, val);\n\t\t},\n\t\tsaturationv: function (val) {\n\t\t\treturn this.setChannel('hsv', 1, val);\n\t\t},\n\t\twhiteness: function (val) {\n\t\t\treturn this.setChannel('hwb', 1, val);\n\t\t},\n\t\tblackness: function (val) {\n\t\t\treturn this.setChannel('hwb', 2, val);\n\t\t},\n\t\tvalue: function (val) {\n\t\t\treturn this.setChannel('hsv', 2, val);\n\t\t},\n\t\tcyan: function (val) {\n\t\t\treturn this.setChannel('cmyk', 0, val);\n\t\t},\n\t\tmagenta: function (val) {\n\t\t\treturn this.setChannel('cmyk', 1, val);\n\t\t},\n\t\tyellow: function (val) {\n\t\t\treturn this.setChannel('cmyk', 2, val);\n\t\t},\n\t\tblack: function (val) {\n\t\t\treturn this.setChannel('cmyk', 3, val);\n\t\t},\n\t\n\t\thexString: function () {\n\t\t\treturn colorString.hexString(this.values.rgb);\n\t\t},\n\t\trgbString: function () {\n\t\t\treturn colorString.rgbString(this.values.rgb, this.values.alpha);\n\t\t},\n\t\trgbaString: function () {\n\t\t\treturn colorString.rgbaString(this.values.rgb, this.values.alpha);\n\t\t},\n\t\tpercentString: function () {\n\t\t\treturn colorString.percentString(this.values.rgb, this.values.alpha);\n\t\t},\n\t\thslString: function () {\n\t\t\treturn colorString.hslString(this.values.hsl, this.values.alpha);\n\t\t},\n\t\thslaString: function () {\n\t\t\treturn colorString.hslaString(this.values.hsl, this.values.alpha);\n\t\t},\n\t\thwbString: function () {\n\t\t\treturn colorString.hwbString(this.values.hwb, this.values.alpha);\n\t\t},\n\t\tkeyword: function () {\n\t\t\treturn colorString.keyword(this.values.rgb, this.values.alpha);\n\t\t},\n\t\n\t\trgbNumber: function () {\n\t\t\tvar rgb = this.values.rgb;\n\t\t\treturn (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\n\t\t},\n\t\n\t\tluminosity: function () {\n\t\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\t\tvar rgb = this.values.rgb;\n\t\t\tvar lum = [];\n\t\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\t\tvar chan = rgb[i] / 255;\n\t\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n\t\t\t}\n\t\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t\t},\n\t\n\t\tcontrast: function (color2) {\n\t\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\t\tvar lum1 = this.luminosity();\n\t\t\tvar lum2 = color2.luminosity();\n\t\t\tif (lum1 > lum2) {\n\t\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t\t}\n\t\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t\t},\n\t\n\t\tlevel: function (color2) {\n\t\t\tvar contrastRatio = this.contrast(color2);\n\t\t\tif (contrastRatio >= 7.1) {\n\t\t\t\treturn 'AAA';\n\t\t\t}\n\t\n\t\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t\t},\n\t\n\t\tdark: function () {\n\t\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\t\tvar rgb = this.values.rgb;\n\t\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n\t\t\treturn yiq < 128;\n\t\t},\n\t\n\t\tlight: function () {\n\t\t\treturn !this.dark();\n\t\t},\n\t\n\t\tnegate: function () {\n\t\t\tvar rgb = [];\n\t\t\tfor (var i = 0; i < 3; i++) {\n\t\t\t\trgb[i] = 255 - this.values.rgb[i];\n\t\t\t}\n\t\t\tthis.setValues('rgb', rgb);\n\t\t\treturn this;\n\t\t},\n\t\n\t\tlighten: function (ratio) {\n\t\t\tvar hsl = this.values.hsl;\n\t\t\thsl[2] += hsl[2] * ratio;\n\t\t\tthis.setValues('hsl', hsl);\n\t\t\treturn this;\n\t\t},\n\t\n\t\tdarken: function (ratio) {\n\t\t\tvar hsl = this.values.hsl;\n\t\t\thsl[2] -= hsl[2] * ratio;\n\t\t\tthis.setValues('hsl', hsl);\n\t\t\treturn this;\n\t\t},\n\t\n\t\tsaturate: function (ratio) {\n\t\t\tvar hsl = this.values.hsl;\n\t\t\thsl[1] += hsl[1] * ratio;\n\t\t\tthis.setValues('hsl', hsl);\n\t\t\treturn this;\n\t\t},\n\t\n\t\tdesaturate: function (ratio) {\n\t\t\tvar hsl = this.values.hsl;\n\t\t\thsl[1] -= hsl[1] * ratio;\n\t\t\tthis.setValues('hsl', hsl);\n\t\t\treturn this;\n\t\t},\n\t\n\t\twhiten: function (ratio) {\n\t\t\tvar hwb = this.values.hwb;\n\t\t\thwb[1] += hwb[1] * ratio;\n\t\t\tthis.setValues('hwb', hwb);\n\t\t\treturn this;\n\t\t},\n\t\n\t\tblacken: function (ratio) {\n\t\t\tvar hwb = this.values.hwb;\n\t\t\thwb[2] += hwb[2] * ratio;\n\t\t\tthis.setValues('hwb', hwb);\n\t\t\treturn this;\n\t\t},\n\t\n\t\tgreyscale: function () {\n\t\t\tvar rgb = this.values.rgb;\n\t\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\t\tthis.setValues('rgb', [val, val, val]);\n\t\t\treturn this;\n\t\t},\n\t\n\t\tclearer: function (ratio) {\n\t\t\tvar alpha = this.values.alpha;\n\t\t\tthis.setValues('alpha', alpha - (alpha * ratio));\n\t\t\treturn this;\n\t\t},\n\t\n\t\topaquer: function (ratio) {\n\t\t\tvar alpha = this.values.alpha;\n\t\t\tthis.setValues('alpha', alpha + (alpha * ratio));\n\t\t\treturn this;\n\t\t},\n\t\n\t\trotate: function (degrees) {\n\t\t\tvar hsl = this.values.hsl;\n\t\t\tvar hue = (hsl[0] + degrees) % 360;\n\t\t\thsl[0] = hue < 0 ? 360 + hue : hue;\n\t\t\tthis.setValues('hsl', hsl);\n\t\t\treturn this;\n\t\t},\n\t\n\t\t/**\n\t\t * Ported from sass implementation in C\n\t\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t\t */\n\t\tmix: function (mixinColor, weight) {\n\t\t\tvar color1 = this;\n\t\t\tvar color2 = mixinColor;\n\t\t\tvar p = weight === undefined ? 0.5 : weight;\n\t\n\t\t\tvar w = 2 * p - 1;\n\t\t\tvar a = color1.alpha() - color2.alpha();\n\t\n\t\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\t\tvar w2 = 1 - w1;\n\t\n\t\t\treturn this\n\t\t\t\t.rgb(\n\t\t\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\t\t\tw1 * color1.blue() + w2 * color2.blue()\n\t\t\t\t)\n\t\t\t\t.alpha(color1.alpha() * p + color2.alpha() * (1 - p));\n\t\t},\n\t\n\t\ttoJSON: function () {\n\t\t\treturn this.rgb();\n\t\t},\n\t\n\t\tclone: function () {\n\t\t\t// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\n\t\t\t// making the final build way to big to embed in Chart.js. So let's do it manually,\n\t\t\t// assuming that values to clone are 1 dimension arrays containing only numbers,\n\t\t\t// except 'alpha' which is a number.\n\t\t\tvar result = new Color();\n\t\t\tvar source = this.values;\n\t\t\tvar target = result.values;\n\t\t\tvar value, type;\n\t\n\t\t\tfor (var prop in source) {\n\t\t\t\tif (source.hasOwnProperty(prop)) {\n\t\t\t\t\tvalue = source[prop];\n\t\t\t\t\ttype = ({}).toString.call(value);\n\t\t\t\t\tif (type === '[object Array]') {\n\t\t\t\t\t\ttarget[prop] = value.slice(0);\n\t\t\t\t\t} else if (type === '[object Number]') {\n\t\t\t\t\t\ttarget[prop] = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('unexpected color value:', value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\t}\n\t};\n\t\n\tColor.prototype.spaces = {\n\t\trgb: ['red', 'green', 'blue'],\n\t\thsl: ['hue', 'saturation', 'lightness'],\n\t\thsv: ['hue', 'saturation', 'value'],\n\t\thwb: ['hue', 'whiteness', 'blackness'],\n\t\tcmyk: ['cyan', 'magenta', 'yellow', 'black']\n\t};\n\t\n\tColor.prototype.maxes = {\n\t\trgb: [255, 255, 255],\n\t\thsl: [360, 100, 100],\n\t\thsv: [360, 100, 100],\n\t\thwb: [360, 100, 100],\n\t\tcmyk: [100, 100, 100, 100]\n\t};\n\t\n\tColor.prototype.getValues = function (space) {\n\t\tvar values = this.values;\n\t\tvar vals = {};\n\t\n\t\tfor (var i = 0; i < space.length; i++) {\n\t\t\tvals[space.charAt(i)] = values[space][i];\n\t\t}\n\t\n\t\tif (values.alpha !== 1) {\n\t\t\tvals.a = values.alpha;\n\t\t}\n\t\n\t\t// {r: 255, g: 255, b: 255, a: 0.4}\n\t\treturn vals;\n\t};\n\t\n\tColor.prototype.setValues = function (space, vals) {\n\t\tvar values = this.values;\n\t\tvar spaces = this.spaces;\n\t\tvar maxes = this.maxes;\n\t\tvar alpha = 1;\n\t\tvar i;\n\t\n\t\tthis.valid = true;\n\t\n\t\tif (space === 'alpha') {\n\t\t\talpha = vals;\n\t\t} else if (vals.length) {\n\t\t\t// [10, 10, 10]\n\t\t\tvalues[space] = vals.slice(0, space.length);\n\t\t\talpha = vals[space.length];\n\t\t} else if (vals[space.charAt(0)] !== undefined) {\n\t\t\t// {r: 10, g: 10, b: 10}\n\t\t\tfor (i = 0; i < space.length; i++) {\n\t\t\t\tvalues[space][i] = vals[space.charAt(i)];\n\t\t\t}\n\t\n\t\t\talpha = vals.a;\n\t\t} else if (vals[spaces[space][0]] !== undefined) {\n\t\t\t// {red: 10, green: 10, blue: 10}\n\t\t\tvar chans = spaces[space];\n\t\n\t\t\tfor (i = 0; i < space.length; i++) {\n\t\t\t\tvalues[space][i] = vals[chans[i]];\n\t\t\t}\n\t\n\t\t\talpha = vals.alpha;\n\t\t}\n\t\n\t\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));\n\t\n\t\tif (space === 'alpha') {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tvar capped;\n\t\n\t\t// cap values of the space prior converting all values\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tcapped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\n\t\t\tvalues[space][i] = Math.round(capped);\n\t\t}\n\t\n\t\t// convert to all the other color spaces\n\t\tfor (var sname in spaces) {\n\t\t\tif (sname !== space) {\n\t\t\t\tvalues[sname] = colorConvert[space][sname](values[space]);\n\t\t\t}\n\t\t}\n\t\n\t\treturn true;\n\t};\n\t\n\tColor.prototype.setSpace = function (space, args) {\n\t\tvar vals = args[0];\n\t\n\t\tif (vals === undefined) {\n\t\t\t// color.rgb()\n\t\t\treturn this.getValues(space);\n\t\t}\n\t\n\t\t// color.rgb(10, 10, 10)\n\t\tif (typeof vals === 'number') {\n\t\t\tvals = Array.prototype.slice.call(args);\n\t\t}\n\t\n\t\tthis.setValues(space, vals);\n\t\treturn this;\n\t};\n\t\n\tColor.prototype.setChannel = function (space, index, val) {\n\t\tvar svalues = this.values[space];\n\t\tif (val === undefined) {\n\t\t\t// color.red()\n\t\t\treturn svalues[index];\n\t\t} else if (val === svalues[index]) {\n\t\t\t// color.red(color.red())\n\t\t\treturn this;\n\t\t}\n\t\n\t\t// color.red(100)\n\t\tsvalues[index] = val;\n\t\tthis.setValues(space, svalues);\n\t\n\t\treturn this;\n\t};\n\t\n\tif (typeof window !== 'undefined') {\n\t\twindow.Color = Color;\n\t}\n\t\n\tvar chartjsColor = Color;\n\t\n\t/**\n\t * @namespace Chart.helpers\n\t */\n\tvar helpers = {\n\t\t/**\n\t\t * An empty function that can be used, for example, for optional callback.\n\t\t */\n\t\tnoop: function() {},\n\t\n\t\t/**\n\t\t * Returns a unique id, sequentially generated from a global variable.\n\t\t * @returns {number}\n\t\t * @function\n\t\t */\n\t\tuid: (function() {\n\t\t\tvar id = 0;\n\t\t\treturn function() {\n\t\t\t\treturn id++;\n\t\t\t};\n\t\t}()),\n\t\n\t\t/**\n\t\t * Returns true if `value` is neither null nor undefined, else returns false.\n\t\t * @param {*} value - The value to test.\n\t\t * @returns {boolean}\n\t\t * @since 2.7.0\n\t\t */\n\t\tisNullOrUndef: function(value) {\n\t\t\treturn value === null || typeof value === 'undefined';\n\t\t},\n\t\n\t\t/**\n\t\t * Returns true if `value` is an array (including typed arrays), else returns false.\n\t\t * @param {*} value - The value to test.\n\t\t * @returns {boolean}\n\t\t * @function\n\t\t */\n\t\tisArray: function(value) {\n\t\t\tif (Array.isArray && Array.isArray(value)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar type = Object.prototype.toString.call(value);\n\t\t\tif (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\n\t\t/**\n\t\t * Returns true if `value` is an object (excluding null), else returns false.\n\t\t * @param {*} value - The value to test.\n\t\t * @returns {boolean}\n\t\t * @since 2.7.0\n\t\t */\n\t\tisObject: function(value) {\n\t\t\treturn value !== null && Object.prototype.toString.call(value) === '[object Object]';\n\t\t},\n\t\n\t\t/**\n\t\t * Returns true if `value` is a finite number, else returns false\n\t\t * @param {*} value  - The value to test.\n\t\t * @returns {boolean}\n\t\t */\n\t\tisFinite: function(value) {\n\t\t\treturn (typeof value === 'number' || value instanceof Number) && isFinite(value);\n\t\t},\n\t\n\t\t/**\n\t\t * Returns `value` if defined, else returns `defaultValue`.\n\t\t * @param {*} value - The value to return if defined.\n\t\t * @param {*} defaultValue - The value to return if `value` is undefined.\n\t\t * @returns {*}\n\t\t */\n\t\tvalueOrDefault: function(value, defaultValue) {\n\t\t\treturn typeof value === 'undefined' ? defaultValue : value;\n\t\t},\n\t\n\t\t/**\n\t\t * Returns value at the given `index` in array if defined, else returns `defaultValue`.\n\t\t * @param {Array} value - The array to lookup for value at `index`.\n\t\t * @param {number} index - The index in `value` to lookup for value.\n\t\t * @param {*} defaultValue - The value to return if `value[index]` is undefined.\n\t\t * @returns {*}\n\t\t */\n\t\tvalueAtIndexOrDefault: function(value, index, defaultValue) {\n\t\t\treturn helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);\n\t\t},\n\t\n\t\t/**\n\t\t * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n\t\t * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n\t\t * @param {function} fn - The function to call.\n\t\t * @param {Array|undefined|null} args - The arguments with which `fn` should be called.\n\t\t * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.\n\t\t * @returns {*}\n\t\t */\n\t\tcallback: function(fn, args, thisArg) {\n\t\t\tif (fn && typeof fn.call === 'function') {\n\t\t\t\treturn fn.apply(thisArg, args);\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * Note(SB) for performance sake, this method should only be used when loopable type\n\t\t * is unknown or in none intensive code (not called often and small loopable). Else\n\t\t * it's preferable to use a regular for() loop and save extra function calls.\n\t\t * @param {object|Array} loopable - The object or array to be iterated.\n\t\t * @param {function} fn - The function to call for each item.\n\t\t * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.\n\t\t * @param {boolean} [reverse] - If true, iterates backward on the loopable.\n\t\t */\n\t\teach: function(loopable, fn, thisArg, reverse) {\n\t\t\tvar i, len, keys;\n\t\t\tif (helpers.isArray(loopable)) {\n\t\t\t\tlen = loopable.length;\n\t\t\t\tif (reverse) {\n\t\t\t\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\t\t\t\tfn.call(thisArg, loopable[i], i);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tfn.call(thisArg, loopable[i], i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (helpers.isObject(loopable)) {\n\t\t\t\tkeys = Object.keys(loopable);\n\t\t\t\tlen = keys.length;\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tfn.call(thisArg, loopable[keys[i]], keys[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n\t\t * @see https://stackoverflow.com/a/14853974\n\t\t * @param {Array} a0 - The array to compare\n\t\t * @param {Array} a1 - The array to compare\n\t\t * @returns {boolean}\n\t\t */\n\t\tarrayEquals: function(a0, a1) {\n\t\t\tvar i, ilen, v0, v1;\n\t\n\t\t\tif (!a0 || !a1 || a0.length !== a1.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tfor (i = 0, ilen = a0.length; i < ilen; ++i) {\n\t\t\t\tv0 = a0[i];\n\t\t\t\tv1 = a1[i];\n\t\n\t\t\t\tif (v0 instanceof Array && v1 instanceof Array) {\n\t\t\t\t\tif (!helpers.arrayEquals(v0, v1)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t} else if (v0 !== v1) {\n\t\t\t\t\t// NOTE: two different object instances will never be equal: {x:20} != {x:20}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\t},\n\t\n\t\t/**\n\t\t * Returns a deep copy of `source` without keeping references on objects and arrays.\n\t\t * @param {*} source - The value to clone.\n\t\t * @returns {*}\n\t\t */\n\t\tclone: function(source) {\n\t\t\tif (helpers.isArray(source)) {\n\t\t\t\treturn source.map(helpers.clone);\n\t\t\t}\n\t\n\t\t\tif (helpers.isObject(source)) {\n\t\t\t\tvar target = {};\n\t\t\t\tvar keys = Object.keys(source);\n\t\t\t\tvar klen = keys.length;\n\t\t\t\tvar k = 0;\n\t\n\t\t\t\tfor (; k < klen; ++k) {\n\t\t\t\t\ttarget[keys[k]] = helpers.clone(source[keys[k]]);\n\t\t\t\t}\n\t\n\t\t\t\treturn target;\n\t\t\t}\n\t\n\t\t\treturn source;\n\t\t},\n\t\n\t\t/**\n\t\t * The default merger when Chart.helpers.merge is called without merger option.\n\t\t * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n\t\t * @private\n\t\t */\n\t\t_merger: function(key, target, source, options) {\n\t\t\tvar tval = target[key];\n\t\t\tvar sval = source[key];\n\t\n\t\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\n\t\t\t\thelpers.merge(tval, sval, options);\n\t\t\t} else {\n\t\t\t\ttarget[key] = helpers.clone(sval);\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * Merges source[key] in target[key] only if target[key] is undefined.\n\t\t * @private\n\t\t */\n\t\t_mergerIf: function(key, target, source) {\n\t\t\tvar tval = target[key];\n\t\t\tvar sval = source[key];\n\t\n\t\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\n\t\t\t\thelpers.mergeIf(tval, sval);\n\t\t\t} else if (!target.hasOwnProperty(key)) {\n\t\t\t\ttarget[key] = helpers.clone(sval);\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * Recursively deep copies `source` properties into `target` with the given `options`.\n\t\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n\t\t * @param {object} target - The target object in which all sources are merged into.\n\t\t * @param {object|object[]} source - Object(s) to merge into `target`.\n\t\t * @param {object} [options] - Merging options:\n\t\t * @param {function} [options.merger] - The merge method (key, target, source, options)\n\t\t * @returns {object} The `target` object.\n\t\t */\n\t\tmerge: function(target, source, options) {\n\t\t\tvar sources = helpers.isArray(source) ? source : [source];\n\t\t\tvar ilen = sources.length;\n\t\t\tvar merge, i, keys, klen, k;\n\t\n\t\t\tif (!helpers.isObject(target)) {\n\t\t\t\treturn target;\n\t\t\t}\n\t\n\t\t\toptions = options || {};\n\t\t\tmerge = options.merger || helpers._merger;\n\t\n\t\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\t\tsource = sources[i];\n\t\t\t\tif (!helpers.isObject(source)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tkeys = Object.keys(source);\n\t\t\t\tfor (k = 0, klen = keys.length; k < klen; ++k) {\n\t\t\t\t\tmerge(keys[k], target, source, options);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn target;\n\t\t},\n\t\n\t\t/**\n\t\t * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n\t\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n\t\t * @param {object} target - The target object in which all sources are merged into.\n\t\t * @param {object|object[]} source - Object(s) to merge into `target`.\n\t\t * @returns {object} The `target` object.\n\t\t */\n\t\tmergeIf: function(target, source) {\n\t\t\treturn helpers.merge(target, source, {merger: helpers._mergerIf});\n\t\t},\n\t\n\t\t/**\n\t\t * Applies the contents of two or more objects together into the first object.\n\t\t * @param {object} target - The target object in which all objects are merged into.\n\t\t * @param {object} arg1 - Object containing additional properties to merge in target.\n\t\t * @param {object} argN - Additional objects containing properties to merge in target.\n\t\t * @returns {object} The `target` object.\n\t\t */\n\t\textend: function(target) {\n\t\t\tvar setFn = function(value, key) {\n\t\t\t\ttarget[key] = value;\n\t\t\t};\n\t\t\tfor (var i = 1, ilen = arguments.length; i < ilen; ++i) {\n\t\t\t\thelpers.each(arguments[i], setFn);\n\t\t\t}\n\t\t\treturn target;\n\t\t},\n\t\n\t\t/**\n\t\t * Basic javascript inheritance based on the model created in Backbone.js\n\t\t */\n\t\tinherits: function(extensions) {\n\t\t\tvar me = this;\n\t\t\tvar ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {\n\t\t\t\treturn me.apply(this, arguments);\n\t\t\t};\n\t\n\t\t\tvar Surrogate = function() {\n\t\t\t\tthis.constructor = ChartElement;\n\t\t\t};\n\t\n\t\t\tSurrogate.prototype = me.prototype;\n\t\t\tChartElement.prototype = new Surrogate();\n\t\t\tChartElement.extend = helpers.inherits;\n\t\n\t\t\tif (extensions) {\n\t\t\t\thelpers.extend(ChartElement.prototype, extensions);\n\t\t\t}\n\t\n\t\t\tChartElement.__super__ = me.prototype;\n\t\t\treturn ChartElement;\n\t\t}\n\t};\n\t\n\tvar helpers_core = helpers;\n\t\n\t// DEPRECATIONS\n\t\n\t/**\n\t * Provided for backward compatibility, use Chart.helpers.callback instead.\n\t * @function Chart.helpers.callCallback\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\thelpers.callCallback = helpers.callback;\n\t\n\t/**\n\t * Provided for backward compatibility, use Array.prototype.indexOf instead.\n\t * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+\n\t * @function Chart.helpers.indexOf\n\t * @deprecated since version 2.7.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\thelpers.indexOf = function(array, item, fromIndex) {\n\t\treturn Array.prototype.indexOf.call(array, item, fromIndex);\n\t};\n\t\n\t/**\n\t * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.\n\t * @function Chart.helpers.getValueOrDefault\n\t * @deprecated since version 2.7.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\thelpers.getValueOrDefault = helpers.valueOrDefault;\n\t\n\t/**\n\t * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.\n\t * @function Chart.helpers.getValueAtIndexOrDefault\n\t * @deprecated since version 2.7.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\thelpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\t\n\t/**\n\t * Easing functions adapted from Robert Penner's easing equations.\n\t * @namespace Chart.helpers.easingEffects\n\t * @see http://www.robertpenner.com/easing/\n\t */\n\tvar effects = {\n\t\tlinear: function(t) {\n\t\t\treturn t;\n\t\t},\n\t\n\t\teaseInQuad: function(t) {\n\t\t\treturn t * t;\n\t\t},\n\t\n\t\teaseOutQuad: function(t) {\n\t\t\treturn -t * (t - 2);\n\t\t},\n\t\n\t\teaseInOutQuad: function(t) {\n\t\t\tif ((t /= 0.5) < 1) {\n\t\t\t\treturn 0.5 * t * t;\n\t\t\t}\n\t\t\treturn -0.5 * ((--t) * (t - 2) - 1);\n\t\t},\n\t\n\t\teaseInCubic: function(t) {\n\t\t\treturn t * t * t;\n\t\t},\n\t\n\t\teaseOutCubic: function(t) {\n\t\t\treturn (t = t - 1) * t * t + 1;\n\t\t},\n\t\n\t\teaseInOutCubic: function(t) {\n\t\t\tif ((t /= 0.5) < 1) {\n\t\t\t\treturn 0.5 * t * t * t;\n\t\t\t}\n\t\t\treturn 0.5 * ((t -= 2) * t * t + 2);\n\t\t},\n\t\n\t\teaseInQuart: function(t) {\n\t\t\treturn t * t * t * t;\n\t\t},\n\t\n\t\teaseOutQuart: function(t) {\n\t\t\treturn -((t = t - 1) * t * t * t - 1);\n\t\t},\n\t\n\t\teaseInOutQuart: function(t) {\n\t\t\tif ((t /= 0.5) < 1) {\n\t\t\t\treturn 0.5 * t * t * t * t;\n\t\t\t}\n\t\t\treturn -0.5 * ((t -= 2) * t * t * t - 2);\n\t\t},\n\t\n\t\teaseInQuint: function(t) {\n\t\t\treturn t * t * t * t * t;\n\t\t},\n\t\n\t\teaseOutQuint: function(t) {\n\t\t\treturn (t = t - 1) * t * t * t * t + 1;\n\t\t},\n\t\n\t\teaseInOutQuint: function(t) {\n\t\t\tif ((t /= 0.5) < 1) {\n\t\t\t\treturn 0.5 * t * t * t * t * t;\n\t\t\t}\n\t\t\treturn 0.5 * ((t -= 2) * t * t * t * t + 2);\n\t\t},\n\t\n\t\teaseInSine: function(t) {\n\t\t\treturn -Math.cos(t * (Math.PI / 2)) + 1;\n\t\t},\n\t\n\t\teaseOutSine: function(t) {\n\t\t\treturn Math.sin(t * (Math.PI / 2));\n\t\t},\n\t\n\t\teaseInOutSine: function(t) {\n\t\t\treturn -0.5 * (Math.cos(Math.PI * t) - 1);\n\t\t},\n\t\n\t\teaseInExpo: function(t) {\n\t\t\treturn (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));\n\t\t},\n\t\n\t\teaseOutExpo: function(t) {\n\t\t\treturn (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;\n\t\t},\n\t\n\t\teaseInOutExpo: function(t) {\n\t\t\tif (t === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (t === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif ((t /= 0.5) < 1) {\n\t\t\t\treturn 0.5 * Math.pow(2, 10 * (t - 1));\n\t\t\t}\n\t\t\treturn 0.5 * (-Math.pow(2, -10 * --t) + 2);\n\t\t},\n\t\n\t\teaseInCirc: function(t) {\n\t\t\tif (t >= 1) {\n\t\t\t\treturn t;\n\t\t\t}\n\t\t\treturn -(Math.sqrt(1 - t * t) - 1);\n\t\t},\n\t\n\t\teaseOutCirc: function(t) {\n\t\t\treturn Math.sqrt(1 - (t = t - 1) * t);\n\t\t},\n\t\n\t\teaseInOutCirc: function(t) {\n\t\t\tif ((t /= 0.5) < 1) {\n\t\t\t\treturn -0.5 * (Math.sqrt(1 - t * t) - 1);\n\t\t\t}\n\t\t\treturn 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n\t\t},\n\t\n\t\teaseInElastic: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\tvar p = 0;\n\t\t\tvar a = 1;\n\t\t\tif (t === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (t === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tp = 0.3;\n\t\t\t}\n\t\t\tif (a < 1) {\n\t\t\t\ta = 1;\n\t\t\t\ts = p / 4;\n\t\t\t} else {\n\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t}\n\t\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n\t\t},\n\t\n\t\teaseOutElastic: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\tvar p = 0;\n\t\t\tvar a = 1;\n\t\t\tif (t === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (t === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tp = 0.3;\n\t\t\t}\n\t\t\tif (a < 1) {\n\t\t\t\ta = 1;\n\t\t\t\ts = p / 4;\n\t\t\t} else {\n\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t}\n\t\t\treturn a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;\n\t\t},\n\t\n\t\teaseInOutElastic: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\tvar p = 0;\n\t\t\tvar a = 1;\n\t\t\tif (t === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((t /= 0.5) === 2) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (!p) {\n\t\t\t\tp = 0.45;\n\t\t\t}\n\t\t\tif (a < 1) {\n\t\t\t\ta = 1;\n\t\t\t\ts = p / 4;\n\t\t\t} else {\n\t\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t\t}\n\t\t\tif (t < 1) {\n\t\t\t\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n\t\t\t}\n\t\t\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\t},\n\t\teaseInBack: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\treturn t * t * ((s + 1) * t - s);\n\t\t},\n\t\n\t\teaseOutBack: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\treturn (t = t - 1) * t * ((s + 1) * t + s) + 1;\n\t\t},\n\t\n\t\teaseInOutBack: function(t) {\n\t\t\tvar s = 1.70158;\n\t\t\tif ((t /= 0.5) < 1) {\n\t\t\t\treturn 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n\t\t\t}\n\t\t\treturn 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n\t\t},\n\t\n\t\teaseInBounce: function(t) {\n\t\t\treturn 1 - effects.easeOutBounce(1 - t);\n\t\t},\n\t\n\t\teaseOutBounce: function(t) {\n\t\t\tif (t < (1 / 2.75)) {\n\t\t\t\treturn 7.5625 * t * t;\n\t\t\t}\n\t\t\tif (t < (2 / 2.75)) {\n\t\t\t\treturn 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;\n\t\t\t}\n\t\t\tif (t < (2.5 / 2.75)) {\n\t\t\t\treturn 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;\n\t\t\t}\n\t\t\treturn 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;\n\t\t},\n\t\n\t\teaseInOutBounce: function(t) {\n\t\t\tif (t < 0.5) {\n\t\t\t\treturn effects.easeInBounce(t * 2) * 0.5;\n\t\t\t}\n\t\t\treturn effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\n\t\t}\n\t};\n\t\n\tvar helpers_easing = {\n\t\teffects: effects\n\t};\n\t\n\t// DEPRECATIONS\n\t\n\t/**\n\t * Provided for backward compatibility, use Chart.helpers.easing.effects instead.\n\t * @function Chart.helpers.easingEffects\n\t * @deprecated since version 2.7.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\thelpers_core.easingEffects = effects;\n\t\n\tvar PI = Math.PI;\n\tvar RAD_PER_DEG = PI / 180;\n\tvar DOUBLE_PI = PI * 2;\n\tvar HALF_PI = PI / 2;\n\tvar QUARTER_PI = PI / 4;\n\tvar TWO_THIRDS_PI = PI * 2 / 3;\n\t\n\t/**\n\t * @namespace Chart.helpers.canvas\n\t */\n\tvar exports$1 = {\n\t\t/**\n\t\t * Clears the entire canvas associated to the given `chart`.\n\t\t * @param {Chart} chart - The chart for which to clear the canvas.\n\t\t */\n\t\tclear: function(chart) {\n\t\t\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\n\t\t},\n\t\n\t\t/**\n\t\t * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with a\n\t\t * given size (width, height) and the same `radius` for all corners.\n\t\t * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\n\t\t * @param {number} x - The x axis of the coordinate for the rectangle starting point.\n\t\t * @param {number} y - The y axis of the coordinate for the rectangle starting point.\n\t\t * @param {number} width - The rectangle's width.\n\t\t * @param {number} height - The rectangle's height.\n\t\t * @param {number} radius - The rounded amount (in pixels) for the four corners.\n\t\t * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?\n\t\t */\n\t\troundedRect: function(ctx, x, y, width, height, radius) {\n\t\t\tif (radius) {\n\t\t\t\tvar r = Math.min(radius, height / 2, width / 2);\n\t\t\t\tvar left = x + r;\n\t\t\t\tvar top = y + r;\n\t\t\t\tvar right = x + width - r;\n\t\t\t\tvar bottom = y + height - r;\n\t\n\t\t\t\tctx.moveTo(x, top);\n\t\t\t\tif (left < right && top < bottom) {\n\t\t\t\t\tctx.arc(left, top, r, -PI, -HALF_PI);\n\t\t\t\t\tctx.arc(right, top, r, -HALF_PI, 0);\n\t\t\t\t\tctx.arc(right, bottom, r, 0, HALF_PI);\n\t\t\t\t\tctx.arc(left, bottom, r, HALF_PI, PI);\n\t\t\t\t} else if (left < right) {\n\t\t\t\t\tctx.moveTo(left, y);\n\t\t\t\t\tctx.arc(right, top, r, -HALF_PI, HALF_PI);\n\t\t\t\t\tctx.arc(left, top, r, HALF_PI, PI + HALF_PI);\n\t\t\t\t} else if (top < bottom) {\n\t\t\t\t\tctx.arc(left, top, r, -PI, 0);\n\t\t\t\t\tctx.arc(left, bottom, r, 0, PI);\n\t\t\t\t} else {\n\t\t\t\t\tctx.arc(left, top, r, -PI, PI);\n\t\t\t\t}\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.moveTo(x, y);\n\t\t\t} else {\n\t\t\t\tctx.rect(x, y, width, height);\n\t\t\t}\n\t\t},\n\t\n\t\tdrawPoint: function(ctx, style, radius, x, y, rotation) {\n\t\t\tvar type, xOffset, yOffset, size, cornerRadius;\n\t\t\tvar rad = (rotation || 0) * RAD_PER_DEG;\n\t\n\t\t\tif (style && typeof style === 'object') {\n\t\t\t\ttype = style.toString();\n\t\t\t\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n\t\t\t\t\tctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (isNaN(radius) || radius <= 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tctx.beginPath();\n\t\n\t\t\tswitch (style) {\n\t\t\t// Default includes circle\n\t\t\tdefault:\n\t\t\t\tctx.arc(x, y, radius, 0, DOUBLE_PI);\n\t\t\t\tctx.closePath();\n\t\t\t\tbreak;\n\t\t\tcase 'triangle':\n\t\t\t\tctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n\t\t\t\trad += TWO_THIRDS_PI;\n\t\t\t\tctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n\t\t\t\trad += TWO_THIRDS_PI;\n\t\t\t\tctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n\t\t\t\tctx.closePath();\n\t\t\t\tbreak;\n\t\t\tcase 'rectRounded':\n\t\t\t\t// NOTE: the rounded rect implementation changed to use `arc` instead of\n\t\t\t\t// `quadraticCurveTo` since it generates better results when rect is\n\t\t\t\t// almost a circle. 0.516 (instead of 0.5) produces results with visually\n\t\t\t\t// closer proportion to the previous impl and it is inscribed in the\n\t\t\t\t// circle with `radius`. For more details, see the following PRs:\n\t\t\t\t// https://github.com/chartjs/Chart.js/issues/5597\n\t\t\t\t// https://github.com/chartjs/Chart.js/issues/5858\n\t\t\t\tcornerRadius = radius * 0.516;\n\t\t\t\tsize = radius - cornerRadius;\n\t\t\t\txOffset = Math.cos(rad + QUARTER_PI) * size;\n\t\t\t\tyOffset = Math.sin(rad + QUARTER_PI) * size;\n\t\t\t\tctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n\t\t\t\tctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n\t\t\t\tctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n\t\t\t\tctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n\t\t\t\tctx.closePath();\n\t\t\t\tbreak;\n\t\t\tcase 'rect':\n\t\t\t\tif (!rotation) {\n\t\t\t\t\tsize = Math.SQRT1_2 * radius;\n\t\t\t\t\tctx.rect(x - size, y - size, 2 * size, 2 * size);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trad += QUARTER_PI;\n\t\t\t\t/* falls through */\n\t\t\tcase 'rectRot':\n\t\t\t\txOffset = Math.cos(rad) * radius;\n\t\t\t\tyOffset = Math.sin(rad) * radius;\n\t\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\t\tctx.lineTo(x + yOffset, y - xOffset);\n\t\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\t\tctx.lineTo(x - yOffset, y + xOffset);\n\t\t\t\tctx.closePath();\n\t\t\t\tbreak;\n\t\t\tcase 'crossRot':\n\t\t\t\trad += QUARTER_PI;\n\t\t\t\t/* falls through */\n\t\t\tcase 'cross':\n\t\t\t\txOffset = Math.cos(rad) * radius;\n\t\t\t\tyOffset = Math.sin(rad) * radius;\n\t\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\t\tctx.moveTo(x + yOffset, y - xOffset);\n\t\t\t\tctx.lineTo(x - yOffset, y + xOffset);\n\t\t\t\tbreak;\n\t\t\tcase 'star':\n\t\t\t\txOffset = Math.cos(rad) * radius;\n\t\t\t\tyOffset = Math.sin(rad) * radius;\n\t\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\t\tctx.moveTo(x + yOffset, y - xOffset);\n\t\t\t\tctx.lineTo(x - yOffset, y + xOffset);\n\t\t\t\trad += QUARTER_PI;\n\t\t\t\txOffset = Math.cos(rad) * radius;\n\t\t\t\tyOffset = Math.sin(rad) * radius;\n\t\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\t\tctx.moveTo(x + yOffset, y - xOffset);\n\t\t\t\tctx.lineTo(x - yOffset, y + xOffset);\n\t\t\t\tbreak;\n\t\t\tcase 'line':\n\t\t\t\txOffset = Math.cos(rad) * radius;\n\t\t\t\tyOffset = Math.sin(rad) * radius;\n\t\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\t\tbreak;\n\t\t\tcase 'dash':\n\t\t\t\tctx.moveTo(x, y);\n\t\t\t\tctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n\t\t\t\tbreak;\n\t\t\t}\n\t\n\t\t\tctx.fill();\n\t\t\tctx.stroke();\n\t\t},\n\t\n\t\t/**\n\t\t * Returns true if the point is inside the rectangle\n\t\t * @param {object} point - The point to test\n\t\t * @param {object} area - The rectangle\n\t\t * @returns {boolean}\n\t\t * @private\n\t\t */\n\t\t_isPointInArea: function(point, area) {\n\t\t\tvar epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\n\t\n\t\t\treturn point.x > area.left - epsilon && point.x < area.right + epsilon &&\n\t\t\t\tpoint.y > area.top - epsilon && point.y < area.bottom + epsilon;\n\t\t},\n\t\n\t\tclipArea: function(ctx, area) {\n\t\t\tctx.save();\n\t\t\tctx.beginPath();\n\t\t\tctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n\t\t\tctx.clip();\n\t\t},\n\t\n\t\tunclipArea: function(ctx) {\n\t\t\tctx.restore();\n\t\t},\n\t\n\t\tlineTo: function(ctx, previous, target, flip) {\n\t\t\tvar stepped = target.steppedLine;\n\t\t\tif (stepped) {\n\t\t\t\tif (stepped === 'middle') {\n\t\t\t\t\tvar midpoint = (previous.x + target.x) / 2.0;\n\t\t\t\t\tctx.lineTo(midpoint, flip ? target.y : previous.y);\n\t\t\t\t\tctx.lineTo(midpoint, flip ? previous.y : target.y);\n\t\t\t\t} else if ((stepped === 'after' && !flip) || (stepped !== 'after' && flip)) {\n\t\t\t\t\tctx.lineTo(previous.x, target.y);\n\t\t\t\t} else {\n\t\t\t\t\tctx.lineTo(target.x, previous.y);\n\t\t\t\t}\n\t\t\t\tctx.lineTo(target.x, target.y);\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif (!target.tension) {\n\t\t\t\tctx.lineTo(target.x, target.y);\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tctx.bezierCurveTo(\n\t\t\t\tflip ? previous.controlPointPreviousX : previous.controlPointNextX,\n\t\t\t\tflip ? previous.controlPointPreviousY : previous.controlPointNextY,\n\t\t\t\tflip ? target.controlPointNextX : target.controlPointPreviousX,\n\t\t\t\tflip ? target.controlPointNextY : target.controlPointPreviousY,\n\t\t\t\ttarget.x,\n\t\t\t\ttarget.y);\n\t\t}\n\t};\n\t\n\tvar helpers_canvas = exports$1;\n\t\n\t// DEPRECATIONS\n\t\n\t/**\n\t * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.\n\t * @namespace Chart.helpers.clear\n\t * @deprecated since version 2.7.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\thelpers_core.clear = exports$1.clear;\n\t\n\t/**\n\t * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.\n\t * @namespace Chart.helpers.drawRoundedRectangle\n\t * @deprecated since version 2.7.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\thelpers_core.drawRoundedRectangle = function(ctx) {\n\t\tctx.beginPath();\n\t\texports$1.roundedRect.apply(exports$1, arguments);\n\t};\n\t\n\tvar defaults = {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_set: function(scope, values) {\n\t\t\treturn helpers_core.merge(this[scope] || (this[scope] = {}), values);\n\t\t}\n\t};\n\t\n\tdefaults._set('global', {\n\t\tdefaultColor: 'rgba(0,0,0,0.1)',\n\t\tdefaultFontColor: '#666',\n\t\tdefaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n\t\tdefaultFontSize: 12,\n\t\tdefaultFontStyle: 'normal',\n\t\tdefaultLineHeight: 1.2,\n\t\tshowLines: true\n\t});\n\t\n\tvar core_defaults = defaults;\n\t\n\tvar valueOrDefault = helpers_core.valueOrDefault;\n\t\n\t/**\n\t * Converts the given font object into a CSS font string.\n\t * @param {object} font - A font object.\n\t * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n\t * @private\n\t */\n\tfunction toFontString(font) {\n\t\tif (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\treturn (font.style ? font.style + ' ' : '')\n\t\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t\t+ font.size + 'px '\n\t\t\t+ font.family;\n\t}\n\t\n\t/**\n\t * @alias Chart.helpers.options\n\t * @namespace\n\t */\n\tvar helpers_options = {\n\t\t/**\n\t\t * Converts the given line height `value` in pixels for a specific font `size`.\n\t\t * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n\t\t * @param {number} size - The font size (in pixels) used to resolve relative `value`.\n\t\t * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).\n\t\t * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n\t\t * @since 2.7.0\n\t\t */\n\t\ttoLineHeight: function(value, size) {\n\t\t\tvar matches = ('' + value).match(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\n\t\t\tif (!matches || matches[1] === 'normal') {\n\t\t\t\treturn size * 1.2;\n\t\t\t}\n\t\n\t\t\tvalue = +matches[2];\n\t\n\t\t\tswitch (matches[3]) {\n\t\t\tcase 'px':\n\t\t\t\treturn value;\n\t\t\tcase '%':\n\t\t\t\tvalue /= 100;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\n\t\t\treturn size * value;\n\t\t},\n\t\n\t\t/**\n\t\t * Converts the given value into a padding object with pre-computed width/height.\n\t\t * @param {number|object} value - If a number, set the value to all TRBL component,\n\t\t *  else, if and object, use defined properties and sets undefined ones to 0.\n\t\t * @returns {object} The padding values (top, right, bottom, left, width, height)\n\t\t * @since 2.7.0\n\t\t */\n\t\ttoPadding: function(value) {\n\t\t\tvar t, r, b, l;\n\t\n\t\t\tif (helpers_core.isObject(value)) {\n\t\t\t\tt = +value.top || 0;\n\t\t\t\tr = +value.right || 0;\n\t\t\t\tb = +value.bottom || 0;\n\t\t\t\tl = +value.left || 0;\n\t\t\t} else {\n\t\t\t\tt = r = b = l = +value || 0;\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\ttop: t,\n\t\t\t\tright: r,\n\t\t\t\tbottom: b,\n\t\t\t\tleft: l,\n\t\t\t\theight: t + b,\n\t\t\t\twidth: l + r\n\t\t\t};\n\t\t},\n\t\n\t\t/**\n\t\t * Parses font options and returns the font object.\n\t\t * @param {object} options - A object that contains font options to be parsed.\n\t\t * @return {object} The font object.\n\t\t * @todo Support font.* options and renamed to toFont().\n\t\t * @private\n\t\t */\n\t\t_parseFont: function(options) {\n\t\t\tvar globalDefaults = core_defaults.global;\n\t\t\tvar size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n\t\t\tvar font = {\n\t\t\t\tfamily: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),\n\t\t\t\tlineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),\n\t\t\t\tsize: size,\n\t\t\t\tstyle: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),\n\t\t\t\tweight: null,\n\t\t\t\tstring: ''\n\t\t\t};\n\t\n\t\t\tfont.string = toFontString(font);\n\t\t\treturn font;\n\t\t},\n\t\n\t\t/**\n\t\t * Evaluates the given `inputs` sequentially and returns the first defined value.\n\t\t * @param {Array} inputs - An array of values, falling back to the last value.\n\t\t * @param {object} [context] - If defined and the current value is a function, the value\n\t\t * is called with `context` as first argument and the result becomes the new input.\n\t\t * @param {number} [index] - If defined and the current value is an array, the value\n\t\t * at `index` become the new input.\n\t\t * @since 2.7.0\n\t\t */\n\t\tresolve: function(inputs, context, index) {\n\t\t\tvar i, ilen, value;\n\t\n\t\t\tfor (i = 0, ilen = inputs.length; i < ilen; ++i) {\n\t\t\t\tvalue = inputs[i];\n\t\t\t\tif (value === undefined) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (context !== undefined && typeof value === 'function') {\n\t\t\t\t\tvalue = value(context);\n\t\t\t\t}\n\t\t\t\tif (index !== undefined && helpers_core.isArray(value)) {\n\t\t\t\t\tvalue = value[index];\n\t\t\t\t}\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\tvar helpers$1 = helpers_core;\n\tvar easing = helpers_easing;\n\tvar canvas = helpers_canvas;\n\tvar options = helpers_options;\n\thelpers$1.easing = easing;\n\thelpers$1.canvas = canvas;\n\thelpers$1.options = options;\n\t\n\tfunction interpolate(start, view, model, ease) {\n\t\tvar keys = Object.keys(model);\n\t\tvar i, ilen, key, actual, origin, target, type, c0, c1;\n\t\n\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\tkey = keys[i];\n\t\n\t\t\ttarget = model[key];\n\t\n\t\t\t// if a value is added to the model after pivot() has been called, the view\n\t\t\t// doesn't contain it, so let's initialize the view to the target value.\n\t\t\tif (!view.hasOwnProperty(key)) {\n\t\t\t\tview[key] = target;\n\t\t\t}\n\t\n\t\t\tactual = view[key];\n\t\n\t\t\tif (actual === target || key[0] === '_') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tif (!start.hasOwnProperty(key)) {\n\t\t\t\tstart[key] = actual;\n\t\t\t}\n\t\n\t\t\torigin = start[key];\n\t\n\t\t\ttype = typeof target;\n\t\n\t\t\tif (type === typeof origin) {\n\t\t\t\tif (type === 'string') {\n\t\t\t\t\tc0 = chartjsColor(origin);\n\t\t\t\t\tif (c0.valid) {\n\t\t\t\t\t\tc1 = chartjsColor(target);\n\t\t\t\t\t\tif (c1.valid) {\n\t\t\t\t\t\t\tview[key] = c1.mix(c0, ease).rgbString();\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {\n\t\t\t\t\tview[key] = origin + (target - origin) * ease;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tview[key] = target;\n\t\t}\n\t}\n\t\n\tvar Element = function(configuration) {\n\t\thelpers$1.extend(this, configuration);\n\t\tthis.initialize.apply(this, arguments);\n\t};\n\t\n\thelpers$1.extend(Element.prototype, {\n\t\n\t\tinitialize: function() {\n\t\t\tthis.hidden = false;\n\t\t},\n\t\n\t\tpivot: function() {\n\t\t\tvar me = this;\n\t\t\tif (!me._view) {\n\t\t\t\tme._view = helpers$1.clone(me._model);\n\t\t\t}\n\t\t\tme._start = {};\n\t\t\treturn me;\n\t\t},\n\t\n\t\ttransition: function(ease) {\n\t\t\tvar me = this;\n\t\t\tvar model = me._model;\n\t\t\tvar start = me._start;\n\t\t\tvar view = me._view;\n\t\n\t\t\t// No animation -> No Transition\n\t\t\tif (!model || ease === 1) {\n\t\t\t\tme._view = model;\n\t\t\t\tme._start = null;\n\t\t\t\treturn me;\n\t\t\t}\n\t\n\t\t\tif (!view) {\n\t\t\t\tview = me._view = {};\n\t\t\t}\n\t\n\t\t\tif (!start) {\n\t\t\t\tstart = me._start = {};\n\t\t\t}\n\t\n\t\t\tinterpolate(start, view, model, ease);\n\t\n\t\t\treturn me;\n\t\t},\n\t\n\t\ttooltipPosition: function() {\n\t\t\treturn {\n\t\t\t\tx: this._model.x,\n\t\t\t\ty: this._model.y\n\t\t\t};\n\t\t},\n\t\n\t\thasValue: function() {\n\t\t\treturn helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);\n\t\t}\n\t});\n\t\n\tElement.extend = helpers$1.inherits;\n\t\n\tvar core_element = Element;\n\t\n\tvar exports$2 = core_element.extend({\n\t\tchart: null, // the animation associated chart instance\n\t\tcurrentStep: 0, // the current animation step\n\t\tnumSteps: 60, // default number of steps\n\t\teasing: '', // the easing to use for this animation\n\t\trender: null, // render function used by the animation service\n\t\n\t\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\n\t\tonAnimationComplete: null, // user specified callback to fire when the animation finishes\n\t});\n\t\n\tvar core_animation = exports$2;\n\t\n\t// DEPRECATIONS\n\t\n\t/**\n\t * Provided for backward compatibility, use Chart.Animation instead\n\t * @prop Chart.Animation#animationObject\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t */\n\tObject.defineProperty(exports$2.prototype, 'animationObject', {\n\t\tget: function() {\n\t\t\treturn this;\n\t\t}\n\t});\n\t\n\t/**\n\t * Provided for backward compatibility, use Chart.Animation#chart instead\n\t * @prop Chart.Animation#chartInstance\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t */\n\tObject.defineProperty(exports$2.prototype, 'chartInstance', {\n\t\tget: function() {\n\t\t\treturn this.chart;\n\t\t},\n\t\tset: function(value) {\n\t\t\tthis.chart = value;\n\t\t}\n\t});\n\t\n\tcore_defaults._set('global', {\n\t\tanimation: {\n\t\t\tduration: 1000,\n\t\t\teasing: 'easeOutQuart',\n\t\t\tonProgress: helpers$1.noop,\n\t\t\tonComplete: helpers$1.noop\n\t\t}\n\t});\n\t\n\tvar core_animations = {\n\t\tanimations: [],\n\t\trequest: null,\n\t\n\t\t/**\n\t\t * @param {Chart} chart - The chart to animate.\n\t\t * @param {Chart.Animation} animation - The animation that we will animate.\n\t\t * @param {number} duration - The animation duration in ms.\n\t\t * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions\n\t\t */\n\t\taddAnimation: function(chart, animation, duration, lazy) {\n\t\t\tvar animations = this.animations;\n\t\t\tvar i, ilen;\n\t\n\t\t\tanimation.chart = chart;\n\t\t\tanimation.startTime = Date.now();\n\t\t\tanimation.duration = duration;\n\t\n\t\t\tif (!lazy) {\n\t\t\t\tchart.animating = true;\n\t\t\t}\n\t\n\t\t\tfor (i = 0, ilen = animations.length; i < ilen; ++i) {\n\t\t\t\tif (animations[i].chart === chart) {\n\t\t\t\t\tanimations[i] = animation;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tanimations.push(animation);\n\t\n\t\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\n\t\t\tif (animations.length === 1) {\n\t\t\t\tthis.requestAnimationFrame();\n\t\t\t}\n\t\t},\n\t\n\t\tcancelAnimation: function(chart) {\n\t\t\tvar index = helpers$1.findIndex(this.animations, function(animation) {\n\t\t\t\treturn animation.chart === chart;\n\t\t\t});\n\t\n\t\t\tif (index !== -1) {\n\t\t\t\tthis.animations.splice(index, 1);\n\t\t\t\tchart.animating = false;\n\t\t\t}\n\t\t},\n\t\n\t\trequestAnimationFrame: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.request === null) {\n\t\t\t\t// Skip animation frame requests until the active one is executed.\n\t\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'\n\t\t\t\t// and 'mouseout' events will trigger multiple renders.\n\t\t\t\tme.request = helpers$1.requestAnimFrame.call(window, function() {\n\t\t\t\t\tme.request = null;\n\t\t\t\t\tme.startDigest();\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tstartDigest: function() {\n\t\t\tvar me = this;\n\t\n\t\t\tme.advance();\n\t\n\t\t\t// Do we have more stuff to animate?\n\t\t\tif (me.animations.length > 0) {\n\t\t\t\tme.requestAnimationFrame();\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tadvance: function() {\n\t\t\tvar animations = this.animations;\n\t\t\tvar animation, chart, numSteps, nextStep;\n\t\t\tvar i = 0;\n\t\n\t\t\t// 1 animation per chart, so we are looping charts here\n\t\t\twhile (i < animations.length) {\n\t\t\t\tanimation = animations[i];\n\t\t\t\tchart = animation.chart;\n\t\t\t\tnumSteps = animation.numSteps;\n\t\n\t\t\t\t// Make sure that currentStep starts at 1\n\t\t\t\t// https://github.com/chartjs/Chart.js/issues/6104\n\t\t\t\tnextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;\n\t\t\t\tanimation.currentStep = Math.min(nextStep, numSteps);\n\t\n\t\t\t\thelpers$1.callback(animation.render, [chart, animation], chart);\n\t\t\t\thelpers$1.callback(animation.onAnimationProgress, [animation], chart);\n\t\n\t\t\t\tif (animation.currentStep >= numSteps) {\n\t\t\t\t\thelpers$1.callback(animation.onAnimationComplete, [animation], chart);\n\t\t\t\t\tchart.animating = false;\n\t\t\t\t\tanimations.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t\n\tvar resolve = helpers$1.options.resolve;\n\t\n\tvar arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\n\t\n\t/**\n\t * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n\t * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n\t * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\n\t */\n\tfunction listenArrayEvents(array, listener) {\n\t\tif (array._chartjs) {\n\t\t\tarray._chartjs.listeners.push(listener);\n\t\t\treturn;\n\t\t}\n\t\n\t\tObject.defineProperty(array, '_chartjs', {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: {\n\t\t\t\tlisteners: [listener]\n\t\t\t}\n\t\t});\n\t\n\t\tarrayEvents.forEach(function(key) {\n\t\t\tvar method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\n\t\t\tvar base = array[key];\n\t\n\t\t\tObject.defineProperty(array, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: function() {\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\t\t\tvar res = base.apply(this, args);\n\t\n\t\t\t\t\thelpers$1.each(array._chartjs.listeners, function(object) {\n\t\t\t\t\t\tif (typeof object[method] === 'function') {\n\t\t\t\t\t\t\tobject[method].apply(object, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\t\n\t/**\n\t * Removes the given array event listener and cleanup extra attached properties (such as\n\t * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n\t */\n\tfunction unlistenArrayEvents(array, listener) {\n\t\tvar stub = array._chartjs;\n\t\tif (!stub) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tvar listeners = stub.listeners;\n\t\tvar index = listeners.indexOf(listener);\n\t\tif (index !== -1) {\n\t\t\tlisteners.splice(index, 1);\n\t\t}\n\t\n\t\tif (listeners.length > 0) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tarrayEvents.forEach(function(key) {\n\t\t\tdelete array[key];\n\t\t});\n\t\n\t\tdelete array._chartjs;\n\t}\n\t\n\t// Base class for all dataset controllers (line, bar, etc)\n\tvar DatasetController = function(chart, datasetIndex) {\n\t\tthis.initialize(chart, datasetIndex);\n\t};\n\t\n\thelpers$1.extend(DatasetController.prototype, {\n\t\n\t\t/**\n\t\t * Element type used to generate a meta dataset (e.g. Chart.element.Line).\n\t\t * @type {Chart.core.element}\n\t\t */\n\t\tdatasetElementType: null,\n\t\n\t\t/**\n\t\t * Element type used to generate a meta data (e.g. Chart.element.Point).\n\t\t * @type {Chart.core.element}\n\t\t */\n\t\tdataElementType: null,\n\t\n\t\tinitialize: function(chart, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tme.chart = chart;\n\t\t\tme.index = datasetIndex;\n\t\t\tme.linkScales();\n\t\t\tme.addElements();\n\t\t},\n\t\n\t\tupdateIndex: function(datasetIndex) {\n\t\t\tthis.index = datasetIndex;\n\t\t},\n\t\n\t\tlinkScales: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\t\n\t\t\tif (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {\n\t\t\t\tmeta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;\n\t\t\t}\n\t\t\tif (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {\n\t\t\t\tmeta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;\n\t\t\t}\n\t\t},\n\t\n\t\tgetDataset: function() {\n\t\t\treturn this.chart.data.datasets[this.index];\n\t\t},\n\t\n\t\tgetMeta: function() {\n\t\t\treturn this.chart.getDatasetMeta(this.index);\n\t\t},\n\t\n\t\tgetScaleForId: function(scaleID) {\n\t\t\treturn this.chart.scales[scaleID];\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_getValueScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_getIndexScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_getValueScale: function() {\n\t\t\treturn this.getScaleForId(this._getValueScaleId());\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_getIndexScale: function() {\n\t\t\treturn this.getScaleForId(this._getIndexScaleId());\n\t\t},\n\t\n\t\treset: function() {\n\t\t\tthis.update(true);\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tdestroy: function() {\n\t\t\tif (this._data) {\n\t\t\t\tunlistenArrayEvents(this._data, this);\n\t\t\t}\n\t\t},\n\t\n\t\tcreateMetaDataset: function() {\n\t\t\tvar me = this;\n\t\t\tvar type = me.datasetElementType;\n\t\t\treturn type && new type({\n\t\t\t\t_chart: me.chart,\n\t\t\t\t_datasetIndex: me.index\n\t\t\t});\n\t\t},\n\t\n\t\tcreateMetaData: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar type = me.dataElementType;\n\t\t\treturn type && new type({\n\t\t\t\t_chart: me.chart,\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index\n\t\t\t});\n\t\t},\n\t\n\t\taddElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar data = me.getDataset().data || [];\n\t\t\tvar metaData = meta.data;\n\t\t\tvar i, ilen;\n\t\n\t\t\tfor (i = 0, ilen = data.length; i < ilen; ++i) {\n\t\t\t\tmetaData[i] = metaData[i] || me.createMetaData(i);\n\t\t\t}\n\t\n\t\t\tmeta.dataset = meta.dataset || me.createMetaDataset();\n\t\t},\n\t\n\t\taddElementAndReset: function(index) {\n\t\t\tvar element = this.createMetaData(index);\n\t\t\tthis.getMeta().data.splice(index, 0, element);\n\t\t\tthis.updateElement(element, index, true);\n\t\t},\n\t\n\t\tbuildOrUpdateElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar data = dataset.data || (dataset.data = []);\n\t\n\t\t\t// In order to correctly handle data addition/deletion animation (an thus simulate\n\t\t\t// real-time charts), we need to monitor these data modifications and synchronize\n\t\t\t// the internal meta data accordingly.\n\t\t\tif (me._data !== data) {\n\t\t\t\tif (me._data) {\n\t\t\t\t\t// This case happens when the user replaced the data array instance.\n\t\t\t\t\tunlistenArrayEvents(me._data, me);\n\t\t\t\t}\n\t\n\t\t\t\tif (data && Object.isExtensible(data)) {\n\t\t\t\t\tlistenArrayEvents(data, me);\n\t\t\t\t}\n\t\t\t\tme._data = data;\n\t\t\t}\n\t\n\t\t\t// Re-sync meta data in case the user replaced the data array or if we missed\n\t\t\t// any updates and so make sure that we handle number of datapoints changing.\n\t\t\tme.resyncElements();\n\t\t},\n\t\n\t\tupdate: helpers$1.noop,\n\t\n\t\ttransition: function(easingValue) {\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar elements = meta.data || [];\n\t\t\tvar ilen = elements.length;\n\t\t\tvar i = 0;\n\t\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\telements[i].transition(easingValue);\n\t\t\t}\n\t\n\t\t\tif (meta.dataset) {\n\t\t\t\tmeta.dataset.transition(easingValue);\n\t\t\t}\n\t\t},\n\t\n\t\tdraw: function() {\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar elements = meta.data || [];\n\t\t\tvar ilen = elements.length;\n\t\t\tvar i = 0;\n\t\n\t\t\tif (meta.dataset) {\n\t\t\t\tmeta.dataset.draw();\n\t\t\t}\n\t\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\telements[i].draw();\n\t\t\t}\n\t\t},\n\t\n\t\tremoveHoverStyle: function(element) {\n\t\t\thelpers$1.merge(element._model, element.$previousStyle || {});\n\t\t\tdelete element.$previousStyle;\n\t\t},\n\t\n\t\tsetHoverStyle: function(element) {\n\t\t\tvar dataset = this.chart.data.datasets[element._datasetIndex];\n\t\t\tvar index = element._index;\n\t\t\tvar custom = element.custom || {};\n\t\t\tvar model = element._model;\n\t\t\tvar getHoverColor = helpers$1.getHoverColor;\n\t\n\t\t\telement.$previousStyle = {\n\t\t\t\tbackgroundColor: model.backgroundColor,\n\t\t\t\tborderColor: model.borderColor,\n\t\t\t\tborderWidth: model.borderWidth\n\t\t\t};\n\t\n\t\t\tmodel.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);\n\t\t\tmodel.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);\n\t\t\tmodel.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tresyncElements: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar data = me.getDataset().data;\n\t\t\tvar numMeta = meta.data.length;\n\t\t\tvar numData = data.length;\n\t\n\t\t\tif (numData < numMeta) {\n\t\t\t\tmeta.data.splice(numData, numMeta - numData);\n\t\t\t} else if (numData > numMeta) {\n\t\t\t\tme.insertElements(numMeta, numData - numMeta);\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tinsertElements: function(start, count) {\n\t\t\tfor (var i = 0; i < count; ++i) {\n\t\t\t\tthis.addElementAndReset(start + i);\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataPush: function() {\n\t\t\tvar count = arguments.length;\n\t\t\tthis.insertElements(this.getDataset().data.length - count, count);\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataPop: function() {\n\t\t\tthis.getMeta().data.pop();\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataShift: function() {\n\t\t\tthis.getMeta().data.shift();\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataSplice: function(start, count) {\n\t\t\tthis.getMeta().data.splice(start, count);\n\t\t\tthis.insertElements(start, arguments.length - 2);\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tonDataUnshift: function() {\n\t\t\tthis.insertElements(0, arguments.length);\n\t\t}\n\t});\n\t\n\tDatasetController.extend = helpers$1.inherits;\n\t\n\tvar core_datasetController = DatasetController;\n\t\n\tcore_defaults._set('global', {\n\t\telements: {\n\t\t\tarc: {\n\t\t\t\tbackgroundColor: core_defaults.global.defaultColor,\n\t\t\t\tborderColor: '#fff',\n\t\t\t\tborderWidth: 2,\n\t\t\t\tborderAlign: 'center'\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar element_arc = core_element.extend({\n\t\tinLabelRange: function(mouseX) {\n\t\t\tvar vm = this._view;\n\t\n\t\t\tif (vm) {\n\t\t\t\treturn (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\n\t\tinRange: function(chartX, chartY) {\n\t\t\tvar vm = this._view;\n\t\n\t\t\tif (vm) {\n\t\t\t\tvar pointRelativePosition = helpers$1.getAngleFromPoint(vm, {x: chartX, y: chartY});\n\t\t\t\tvar\tangle = pointRelativePosition.angle;\n\t\t\t\tvar distance = pointRelativePosition.distance;\n\t\n\t\t\t\t// Sanitise angle range\n\t\t\t\tvar startAngle = vm.startAngle;\n\t\t\t\tvar endAngle = vm.endAngle;\n\t\t\t\twhile (endAngle < startAngle) {\n\t\t\t\t\tendAngle += 2.0 * Math.PI;\n\t\t\t\t}\n\t\t\t\twhile (angle > endAngle) {\n\t\t\t\t\tangle -= 2.0 * Math.PI;\n\t\t\t\t}\n\t\t\t\twhile (angle < startAngle) {\n\t\t\t\t\tangle += 2.0 * Math.PI;\n\t\t\t\t}\n\t\n\t\t\t\t// Check if within the range of the open/close angle\n\t\t\t\tvar betweenAngles = (angle >= startAngle && angle <= endAngle);\n\t\t\t\tvar withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);\n\t\n\t\t\t\treturn (betweenAngles && withinRadius);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\n\t\tgetCenterPoint: function() {\n\t\t\tvar vm = this._view;\n\t\t\tvar halfAngle = (vm.startAngle + vm.endAngle) / 2;\n\t\t\tvar halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\n\t\t\treturn {\n\t\t\t\tx: vm.x + Math.cos(halfAngle) * halfRadius,\n\t\t\t\ty: vm.y + Math.sin(halfAngle) * halfRadius\n\t\t\t};\n\t\t},\n\t\n\t\tgetArea: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\n\t\t},\n\t\n\t\ttooltipPosition: function() {\n\t\t\tvar vm = this._view;\n\t\t\tvar centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);\n\t\t\tvar rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\n\t\n\t\t\treturn {\n\t\t\t\tx: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\n\t\t\t\ty: vm.y + (Math.sin(centreAngle) * rangeFromCentre)\n\t\t\t};\n\t\t},\n\t\n\t\tdraw: function() {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\t\t\tvar sA = vm.startAngle;\n\t\t\tvar eA = vm.endAngle;\n\t\t\tvar pixelMargin = (vm.borderAlign === 'inner') ? 0.33 : 0;\n\t\t\tvar angleMargin;\n\t\n\t\t\tctx.save();\n\t\n\t\t\tctx.beginPath();\n\t\t\tctx.arc(vm.x, vm.y, Math.max(vm.outerRadius - pixelMargin, 0), sA, eA);\n\t\t\tctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\n\t\t\tctx.closePath();\n\t\n\t\t\tctx.fillStyle = vm.backgroundColor;\n\t\t\tctx.fill();\n\t\n\t\t\tif (vm.borderWidth) {\n\t\t\t\tif (vm.borderAlign === 'inner') {\n\t\t\t\t\t// Draw an inner border by cliping the arc and drawing a double-width border\n\t\t\t\t\t// Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tangleMargin = pixelMargin / vm.outerRadius;\n\t\t\t\t\tctx.arc(vm.x, vm.y, vm.outerRadius, sA - angleMargin, eA + angleMargin);\n\t\t\t\t\tif (vm.innerRadius > pixelMargin) {\n\t\t\t\t\t\tangleMargin = pixelMargin / vm.innerRadius;\n\t\t\t\t\t\tctx.arc(vm.x, vm.y, vm.innerRadius - pixelMargin, eA + angleMargin, sA - angleMargin, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.arc(vm.x, vm.y, pixelMargin, eA + Math.PI / 2, sA - Math.PI / 2);\n\t\t\t\t\t}\n\t\t\t\t\tctx.closePath();\n\t\t\t\t\tctx.clip();\n\t\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);\n\t\t\t\t\tctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\n\t\t\t\t\tctx.closePath();\n\t\n\t\t\t\t\tctx.lineWidth = vm.borderWidth * 2;\n\t\t\t\t\tctx.lineJoin = 'round';\n\t\t\t\t} else {\n\t\t\t\t\tctx.lineWidth = vm.borderWidth;\n\t\t\t\t\tctx.lineJoin = 'bevel';\n\t\t\t\t}\n\t\n\t\t\t\tctx.strokeStyle = vm.borderColor;\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\n\t\t\tctx.restore();\n\t\t}\n\t});\n\t\n\tvar valueOrDefault$1 = helpers$1.valueOrDefault;\n\t\n\tvar defaultColor = core_defaults.global.defaultColor;\n\t\n\tcore_defaults._set('global', {\n\t\telements: {\n\t\t\tline: {\n\t\t\t\ttension: 0.4,\n\t\t\t\tbackgroundColor: defaultColor,\n\t\t\t\tborderWidth: 3,\n\t\t\t\tborderColor: defaultColor,\n\t\t\t\tborderCapStyle: 'butt',\n\t\t\t\tborderDash: [],\n\t\t\t\tborderDashOffset: 0.0,\n\t\t\t\tborderJoinStyle: 'miter',\n\t\t\t\tcapBezierPoints: true,\n\t\t\t\tfill: true, // do we fill in the area between the line and its base axis\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar element_line = core_element.extend({\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar vm = me._view;\n\t\t\tvar ctx = me._chart.ctx;\n\t\t\tvar spanGaps = vm.spanGaps;\n\t\t\tvar points = me._children.slice(); // clone array\n\t\t\tvar globalDefaults = core_defaults.global;\n\t\t\tvar globalOptionLineElements = globalDefaults.elements.line;\n\t\t\tvar lastDrawnIndex = -1;\n\t\t\tvar index, current, previous, currentVM;\n\t\n\t\t\t// If we are looping, adding the first point again\n\t\t\tif (me._loop && points.length) {\n\t\t\t\tpoints.push(points[0]);\n\t\t\t}\n\t\n\t\t\tctx.save();\n\t\n\t\t\t// Stroke Line Options\n\t\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\n\t\n\t\t\t// IE 9 and 10 do not support line dash\n\t\t\tif (ctx.setLineDash) {\n\t\t\t\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n\t\t\t}\n\t\n\t\t\tctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);\n\t\t\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n\t\t\tctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);\n\t\t\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\n\t\n\t\t\t// Stroke Line\n\t\t\tctx.beginPath();\n\t\t\tlastDrawnIndex = -1;\n\t\n\t\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\t\tcurrent = points[index];\n\t\t\t\tprevious = helpers$1.previousItem(points, index);\n\t\t\t\tcurrentVM = current._view;\n\t\n\t\t\t\t// First point moves to it's starting position no matter what\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\t\n\t\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\t\tif ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\n\t\t\t\t\t\t\t// There was a gap and this is the first point after the gap\n\t\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\t\thelpers$1.canvas.lineTo(ctx, previous._view, current._view);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tctx.stroke();\n\t\t\tctx.restore();\n\t\t}\n\t});\n\t\n\tvar valueOrDefault$2 = helpers$1.valueOrDefault;\n\t\n\tvar defaultColor$1 = core_defaults.global.defaultColor;\n\t\n\tcore_defaults._set('global', {\n\t\telements: {\n\t\t\tpoint: {\n\t\t\t\tradius: 3,\n\t\t\t\tpointStyle: 'circle',\n\t\t\t\tbackgroundColor: defaultColor$1,\n\t\t\t\tborderColor: defaultColor$1,\n\t\t\t\tborderWidth: 1,\n\t\t\t\t// Hover\n\t\t\t\thitRadius: 1,\n\t\t\t\thoverRadius: 4,\n\t\t\t\thoverBorderWidth: 1\n\t\t\t}\n\t\t}\n\t});\n\t\n\tfunction xRange(mouseX) {\n\t\tvar vm = this._view;\n\t\treturn vm ? (Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius) : false;\n\t}\n\t\n\tfunction yRange(mouseY) {\n\t\tvar vm = this._view;\n\t\treturn vm ? (Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius) : false;\n\t}\n\t\n\tvar element_point = core_element.extend({\n\t\tinRange: function(mouseX, mouseY) {\n\t\t\tvar vm = this._view;\n\t\t\treturn vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;\n\t\t},\n\t\n\t\tinLabelRange: xRange,\n\t\tinXRange: xRange,\n\t\tinYRange: yRange,\n\t\n\t\tgetCenterPoint: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\t\t},\n\t\n\t\tgetArea: function() {\n\t\t\treturn Math.PI * Math.pow(this._view.radius, 2);\n\t\t},\n\t\n\t\ttooltipPosition: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y,\n\t\t\t\tpadding: vm.radius + vm.borderWidth\n\t\t\t};\n\t\t},\n\t\n\t\tdraw: function(chartArea) {\n\t\t\tvar vm = this._view;\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar pointStyle = vm.pointStyle;\n\t\t\tvar rotation = vm.rotation;\n\t\t\tvar radius = vm.radius;\n\t\t\tvar x = vm.x;\n\t\t\tvar y = vm.y;\n\t\t\tvar globalDefaults = core_defaults.global;\n\t\t\tvar defaultColor = globalDefaults.defaultColor; // eslint-disable-line no-shadow\n\t\n\t\t\tif (vm.skip) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Clipping for Points.\n\t\t\tif (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {\n\t\t\t\tctx.strokeStyle = vm.borderColor || defaultColor;\n\t\t\t\tctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);\n\t\t\t\tctx.fillStyle = vm.backgroundColor || defaultColor;\n\t\t\t\thelpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar defaultColor$2 = core_defaults.global.defaultColor;\n\t\n\tcore_defaults._set('global', {\n\t\telements: {\n\t\t\trectangle: {\n\t\t\t\tbackgroundColor: defaultColor$2,\n\t\t\t\tborderColor: defaultColor$2,\n\t\t\t\tborderSkipped: 'bottom',\n\t\t\t\tborderWidth: 0\n\t\t\t}\n\t\t}\n\t});\n\t\n\tfunction isVertical(vm) {\n\t\treturn vm && vm.width !== undefined;\n\t}\n\t\n\t/**\n\t * Helper function to get the bounds of the bar regardless of the orientation\n\t * @param bar {Chart.Element.Rectangle} the bar\n\t * @return {Bounds} bounds of the bar\n\t * @private\n\t */\n\tfunction getBarBounds(vm) {\n\t\tvar x1, x2, y1, y2, half;\n\t\n\t\tif (isVertical(vm)) {\n\t\t\thalf = vm.width / 2;\n\t\t\tx1 = vm.x - half;\n\t\t\tx2 = vm.x + half;\n\t\t\ty1 = Math.min(vm.y, vm.base);\n\t\t\ty2 = Math.max(vm.y, vm.base);\n\t\t} else {\n\t\t\thalf = vm.height / 2;\n\t\t\tx1 = Math.min(vm.x, vm.base);\n\t\t\tx2 = Math.max(vm.x, vm.base);\n\t\t\ty1 = vm.y - half;\n\t\t\ty2 = vm.y + half;\n\t\t}\n\t\n\t\treturn {\n\t\t\tleft: x1,\n\t\t\ttop: y1,\n\t\t\tright: x2,\n\t\t\tbottom: y2\n\t\t};\n\t}\n\t\n\tfunction swap(orig, v1, v2) {\n\t\treturn orig === v1 ? v2 : orig === v2 ? v1 : orig;\n\t}\n\t\n\tfunction parseBorderSkipped(vm) {\n\t\tvar edge = vm.borderSkipped;\n\t\tvar res = {};\n\t\n\t\tif (!edge) {\n\t\t\treturn res;\n\t\t}\n\t\n\t\tif (vm.horizontal) {\n\t\t\tif (vm.base > vm.x) {\n\t\t\t\tedge = swap(edge, 'left', 'right');\n\t\t\t}\n\t\t} else if (vm.base < vm.y) {\n\t\t\tedge = swap(edge, 'bottom', 'top');\n\t\t}\n\t\n\t\tres[edge] = true;\n\t\treturn res;\n\t}\n\t\n\tfunction parseBorderWidth(vm, maxW, maxH) {\n\t\tvar value = vm.borderWidth;\n\t\tvar skip = parseBorderSkipped(vm);\n\t\tvar t, r, b, l;\n\t\n\t\tif (helpers$1.isObject(value)) {\n\t\t\tt = +value.top || 0;\n\t\t\tr = +value.right || 0;\n\t\t\tb = +value.bottom || 0;\n\t\t\tl = +value.left || 0;\n\t\t} else {\n\t\t\tt = r = b = l = +value || 0;\n\t\t}\n\t\n\t\treturn {\n\t\t\tt: skip.top || (t < 0) ? 0 : t > maxH ? maxH : t,\n\t\t\tr: skip.right || (r < 0) ? 0 : r > maxW ? maxW : r,\n\t\t\tb: skip.bottom || (b < 0) ? 0 : b > maxH ? maxH : b,\n\t\t\tl: skip.left || (l < 0) ? 0 : l > maxW ? maxW : l\n\t\t};\n\t}\n\t\n\tfunction boundingRects(vm) {\n\t\tvar bounds = getBarBounds(vm);\n\t\tvar width = bounds.right - bounds.left;\n\t\tvar height = bounds.bottom - bounds.top;\n\t\tvar border = parseBorderWidth(vm, width / 2, height / 2);\n\t\n\t\treturn {\n\t\t\touter: {\n\t\t\t\tx: bounds.left,\n\t\t\t\ty: bounds.top,\n\t\t\t\tw: width,\n\t\t\t\th: height\n\t\t\t},\n\t\t\tinner: {\n\t\t\t\tx: bounds.left + border.l,\n\t\t\t\ty: bounds.top + border.t,\n\t\t\t\tw: width - border.l - border.r,\n\t\t\t\th: height - border.t - border.b\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction inRange(vm, x, y) {\n\t\tvar skipX = x === null;\n\t\tvar skipY = y === null;\n\t\tvar bounds = !vm || (skipX && skipY) ? false : getBarBounds(vm);\n\t\n\t\treturn bounds\n\t\t\t&& (skipX || x >= bounds.left && x <= bounds.right)\n\t\t\t&& (skipY || y >= bounds.top && y <= bounds.bottom);\n\t}\n\t\n\tvar element_rectangle = core_element.extend({\n\t\tdraw: function() {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\t\t\tvar rects = boundingRects(vm);\n\t\t\tvar outer = rects.outer;\n\t\t\tvar inner = rects.inner;\n\t\n\t\t\tctx.fillStyle = vm.backgroundColor;\n\t\t\tctx.fillRect(outer.x, outer.y, outer.w, outer.h);\n\t\n\t\t\tif (outer.w === inner.w && outer.h === inner.h) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tctx.save();\n\t\t\tctx.beginPath();\n\t\t\tctx.rect(outer.x, outer.y, outer.w, outer.h);\n\t\t\tctx.clip();\n\t\t\tctx.fillStyle = vm.borderColor;\n\t\t\tctx.rect(inner.x, inner.y, inner.w, inner.h);\n\t\t\tctx.fill('evenodd');\n\t\t\tctx.restore();\n\t\t},\n\t\n\t\theight: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn vm.base - vm.y;\n\t\t},\n\t\n\t\tinRange: function(mouseX, mouseY) {\n\t\t\treturn inRange(this._view, mouseX, mouseY);\n\t\t},\n\t\n\t\tinLabelRange: function(mouseX, mouseY) {\n\t\t\tvar vm = this._view;\n\t\t\treturn isVertical(vm)\n\t\t\t\t? inRange(vm, mouseX, null)\n\t\t\t\t: inRange(vm, null, mouseY);\n\t\t},\n\t\n\t\tinXRange: function(mouseX) {\n\t\t\treturn inRange(this._view, mouseX, null);\n\t\t},\n\t\n\t\tinYRange: function(mouseY) {\n\t\t\treturn inRange(this._view, null, mouseY);\n\t\t},\n\t\n\t\tgetCenterPoint: function() {\n\t\t\tvar vm = this._view;\n\t\t\tvar x, y;\n\t\t\tif (isVertical(vm)) {\n\t\t\t\tx = vm.x;\n\t\t\t\ty = (vm.y + vm.base) / 2;\n\t\t\t} else {\n\t\t\t\tx = (vm.x + vm.base) / 2;\n\t\t\t\ty = vm.y;\n\t\t\t}\n\t\n\t\t\treturn {x: x, y: y};\n\t\t},\n\t\n\t\tgetArea: function() {\n\t\t\tvar vm = this._view;\n\t\n\t\t\treturn isVertical(vm)\n\t\t\t\t? vm.width * Math.abs(vm.y - vm.base)\n\t\t\t\t: vm.height * Math.abs(vm.x - vm.base);\n\t\t},\n\t\n\t\ttooltipPosition: function() {\n\t\t\tvar vm = this._view;\n\t\t\treturn {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\t\t}\n\t});\n\t\n\tvar elements = {};\n\tvar Arc = element_arc;\n\tvar Line = element_line;\n\tvar Point = element_point;\n\tvar Rectangle = element_rectangle;\n\telements.Arc = Arc;\n\telements.Line = Line;\n\telements.Point = Point;\n\telements.Rectangle = Rectangle;\n\t\n\tvar resolve$1 = helpers$1.options.resolve;\n\t\n\tcore_defaults._set('bar', {\n\t\thover: {\n\t\t\tmode: 'label'\n\t\t},\n\t\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'category',\n\t\t\t\tcategoryPercentage: 0.8,\n\t\t\t\tbarPercentage: 0.9,\n\t\t\t\toffset: true,\n\t\t\t\tgridLines: {\n\t\t\t\t\toffsetGridLines: true\n\t\t\t\t}\n\t\t\t}],\n\t\n\t\t\tyAxes: [{\n\t\t\t\ttype: 'linear'\n\t\t\t}]\n\t\t}\n\t});\n\t\n\t/**\n\t * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n\t * @private\n\t */\n\tfunction computeMinSampleSize(scale, pixels) {\n\t\tvar min = scale.isHorizontal() ? scale.width : scale.height;\n\t\tvar ticks = scale.getTicks();\n\t\tvar prev, curr, i, ilen;\n\t\n\t\tfor (i = 1, ilen = pixels.length; i < ilen; ++i) {\n\t\t\tmin = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));\n\t\t}\n\t\n\t\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\t\tcurr = scale.getPixelForTick(i);\n\t\t\tmin = i > 0 ? Math.min(min, curr - prev) : min;\n\t\t\tprev = curr;\n\t\t}\n\t\n\t\treturn min;\n\t}\n\t\n\t/**\n\t * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n\t * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n\t * mode currently always generates bars equally sized (until we introduce scriptable options?).\n\t * @private\n\t */\n\tfunction computeFitCategoryTraits(index, ruler, options) {\n\t\tvar thickness = options.barThickness;\n\t\tvar count = ruler.stackCount;\n\t\tvar curr = ruler.pixels[index];\n\t\tvar size, ratio;\n\t\n\t\tif (helpers$1.isNullOrUndef(thickness)) {\n\t\t\tsize = ruler.min * options.categoryPercentage;\n\t\t\tratio = options.barPercentage;\n\t\t} else {\n\t\t\t// When bar thickness is enforced, category and bar percentages are ignored.\n\t\t\t// Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n\t\t\t// and deprecate barPercentage since this value is ignored when thickness is absolute.\n\t\t\tsize = thickness * count;\n\t\t\tratio = 1;\n\t\t}\n\t\n\t\treturn {\n\t\t\tchunk: size / count,\n\t\t\tratio: ratio,\n\t\t\tstart: curr - (size / 2)\n\t\t};\n\t}\n\t\n\t/**\n\t * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n\t * percentage options are 1), based on the previous and following categories. This mode\n\t * generates bars with different widths when data are not evenly spaced.\n\t * @private\n\t */\n\tfunction computeFlexCategoryTraits(index, ruler, options) {\n\t\tvar pixels = ruler.pixels;\n\t\tvar curr = pixels[index];\n\t\tvar prev = index > 0 ? pixels[index - 1] : null;\n\t\tvar next = index < pixels.length - 1 ? pixels[index + 1] : null;\n\t\tvar percent = options.categoryPercentage;\n\t\tvar start, size;\n\t\n\t\tif (prev === null) {\n\t\t\t// first data: its size is double based on the next point or,\n\t\t\t// if it's also the last data, we use the scale size.\n\t\t\tprev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n\t\t}\n\t\n\t\tif (next === null) {\n\t\t\t// last data: its size is also double based on the previous point.\n\t\t\tnext = curr + curr - prev;\n\t\t}\n\t\n\t\tstart = curr - (curr - Math.min(prev, next)) / 2 * percent;\n\t\tsize = Math.abs(next - prev) / 2 * percent;\n\t\n\t\treturn {\n\t\t\tchunk: size / ruler.stackCount,\n\t\t\tratio: options.barPercentage,\n\t\t\tstart: start\n\t\t};\n\t}\n\t\n\tvar controller_bar = core_datasetController.extend({\n\t\n\t\tdataElementType: elements.Rectangle,\n\t\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta;\n\t\n\t\t\tcore_datasetController.prototype.initialize.apply(me, arguments);\n\t\n\t\t\tmeta = me.getMeta();\n\t\t\tmeta.stack = me.getDataset().stack;\n\t\t\tmeta.bar = true;\n\t\t},\n\t\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar rects = me.getMeta().data;\n\t\t\tvar i, ilen;\n\t\n\t\t\tme._ruler = me.getRuler();\n\t\n\t\t\tfor (i = 0, ilen = rects.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(rects[i], i, reset);\n\t\t\t}\n\t\t},\n\t\n\t\tupdateElement: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar options = me._resolveElementOptions(rectangle, index);\n\t\n\t\t\trectangle._xScale = me.getScaleForId(meta.xAxisID);\n\t\t\trectangle._yScale = me.getScaleForId(meta.yAxisID);\n\t\t\trectangle._datasetIndex = me.index;\n\t\t\trectangle._index = index;\n\t\t\trectangle._model = {\n\t\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\t\tborderColor: options.borderColor,\n\t\t\t\tborderSkipped: options.borderSkipped,\n\t\t\t\tborderWidth: options.borderWidth,\n\t\t\t\tdatasetLabel: dataset.label,\n\t\t\t\tlabel: me.chart.data.labels[index]\n\t\t\t};\n\t\n\t\t\tme._updateElementGeometry(rectangle, index, reset);\n\t\n\t\t\trectangle.pivot();\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_updateElementGeometry: function(rectangle, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar model = rectangle._model;\n\t\t\tvar vscale = me._getValueScale();\n\t\t\tvar base = vscale.getBasePixel();\n\t\t\tvar horizontal = vscale.isHorizontal();\n\t\t\tvar ruler = me._ruler || me.getRuler();\n\t\t\tvar vpixels = me.calculateBarValuePixels(me.index, index);\n\t\t\tvar ipixels = me.calculateBarIndexPixels(me.index, index, ruler);\n\t\n\t\t\tmodel.horizontal = horizontal;\n\t\t\tmodel.base = reset ? base : vpixels.base;\n\t\t\tmodel.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\n\t\t\tmodel.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\n\t\t\tmodel.height = horizontal ? ipixels.size : undefined;\n\t\t\tmodel.width = horizontal ? undefined : ipixels.size;\n\t\t},\n\t\n\t\t/**\n\t\t * Returns the stacks based on groups and bar visibility.\n\t\t * @param {number} [last] - The dataset index\n\t\t * @returns {string[]} The list of stack IDs\n\t\t * @private\n\t\t */\n\t\t_getStacks: function(last) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar scale = me._getIndexScale();\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar ilen = last === undefined ? chart.data.datasets.length : last + 1;\n\t\t\tvar stacks = [];\n\t\t\tvar i, meta;\n\t\n\t\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tif (meta.bar && chart.isDatasetVisible(i) &&\n\t\t\t\t\t(stacked === false ||\n\t\t\t\t\t(stacked === true && stacks.indexOf(meta.stack) === -1) ||\n\t\t\t\t\t(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {\n\t\t\t\t\tstacks.push(meta.stack);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn stacks;\n\t\t},\n\t\n\t\t/**\n\t\t * Returns the effective number of stacks based on groups and bar visibility.\n\t\t * @private\n\t\t */\n\t\tgetStackCount: function() {\n\t\t\treturn this._getStacks().length;\n\t\t},\n\t\n\t\t/**\n\t\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t\t * @param {number} [datasetIndex] - The dataset index\n\t\t * @param {string} [name] - The stack name to find\n\t\t * @returns {number} The stack index\n\t\t * @private\n\t\t */\n\t\tgetStackIndex: function(datasetIndex, name) {\n\t\t\tvar stacks = this._getStacks(datasetIndex);\n\t\t\tvar index = (name !== undefined)\n\t\t\t\t? stacks.indexOf(name)\n\t\t\t\t: -1; // indexOf returns -1 if element is not present\n\t\n\t\t\treturn (index === -1)\n\t\t\t\t? stacks.length - 1\n\t\t\t\t: index;\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetRuler: function() {\n\t\t\tvar me = this;\n\t\t\tvar scale = me._getIndexScale();\n\t\t\tvar stackCount = me.getStackCount();\n\t\t\tvar datasetIndex = me.index;\n\t\t\tvar isHorizontal = scale.isHorizontal();\n\t\t\tvar start = isHorizontal ? scale.left : scale.top;\n\t\t\tvar end = start + (isHorizontal ? scale.width : scale.height);\n\t\t\tvar pixels = [];\n\t\t\tvar i, ilen, min;\n\t\n\t\t\tfor (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\n\t\t\t\tpixels.push(scale.getPixelForValue(null, i, datasetIndex));\n\t\t\t}\n\t\n\t\t\tmin = helpers$1.isNullOrUndef(scale.options.barThickness)\n\t\t\t\t? computeMinSampleSize(scale, pixels)\n\t\t\t\t: -1;\n\t\n\t\t\treturn {\n\t\t\t\tmin: min,\n\t\t\t\tpixels: pixels,\n\t\t\t\tstart: start,\n\t\t\t\tend: end,\n\t\t\t\tstackCount: stackCount,\n\t\t\t\tscale: scale\n\t\t\t};\n\t\t},\n\t\n\t\t/**\n\t\t * Note: pixel values are not clamped to the scale area.\n\t\t * @private\n\t\t */\n\t\tcalculateBarValuePixels: function(datasetIndex, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar scale = me._getValueScale();\n\t\t\tvar isHorizontal = scale.isHorizontal();\n\t\t\tvar datasets = chart.data.datasets;\n\t\t\tvar value = +scale.getRightValue(datasets[datasetIndex].data[index]);\n\t\t\tvar minBarLength = scale.options.minBarLength;\n\t\t\tvar stacked = scale.options.stacked;\n\t\t\tvar stack = meta.stack;\n\t\t\tvar start = 0;\n\t\t\tvar i, imeta, ivalue, base, head, size;\n\t\n\t\t\tif (stacked || (stacked === undefined && stack !== undefined)) {\n\t\t\t\tfor (i = 0; i < datasetIndex; ++i) {\n\t\t\t\t\timeta = chart.getDatasetMeta(i);\n\t\n\t\t\t\t\tif (imeta.bar &&\n\t\t\t\t\t\timeta.stack === stack &&\n\t\t\t\t\t\timeta.controller._getValueScaleId() === scale.id &&\n\t\t\t\t\t\tchart.isDatasetVisible(i)) {\n\t\n\t\t\t\t\t\tivalue = +scale.getRightValue(datasets[i].data[index]);\n\t\t\t\t\t\tif ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {\n\t\t\t\t\t\t\tstart += ivalue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tbase = scale.getPixelForValue(start);\n\t\t\thead = scale.getPixelForValue(start + value);\n\t\t\tsize = head - base;\n\t\n\t\t\tif (minBarLength !== undefined && Math.abs(size) < minBarLength) {\n\t\t\t\tsize = minBarLength;\n\t\t\t\tif (value >= 0 && !isHorizontal || value < 0 && isHorizontal) {\n\t\t\t\t\thead = base - minBarLength;\n\t\t\t\t} else {\n\t\t\t\t\thead = base + minBarLength;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tsize: size,\n\t\t\t\tbase: base,\n\t\t\t\thead: head,\n\t\t\t\tcenter: head + size / 2\n\t\t\t};\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tcalculateBarIndexPixels: function(datasetIndex, index, ruler) {\n\t\t\tvar me = this;\n\t\t\tvar options = ruler.scale.options;\n\t\t\tvar range = options.barThickness === 'flex'\n\t\t\t\t? computeFlexCategoryTraits(index, ruler, options)\n\t\t\t\t: computeFitCategoryTraits(index, ruler, options);\n\t\n\t\t\tvar stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\n\t\t\tvar center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n\t\t\tvar size = Math.min(\n\t\t\t\thelpers$1.valueOrDefault(options.maxBarThickness, Infinity),\n\t\t\t\trange.chunk * range.ratio);\n\t\n\t\t\treturn {\n\t\t\t\tbase: center - size / 2,\n\t\t\t\thead: center + size / 2,\n\t\t\t\tcenter: center,\n\t\t\t\tsize: size\n\t\t\t};\n\t\t},\n\t\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar scale = me._getValueScale();\n\t\t\tvar rects = me.getMeta().data;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar ilen = rects.length;\n\t\t\tvar i = 0;\n\t\n\t\t\thelpers$1.canvas.clipArea(chart.ctx, chart.chartArea);\n\t\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\tif (!isNaN(scale.getRightValue(dataset.data[i]))) {\n\t\t\t\t\trects[i].draw();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\thelpers$1.canvas.unclipArea(chart.ctx);\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_resolveElementOptions: function(rectangle, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar datasets = chart.data.datasets;\n\t\t\tvar dataset = datasets[me.index];\n\t\t\tvar custom = rectangle.custom || {};\n\t\t\tvar options = chart.options.elements.rectangle;\n\t\t\tvar values = {};\n\t\t\tvar i, ilen, key;\n\t\n\t\t\t// Scriptable options\n\t\t\tvar context = {\n\t\t\t\tchart: chart,\n\t\t\t\tdataIndex: index,\n\t\t\t\tdataset: dataset,\n\t\t\t\tdatasetIndex: me.index\n\t\t\t};\n\t\n\t\t\tvar keys = [\n\t\t\t\t'backgroundColor',\n\t\t\t\t'borderColor',\n\t\t\t\t'borderSkipped',\n\t\t\t\t'borderWidth'\n\t\t\t];\n\t\n\t\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\t\tkey = keys[i];\n\t\t\t\tvalues[key] = resolve$1([\n\t\t\t\t\tcustom[key],\n\t\t\t\t\tdataset[key],\n\t\t\t\t\toptions[key]\n\t\t\t\t], context, index);\n\t\t\t}\n\t\n\t\t\treturn values;\n\t\t}\n\t});\n\t\n\tvar valueOrDefault$3 = helpers$1.valueOrDefault;\n\tvar resolve$2 = helpers$1.options.resolve;\n\t\n\tcore_defaults._set('bubble', {\n\t\thover: {\n\t\t\tmode: 'single'\n\t\t},\n\t\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'linear', // bubble should probably use a linear scale by default\n\t\t\t\tposition: 'bottom',\n\t\t\t\tid: 'x-axis-0' // need an ID so datasets can reference the scale\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\ttype: 'linear',\n\t\t\t\tposition: 'left',\n\t\t\t\tid: 'y-axis-0'\n\t\t\t}]\n\t\t},\n\t\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function() {\n\t\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\tlabel: function(item, data) {\n\t\t\t\t\tvar datasetLabel = data.datasets[item.datasetIndex].label || '';\n\t\t\t\t\tvar dataPoint = data.datasets[item.datasetIndex].data[item.index];\n\t\t\t\t\treturn datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar controller_bubble = core_datasetController.extend({\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tdataElementType: elements.Point,\n\t\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data;\n\t\n\t\t\t// Update Points\n\t\t\thelpers$1.each(points, function(point, index) {\n\t\t\t\tme.updateElement(point, index, reset);\n\t\t\t});\n\t\t},\n\t\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar options = me._resolveElementOptions(point, index);\n\t\t\tvar data = me.getDataset().data[index];\n\t\t\tvar dsIndex = me.index;\n\t\n\t\t\tvar x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);\n\t\t\tvar y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);\n\t\n\t\t\tpoint._xScale = xScale;\n\t\t\tpoint._yScale = yScale;\n\t\t\tpoint._options = options;\n\t\t\tpoint._datasetIndex = dsIndex;\n\t\t\tpoint._index = index;\n\t\t\tpoint._model = {\n\t\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\t\tborderColor: options.borderColor,\n\t\t\t\tborderWidth: options.borderWidth,\n\t\t\t\thitRadius: options.hitRadius,\n\t\t\t\tpointStyle: options.pointStyle,\n\t\t\t\trotation: options.rotation,\n\t\t\t\tradius: reset ? 0 : options.radius,\n\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t};\n\t\n\t\t\tpoint.pivot();\n\t\t},\n\t\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tsetHoverStyle: function(point) {\n\t\t\tvar model = point._model;\n\t\t\tvar options = point._options;\n\t\t\tvar getHoverColor = helpers$1.getHoverColor;\n\t\n\t\t\tpoint.$previousStyle = {\n\t\t\t\tbackgroundColor: model.backgroundColor,\n\t\t\t\tborderColor: model.borderColor,\n\t\t\t\tborderWidth: model.borderWidth,\n\t\t\t\tradius: model.radius\n\t\t\t};\n\t\n\t\t\tmodel.backgroundColor = valueOrDefault$3(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n\t\t\tmodel.borderColor = valueOrDefault$3(options.hoverBorderColor, getHoverColor(options.borderColor));\n\t\t\tmodel.borderWidth = valueOrDefault$3(options.hoverBorderWidth, options.borderWidth);\n\t\t\tmodel.radius = options.radius + options.hoverRadius;\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_resolveElementOptions: function(point, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar datasets = chart.data.datasets;\n\t\t\tvar dataset = datasets[me.index];\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar options = chart.options.elements.point;\n\t\t\tvar data = dataset.data[index];\n\t\t\tvar values = {};\n\t\t\tvar i, ilen, key;\n\t\n\t\t\t// Scriptable options\n\t\t\tvar context = {\n\t\t\t\tchart: chart,\n\t\t\t\tdataIndex: index,\n\t\t\t\tdataset: dataset,\n\t\t\t\tdatasetIndex: me.index\n\t\t\t};\n\t\n\t\t\tvar keys = [\n\t\t\t\t'backgroundColor',\n\t\t\t\t'borderColor',\n\t\t\t\t'borderWidth',\n\t\t\t\t'hoverBackgroundColor',\n\t\t\t\t'hoverBorderColor',\n\t\t\t\t'hoverBorderWidth',\n\t\t\t\t'hoverRadius',\n\t\t\t\t'hitRadius',\n\t\t\t\t'pointStyle',\n\t\t\t\t'rotation'\n\t\t\t];\n\t\n\t\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\t\tkey = keys[i];\n\t\t\t\tvalues[key] = resolve$2([\n\t\t\t\t\tcustom[key],\n\t\t\t\t\tdataset[key],\n\t\t\t\t\toptions[key]\n\t\t\t\t], context, index);\n\t\t\t}\n\t\n\t\t\t// Custom radius resolution\n\t\t\tvalues.radius = resolve$2([\n\t\t\t\tcustom.radius,\n\t\t\t\tdata ? data.r : undefined,\n\t\t\t\tdataset.radius,\n\t\t\t\toptions.radius\n\t\t\t], context, index);\n\t\n\t\t\treturn values;\n\t\t}\n\t});\n\t\n\tvar resolve$3 = helpers$1.options.resolve;\n\tvar valueOrDefault$4 = helpers$1.valueOrDefault;\n\t\n\tcore_defaults._set('doughnut', {\n\t\tanimation: {\n\t\t\t// Boolean - Whether we animate the rotation of the Doughnut\n\t\t\tanimateRotate: true,\n\t\t\t// Boolean - Whether we animate scaling the Doughnut from the centre\n\t\t\tanimateScale: false\n\t\t},\n\t\thover: {\n\t\t\tmode: 'single'\n\t\t},\n\t\tlegendCallback: function(chart) {\n\t\t\tvar text = [];\n\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar labels = data.labels;\n\t\n\t\t\tif (datasets.length) {\n\t\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\t\tif (labels[i]) {\n\t\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t\t}\n\t\t\t\t\ttext.push('</li>');\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\ttext.push('</ul>');\n\t\t\treturn text.join('');\n\t\t},\n\t\tlegend: {\n\t\t\tlabels: {\n\t\t\t\tgenerateLabels: function(chart) {\n\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\t\tvar custom = arc && arc.custom || {};\n\t\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\t\tvar fill = resolve$3([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);\n\t\t\t\t\t\t\tvar stroke = resolve$3([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);\n\t\t\t\t\t\t\tvar bw = resolve$3([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);\n\t\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\t\n\t\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tonClick: function(e, legendItem) {\n\t\t\t\tvar index = legendItem.index;\n\t\t\t\tvar chart = this.chart;\n\t\t\t\tvar i, ilen, meta;\n\t\n\t\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\t// toggle visibility of index if exists\n\t\t\t\t\tif (meta.data[index]) {\n\t\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tchart.update();\n\t\t\t}\n\t\t},\n\t\n\t\t// The percentage of the chart that we cut out of the middle.\n\t\tcutoutPercentage: 50,\n\t\n\t\t// The rotation of the chart, where the first data arc begins.\n\t\trotation: Math.PI * -0.5,\n\t\n\t\t// The total circumference of the chart.\n\t\tcircumference: Math.PI * 2.0,\n\t\n\t\t// Need to override these to give a nice default\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function() {\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\tvar dataLabel = data.labels[tooltipItem.index];\n\t\t\t\t\tvar value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\t\n\t\t\t\t\tif (helpers$1.isArray(dataLabel)) {\n\t\t\t\t\t\t// show value on first line of multiline label\n\t\t\t\t\t\t// need to clone because we are changing the value\n\t\t\t\t\t\tdataLabel = dataLabel.slice();\n\t\t\t\t\t\tdataLabel[0] += value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdataLabel += value;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn dataLabel;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar controller_doughnut = core_datasetController.extend({\n\t\n\t\tdataElementType: elements.Arc,\n\t\n\t\tlinkScales: helpers$1.noop,\n\t\n\t\t// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\n\t\tgetRingIndex: function(datasetIndex) {\n\t\t\tvar ringIndex = 0;\n\t\n\t\t\tfor (var j = 0; j < datasetIndex; ++j) {\n\t\t\t\tif (this.chart.isDatasetVisible(j)) {\n\t\t\t\t\t++ringIndex;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn ringIndex;\n\t\t},\n\t\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar opts = chart.options;\n\t\t\tvar availableWidth = chartArea.right - chartArea.left;\n\t\t\tvar availableHeight = chartArea.bottom - chartArea.top;\n\t\t\tvar minSize = Math.min(availableWidth, availableHeight);\n\t\t\tvar offset = {x: 0, y: 0};\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar arcs = meta.data;\n\t\t\tvar cutoutPercentage = opts.cutoutPercentage;\n\t\t\tvar circumference = opts.circumference;\n\t\t\tvar chartWeight = me._getRingWeight(me.index);\n\t\t\tvar i, ilen;\n\t\n\t\t\t// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc\n\t\t\tif (circumference < Math.PI * 2.0) {\n\t\t\t\tvar startAngle = opts.rotation % (Math.PI * 2.0);\n\t\t\t\tstartAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);\n\t\t\t\tvar endAngle = startAngle + circumference;\n\t\t\t\tvar start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};\n\t\t\t\tvar end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};\n\t\t\t\tvar contains0 = (startAngle <= 0 && endAngle >= 0) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);\n\t\t\t\tvar contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);\n\t\t\t\tvar contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);\n\t\t\t\tvar contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);\n\t\t\t\tvar cutout = cutoutPercentage / 100.0;\n\t\t\t\tvar min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};\n\t\t\t\tvar max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};\n\t\t\t\tvar size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};\n\t\t\t\tminSize = Math.min(availableWidth / size.width, availableHeight / size.height);\n\t\t\t\toffset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};\n\t\t\t}\n\t\n\t\t\tfor (i = 0, ilen = arcs.length; i < ilen; ++i) {\n\t\t\t\tarcs[i]._options = me._resolveElementOptions(arcs[i], i);\n\t\t\t}\n\t\n\t\t\tchart.borderWidth = me.getMaxBorderWidth();\n\t\t\tchart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);\n\t\t\tchart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);\n\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);\n\t\t\tchart.offsetX = offset.x * chart.outerRadius;\n\t\t\tchart.offsetY = offset.y * chart.outerRadius;\n\t\n\t\t\tmeta.total = me.calculateTotal();\n\t\n\t\t\tme.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);\n\t\t\tme.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);\n\t\n\t\t\tfor (i = 0, ilen = arcs.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(arcs[i], i, reset);\n\t\t\t}\n\t\t},\n\t\n\t\tupdateElement: function(arc, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar opts = chart.options;\n\t\t\tvar animationOpts = opts.animation;\n\t\t\tvar centerX = (chartArea.left + chartArea.right) / 2;\n\t\t\tvar centerY = (chartArea.top + chartArea.bottom) / 2;\n\t\t\tvar startAngle = opts.rotation; // non reset case handled later\n\t\t\tvar endAngle = opts.rotation; // non reset case handled later\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));\n\t\t\tvar innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;\n\t\t\tvar outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;\n\t\t\tvar options = arc._options || {};\n\t\n\t\t\thelpers$1.extend(arc, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\t\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\t\t\tborderColor: options.borderColor,\n\t\t\t\t\tborderWidth: options.borderWidth,\n\t\t\t\t\tborderAlign: options.borderAlign,\n\t\t\t\t\tx: centerX + chart.offsetX,\n\t\t\t\t\ty: centerY + chart.offsetY,\n\t\t\t\t\tstartAngle: startAngle,\n\t\t\t\t\tendAngle: endAngle,\n\t\t\t\t\tcircumference: circumference,\n\t\t\t\t\touterRadius: outerRadius,\n\t\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\t\tlabel: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tvar model = arc._model;\n\t\n\t\t\t// Set correct angles if not resetting\n\t\t\tif (!reset || !animationOpts.animateRotate) {\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tmodel.startAngle = opts.rotation;\n\t\t\t\t} else {\n\t\t\t\t\tmodel.startAngle = me.getMeta().data[index - 1]._model.endAngle;\n\t\t\t\t}\n\t\n\t\t\t\tmodel.endAngle = model.startAngle + model.circumference;\n\t\t\t}\n\t\n\t\t\tarc.pivot();\n\t\t},\n\t\n\t\tcalculateTotal: function() {\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar total = 0;\n\t\t\tvar value;\n\t\n\t\t\thelpers$1.each(meta.data, function(element, index) {\n\t\t\t\tvalue = dataset.data[index];\n\t\t\t\tif (!isNaN(value) && !element.hidden) {\n\t\t\t\t\ttotal += Math.abs(value);\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\t/* if (total === 0) {\n\t\t\t\ttotal = NaN;\n\t\t\t}*/\n\t\n\t\t\treturn total;\n\t\t},\n\t\n\t\tcalculateCircumference: function(value) {\n\t\t\tvar total = this.getMeta().total;\n\t\t\tif (total > 0 && !isNaN(value)) {\n\t\t\t\treturn (Math.PI * 2.0) * (Math.abs(value) / total);\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\t\n\t\t// gets the max border or hover width to properly scale pie charts\n\t\tgetMaxBorderWidth: function(arcs) {\n\t\t\tvar me = this;\n\t\t\tvar max = 0;\n\t\t\tvar chart = me.chart;\n\t\t\tvar i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;\n\t\n\t\t\tif (!arcs) {\n\t\t\t\t// Find the outmost visible dataset\n\t\t\t\tfor (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n\t\t\t\t\tif (chart.isDatasetVisible(i)) {\n\t\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\t\tarcs = meta.data;\n\t\t\t\t\t\tif (i !== me.index) {\n\t\t\t\t\t\t\tcontroller = meta.controller;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (!arcs) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\tfor (i = 0, ilen = arcs.length; i < ilen; ++i) {\n\t\t\t\tarc = arcs[i];\n\t\t\t\toptions = controller ? controller._resolveElementOptions(arc, i) : arc._options;\n\t\t\t\tif (options.borderAlign !== 'inner') {\n\t\t\t\t\tborderWidth = options.borderWidth;\n\t\t\t\t\thoverWidth = options.hoverBorderWidth;\n\t\n\t\t\t\t\tmax = borderWidth > max ? borderWidth : max;\n\t\t\t\t\tmax = hoverWidth > max ? hoverWidth : max;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn max;\n\t\t},\n\t\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tsetHoverStyle: function(arc) {\n\t\t\tvar model = arc._model;\n\t\t\tvar options = arc._options;\n\t\t\tvar getHoverColor = helpers$1.getHoverColor;\n\t\n\t\t\tarc.$previousStyle = {\n\t\t\t\tbackgroundColor: model.backgroundColor,\n\t\t\t\tborderColor: model.borderColor,\n\t\t\t\tborderWidth: model.borderWidth,\n\t\t\t};\n\t\n\t\t\tmodel.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n\t\t\tmodel.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));\n\t\t\tmodel.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_resolveElementOptions: function(arc, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar custom = arc.custom || {};\n\t\t\tvar options = chart.options.elements.arc;\n\t\t\tvar values = {};\n\t\t\tvar i, ilen, key;\n\t\n\t\t\t// Scriptable options\n\t\t\tvar context = {\n\t\t\t\tchart: chart,\n\t\t\t\tdataIndex: index,\n\t\t\t\tdataset: dataset,\n\t\t\t\tdatasetIndex: me.index\n\t\t\t};\n\t\n\t\t\tvar keys = [\n\t\t\t\t'backgroundColor',\n\t\t\t\t'borderColor',\n\t\t\t\t'borderWidth',\n\t\t\t\t'borderAlign',\n\t\t\t\t'hoverBackgroundColor',\n\t\t\t\t'hoverBorderColor',\n\t\t\t\t'hoverBorderWidth',\n\t\t\t];\n\t\n\t\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\t\tkey = keys[i];\n\t\t\t\tvalues[key] = resolve$3([\n\t\t\t\t\tcustom[key],\n\t\t\t\t\tdataset[key],\n\t\t\t\t\toptions[key]\n\t\t\t\t], context, index);\n\t\t\t}\n\t\n\t\t\treturn values;\n\t\t},\n\t\n\t\t/**\n\t\t * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly\n\t\t * @private\n\t\t */\n\t\t_getRingWeightOffset: function(datasetIndex) {\n\t\t\tvar ringWeightOffset = 0;\n\t\n\t\t\tfor (var i = 0; i < datasetIndex; ++i) {\n\t\t\t\tif (this.chart.isDatasetVisible(i)) {\n\t\t\t\t\tringWeightOffset += this._getRingWeight(i);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn ringWeightOffset;\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_getRingWeight: function(dataSetIndex) {\n\t\t\treturn Math.max(valueOrDefault$4(this.chart.data.datasets[dataSetIndex].weight, 1), 0);\n\t\t},\n\t\n\t\t/**\n\t\t * Returns the sum of all visibile data set weights.  This value can be 0.\n\t\t * @private\n\t\t */\n\t\t_getVisibleDatasetWeightTotal: function() {\n\t\t\treturn this._getRingWeightOffset(this.chart.data.datasets.length);\n\t\t}\n\t});\n\t\n\tcore_defaults._set('horizontalBar', {\n\t\thover: {\n\t\t\tmode: 'index',\n\t\t\taxis: 'y'\n\t\t},\n\t\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'linear',\n\t\t\t\tposition: 'bottom'\n\t\t\t}],\n\t\n\t\t\tyAxes: [{\n\t\t\t\ttype: 'category',\n\t\t\t\tposition: 'left',\n\t\t\t\tcategoryPercentage: 0.8,\n\t\t\t\tbarPercentage: 0.9,\n\t\t\t\toffset: true,\n\t\t\t\tgridLines: {\n\t\t\t\t\toffsetGridLines: true\n\t\t\t\t}\n\t\t\t}]\n\t\t},\n\t\n\t\telements: {\n\t\t\trectangle: {\n\t\t\t\tborderSkipped: 'left'\n\t\t\t}\n\t\t},\n\t\n\t\ttooltips: {\n\t\t\tmode: 'index',\n\t\t\taxis: 'y'\n\t\t}\n\t});\n\t\n\tvar controller_horizontalBar = controller_bar.extend({\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_getValueScaleId: function() {\n\t\t\treturn this.getMeta().xAxisID;\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_getIndexScaleId: function() {\n\t\t\treturn this.getMeta().yAxisID;\n\t\t}\n\t});\n\t\n\tvar valueOrDefault$5 = helpers$1.valueOrDefault;\n\tvar resolve$4 = helpers$1.options.resolve;\n\tvar isPointInArea = helpers$1.canvas._isPointInArea;\n\t\n\tcore_defaults._set('line', {\n\t\tshowLines: true,\n\t\tspanGaps: false,\n\t\n\t\thover: {\n\t\t\tmode: 'label'\n\t\t},\n\t\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\ttype: 'category',\n\t\t\t\tid: 'x-axis-0'\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\ttype: 'linear',\n\t\t\t\tid: 'y-axis-0'\n\t\t\t}]\n\t\t}\n\t});\n\t\n\tfunction lineEnabled(dataset, options) {\n\t\treturn valueOrDefault$5(dataset.showLine, options.showLines);\n\t}\n\t\n\tvar controller_line = core_datasetController.extend({\n\t\n\t\tdatasetElementType: elements.Line,\n\t\n\t\tdataElementType: elements.Point,\n\t\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data || [];\n\t\t\tvar scale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar showLine = lineEnabled(dataset, me.chart.options);\n\t\t\tvar i, ilen;\n\t\n\t\t\t// Update Line\n\t\t\tif (showLine) {\n\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t\t}\n\t\n\t\t\t\t// Utility\n\t\t\t\tline._scale = scale;\n\t\t\t\tline._datasetIndex = me.index;\n\t\t\t\t// Data\n\t\t\t\tline._children = points;\n\t\t\t\t// Model\n\t\t\t\tline._model = me._resolveLineOptions(line);\n\t\n\t\t\t\tline.pivot();\n\t\t\t}\n\t\n\t\t\t// Update Points\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(points[i], i, reset);\n\t\t\t}\n\t\n\t\t\tif (showLine && line._model.tension !== 0) {\n\t\t\t\tme.updateBezierControlPoints();\n\t\t\t}\n\t\n\t\t\t// Now pivot the point for animation\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tpoints[i].pivot();\n\t\t\t}\n\t\t},\n\t\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar datasetIndex = me.index;\n\t\t\tvar value = dataset.data[index];\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar lineModel = meta.dataset._model;\n\t\t\tvar x, y;\n\t\n\t\t\tvar options = me._resolvePointOptions(point, index);\n\t\n\t\t\tx = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);\n\t\t\ty = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\n\t\n\t\t\t// Utility\n\t\t\tpoint._xScale = xScale;\n\t\t\tpoint._yScale = yScale;\n\t\t\tpoint._options = options;\n\t\t\tpoint._datasetIndex = datasetIndex;\n\t\t\tpoint._index = index;\n\t\n\t\t\t// Desired view properties\n\t\t\tpoint._model = {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\t// Appearance\n\t\t\t\tradius: options.radius,\n\t\t\t\tpointStyle: options.pointStyle,\n\t\t\t\trotation: options.rotation,\n\t\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\t\tborderColor: options.borderColor,\n\t\t\t\tborderWidth: options.borderWidth,\n\t\t\t\ttension: valueOrDefault$5(custom.tension, lineModel ? lineModel.tension : 0),\n\t\t\t\tsteppedLine: lineModel ? lineModel.steppedLine : false,\n\t\t\t\t// Tooltip\n\t\t\t\thitRadius: options.hitRadius\n\t\t\t};\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_resolvePointOptions: function(element, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar dataset = chart.data.datasets[me.index];\n\t\t\tvar custom = element.custom || {};\n\t\t\tvar options = chart.options.elements.point;\n\t\t\tvar values = {};\n\t\t\tvar i, ilen, key;\n\t\n\t\t\t// Scriptable options\n\t\t\tvar context = {\n\t\t\t\tchart: chart,\n\t\t\t\tdataIndex: index,\n\t\t\t\tdataset: dataset,\n\t\t\t\tdatasetIndex: me.index\n\t\t\t};\n\t\n\t\t\tvar ELEMENT_OPTIONS = {\n\t\t\t\tbackgroundColor: 'pointBackgroundColor',\n\t\t\t\tborderColor: 'pointBorderColor',\n\t\t\t\tborderWidth: 'pointBorderWidth',\n\t\t\t\thitRadius: 'pointHitRadius',\n\t\t\t\thoverBackgroundColor: 'pointHoverBackgroundColor',\n\t\t\t\thoverBorderColor: 'pointHoverBorderColor',\n\t\t\t\thoverBorderWidth: 'pointHoverBorderWidth',\n\t\t\t\thoverRadius: 'pointHoverRadius',\n\t\t\t\tpointStyle: 'pointStyle',\n\t\t\t\tradius: 'pointRadius',\n\t\t\t\trotation: 'pointRotation'\n\t\t\t};\n\t\t\tvar keys = Object.keys(ELEMENT_OPTIONS);\n\t\n\t\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\t\tkey = keys[i];\n\t\t\t\tvalues[key] = resolve$4([\n\t\t\t\t\tcustom[key],\n\t\t\t\t\tdataset[ELEMENT_OPTIONS[key]],\n\t\t\t\t\tdataset[key],\n\t\t\t\t\toptions[key]\n\t\t\t\t], context, index);\n\t\t\t}\n\t\n\t\t\treturn values;\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_resolveLineOptions: function(element) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar dataset = chart.data.datasets[me.index];\n\t\t\tvar custom = element.custom || {};\n\t\t\tvar options = chart.options;\n\t\t\tvar elementOptions = options.elements.line;\n\t\t\tvar values = {};\n\t\t\tvar i, ilen, key;\n\t\n\t\t\tvar keys = [\n\t\t\t\t'backgroundColor',\n\t\t\t\t'borderWidth',\n\t\t\t\t'borderColor',\n\t\t\t\t'borderCapStyle',\n\t\t\t\t'borderDash',\n\t\t\t\t'borderDashOffset',\n\t\t\t\t'borderJoinStyle',\n\t\t\t\t'fill',\n\t\t\t\t'cubicInterpolationMode'\n\t\t\t];\n\t\n\t\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\t\tkey = keys[i];\n\t\t\t\tvalues[key] = resolve$4([\n\t\t\t\t\tcustom[key],\n\t\t\t\t\tdataset[key],\n\t\t\t\t\telementOptions[key]\n\t\t\t\t]);\n\t\t\t}\n\t\n\t\t\t// The default behavior of lines is to break at null values, according\n\t\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\n\t\t\t// This option gives lines the ability to span gaps\n\t\t\tvalues.spanGaps = valueOrDefault$5(dataset.spanGaps, options.spanGaps);\n\t\t\tvalues.tension = valueOrDefault$5(dataset.lineTension, elementOptions.tension);\n\t\t\tvalues.steppedLine = resolve$4([custom.steppedLine, dataset.steppedLine, elementOptions.stepped]);\n\t\n\t\t\treturn values;\n\t\t},\n\t\n\t\tcalculatePointY: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar sumPos = 0;\n\t\t\tvar sumNeg = 0;\n\t\t\tvar i, ds, dsMeta;\n\t\n\t\t\tif (yScale.options.stacked) {\n\t\t\t\tfor (i = 0; i < datasetIndex; i++) {\n\t\t\t\t\tds = chart.data.datasets[i];\n\t\t\t\t\tdsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\tif (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n\t\t\t\t\t\tvar stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\n\t\t\t\t\t\tif (stackedRightValue < 0) {\n\t\t\t\t\t\t\tsumNeg += stackedRightValue || 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsumPos += stackedRightValue || 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar rightValue = Number(yScale.getRightValue(value));\n\t\t\t\tif (rightValue < 0) {\n\t\t\t\t\treturn yScale.getPixelForValue(sumNeg + rightValue);\n\t\t\t\t}\n\t\t\t\treturn yScale.getPixelForValue(sumPos + rightValue);\n\t\t\t}\n\t\n\t\t\treturn yScale.getPixelForValue(value);\n\t\t},\n\t\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar lineModel = meta.dataset._model;\n\t\t\tvar area = chart.chartArea;\n\t\t\tvar points = meta.data || [];\n\t\t\tvar i, ilen, model, controlPoints;\n\t\n\t\t\t// Only consider points that are drawn in case the spanGaps option is used\n\t\t\tif (lineModel.spanGaps) {\n\t\t\t\tpoints = points.filter(function(pt) {\n\t\t\t\t\treturn !pt._model.skip;\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tfunction capControlPoint(pt, min, max) {\n\t\t\t\treturn Math.max(Math.min(pt, max), min);\n\t\t\t}\n\t\n\t\t\tif (lineModel.cubicInterpolationMode === 'monotone') {\n\t\t\t\thelpers$1.splineCurveMonotone(points);\n\t\t\t} else {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tmodel = points[i]._model;\n\t\t\t\t\tcontrolPoints = helpers$1.splineCurve(\n\t\t\t\t\t\thelpers$1.previousItem(points, i)._model,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\thelpers$1.nextItem(points, i)._model,\n\t\t\t\t\t\tlineModel.tension\n\t\t\t\t\t);\n\t\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\n\t\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\n\t\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\n\t\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (chart.options.elements.line.capBezierPoints) {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tmodel = points[i]._model;\n\t\t\t\t\tif (isPointInArea(model, area)) {\n\t\t\t\t\t\tif (i > 0 && isPointInArea(points[i - 1]._model, area)) {\n\t\t\t\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n\t\t\t\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {\n\t\t\t\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n\t\t\t\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data || [];\n\t\t\tvar area = chart.chartArea;\n\t\t\tvar ilen = points.length;\n\t\t\tvar halfBorderWidth;\n\t\t\tvar i = 0;\n\t\n\t\t\tif (lineEnabled(me.getDataset(), chart.options)) {\n\t\t\t\thalfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;\n\t\n\t\t\t\thelpers$1.canvas.clipArea(chart.ctx, {\n\t\t\t\t\tleft: area.left,\n\t\t\t\t\tright: area.right,\n\t\t\t\t\ttop: area.top - halfBorderWidth,\n\t\t\t\t\tbottom: area.bottom + halfBorderWidth\n\t\t\t\t});\n\t\n\t\t\t\tmeta.dataset.draw();\n\t\n\t\t\t\thelpers$1.canvas.unclipArea(chart.ctx);\n\t\t\t}\n\t\n\t\t\t// Draw the points\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\tpoints[i].draw(area);\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tsetHoverStyle: function(point) {\n\t\t\tvar model = point._model;\n\t\t\tvar options = point._options;\n\t\t\tvar getHoverColor = helpers$1.getHoverColor;\n\t\n\t\t\tpoint.$previousStyle = {\n\t\t\t\tbackgroundColor: model.backgroundColor,\n\t\t\t\tborderColor: model.borderColor,\n\t\t\t\tborderWidth: model.borderWidth,\n\t\t\t\tradius: model.radius\n\t\t\t};\n\t\n\t\t\tmodel.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n\t\t\tmodel.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));\n\t\t\tmodel.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);\n\t\t\tmodel.radius = valueOrDefault$5(options.hoverRadius, options.radius);\n\t\t},\n\t});\n\t\n\tvar resolve$5 = helpers$1.options.resolve;\n\t\n\tcore_defaults._set('polarArea', {\n\t\tscale: {\n\t\t\ttype: 'radialLinear',\n\t\t\tangleLines: {\n\t\t\t\tdisplay: false\n\t\t\t},\n\t\t\tgridLines: {\n\t\t\t\tcircular: true\n\t\t\t},\n\t\t\tpointLabels: {\n\t\t\t\tdisplay: false\n\t\t\t},\n\t\t\tticks: {\n\t\t\t\tbeginAtZero: true\n\t\t\t}\n\t\t},\n\t\n\t\t// Boolean - Whether to animate the rotation of the chart\n\t\tanimation: {\n\t\t\tanimateRotate: true,\n\t\t\tanimateScale: true\n\t\t},\n\t\n\t\tstartAngle: -0.5 * Math.PI,\n\t\tlegendCallback: function(chart) {\n\t\t\tvar text = [];\n\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar labels = data.labels;\n\t\n\t\t\tif (datasets.length) {\n\t\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\t\tif (labels[i]) {\n\t\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t\t}\n\t\t\t\t\ttext.push('</li>');\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\ttext.push('</ul>');\n\t\t\treturn text.join('');\n\t\t},\n\t\tlegend: {\n\t\t\tlabels: {\n\t\t\t\tgenerateLabels: function(chart) {\n\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\t\tvar custom = arc.custom || {};\n\t\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\t\tvar fill = resolve$5([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);\n\t\t\t\t\t\t\tvar stroke = resolve$5([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);\n\t\t\t\t\t\t\tvar bw = resolve$5([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);\n\t\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\t\n\t\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\tonClick: function(e, legendItem) {\n\t\t\t\tvar index = legendItem.index;\n\t\t\t\tvar chart = this.chart;\n\t\t\t\tvar i, ilen, meta;\n\t\n\t\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t}\n\t\n\t\t\t\tchart.update();\n\t\t\t}\n\t\t},\n\t\n\t\t// Need to override these to give a nice default\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function() {\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\tlabel: function(item, data) {\n\t\t\t\t\treturn data.labels[item.index] + ': ' + item.yLabel;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar controller_polarArea = core_datasetController.extend({\n\t\n\t\tdataElementType: elements.Arc,\n\t\n\t\tlinkScales: helpers$1.noop,\n\t\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar start = me.chart.options.startAngle || 0;\n\t\t\tvar starts = me._starts = [];\n\t\t\tvar angles = me._angles = [];\n\t\t\tvar arcs = meta.data;\n\t\t\tvar i, ilen, angle;\n\t\n\t\t\tme._updateRadius();\n\t\n\t\t\tmeta.count = me.countVisibleElements();\n\t\n\t\t\tfor (i = 0, ilen = dataset.data.length; i < ilen; i++) {\n\t\t\t\tstarts[i] = start;\n\t\t\t\tangle = me._computeAngle(i);\n\t\t\t\tangles[i] = angle;\n\t\t\t\tstart += angle;\n\t\t\t}\n\t\n\t\t\tfor (i = 0, ilen = arcs.length; i < ilen; ++i) {\n\t\t\t\tarcs[i]._options = me._resolveElementOptions(arcs[i], i);\n\t\t\t\tme.updateElement(arcs[i], i, reset);\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_updateRadius: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar chartArea = chart.chartArea;\n\t\t\tvar opts = chart.options;\n\t\t\tvar minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\t\n\t\t\tchart.outerRadius = Math.max(minSize / 2, 0);\n\t\t\tchart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n\t\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\t\n\t\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);\n\t\t\tme.innerRadius = me.outerRadius - chart.radiusLength;\n\t\t},\n\t\n\t\tupdateElement: function(arc, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar opts = chart.options;\n\t\t\tvar animationOpts = opts.animation;\n\t\t\tvar scale = chart.scale;\n\t\t\tvar labels = chart.data.labels;\n\t\n\t\t\tvar centerX = scale.xCenter;\n\t\t\tvar centerY = scale.yCenter;\n\t\n\t\t\t// var negHalfPI = -0.5 * Math.PI;\n\t\t\tvar datasetStartAngle = opts.startAngle;\n\t\t\tvar distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\t\t\tvar startAngle = me._starts[index];\n\t\t\tvar endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);\n\t\n\t\t\tvar resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\t\t\tvar options = arc._options || {};\n\t\n\t\t\thelpers$1.extend(arc, {\n\t\t\t\t// Utility\n\t\t\t\t_datasetIndex: me.index,\n\t\t\t\t_index: index,\n\t\t\t\t_scale: scale,\n\t\n\t\t\t\t// Desired view properties\n\t\t\t\t_model: {\n\t\t\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\t\t\tborderColor: options.borderColor,\n\t\t\t\t\tborderWidth: options.borderWidth,\n\t\t\t\t\tborderAlign: options.borderAlign,\n\t\t\t\t\tx: centerX,\n\t\t\t\t\ty: centerY,\n\t\t\t\t\tinnerRadius: 0,\n\t\t\t\t\touterRadius: reset ? resetRadius : distance,\n\t\t\t\t\tstartAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\n\t\t\t\t\tendAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\n\t\t\t\t\tlabel: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tarc.pivot();\n\t\t},\n\t\n\t\tcountVisibleElements: function() {\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar meta = this.getMeta();\n\t\t\tvar count = 0;\n\t\n\t\t\thelpers$1.each(meta.data, function(element, index) {\n\t\t\t\tif (!isNaN(dataset.data[index]) && !element.hidden) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\treturn count;\n\t\t},\n\t\n\t\t/**\n\t\t * @protected\n\t\t */\n\t\tsetHoverStyle: function(arc) {\n\t\t\tvar model = arc._model;\n\t\t\tvar options = arc._options;\n\t\t\tvar getHoverColor = helpers$1.getHoverColor;\n\t\t\tvar valueOrDefault = helpers$1.valueOrDefault;\n\t\n\t\t\tarc.$previousStyle = {\n\t\t\t\tbackgroundColor: model.backgroundColor,\n\t\t\t\tborderColor: model.borderColor,\n\t\t\t\tborderWidth: model.borderWidth,\n\t\t\t};\n\t\n\t\t\tmodel.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n\t\t\tmodel.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));\n\t\t\tmodel.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_resolveElementOptions: function(arc, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar custom = arc.custom || {};\n\t\t\tvar options = chart.options.elements.arc;\n\t\t\tvar values = {};\n\t\t\tvar i, ilen, key;\n\t\n\t\t\t// Scriptable options\n\t\t\tvar context = {\n\t\t\t\tchart: chart,\n\t\t\t\tdataIndex: index,\n\t\t\t\tdataset: dataset,\n\t\t\t\tdatasetIndex: me.index\n\t\t\t};\n\t\n\t\t\tvar keys = [\n\t\t\t\t'backgroundColor',\n\t\t\t\t'borderColor',\n\t\t\t\t'borderWidth',\n\t\t\t\t'borderAlign',\n\t\t\t\t'hoverBackgroundColor',\n\t\t\t\t'hoverBorderColor',\n\t\t\t\t'hoverBorderWidth',\n\t\t\t];\n\t\n\t\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\t\tkey = keys[i];\n\t\t\t\tvalues[key] = resolve$5([\n\t\t\t\t\tcustom[key],\n\t\t\t\t\tdataset[key],\n\t\t\t\t\toptions[key]\n\t\t\t\t], context, index);\n\t\t\t}\n\t\n\t\t\treturn values;\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_computeAngle: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar count = this.getMeta().count;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar meta = me.getMeta();\n\t\n\t\t\tif (isNaN(dataset.data[index]) || meta.data[index].hidden) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\t// Scriptable options\n\t\t\tvar context = {\n\t\t\t\tchart: me.chart,\n\t\t\t\tdataIndex: index,\n\t\t\t\tdataset: dataset,\n\t\t\t\tdatasetIndex: me.index\n\t\t\t};\n\t\n\t\t\treturn resolve$5([\n\t\t\t\tme.chart.options.elements.arc.angle,\n\t\t\t\t(2 * Math.PI) / count\n\t\t\t], context, index);\n\t\t}\n\t});\n\t\n\tcore_defaults._set('pie', helpers$1.clone(core_defaults.doughnut));\n\tcore_defaults._set('pie', {\n\t\tcutoutPercentage: 0\n\t});\n\t\n\t// Pie charts are Doughnut chart with different defaults\n\tvar controller_pie = controller_doughnut;\n\t\n\tvar valueOrDefault$6 = helpers$1.valueOrDefault;\n\tvar resolve$6 = helpers$1.options.resolve;\n\t\n\tcore_defaults._set('radar', {\n\t\tscale: {\n\t\t\ttype: 'radialLinear'\n\t\t},\n\t\telements: {\n\t\t\tline: {\n\t\t\t\ttension: 0 // no bezier in radar\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar controller_radar = core_datasetController.extend({\n\t\n\t\tdatasetElementType: elements.Line,\n\t\n\t\tdataElementType: elements.Point,\n\t\n\t\tlinkScales: helpers$1.noop,\n\t\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data || [];\n\t\t\tvar scale = me.chart.scale;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar i, ilen;\n\t\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t}\n\t\n\t\t\t// Utility\n\t\t\tline._scale = scale;\n\t\t\tline._datasetIndex = me.index;\n\t\t\t// Data\n\t\t\tline._children = points;\n\t\t\tline._loop = true;\n\t\t\t// Model\n\t\t\tline._model = me._resolveLineOptions(line);\n\t\n\t\t\tline.pivot();\n\t\n\t\t\t// Update Points\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(points[i], i, reset);\n\t\t\t}\n\t\n\t\t\t// Update bezier control points\n\t\t\tme.updateBezierControlPoints();\n\t\n\t\t\t// Now pivot the point for animation\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tpoints[i].pivot();\n\t\t\t}\n\t\t},\n\t\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar scale = me.chart.scale;\n\t\t\tvar pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\n\t\t\tvar options = me._resolvePointOptions(point, index);\n\t\t\tvar lineModel = me.getMeta().dataset._model;\n\t\t\tvar x = reset ? scale.xCenter : pointPosition.x;\n\t\t\tvar y = reset ? scale.yCenter : pointPosition.y;\n\t\n\t\t\t// Utility\n\t\t\tpoint._scale = scale;\n\t\t\tpoint._options = options;\n\t\t\tpoint._datasetIndex = me.index;\n\t\t\tpoint._index = index;\n\t\n\t\t\t// Desired view properties\n\t\t\tpoint._model = {\n\t\t\t\tx: x, // value not used in dataset scale, but we want a consistent API between scales\n\t\t\t\ty: y,\n\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\t// Appearance\n\t\t\t\tradius: options.radius,\n\t\t\t\tpointStyle: options.pointStyle,\n\t\t\t\trotation: options.rotation,\n\t\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\t\tborderColor: options.borderColor,\n\t\t\t\tborderWidth: options.borderWidth,\n\t\t\t\ttension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),\n\t\n\t\t\t\t// Tooltip\n\t\t\t\thitRadius: options.hitRadius\n\t\t\t};\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_resolvePointOptions: function(element, index) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar dataset = chart.data.datasets[me.index];\n\t\t\tvar custom = element.custom || {};\n\t\t\tvar options = chart.options.elements.point;\n\t\t\tvar values = {};\n\t\t\tvar i, ilen, key;\n\t\n\t\t\t// Scriptable options\n\t\t\tvar context = {\n\t\t\t\tchart: chart,\n\t\t\t\tdataIndex: index,\n\t\t\t\tdataset: dataset,\n\t\t\t\tdatasetIndex: me.index\n\t\t\t};\n\t\n\t\t\tvar ELEMENT_OPTIONS = {\n\t\t\t\tbackgroundColor: 'pointBackgroundColor',\n\t\t\t\tborderColor: 'pointBorderColor',\n\t\t\t\tborderWidth: 'pointBorderWidth',\n\t\t\t\thitRadius: 'pointHitRadius',\n\t\t\t\thoverBackgroundColor: 'pointHoverBackgroundColor',\n\t\t\t\thoverBorderColor: 'pointHoverBorderColor',\n\t\t\t\thoverBorderWidth: 'pointHoverBorderWidth',\n\t\t\t\thoverRadius: 'pointHoverRadius',\n\t\t\t\tpointStyle: 'pointStyle',\n\t\t\t\tradius: 'pointRadius',\n\t\t\t\trotation: 'pointRotation'\n\t\t\t};\n\t\t\tvar keys = Object.keys(ELEMENT_OPTIONS);\n\t\n\t\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\t\tkey = keys[i];\n\t\t\t\tvalues[key] = resolve$6([\n\t\t\t\t\tcustom[key],\n\t\t\t\t\tdataset[ELEMENT_OPTIONS[key]],\n\t\t\t\t\tdataset[key],\n\t\t\t\t\toptions[key]\n\t\t\t\t], context, index);\n\t\t\t}\n\t\n\t\t\treturn values;\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_resolveLineOptions: function(element) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar dataset = chart.data.datasets[me.index];\n\t\t\tvar custom = element.custom || {};\n\t\t\tvar options = chart.options.elements.line;\n\t\t\tvar values = {};\n\t\t\tvar i, ilen, key;\n\t\n\t\t\tvar keys = [\n\t\t\t\t'backgroundColor',\n\t\t\t\t'borderWidth',\n\t\t\t\t'borderColor',\n\t\t\t\t'borderCapStyle',\n\t\t\t\t'borderDash',\n\t\t\t\t'borderDashOffset',\n\t\t\t\t'borderJoinStyle',\n\t\t\t\t'fill'\n\t\t\t];\n\t\n\t\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\t\tkey = keys[i];\n\t\t\t\tvalues[key] = resolve$6([\n\t\t\t\t\tcustom[key],\n\t\t\t\t\tdataset[key],\n\t\t\t\t\toptions[key]\n\t\t\t\t]);\n\t\t\t}\n\t\n\t\t\tvalues.tension = valueOrDefault$6(dataset.lineTension, options.tension);\n\t\n\t\t\treturn values;\n\t\t},\n\t\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar area = me.chart.chartArea;\n\t\t\tvar points = meta.data || [];\n\t\t\tvar i, ilen, model, controlPoints;\n\t\n\t\t\tfunction capControlPoint(pt, min, max) {\n\t\t\t\treturn Math.max(Math.min(pt, max), min);\n\t\t\t}\n\t\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tmodel = points[i]._model;\n\t\t\t\tcontrolPoints = helpers$1.splineCurve(\n\t\t\t\t\thelpers$1.previousItem(points, i, true)._model,\n\t\t\t\t\tmodel,\n\t\t\t\t\thelpers$1.nextItem(points, i, true)._model,\n\t\t\t\t\tmodel.tension\n\t\t\t\t);\n\t\n\t\t\t\t// Prevent the bezier going outside of the bounds of the graph\n\t\t\t\tmodel.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);\n\t\t\t\tmodel.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);\n\t\t\t\tmodel.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);\n\t\t\t\tmodel.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);\n\t\t\t}\n\t\t},\n\t\n\t\tsetHoverStyle: function(point) {\n\t\t\tvar model = point._model;\n\t\t\tvar options = point._options;\n\t\t\tvar getHoverColor = helpers$1.getHoverColor;\n\t\n\t\t\tpoint.$previousStyle = {\n\t\t\t\tbackgroundColor: model.backgroundColor,\n\t\t\t\tborderColor: model.borderColor,\n\t\t\t\tborderWidth: model.borderWidth,\n\t\t\t\tradius: model.radius\n\t\t\t};\n\t\n\t\t\tmodel.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n\t\t\tmodel.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));\n\t\t\tmodel.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);\n\t\t\tmodel.radius = valueOrDefault$6(options.hoverRadius, options.radius);\n\t\t}\n\t});\n\t\n\tcore_defaults._set('scatter', {\n\t\thover: {\n\t\t\tmode: 'single'\n\t\t},\n\t\n\t\tscales: {\n\t\t\txAxes: [{\n\t\t\t\tid: 'x-axis-1',    // need an ID so datasets can reference the scale\n\t\t\t\ttype: 'linear',    // scatter should not use a category axis\n\t\t\t\tposition: 'bottom'\n\t\t\t}],\n\t\t\tyAxes: [{\n\t\t\t\tid: 'y-axis-1',\n\t\t\t\ttype: 'linear',\n\t\t\t\tposition: 'left'\n\t\t\t}]\n\t\t},\n\t\n\t\tshowLines: false,\n\t\n\t\ttooltips: {\n\t\t\tcallbacks: {\n\t\t\t\ttitle: function() {\n\t\t\t\t\treturn '';     // doesn't make sense for scatter since data are formatted as a point\n\t\t\t\t},\n\t\t\t\tlabel: function(item) {\n\t\t\t\t\treturn '(' + item.xLabel + ', ' + item.yLabel + ')';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\t\n\t// Scatter charts use line controllers\n\tvar controller_scatter = controller_line;\n\t\n\t// NOTE export a map in which the key represents the controller type, not\n\t// the class, and so must be CamelCase in order to be correctly retrieved\n\t// by the controller in core.controller.js (`controllers[meta.type]`).\n\t\n\tvar controllers = {\n\t\tbar: controller_bar,\n\t\tbubble: controller_bubble,\n\t\tdoughnut: controller_doughnut,\n\t\thorizontalBar: controller_horizontalBar,\n\t\tline: controller_line,\n\t\tpolarArea: controller_polarArea,\n\t\tpie: controller_pie,\n\t\tradar: controller_radar,\n\t\tscatter: controller_scatter\n\t};\n\t\n\t/**\n\t * Helper function to get relative position for an event\n\t * @param {Event|IEvent} event - The event to get the position for\n\t * @param {Chart} chart - The chart\n\t * @returns {object} the event position\n\t */\n\tfunction getRelativePosition(e, chart) {\n\t\tif (e.native) {\n\t\t\treturn {\n\t\t\t\tx: e.x,\n\t\t\t\ty: e.y\n\t\t\t};\n\t\t}\n\t\n\t\treturn helpers$1.getRelativePosition(e, chart);\n\t}\n\t\n\t/**\n\t * Helper function to traverse all of the visible elements in the chart\n\t * @param {Chart} chart - the chart\n\t * @param {function} handler - the callback to execute for each visible item\n\t */\n\tfunction parseVisibleItems(chart, handler) {\n\t\tvar datasets = chart.data.datasets;\n\t\tvar meta, i, j, ilen, jlen;\n\t\n\t\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\n\t\t\tif (!chart.isDatasetVisible(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\tfor (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n\t\t\t\tvar element = meta.data[j];\n\t\t\t\tif (!element._view.skip) {\n\t\t\t\t\thandler(element);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Helper function to get the items that intersect the event position\n\t * @param {ChartElement[]} items - elements to filter\n\t * @param {object} position - the point to be nearest to\n\t * @return {ChartElement[]} the nearest items\n\t */\n\tfunction getIntersectItems(chart, position) {\n\t\tvar elements = [];\n\t\n\t\tparseVisibleItems(chart, function(element) {\n\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\telements.push(element);\n\t\t\t}\n\t\t});\n\t\n\t\treturn elements;\n\t}\n\t\n\t/**\n\t * Helper function to get the items nearest to the event position considering all visible items in teh chart\n\t * @param {Chart} chart - the chart to look at elements from\n\t * @param {object} position - the point to be nearest to\n\t * @param {boolean} intersect - if true, only consider items that intersect the position\n\t * @param {function} distanceMetric - function to provide the distance between points\n\t * @return {ChartElement[]} the nearest items\n\t */\n\tfunction getNearestItems(chart, position, intersect, distanceMetric) {\n\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\tvar nearestItems = [];\n\t\n\t\tparseVisibleItems(chart, function(element) {\n\t\t\tif (intersect && !element.inRange(position.x, position.y)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar center = element.getCenterPoint();\n\t\t\tvar distance = distanceMetric(position, center);\n\t\t\tif (distance < minDistance) {\n\t\t\t\tnearestItems = [element];\n\t\t\t\tminDistance = distance;\n\t\t\t} else if (distance === minDistance) {\n\t\t\t\t// Can have multiple items at the same distance in which case we sort by size\n\t\t\t\tnearestItems.push(element);\n\t\t\t}\n\t\t});\n\t\n\t\treturn nearestItems;\n\t}\n\t\n\t/**\n\t * Get a distance metric function for two points based on the\n\t * axis mode setting\n\t * @param {string} axis - the axis mode. x|y|xy\n\t */\n\tfunction getDistanceMetricForAxis(axis) {\n\t\tvar useX = axis.indexOf('x') !== -1;\n\t\tvar useY = axis.indexOf('y') !== -1;\n\t\n\t\treturn function(pt1, pt2) {\n\t\t\tvar deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n\t\t\tvar deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n\t\t\treturn Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n\t\t};\n\t}\n\t\n\tfunction indexMode(chart, e, options) {\n\t\tvar position = getRelativePosition(e, chart);\n\t\t// Default axis for index mode is 'x' to match old behaviour\n\t\toptions.axis = options.axis || 'x';\n\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\t\tvar elements = [];\n\t\n\t\tif (!items.length) {\n\t\t\treturn [];\n\t\t}\n\t\n\t\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\n\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\tvar element = meta.data[items[0]._index];\n\t\n\t\t\t\t// don't count items that are skipped (null data)\n\t\t\t\tif (element && !element._view.skip) {\n\t\t\t\t\telements.push(element);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\n\t\treturn elements;\n\t}\n\t\n\t/**\n\t * @interface IInteractionOptions\n\t */\n\t/**\n\t * If true, only consider items that intersect the point\n\t * @name IInterfaceOptions#boolean\n\t * @type Boolean\n\t */\n\t\n\t/**\n\t * Contains interaction related functions\n\t * @namespace Chart.Interaction\n\t */\n\tvar core_interaction = {\n\t\t// Helper function for different modes\n\t\tmodes: {\n\t\t\tsingle: function(chart, e) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\tvar elements = [];\n\t\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\telements.push(element);\n\t\t\t\t\t\treturn elements;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\treturn elements.slice(0, 1);\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * @function Chart.Interaction.modes.label\n\t\t\t * @deprecated since version 2.4.0\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tlabel: indexMode,\n\t\n\t\t\t/**\n\t\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t\t * @function Chart.Interaction.modes.index\n\t\t\t * @since v2.4.0\n\t\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t\t * @param {Event} e - the event we are find things at\n\t\t\t * @param {IInteractionOptions} options - options to use during interaction\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tindex: indexMode,\n\t\n\t\t\t/**\n\t\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t\t * @function Chart.Interaction.modes.dataset\n\t\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t\t * @param {Event} e - the event we are find things at\n\t\t\t * @param {IInteractionOptions} options - options to use during interaction\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tdataset: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\toptions.axis = options.axis || 'xy';\n\t\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\t\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\t\n\t\t\t\tif (items.length > 0) {\n\t\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\n\t\t\t\t}\n\t\n\t\t\t\treturn items;\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * @function Chart.Interaction.modes.x-axis\n\t\t\t * @deprecated since version 2.4.0. Use index mode and intersect == true\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\t'x-axis': function(chart, e) {\n\t\t\t\treturn indexMode(chart, e, {intersect: false});\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Point mode returns all elements that hit test based on the event position\n\t\t\t * of the event\n\t\t\t * @function Chart.Interaction.modes.intersect\n\t\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t\t * @param {Event} e - the event we are find things at\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tpoint: function(chart, e) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\treturn getIntersectItems(chart, position);\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * nearest mode returns the element closest to the point\n\t\t\t * @function Chart.Interaction.modes.intersect\n\t\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t\t * @param {Event} e - the event we are find things at\n\t\t\t * @param {IInteractionOptions} options - options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tnearest: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\toptions.axis = options.axis || 'xy';\n\t\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\t\t\t\treturn getNearestItems(chart, position, options.intersect, distanceMetric);\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t\t * @function Chart.Interaction.modes.x\n\t\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t\t * @param {Event} e - the event we are find things at\n\t\t\t * @param {IInteractionOptions} options - options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\tx: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\tvar items = [];\n\t\t\t\tvar intersectsItem = false;\n\t\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inXRange(position.x)) {\n\t\t\t\t\t\titems.push(element);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\tintersectsItem = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t\t// that intersect the position, return nothing\n\t\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\t\titems = [];\n\t\t\t\t}\n\t\t\t\treturn items;\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t\t * @function Chart.Interaction.modes.y\n\t\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t\t * @param {Event} e - the event we are find things at\n\t\t\t * @param {IInteractionOptions} options - options to use\n\t\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t\t */\n\t\t\ty: function(chart, e, options) {\n\t\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\t\tvar items = [];\n\t\t\t\tvar intersectsItem = false;\n\t\n\t\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\t\tif (element.inYRange(position.y)) {\n\t\t\t\t\t\titems.push(element);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\t\tintersectsItem = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t\t// that intersect the position, return nothing\n\t\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\t\titems = [];\n\t\t\t\t}\n\t\t\t\treturn items;\n\t\t\t}\n\t\t}\n\t};\n\t\n\tfunction filterByPosition(array, position) {\n\t\treturn helpers$1.where(array, function(v) {\n\t\t\treturn v.position === position;\n\t\t});\n\t}\n\t\n\tfunction sortByWeight(array, reverse) {\n\t\tarray.forEach(function(v, i) {\n\t\t\tv._tmpIndex_ = i;\n\t\t\treturn v;\n\t\t});\n\t\tarray.sort(function(a, b) {\n\t\t\tvar v0 = reverse ? b : a;\n\t\t\tvar v1 = reverse ? a : b;\n\t\t\treturn v0.weight === v1.weight ?\n\t\t\t\tv0._tmpIndex_ - v1._tmpIndex_ :\n\t\t\t\tv0.weight - v1.weight;\n\t\t});\n\t\tarray.forEach(function(v) {\n\t\t\tdelete v._tmpIndex_;\n\t\t});\n\t}\n\t\n\tfunction findMaxPadding(boxes) {\n\t\tvar top = 0;\n\t\tvar left = 0;\n\t\tvar bottom = 0;\n\t\tvar right = 0;\n\t\thelpers$1.each(boxes, function(box) {\n\t\t\tif (box.getPadding) {\n\t\t\t\tvar boxPadding = box.getPadding();\n\t\t\t\ttop = Math.max(top, boxPadding.top);\n\t\t\t\tleft = Math.max(left, boxPadding.left);\n\t\t\t\tbottom = Math.max(bottom, boxPadding.bottom);\n\t\t\t\tright = Math.max(right, boxPadding.right);\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\ttop: top,\n\t\t\tleft: left,\n\t\t\tbottom: bottom,\n\t\t\tright: right\n\t\t};\n\t}\n\t\n\tfunction addSizeByPosition(boxes, size) {\n\t\thelpers$1.each(boxes, function(box) {\n\t\t\tsize[box.position] += box.isHorizontal() ? box.height : box.width;\n\t\t});\n\t}\n\t\n\tcore_defaults._set('global', {\n\t\tlayout: {\n\t\t\tpadding: {\n\t\t\t\ttop: 0,\n\t\t\t\tright: 0,\n\t\t\t\tbottom: 0,\n\t\t\t\tleft: 0\n\t\t\t}\n\t\t}\n\t});\n\t\n\t/**\n\t * @interface ILayoutItem\n\t * @prop {string} position - The position of the item in the chart layout. Possible values are\n\t * 'left', 'top', 'right', 'bottom', and 'chartArea'\n\t * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n\t * @prop {boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down\n\t * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n\t * @prop {function} update - Takes two parameters: width and height. Returns size of item\n\t * @prop {function} getPadding -  Returns an object with padding on the edges\n\t * @prop {number} width - Width of item. Must be valid after update()\n\t * @prop {number} height - Height of item. Must be valid after update()\n\t * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update\n\t * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update\n\t * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update\n\t * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n\t */\n\t\n\t// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n\t// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n\t// It is this service's responsibility of carrying out that layout.\n\tvar core_layouts = {\n\t\tdefaults: {},\n\t\n\t\t/**\n\t\t * Register a box to a chart.\n\t\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t\t * @param {Chart} chart - the chart to use\n\t\t * @param {ILayoutItem} item - the item to add to be layed out\n\t\t */\n\t\taddBox: function(chart, item) {\n\t\t\tif (!chart.boxes) {\n\t\t\t\tchart.boxes = [];\n\t\t\t}\n\t\n\t\t\t// initialize item with default values\n\t\t\titem.fullWidth = item.fullWidth || false;\n\t\t\titem.position = item.position || 'top';\n\t\t\titem.weight = item.weight || 0;\n\t\n\t\t\tchart.boxes.push(item);\n\t\t},\n\t\n\t\t/**\n\t\t * Remove a layoutItem from a chart\n\t\t * @param {Chart} chart - the chart to remove the box from\n\t\t * @param {ILayoutItem} layoutItem - the item to remove from the layout\n\t\t */\n\t\tremoveBox: function(chart, layoutItem) {\n\t\t\tvar index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n\t\t\tif (index !== -1) {\n\t\t\t\tchart.boxes.splice(index, 1);\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * Sets (or updates) options on the given `item`.\n\t\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t\t * @param {ILayoutItem} item - the item to configure with the given options\n\t\t * @param {object} options - the new item options.\n\t\t */\n\t\tconfigure: function(chart, item, options) {\n\t\t\tvar props = ['fullWidth', 'position', 'weight'];\n\t\t\tvar ilen = props.length;\n\t\t\tvar i = 0;\n\t\t\tvar prop;\n\t\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\tprop = props[i];\n\t\t\t\tif (options.hasOwnProperty(prop)) {\n\t\t\t\t\titem[prop] = options[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t\t * then running a fitting algorithm\n\t\t * @param {Chart} chart - the chart\n\t\t * @param {number} width - the width to fit into\n\t\t * @param {number} height - the height to fit into\n\t\t */\n\t\tupdate: function(chart, width, height) {\n\t\t\tif (!chart) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar layoutOptions = chart.options.layout || {};\n\t\t\tvar padding = helpers$1.options.toPadding(layoutOptions.padding);\n\t\t\tvar leftPadding = padding.left;\n\t\t\tvar rightPadding = padding.right;\n\t\t\tvar topPadding = padding.top;\n\t\t\tvar bottomPadding = padding.bottom;\n\t\n\t\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\n\t\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\n\t\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\n\t\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\n\t\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\n\t\n\t\t\t// Sort boxes by weight. A higher weight is further away from the chart area\n\t\t\tsortByWeight(leftBoxes, true);\n\t\t\tsortByWeight(rightBoxes, false);\n\t\t\tsortByWeight(topBoxes, true);\n\t\t\tsortByWeight(bottomBoxes, false);\n\t\n\t\t\tvar verticalBoxes = leftBoxes.concat(rightBoxes);\n\t\t\tvar horizontalBoxes = topBoxes.concat(bottomBoxes);\n\t\t\tvar outerBoxes = verticalBoxes.concat(horizontalBoxes);\n\t\n\t\t\t// Essentially we now have any number of boxes on each of the 4 sides.\n\t\t\t// Our canvas looks like the following.\n\t\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n\t\t\t// B1 is the bottom axis\n\t\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n\t\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n\t\t\t// an error will be thrown.\n\t\t\t//\n\t\t\t// |----------------------------------------------------|\n\t\t\t// |                  T1 (Full Width)                   |\n\t\t\t// |----------------------------------------------------|\n\t\t\t// |    |    |                 T2                  |    |\n\t\t\t// |    |----|-------------------------------------|----|\n\t\t\t// |    |    | C1 |                           | C2 |    |\n\t\t\t// |    |    |----|                           |----|    |\n\t\t\t// |    |    |                                     |    |\n\t\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\n\t\t\t// |    |    |                                     |    |\n\t\t\t// |    |    |----|                           |----|    |\n\t\t\t// |    |    | C3 |                           | C4 |    |\n\t\t\t// |    |----|-------------------------------------|----|\n\t\t\t// |    |    |                 B1                  |    |\n\t\t\t// |----------------------------------------------------|\n\t\t\t// |                  B2 (Full Width)                   |\n\t\t\t// |----------------------------------------------------|\n\t\t\t//\n\t\t\t// What we do to find the best sizing, we do the following\n\t\t\t// 1. Determine the minimum size of the chart area.\n\t\t\t// 2. Split the remaining width equally between each vertical axis\n\t\t\t// 3. Split the remaining height equally between each horizontal axis\n\t\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n\t\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\n\t\t\t// 6. Refit each axis\n\t\t\t// 7. Position each axis in the final location\n\t\t\t// 8. Tell the chart the final location of the chart area\n\t\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\n\t\n\t\t\t// Step 1\n\t\t\tvar chartWidth = width - leftPadding - rightPadding;\n\t\t\tvar chartHeight = height - topPadding - bottomPadding;\n\t\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\n\t\n\t\t\t// Step 2\n\t\t\tvar verticalBoxWidth = (width - chartAreaWidth) / verticalBoxes.length;\n\t\n\t\t\t// Step 3\n\t\t\t// TODO re-limit horizontal axis height (this limit has affected only padding calculation since PR 1837)\n\t\t\t// var horizontalBoxHeight = (height - chartAreaHeight) / horizontalBoxes.length;\n\t\n\t\t\t// Step 4\n\t\t\tvar maxChartAreaWidth = chartWidth;\n\t\t\tvar maxChartAreaHeight = chartHeight;\n\t\t\tvar outerBoxSizes = {top: topPadding, left: leftPadding, bottom: bottomPadding, right: rightPadding};\n\t\t\tvar minBoxSizes = [];\n\t\t\tvar maxPadding;\n\t\n\t\t\tfunction getMinimumBoxSize(box) {\n\t\t\t\tvar minSize;\n\t\t\t\tvar isHorizontal = box.isHorizontal();\n\t\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2);\n\t\t\t\t\tmaxChartAreaHeight -= minSize.height;\n\t\t\t\t} else {\n\t\t\t\t\tminSize = box.update(verticalBoxWidth, maxChartAreaHeight);\n\t\t\t\t\tmaxChartAreaWidth -= minSize.width;\n\t\t\t\t}\n\t\n\t\t\t\tminBoxSizes.push({\n\t\t\t\t\thorizontal: isHorizontal,\n\t\t\t\t\twidth: minSize.width,\n\t\t\t\t\tbox: box,\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\thelpers$1.each(outerBoxes, getMinimumBoxSize);\n\t\n\t\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\n\t\t\tmaxPadding = findMaxPadding(outerBoxes);\n\t\n\t\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n\t\t\t// be if the axes are drawn at their minimum sizes.\n\t\t\t// Steps 5 & 6\n\t\n\t\t\t// Function to fit a box\n\t\t\tfunction fitBox(box) {\n\t\t\t\tvar minBoxSize = helpers$1.findNextWhere(minBoxSizes, function(minBox) {\n\t\t\t\t\treturn minBox.box === box;\n\t\t\t\t});\n\t\n\t\t\t\tif (minBoxSize) {\n\t\t\t\t\tif (minBoxSize.horizontal) {\n\t\t\t\t\t\tvar scaleMargin = {\n\t\t\t\t\t\t\tleft: Math.max(outerBoxSizes.left, maxPadding.left),\n\t\t\t\t\t\t\tright: Math.max(outerBoxSizes.right, maxPadding.right),\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\tbottom: 0\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n\t\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\n\t\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbox.update(minBoxSize.width, maxChartAreaHeight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Update, and calculate the left and right margins for the horizontal boxes\n\t\t\thelpers$1.each(verticalBoxes, fitBox);\n\t\t\taddSizeByPosition(verticalBoxes, outerBoxSizes);\n\t\n\t\t\t// Set the Left and Right margins for the horizontal boxes\n\t\t\thelpers$1.each(horizontalBoxes, fitBox);\n\t\t\taddSizeByPosition(horizontalBoxes, outerBoxSizes);\n\t\n\t\t\tfunction finalFitVerticalBox(box) {\n\t\t\t\tvar minBoxSize = helpers$1.findNextWhere(minBoxSizes, function(minSize) {\n\t\t\t\t\treturn minSize.box === box;\n\t\t\t\t});\n\t\n\t\t\t\tvar scaleMargin = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tright: 0,\n\t\t\t\t\ttop: outerBoxSizes.top,\n\t\t\t\t\tbottom: outerBoxSizes.bottom\n\t\t\t\t};\n\t\n\t\t\t\tif (minBoxSize) {\n\t\t\t\t\tbox.update(minBoxSize.width, maxChartAreaHeight, scaleMargin);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Let the left layout know the final margin\n\t\t\thelpers$1.each(verticalBoxes, finalFitVerticalBox);\n\t\n\t\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n\t\t\touterBoxSizes = {top: topPadding, left: leftPadding, bottom: bottomPadding, right: rightPadding};\n\t\t\taddSizeByPosition(outerBoxes, outerBoxSizes);\n\t\n\t\t\t// We may be adding some padding to account for rotated x axis labels\n\t\t\tvar leftPaddingAddition = Math.max(maxPadding.left - outerBoxSizes.left, 0);\n\t\t\touterBoxSizes.left += leftPaddingAddition;\n\t\t\touterBoxSizes.right += Math.max(maxPadding.right - outerBoxSizes.right, 0);\n\t\n\t\t\tvar topPaddingAddition = Math.max(maxPadding.top - outerBoxSizes.top, 0);\n\t\t\touterBoxSizes.top += topPaddingAddition;\n\t\t\touterBoxSizes.bottom += Math.max(maxPadding.bottom - outerBoxSizes.bottom, 0);\n\t\n\t\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\n\t\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n\t\t\t// without calling `fit` again\n\t\t\tvar newMaxChartAreaHeight = height - outerBoxSizes.top - outerBoxSizes.bottom;\n\t\t\tvar newMaxChartAreaWidth = width - outerBoxSizes.left - outerBoxSizes.right;\n\t\n\t\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n\t\t\t\thelpers$1.each(verticalBoxes, function(box) {\n\t\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t\t});\n\t\n\t\t\t\thelpers$1.each(horizontalBoxes, function(box) {\n\t\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\n\t\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\n\t\t\t}\n\t\n\t\t\t// Step 7 - Position the boxes\n\t\t\tvar left = leftPadding + leftPaddingAddition;\n\t\t\tvar top = topPadding + topPaddingAddition;\n\t\n\t\t\tfunction placeBox(box) {\n\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\tbox.left = box.fullWidth ? leftPadding : outerBoxSizes.left;\n\t\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : outerBoxSizes.left + maxChartAreaWidth;\n\t\t\t\t\tbox.top = top;\n\t\t\t\t\tbox.bottom = top + box.height;\n\t\n\t\t\t\t\t// Move to next point\n\t\t\t\t\ttop = box.bottom;\n\t\n\t\t\t\t} else {\n\t\n\t\t\t\t\tbox.left = left;\n\t\t\t\t\tbox.right = left + box.width;\n\t\t\t\t\tbox.top = outerBoxSizes.top;\n\t\t\t\t\tbox.bottom = outerBoxSizes.top + maxChartAreaHeight;\n\t\n\t\t\t\t\t// Move to next point\n\t\t\t\t\tleft = box.right;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\thelpers$1.each(leftBoxes.concat(topBoxes), placeBox);\n\t\n\t\t\t// Account for chart width and height\n\t\t\tleft += maxChartAreaWidth;\n\t\t\ttop += maxChartAreaHeight;\n\t\n\t\t\thelpers$1.each(rightBoxes, placeBox);\n\t\t\thelpers$1.each(bottomBoxes, placeBox);\n\t\n\t\t\t// Step 8\n\t\t\tchart.chartArea = {\n\t\t\t\tleft: outerBoxSizes.left,\n\t\t\t\ttop: outerBoxSizes.top,\n\t\t\t\tright: outerBoxSizes.left + maxChartAreaWidth,\n\t\t\t\tbottom: outerBoxSizes.top + maxChartAreaHeight\n\t\t\t};\n\t\n\t\t\t// Step 9\n\t\t\thelpers$1.each(chartAreaBoxes, function(box) {\n\t\t\t\tbox.left = chart.chartArea.left;\n\t\t\t\tbox.top = chart.chartArea.top;\n\t\t\t\tbox.right = chart.chartArea.right;\n\t\t\t\tbox.bottom = chart.chartArea.bottom;\n\t\n\t\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\n\t\t\t});\n\t\t}\n\t};\n\t\n\t/**\n\t * Platform fallback implementation (minimal).\n\t * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\n\t */\n\t\n\tvar platform_basic = {\n\t\tacquireContext: function(item) {\n\t\t\tif (item && item.canvas) {\n\t\t\t\t// Support for any object associated to a canvas (including a context2d)\n\t\t\t\titem = item.canvas;\n\t\t\t}\n\t\n\t\t\treturn item && item.getContext('2d') || null;\n\t\t}\n\t};\n\t\n\tvar platform_dom = \"/*\\n * DOM element rendering detection\\n * https://davidwalsh.name/detect-node-insertion\\n */\\n@keyframes chartjs-render-animation {\\n\\tfrom { opacity: 0.99; }\\n\\tto { opacity: 1; }\\n}\\n\\n.chartjs-render-monitor {\\n\\tanimation: chartjs-render-animation 0.001s;\\n}\\n\\n/*\\n * DOM element resizing detection\\n * https://github.com/marcj/css-element-queries\\n */\\n.chartjs-size-monitor,\\n.chartjs-size-monitor-expand,\\n.chartjs-size-monitor-shrink {\\n\\tposition: absolute;\\n\\tdirection: ltr;\\n\\tleft: 0;\\n\\ttop: 0;\\n\\tright: 0;\\n\\tbottom: 0;\\n\\toverflow: hidden;\\n\\tpointer-events: none;\\n\\tvisibility: hidden;\\n\\tz-index: -1;\\n}\\n\\n.chartjs-size-monitor-expand > div {\\n\\tposition: absolute;\\n\\twidth: 1000000px;\\n\\theight: 1000000px;\\n\\tleft: 0;\\n\\ttop: 0;\\n}\\n\\n.chartjs-size-monitor-shrink > div {\\n\\tposition: absolute;\\n\\twidth: 200%;\\n\\theight: 200%;\\n\\tleft: 0;\\n\\ttop: 0;\\n}\\n\";\n\t\n\tvar platform_dom$1 = /*#__PURE__*/Object.freeze({\n\tdefault: platform_dom\n\t});\n\t\n\tfunction getCjsExportFromNamespace (n) {\n\t\treturn n && n.default || n;\n\t}\n\t\n\tvar stylesheet = getCjsExportFromNamespace(platform_dom$1);\n\t\n\tvar EXPANDO_KEY = '$chartjs';\n\tvar CSS_PREFIX = 'chartjs-';\n\tvar CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';\n\tvar CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';\n\tvar CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';\n\tvar ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];\n\t\n\t/**\n\t * DOM event types -> Chart.js event types.\n\t * Note: only events with different types are mapped.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/Events\n\t */\n\tvar EVENT_TYPES = {\n\t\ttouchstart: 'mousedown',\n\t\ttouchmove: 'mousemove',\n\t\ttouchend: 'mouseup',\n\t\tpointerenter: 'mouseenter',\n\t\tpointerdown: 'mousedown',\n\t\tpointermove: 'mousemove',\n\t\tpointerup: 'mouseup',\n\t\tpointerleave: 'mouseout',\n\t\tpointerout: 'mouseout'\n\t};\n\t\n\t/**\n\t * The \"used\" size is the final value of a dimension property after all calculations have\n\t * been performed. This method uses the computed style of `element` but returns undefined\n\t * if the computed style is not expressed in pixels. That can happen in some cases where\n\t * `element` has a size relative to its parent and this last one is not yet displayed,\n\t * for example because of `display: none` on a parent node.\n\t * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n\t * @returns {number} Size in pixels or undefined if unknown.\n\t */\n\tfunction readUsedSize(element, property) {\n\t\tvar value = helpers$1.getStyle(element, property);\n\t\tvar matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n\t\treturn matches ? Number(matches[1]) : undefined;\n\t}\n\t\n\t/**\n\t * Initializes the canvas style and render size without modifying the canvas display size,\n\t * since responsiveness is handled by the controller.resize() method. The config is used\n\t * to determine the aspect ratio to apply in case no explicit height has been specified.\n\t */\n\tfunction initCanvas(canvas, config) {\n\t\tvar style = canvas.style;\n\t\n\t\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n\t\t// returns null or '' if no explicit value has been set to the canvas attribute.\n\t\tvar renderHeight = canvas.getAttribute('height');\n\t\tvar renderWidth = canvas.getAttribute('width');\n\t\n\t\t// Chart.js modifies some canvas values that we want to restore on destroy\n\t\tcanvas[EXPANDO_KEY] = {\n\t\t\tinitial: {\n\t\t\t\theight: renderHeight,\n\t\t\t\twidth: renderWidth,\n\t\t\t\tstyle: {\n\t\t\t\t\tdisplay: style.display,\n\t\t\t\t\theight: style.height,\n\t\t\t\t\twidth: style.width\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\t// Force canvas to display as block to avoid extra space caused by inline\n\t\t// elements, which would interfere with the responsive resize process.\n\t\t// https://github.com/chartjs/Chart.js/issues/2538\n\t\tstyle.display = style.display || 'block';\n\t\n\t\tif (renderWidth === null || renderWidth === '') {\n\t\t\tvar displayWidth = readUsedSize(canvas, 'width');\n\t\t\tif (displayWidth !== undefined) {\n\t\t\t\tcanvas.width = displayWidth;\n\t\t\t}\n\t\t}\n\t\n\t\tif (renderHeight === null || renderHeight === '') {\n\t\t\tif (canvas.style.height === '') {\n\t\t\t\t// If no explicit render height and style height, let's apply the aspect ratio,\n\t\t\t\t// which one can be specified by the user but also by charts as default option\n\t\t\t\t// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n\t\t\t\tcanvas.height = canvas.width / (config.options.aspectRatio || 2);\n\t\t\t} else {\n\t\t\t\tvar displayHeight = readUsedSize(canvas, 'height');\n\t\t\t\tif (displayWidth !== undefined) {\n\t\t\t\t\tcanvas.height = displayHeight;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn canvas;\n\t}\n\t\n\t/**\n\t * Detects support for options object argument in addEventListener.\n\t * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n\t * @private\n\t */\n\tvar supportsEventListenerOptions = (function() {\n\t\tvar supports = false;\n\t\ttry {\n\t\t\tvar options = Object.defineProperty({}, 'passive', {\n\t\t\t\t// eslint-disable-next-line getter-return\n\t\t\t\tget: function() {\n\t\t\t\t\tsupports = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\twindow.addEventListener('e', null, options);\n\t\t} catch (e) {\n\t\t\t// continue regardless of error\n\t\t}\n\t\treturn supports;\n\t}());\n\t\n\t// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n\t// https://github.com/chartjs/Chart.js/issues/4287\n\tvar eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\n\t\n\tfunction addListener(node, type, listener) {\n\t\tnode.addEventListener(type, listener, eventListenerOptions);\n\t}\n\t\n\tfunction removeListener(node, type, listener) {\n\t\tnode.removeEventListener(type, listener, eventListenerOptions);\n\t}\n\t\n\tfunction createEvent(type, chart, x, y, nativeEvent) {\n\t\treturn {\n\t\t\ttype: type,\n\t\t\tchart: chart,\n\t\t\tnative: nativeEvent || null,\n\t\t\tx: x !== undefined ? x : null,\n\t\t\ty: y !== undefined ? y : null,\n\t\t};\n\t}\n\t\n\tfunction fromNativeEvent(event, chart) {\n\t\tvar type = EVENT_TYPES[event.type] || event.type;\n\t\tvar pos = helpers$1.getRelativePosition(event, chart);\n\t\treturn createEvent(type, chart, pos.x, pos.y, event);\n\t}\n\t\n\tfunction throttled(fn, thisArg) {\n\t\tvar ticking = false;\n\t\tvar args = [];\n\t\n\t\treturn function() {\n\t\t\targs = Array.prototype.slice.call(arguments);\n\t\t\tthisArg = thisArg || this;\n\t\n\t\t\tif (!ticking) {\n\t\t\t\tticking = true;\n\t\t\t\thelpers$1.requestAnimFrame.call(window, function() {\n\t\t\t\t\tticking = false;\n\t\t\t\t\tfn.apply(thisArg, args);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction createDiv(cls) {\n\t\tvar el = document.createElement('div');\n\t\tel.className = cls || '';\n\t\treturn el;\n\t}\n\t\n\t// Implementation based on https://github.com/marcj/css-element-queries\n\tfunction createResizer(handler) {\n\t\tvar maxSize = 1000000;\n\t\n\t\t// NOTE(SB) Don't use innerHTML because it could be considered unsafe.\n\t\t// https://github.com/chartjs/Chart.js/issues/5902\n\t\tvar resizer = createDiv(CSS_SIZE_MONITOR);\n\t\tvar expand = createDiv(CSS_SIZE_MONITOR + '-expand');\n\t\tvar shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');\n\t\n\t\texpand.appendChild(createDiv());\n\t\tshrink.appendChild(createDiv());\n\t\n\t\tresizer.appendChild(expand);\n\t\tresizer.appendChild(shrink);\n\t\tresizer._reset = function() {\n\t\t\texpand.scrollLeft = maxSize;\n\t\t\texpand.scrollTop = maxSize;\n\t\t\tshrink.scrollLeft = maxSize;\n\t\t\tshrink.scrollTop = maxSize;\n\t\t};\n\t\n\t\tvar onScroll = function() {\n\t\t\tresizer._reset();\n\t\t\thandler();\n\t\t};\n\t\n\t\taddListener(expand, 'scroll', onScroll.bind(expand, 'expand'));\n\t\taddListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));\n\t\n\t\treturn resizer;\n\t}\n\t\n\t// https://davidwalsh.name/detect-node-insertion\n\tfunction watchForRender(node, handler) {\n\t\tvar expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\n\t\tvar proxy = expando.renderProxy = function(e) {\n\t\t\tif (e.animationName === CSS_RENDER_ANIMATION) {\n\t\t\t\thandler();\n\t\t\t}\n\t\t};\n\t\n\t\thelpers$1.each(ANIMATION_START_EVENTS, function(type) {\n\t\t\taddListener(node, type, proxy);\n\t\t});\n\t\n\t\t// #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class\n\t\t// is removed then added back immediately (same animation frame?). Accessing the\n\t\t// `offsetParent` property will force a reflow and re-evaluate the CSS animation.\n\t\t// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics\n\t\t// https://github.com/chartjs/Chart.js/issues/4737\n\t\texpando.reflow = !!node.offsetParent;\n\t\n\t\tnode.classList.add(CSS_RENDER_MONITOR);\n\t}\n\t\n\tfunction unwatchForRender(node) {\n\t\tvar expando = node[EXPANDO_KEY] || {};\n\t\tvar proxy = expando.renderProxy;\n\t\n\t\tif (proxy) {\n\t\t\thelpers$1.each(ANIMATION_START_EVENTS, function(type) {\n\t\t\t\tremoveListener(node, type, proxy);\n\t\t\t});\n\t\n\t\t\tdelete expando.renderProxy;\n\t\t}\n\t\n\t\tnode.classList.remove(CSS_RENDER_MONITOR);\n\t}\n\t\n\tfunction addResizeListener(node, listener, chart) {\n\t\tvar expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\n\t\n\t\t// Let's keep track of this added resizer and thus avoid DOM query when removing it.\n\t\tvar resizer = expando.resizer = createResizer(throttled(function() {\n\t\t\tif (expando.resizer) {\n\t\t\t\tvar container = chart.options.maintainAspectRatio && node.parentNode;\n\t\t\t\tvar w = container ? container.clientWidth : 0;\n\t\t\t\tlistener(createEvent('resize', chart));\n\t\t\t\tif (container && container.clientWidth < w && chart.canvas) {\n\t\t\t\t\t// If the container size shrank during chart resize, let's assume\n\t\t\t\t\t// scrollbar appeared. So we resize again with the scrollbar visible -\n\t\t\t\t\t// effectively making chart smaller and the scrollbar hidden again.\n\t\t\t\t\t// Because we are inside `throttled`, and currently `ticking`, scroll\n\t\t\t\t\t// events are ignored during this whole 2 resize process.\n\t\t\t\t\t// If we assumed wrong and something else happened, we are resizing\n\t\t\t\t\t// twice in a frame (potential performance issue)\n\t\t\t\t\tlistener(createEvent('resize', chart));\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t\n\t\t// The resizer needs to be attached to the node parent, so we first need to be\n\t\t// sure that `node` is attached to the DOM before injecting the resizer element.\n\t\twatchForRender(node, function() {\n\t\t\tif (expando.resizer) {\n\t\t\t\tvar container = node.parentNode;\n\t\t\t\tif (container && container !== resizer.parentNode) {\n\t\t\t\t\tcontainer.insertBefore(resizer, container.firstChild);\n\t\t\t\t}\n\t\n\t\t\t\t// The container size might have changed, let's reset the resizer state.\n\t\t\t\tresizer._reset();\n\t\t\t}\n\t\t});\n\t}\n\t\n\tfunction removeResizeListener(node) {\n\t\tvar expando = node[EXPANDO_KEY] || {};\n\t\tvar resizer = expando.resizer;\n\t\n\t\tdelete expando.resizer;\n\t\tunwatchForRender(node);\n\t\n\t\tif (resizer && resizer.parentNode) {\n\t\t\tresizer.parentNode.removeChild(resizer);\n\t\t}\n\t}\n\t\n\tfunction injectCSS(platform, css) {\n\t\t// https://stackoverflow.com/q/3922139\n\t\tvar style = platform._style || document.createElement('style');\n\t\tif (!platform._style) {\n\t\t\tplatform._style = style;\n\t\t\tcss = '/* Chart.js */\\n' + css;\n\t\t\tstyle.setAttribute('type', 'text/css');\n\t\t\tdocument.getElementsByTagName('head')[0].appendChild(style);\n\t\t}\n\t\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n\t\n\tvar platform_dom$2 = {\n\t\t/**\n\t\t * When `true`, prevents the automatic injection of the stylesheet required to\n\t\t * correctly detect when the chart is added to the DOM and then resized. This\n\t\t * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)\n\t\t * to be manually imported to make this library compatible with any CSP.\n\t\t * See https://github.com/chartjs/Chart.js/issues/5208\n\t\t */\n\t\tdisableCSSInjection: false,\n\t\n\t\t/**\n\t\t * This property holds whether this platform is enabled for the current environment.\n\t\t * Currently used by platform.js to select the proper implementation.\n\t\t * @private\n\t\t */\n\t\t_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_ensureLoaded: function() {\n\t\t\tif (this._loaded) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tthis._loaded = true;\n\t\n\t\t\t// https://github.com/chartjs/Chart.js/issues/5208\n\t\t\tif (!this.disableCSSInjection) {\n\t\t\t\tinjectCSS(this, stylesheet);\n\t\t\t}\n\t\t},\n\t\n\t\tacquireContext: function(item, config) {\n\t\t\tif (typeof item === 'string') {\n\t\t\t\titem = document.getElementById(item);\n\t\t\t} else if (item.length) {\n\t\t\t\t// Support for array based queries (such as jQuery)\n\t\t\t\titem = item[0];\n\t\t\t}\n\t\n\t\t\tif (item && item.canvas) {\n\t\t\t\t// Support for any object associated to a canvas (including a context2d)\n\t\t\t\titem = item.canvas;\n\t\t\t}\n\t\n\t\t\t// To prevent canvas fingerprinting, some add-ons undefine the getContext\n\t\t\t// method, for example: https://github.com/kkapsner/CanvasBlocker\n\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\t\tvar context = item && item.getContext && item.getContext('2d');\n\t\n\t\t\t// Load platform resources on first chart creation, to make possible to change\n\t\t\t// platform options after importing the library (e.g. `disableCSSInjection`).\n\t\t\tthis._ensureLoaded();\n\t\n\t\t\t// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is\n\t\t\t// inside an iframe or when running in a protected environment. We could guess the\n\t\t\t// types from their toString() value but let's keep things flexible and assume it's\n\t\t\t// a sufficient condition if the item has a context2D which has item as `canvas`.\n\t\t\t// https://github.com/chartjs/Chart.js/issues/3887\n\t\t\t// https://github.com/chartjs/Chart.js/issues/4102\n\t\t\t// https://github.com/chartjs/Chart.js/issues/4152\n\t\t\tif (context && context.canvas === item) {\n\t\t\t\tinitCanvas(item, config);\n\t\t\t\treturn context;\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\t},\n\t\n\t\treleaseContext: function(context) {\n\t\t\tvar canvas = context.canvas;\n\t\t\tif (!canvas[EXPANDO_KEY]) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar initial = canvas[EXPANDO_KEY].initial;\n\t\t\t['height', 'width'].forEach(function(prop) {\n\t\t\t\tvar value = initial[prop];\n\t\t\t\tif (helpers$1.isNullOrUndef(value)) {\n\t\t\t\t\tcanvas.removeAttribute(prop);\n\t\t\t\t} else {\n\t\t\t\t\tcanvas.setAttribute(prop, value);\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\thelpers$1.each(initial.style || {}, function(value, key) {\n\t\t\t\tcanvas.style[key] = value;\n\t\t\t});\n\t\n\t\t\t// The canvas render size might have been changed (and thus the state stack discarded),\n\t\t\t// we can't use save() and restore() to restore the initial state. So make sure that at\n\t\t\t// least the canvas context is reset to the default state by setting the canvas width.\n\t\t\t// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n\t\t\t// eslint-disable-next-line no-self-assign\n\t\t\tcanvas.width = canvas.width;\n\t\n\t\t\tdelete canvas[EXPANDO_KEY];\n\t\t},\n\t\n\t\taddEventListener: function(chart, type, listener) {\n\t\t\tvar canvas = chart.canvas;\n\t\t\tif (type === 'resize') {\n\t\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\t\taddResizeListener(canvas, listener, chart);\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});\n\t\t\tvar proxies = expando.proxies || (expando.proxies = {});\n\t\t\tvar proxy = proxies[chart.id + '_' + type] = function(event) {\n\t\t\t\tlistener(fromNativeEvent(event, chart));\n\t\t\t};\n\t\n\t\t\taddListener(canvas, type, proxy);\n\t\t},\n\t\n\t\tremoveEventListener: function(chart, type, listener) {\n\t\t\tvar canvas = chart.canvas;\n\t\t\tif (type === 'resize') {\n\t\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\t\tremoveResizeListener(canvas);\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar expando = listener[EXPANDO_KEY] || {};\n\t\t\tvar proxies = expando.proxies || {};\n\t\t\tvar proxy = proxies[chart.id + '_' + type];\n\t\t\tif (!proxy) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tremoveListener(canvas, type, proxy);\n\t\t}\n\t};\n\t\n\t// DEPRECATIONS\n\t\n\t/**\n\t * Provided for backward compatibility, use EventTarget.addEventListener instead.\n\t * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n\t * @function Chart.helpers.addEvent\n\t * @deprecated since version 2.7.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\thelpers$1.addEvent = addListener;\n\t\n\t/**\n\t * Provided for backward compatibility, use EventTarget.removeEventListener instead.\n\t * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\n\t * @function Chart.helpers.removeEvent\n\t * @deprecated since version 2.7.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\thelpers$1.removeEvent = removeListener;\n\t\n\t// @TODO Make possible to select another platform at build time.\n\tvar implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;\n\t\n\t/**\n\t * @namespace Chart.platform\n\t * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\n\t * @since 2.4.0\n\t */\n\tvar platform = helpers$1.extend({\n\t\t/**\n\t\t * @since 2.7.0\n\t\t */\n\t\tinitialize: function() {},\n\t\n\t\t/**\n\t\t * Called at chart construction time, returns a context2d instance implementing\n\t\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t\t * @param {*} item - The native item from which to acquire context (platform specific)\n\t\t * @param {object} options - The chart options\n\t\t * @returns {CanvasRenderingContext2D} context2d instance\n\t\t */\n\t\tacquireContext: function() {},\n\t\n\t\t/**\n\t\t * Called at chart destruction time, releases any resources associated to the context\n\t\t * previously returned by the acquireContext() method.\n\t\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t\t * @returns {boolean} true if the method succeeded, else false\n\t\t */\n\t\treleaseContext: function() {},\n\t\n\t\t/**\n\t\t * Registers the specified listener on the given chart.\n\t\t * @param {Chart} chart - Chart from which to listen for event\n\t\t * @param {string} type - The ({@link IEvent}) type to listen for\n\t\t * @param {function} listener - Receives a notification (an object that implements\n\t\t * the {@link IEvent} interface) when an event of the specified type occurs.\n\t\t */\n\t\taddEventListener: function() {},\n\t\n\t\t/**\n\t\t * Removes the specified listener previously registered with addEventListener.\n\t\t * @param {Chart} chart - Chart from which to remove the listener\n\t\t * @param {string} type - The ({@link IEvent}) type to remove\n\t\t * @param {function} listener - The listener function to remove from the event target.\n\t\t */\n\t\tremoveEventListener: function() {}\n\t\n\t}, implementation);\n\t\n\tcore_defaults._set('global', {\n\t\tplugins: {}\n\t});\n\t\n\t/**\n\t * The plugin service singleton\n\t * @namespace Chart.plugins\n\t * @since 2.1.0\n\t */\n\tvar core_plugins = {\n\t\t/**\n\t\t * Globally registered plugins.\n\t\t * @private\n\t\t */\n\t\t_plugins: [],\n\t\n\t\t/**\n\t\t * This identifier is used to invalidate the descriptors cache attached to each chart\n\t\t * when a global plugin is registered or unregistered. In this case, the cache ID is\n\t\t * incremented and descriptors are regenerated during following API calls.\n\t\t * @private\n\t\t */\n\t\t_cacheId: 0,\n\t\n\t\t/**\n\t\t * Registers the given plugin(s) if not already registered.\n\t\t * @param {IPlugin[]|IPlugin} plugins plugin instance(s).\n\t\t */\n\t\tregister: function(plugins) {\n\t\t\tvar p = this._plugins;\n\t\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\t\tif (p.indexOf(plugin) === -1) {\n\t\t\t\t\tp.push(plugin);\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tthis._cacheId++;\n\t\t},\n\t\n\t\t/**\n\t\t * Unregisters the given plugin(s) only if registered.\n\t\t * @param {IPlugin[]|IPlugin} plugins plugin instance(s).\n\t\t */\n\t\tunregister: function(plugins) {\n\t\t\tvar p = this._plugins;\n\t\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\t\tvar idx = p.indexOf(plugin);\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\tp.splice(idx, 1);\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tthis._cacheId++;\n\t\t},\n\t\n\t\t/**\n\t\t * Remove all registered plugins.\n\t\t * @since 2.1.5\n\t\t */\n\t\tclear: function() {\n\t\t\tthis._plugins = [];\n\t\t\tthis._cacheId++;\n\t\t},\n\t\n\t\t/**\n\t\t * Returns the number of registered plugins?\n\t\t * @returns {number}\n\t\t * @since 2.1.5\n\t\t */\n\t\tcount: function() {\n\t\t\treturn this._plugins.length;\n\t\t},\n\t\n\t\t/**\n\t\t * Returns all registered plugin instances.\n\t\t * @returns {IPlugin[]} array of plugin objects.\n\t\t * @since 2.1.5\n\t\t */\n\t\tgetAll: function() {\n\t\t\treturn this._plugins;\n\t\t},\n\t\n\t\t/**\n\t\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t\t * returned value can be used, for instance, to interrupt the current action.\n\t\t * @param {Chart} chart - The chart instance for which plugins should be called.\n\t\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t\t * @param {Array} [args] - Extra arguments to apply to the hook call.\n\t\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t\t */\n\t\tnotify: function(chart, hook, args) {\n\t\t\tvar descriptors = this.descriptors(chart);\n\t\t\tvar ilen = descriptors.length;\n\t\t\tvar i, descriptor, plugin, params, method;\n\t\n\t\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\t\tdescriptor = descriptors[i];\n\t\t\t\tplugin = descriptor.plugin;\n\t\t\t\tmethod = plugin[hook];\n\t\t\t\tif (typeof method === 'function') {\n\t\t\t\t\tparams = [chart].concat(args || []);\n\t\t\t\t\tparams.push(descriptor.options);\n\t\t\t\t\tif (method.apply(plugin, params) === false) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn true;\n\t\t},\n\t\n\t\t/**\n\t\t * Returns descriptors of enabled plugins for the given chart.\n\t\t * @returns {object[]} [{ plugin, options }]\n\t\t * @private\n\t\t */\n\t\tdescriptors: function(chart) {\n\t\t\tvar cache = chart.$plugins || (chart.$plugins = {});\n\t\t\tif (cache.id === this._cacheId) {\n\t\t\t\treturn cache.descriptors;\n\t\t\t}\n\t\n\t\t\tvar plugins = [];\n\t\t\tvar descriptors = [];\n\t\t\tvar config = (chart && chart.config) || {};\n\t\t\tvar options = (config.options && config.options.plugins) || {};\n\t\n\t\t\tthis._plugins.concat(config.plugins || []).forEach(function(plugin) {\n\t\t\t\tvar idx = plugins.indexOf(plugin);\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tvar id = plugin.id;\n\t\t\t\tvar opts = options[id];\n\t\t\t\tif (opts === false) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif (opts === true) {\n\t\t\t\t\topts = helpers$1.clone(core_defaults.global.plugins[id]);\n\t\t\t\t}\n\t\n\t\t\t\tplugins.push(plugin);\n\t\t\t\tdescriptors.push({\n\t\t\t\t\tplugin: plugin,\n\t\t\t\t\toptions: opts || {}\n\t\t\t\t});\n\t\t\t});\n\t\n\t\t\tcache.descriptors = descriptors;\n\t\t\tcache.id = this._cacheId;\n\t\t\treturn descriptors;\n\t\t},\n\t\n\t\t/**\n\t\t * Invalidates cache for the given chart: descriptors hold a reference on plugin option,\n\t\t * but in some cases, this reference can be changed by the user when updating options.\n\t\t * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n\t\t * @private\n\t\t */\n\t\t_invalidate: function(chart) {\n\t\t\tdelete chart.$plugins;\n\t\t}\n\t};\n\t\n\tvar core_scaleService = {\n\t\t// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\n\t\t// use the new chart options to grab the correct scale\n\t\tconstructors: {},\n\t\t// Use a registration function so that we can move to an ES6 map when we no longer need to support\n\t\t// old browsers\n\t\n\t\t// Scale config defaults\n\t\tdefaults: {},\n\t\tregisterScaleType: function(type, scaleConstructor, scaleDefaults) {\n\t\t\tthis.constructors[type] = scaleConstructor;\n\t\t\tthis.defaults[type] = helpers$1.clone(scaleDefaults);\n\t\t},\n\t\tgetScaleConstructor: function(type) {\n\t\t\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\n\t\t},\n\t\tgetScaleDefaults: function(type) {\n\t\t\t// Return the scale defaults merged with the global settings so that we always use the latest ones\n\t\t\treturn this.defaults.hasOwnProperty(type) ? helpers$1.merge({}, [core_defaults.scale, this.defaults[type]]) : {};\n\t\t},\n\t\tupdateScaleDefaults: function(type, additions) {\n\t\t\tvar me = this;\n\t\t\tif (me.defaults.hasOwnProperty(type)) {\n\t\t\t\tme.defaults[type] = helpers$1.extend(me.defaults[type], additions);\n\t\t\t}\n\t\t},\n\t\taddScalesToLayout: function(chart) {\n\t\t\t// Adds each scale to the chart.boxes array to be sized accordingly\n\t\t\thelpers$1.each(chart.scales, function(scale) {\n\t\t\t\t// Set ILayoutItem parameters for backwards compatibility\n\t\t\t\tscale.fullWidth = scale.options.fullWidth;\n\t\t\t\tscale.position = scale.options.position;\n\t\t\t\tscale.weight = scale.options.weight;\n\t\t\t\tcore_layouts.addBox(chart, scale);\n\t\t\t});\n\t\t}\n\t};\n\t\n\tvar valueOrDefault$7 = helpers$1.valueOrDefault;\n\t\n\tcore_defaults._set('global', {\n\t\ttooltips: {\n\t\t\tenabled: true,\n\t\t\tcustom: null,\n\t\t\tmode: 'nearest',\n\t\t\tposition: 'average',\n\t\t\tintersect: true,\n\t\t\tbackgroundColor: 'rgba(0,0,0,0.8)',\n\t\t\ttitleFontStyle: 'bold',\n\t\t\ttitleSpacing: 2,\n\t\t\ttitleMarginBottom: 6,\n\t\t\ttitleFontColor: '#fff',\n\t\t\ttitleAlign: 'left',\n\t\t\tbodySpacing: 2,\n\t\t\tbodyFontColor: '#fff',\n\t\t\tbodyAlign: 'left',\n\t\t\tfooterFontStyle: 'bold',\n\t\t\tfooterSpacing: 2,\n\t\t\tfooterMarginTop: 6,\n\t\t\tfooterFontColor: '#fff',\n\t\t\tfooterAlign: 'left',\n\t\t\tyPadding: 6,\n\t\t\txPadding: 6,\n\t\t\tcaretPadding: 2,\n\t\t\tcaretSize: 5,\n\t\t\tcornerRadius: 6,\n\t\t\tmultiKeyBackground: '#fff',\n\t\t\tdisplayColors: true,\n\t\t\tborderColor: 'rgba(0,0,0,0)',\n\t\t\tborderWidth: 0,\n\t\t\tcallbacks: {\n\t\t\t\t// Args are: (tooltipItems, data)\n\t\t\t\tbeforeTitle: helpers$1.noop,\n\t\t\t\ttitle: function(tooltipItems, data) {\n\t\t\t\t\tvar title = '';\n\t\t\t\t\tvar labels = data.labels;\n\t\t\t\t\tvar labelCount = labels ? labels.length : 0;\n\t\n\t\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\t\tvar item = tooltipItems[0];\n\t\t\t\t\t\tif (item.label) {\n\t\t\t\t\t\t\ttitle = item.label;\n\t\t\t\t\t\t} else if (item.xLabel) {\n\t\t\t\t\t\t\ttitle = item.xLabel;\n\t\t\t\t\t\t} else if (labelCount > 0 && item.index < labelCount) {\n\t\t\t\t\t\t\ttitle = labels[item.index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn title;\n\t\t\t\t},\n\t\t\t\tafterTitle: helpers$1.noop,\n\t\n\t\t\t\t// Args are: (tooltipItems, data)\n\t\t\t\tbeforeBody: helpers$1.noop,\n\t\n\t\t\t\t// Args are: (tooltipItem, data)\n\t\t\t\tbeforeLabel: helpers$1.noop,\n\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\tvar label = data.datasets[tooltipItem.datasetIndex].label || '';\n\t\n\t\t\t\t\tif (label) {\n\t\t\t\t\t\tlabel += ': ';\n\t\t\t\t\t}\n\t\t\t\t\tif (!helpers$1.isNullOrUndef(tooltipItem.value)) {\n\t\t\t\t\t\tlabel += tooltipItem.value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlabel += tooltipItem.yLabel;\n\t\t\t\t\t}\n\t\t\t\t\treturn label;\n\t\t\t\t},\n\t\t\t\tlabelColor: function(tooltipItem, chart) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(tooltipItem.datasetIndex);\n\t\t\t\t\tvar activeElement = meta.data[tooltipItem.index];\n\t\t\t\t\tvar view = activeElement._view;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tborderColor: view.borderColor,\n\t\t\t\t\t\tbackgroundColor: view.backgroundColor\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\tlabelTextColor: function() {\n\t\t\t\t\treturn this._options.bodyFontColor;\n\t\t\t\t},\n\t\t\t\tafterLabel: helpers$1.noop,\n\t\n\t\t\t\t// Args are: (tooltipItems, data)\n\t\t\t\tafterBody: helpers$1.noop,\n\t\n\t\t\t\t// Args are: (tooltipItems, data)\n\t\t\t\tbeforeFooter: helpers$1.noop,\n\t\t\t\tfooter: helpers$1.noop,\n\t\t\t\tafterFooter: helpers$1.noop\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar positioners = {\n\t\t/**\n\t\t * Average mode places the tooltip at the average position of the elements shown\n\t\t * @function Chart.Tooltip.positioners.average\n\t\t * @param elements {ChartElement[]} the elements being displayed in the tooltip\n\t\t * @returns {object} tooltip position\n\t\t */\n\t\taverage: function(elements) {\n\t\t\tif (!elements.length) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tvar i, len;\n\t\t\tvar x = 0;\n\t\t\tvar y = 0;\n\t\t\tvar count = 0;\n\t\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar pos = el.tooltipPosition();\n\t\t\t\t\tx += pos.x;\n\t\t\t\t\ty += pos.y;\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tx: x / count,\n\t\t\t\ty: y / count\n\t\t\t};\n\t\t},\n\t\n\t\t/**\n\t\t * Gets the tooltip position nearest of the item nearest to the event position\n\t\t * @function Chart.Tooltip.positioners.nearest\n\t\t * @param elements {Chart.Element[]} the tooltip elements\n\t\t * @param eventPosition {object} the position of the event in canvas coordinates\n\t\t * @returns {object} the tooltip position\n\t\t */\n\t\tnearest: function(elements, eventPosition) {\n\t\t\tvar x = eventPosition.x;\n\t\t\tvar y = eventPosition.y;\n\t\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\t\tvar i, len, nearestElement;\n\t\n\t\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\t\tvar el = elements[i];\n\t\t\t\tif (el && el.hasValue()) {\n\t\t\t\t\tvar center = el.getCenterPoint();\n\t\t\t\t\tvar d = helpers$1.distanceBetweenPoints(eventPosition, center);\n\t\n\t\t\t\t\tif (d < minDistance) {\n\t\t\t\t\t\tminDistance = d;\n\t\t\t\t\t\tnearestElement = el;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (nearestElement) {\n\t\t\t\tvar tp = nearestElement.tooltipPosition();\n\t\t\t\tx = tp.x;\n\t\t\t\ty = tp.y;\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t};\n\t\t}\n\t};\n\t\n\t// Helper to push or concat based on if the 2nd parameter is an array or not\n\tfunction pushOrConcat(base, toPush) {\n\t\tif (toPush) {\n\t\t\tif (helpers$1.isArray(toPush)) {\n\t\t\t\t// base = base.concat(toPush);\n\t\t\t\tArray.prototype.push.apply(base, toPush);\n\t\t\t} else {\n\t\t\t\tbase.push(toPush);\n\t\t\t}\n\t\t}\n\t\n\t\treturn base;\n\t}\n\t\n\t/**\n\t * Returns array of strings split by newline\n\t * @param {string} value - The value to split by newline.\n\t * @returns {string[]} value if newline present - Returned from String split() method\n\t * @function\n\t */\n\tfunction splitNewlines(str) {\n\t\tif ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n\t\t\treturn str.split('\\n');\n\t\t}\n\t\treturn str;\n\t}\n\t\n\t\n\t/**\n\t * Private helper to create a tooltip item model\n\t * @param element - the chart element (point, arc, bar) to create the tooltip item for\n\t * @return new tooltip item\n\t */\n\tfunction createTooltipItem(element) {\n\t\tvar xScale = element._xScale;\n\t\tvar yScale = element._yScale || element._scale; // handle radar || polarArea charts\n\t\tvar index = element._index;\n\t\tvar datasetIndex = element._datasetIndex;\n\t\tvar controller = element._chart.getDatasetMeta(datasetIndex).controller;\n\t\tvar indexScale = controller._getIndexScale();\n\t\tvar valueScale = controller._getValueScale();\n\t\n\t\treturn {\n\t\t\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tyLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tlabel: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tvalue: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',\n\t\t\tindex: index,\n\t\t\tdatasetIndex: datasetIndex,\n\t\t\tx: element._model.x,\n\t\t\ty: element._model.y\n\t\t};\n\t}\n\t\n\t/**\n\t * Helper to get the reset model for the tooltip\n\t * @param tooltipOpts {object} the tooltip options\n\t */\n\tfunction getBaseModel(tooltipOpts) {\n\t\tvar globalDefaults = core_defaults.global;\n\t\n\t\treturn {\n\t\t\t// Positioning\n\t\t\txPadding: tooltipOpts.xPadding,\n\t\t\tyPadding: tooltipOpts.yPadding,\n\t\t\txAlign: tooltipOpts.xAlign,\n\t\t\tyAlign: tooltipOpts.yAlign,\n\t\n\t\t\t// Body\n\t\t\tbodyFontColor: tooltipOpts.bodyFontColor,\n\t\t\t_bodyFontFamily: valueOrDefault$7(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_bodyFontStyle: valueOrDefault$7(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\n\t\t\t_bodyAlign: tooltipOpts.bodyAlign,\n\t\t\tbodyFontSize: valueOrDefault$7(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\n\t\t\tbodySpacing: tooltipOpts.bodySpacing,\n\t\n\t\t\t// Title\n\t\t\ttitleFontColor: tooltipOpts.titleFontColor,\n\t\t\t_titleFontFamily: valueOrDefault$7(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_titleFontStyle: valueOrDefault$7(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\n\t\t\ttitleFontSize: valueOrDefault$7(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\n\t\t\t_titleAlign: tooltipOpts.titleAlign,\n\t\t\ttitleSpacing: tooltipOpts.titleSpacing,\n\t\t\ttitleMarginBottom: tooltipOpts.titleMarginBottom,\n\t\n\t\t\t// Footer\n\t\t\tfooterFontColor: tooltipOpts.footerFontColor,\n\t\t\t_footerFontFamily: valueOrDefault$7(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\n\t\t\t_footerFontStyle: valueOrDefault$7(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\n\t\t\tfooterFontSize: valueOrDefault$7(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\n\t\t\t_footerAlign: tooltipOpts.footerAlign,\n\t\t\tfooterSpacing: tooltipOpts.footerSpacing,\n\t\t\tfooterMarginTop: tooltipOpts.footerMarginTop,\n\t\n\t\t\t// Appearance\n\t\t\tcaretSize: tooltipOpts.caretSize,\n\t\t\tcornerRadius: tooltipOpts.cornerRadius,\n\t\t\tbackgroundColor: tooltipOpts.backgroundColor,\n\t\t\topacity: 0,\n\t\t\tlegendColorBackground: tooltipOpts.multiKeyBackground,\n\t\t\tdisplayColors: tooltipOpts.displayColors,\n\t\t\tborderColor: tooltipOpts.borderColor,\n\t\t\tborderWidth: tooltipOpts.borderWidth\n\t\t};\n\t}\n\t\n\t/**\n\t * Get the size of the tooltip\n\t */\n\tfunction getTooltipSize(tooltip, model) {\n\t\tvar ctx = tooltip._chart.ctx;\n\t\n\t\tvar height = model.yPadding * 2; // Tooltip Padding\n\t\tvar width = 0;\n\t\n\t\t// Count of all lines in the body\n\t\tvar body = model.body;\n\t\tvar combinedBodyLength = body.reduce(function(count, bodyItem) {\n\t\t\treturn count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\n\t\t}, 0);\n\t\tcombinedBodyLength += model.beforeBody.length + model.afterBody.length;\n\t\n\t\tvar titleLineCount = model.title.length;\n\t\tvar footerLineCount = model.footer.length;\n\t\tvar titleFontSize = model.titleFontSize;\n\t\tvar bodyFontSize = model.bodyFontSize;\n\t\tvar footerFontSize = model.footerFontSize;\n\t\n\t\theight += titleLineCount * titleFontSize; // Title Lines\n\t\theight += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\n\t\theight += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\n\t\theight += combinedBodyLength * bodyFontSize; // Body Lines\n\t\theight += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\n\t\theight += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\n\t\theight += footerLineCount * (footerFontSize); // Footer Lines\n\t\theight += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\n\t\n\t\t// Title width\n\t\tvar widthPadding = 0;\n\t\tvar maxLineWidth = function(line) {\n\t\t\twidth = Math.max(width, ctx.measureText(line).width + widthPadding);\n\t\t};\n\t\n\t\tctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\n\t\thelpers$1.each(model.title, maxLineWidth);\n\t\n\t\t// Body width\n\t\tctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\n\t\thelpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth);\n\t\n\t\t// Body lines may include some extra width due to the color box\n\t\twidthPadding = model.displayColors ? (bodyFontSize + 2) : 0;\n\t\thelpers$1.each(body, function(bodyItem) {\n\t\t\thelpers$1.each(bodyItem.before, maxLineWidth);\n\t\t\thelpers$1.each(bodyItem.lines, maxLineWidth);\n\t\t\thelpers$1.each(bodyItem.after, maxLineWidth);\n\t\t});\n\t\n\t\t// Reset back to 0\n\t\twidthPadding = 0;\n\t\n\t\t// Footer width\n\t\tctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\n\t\thelpers$1.each(model.footer, maxLineWidth);\n\t\n\t\t// Add padding\n\t\twidth += 2 * model.xPadding;\n\t\n\t\treturn {\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\t}\n\t\n\t/**\n\t * Helper to get the alignment of a tooltip given the size\n\t */\n\tfunction determineAlignment(tooltip, size) {\n\t\tvar model = tooltip._model;\n\t\tvar chart = tooltip._chart;\n\t\tvar chartArea = tooltip._chart.chartArea;\n\t\tvar xAlign = 'center';\n\t\tvar yAlign = 'center';\n\t\n\t\tif (model.y < size.height) {\n\t\t\tyAlign = 'top';\n\t\t} else if (model.y > (chart.height - size.height)) {\n\t\t\tyAlign = 'bottom';\n\t\t}\n\t\n\t\tvar lf, rf; // functions to determine left, right alignment\n\t\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\n\t\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\n\t\tvar midX = (chartArea.left + chartArea.right) / 2;\n\t\tvar midY = (chartArea.top + chartArea.bottom) / 2;\n\t\n\t\tif (yAlign === 'center') {\n\t\t\tlf = function(x) {\n\t\t\t\treturn x <= midX;\n\t\t\t};\n\t\t\trf = function(x) {\n\t\t\t\treturn x > midX;\n\t\t\t};\n\t\t} else {\n\t\t\tlf = function(x) {\n\t\t\t\treturn x <= (size.width / 2);\n\t\t\t};\n\t\t\trf = function(x) {\n\t\t\t\treturn x >= (chart.width - (size.width / 2));\n\t\t\t};\n\t\t}\n\t\n\t\tolf = function(x) {\n\t\t\treturn x + size.width + model.caretSize + model.caretPadding > chart.width;\n\t\t};\n\t\torf = function(x) {\n\t\t\treturn x - size.width - model.caretSize - model.caretPadding < 0;\n\t\t};\n\t\tyf = function(y) {\n\t\t\treturn y <= midY ? 'top' : 'bottom';\n\t\t};\n\t\n\t\tif (lf(model.x)) {\n\t\t\txAlign = 'left';\n\t\n\t\t\t// Is tooltip too wide and goes over the right side of the chart.?\n\t\t\tif (olf(model.x)) {\n\t\t\t\txAlign = 'center';\n\t\t\t\tyAlign = yf(model.y);\n\t\t\t}\n\t\t} else if (rf(model.x)) {\n\t\t\txAlign = 'right';\n\t\n\t\t\t// Is tooltip too wide and goes outside left edge of canvas?\n\t\t\tif (orf(model.x)) {\n\t\t\t\txAlign = 'center';\n\t\t\t\tyAlign = yf(model.y);\n\t\t\t}\n\t\t}\n\t\n\t\tvar opts = tooltip._options;\n\t\treturn {\n\t\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\n\t\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\n\t\t};\n\t}\n\t\n\t/**\n\t * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n\t */\n\tfunction getBackgroundPoint(vm, size, alignment, chart) {\n\t\t// Background Position\n\t\tvar x = vm.x;\n\t\tvar y = vm.y;\n\t\n\t\tvar caretSize = vm.caretSize;\n\t\tvar caretPadding = vm.caretPadding;\n\t\tvar cornerRadius = vm.cornerRadius;\n\t\tvar xAlign = alignment.xAlign;\n\t\tvar yAlign = alignment.yAlign;\n\t\tvar paddingAndSize = caretSize + caretPadding;\n\t\tvar radiusAndPadding = cornerRadius + caretPadding;\n\t\n\t\tif (xAlign === 'right') {\n\t\t\tx -= size.width;\n\t\t} else if (xAlign === 'center') {\n\t\t\tx -= (size.width / 2);\n\t\t\tif (x + size.width > chart.width) {\n\t\t\t\tx = chart.width - size.width;\n\t\t\t}\n\t\t\tif (x < 0) {\n\t\t\t\tx = 0;\n\t\t\t}\n\t\t}\n\t\n\t\tif (yAlign === 'top') {\n\t\t\ty += paddingAndSize;\n\t\t} else if (yAlign === 'bottom') {\n\t\t\ty -= size.height + paddingAndSize;\n\t\t} else {\n\t\t\ty -= (size.height / 2);\n\t\t}\n\t\n\t\tif (yAlign === 'center') {\n\t\t\tif (xAlign === 'left') {\n\t\t\t\tx += paddingAndSize;\n\t\t\t} else if (xAlign === 'right') {\n\t\t\t\tx -= paddingAndSize;\n\t\t\t}\n\t\t} else if (xAlign === 'left') {\n\t\t\tx -= radiusAndPadding;\n\t\t} else if (xAlign === 'right') {\n\t\t\tx += radiusAndPadding;\n\t\t}\n\t\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\t}\n\t\n\tfunction getAlignedX(vm, align) {\n\t\treturn align === 'center'\n\t\t\t? vm.x + vm.width / 2\n\t\t\t: align === 'right'\n\t\t\t\t? vm.x + vm.width - vm.xPadding\n\t\t\t\t: vm.x + vm.xPadding;\n\t}\n\t\n\t/**\n\t * Helper to build before and after body lines\n\t */\n\tfunction getBeforeAfterBodyLines(callback) {\n\t\treturn pushOrConcat([], splitNewlines(callback));\n\t}\n\t\n\tvar exports$3 = core_element.extend({\n\t\tinitialize: function() {\n\t\t\tthis._model = getBaseModel(this._options);\n\t\t\tthis._lastActive = [];\n\t\t},\n\t\n\t\t// Get the title\n\t\t// Args are: (tooltipItem, data)\n\t\tgetTitle: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me._options;\n\t\t\tvar callbacks = opts.callbacks;\n\t\n\t\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments);\n\t\t\tvar title = callbacks.title.apply(me, arguments);\n\t\t\tvar afterTitle = callbacks.afterTitle.apply(me, arguments);\n\t\n\t\t\tvar lines = [];\n\t\t\tlines = pushOrConcat(lines, splitNewlines(beforeTitle));\n\t\t\tlines = pushOrConcat(lines, splitNewlines(title));\n\t\t\tlines = pushOrConcat(lines, splitNewlines(afterTitle));\n\t\n\t\t\treturn lines;\n\t\t},\n\t\n\t\t// Args are: (tooltipItem, data)\n\t\tgetBeforeBody: function() {\n\t\t\treturn getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));\n\t\t},\n\t\n\t\t// Args are: (tooltipItem, data)\n\t\tgetBody: function(tooltipItems, data) {\n\t\t\tvar me = this;\n\t\t\tvar callbacks = me._options.callbacks;\n\t\t\tvar bodyItems = [];\n\t\n\t\t\thelpers$1.each(tooltipItems, function(tooltipItem) {\n\t\t\t\tvar bodyItem = {\n\t\t\t\t\tbefore: [],\n\t\t\t\t\tlines: [],\n\t\t\t\t\tafter: []\n\t\t\t\t};\n\t\t\t\tpushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));\n\t\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\n\t\t\t\tpushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));\n\t\n\t\t\t\tbodyItems.push(bodyItem);\n\t\t\t});\n\t\n\t\t\treturn bodyItems;\n\t\t},\n\t\n\t\t// Args are: (tooltipItem, data)\n\t\tgetAfterBody: function() {\n\t\t\treturn getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));\n\t\t},\n\t\n\t\t// Get the footer and beforeFooter and afterFooter lines\n\t\t// Args are: (tooltipItem, data)\n\t\tgetFooter: function() {\n\t\t\tvar me = this;\n\t\t\tvar callbacks = me._options.callbacks;\n\t\n\t\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\n\t\t\tvar footer = callbacks.footer.apply(me, arguments);\n\t\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\n\t\n\t\t\tvar lines = [];\n\t\t\tlines = pushOrConcat(lines, splitNewlines(beforeFooter));\n\t\t\tlines = pushOrConcat(lines, splitNewlines(footer));\n\t\t\tlines = pushOrConcat(lines, splitNewlines(afterFooter));\n\t\n\t\t\treturn lines;\n\t\t},\n\t\n\t\tupdate: function(changed) {\n\t\t\tvar me = this;\n\t\t\tvar opts = me._options;\n\t\n\t\t\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\n\t\t\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\n\t\t\t// which breaks any animations.\n\t\t\tvar existingModel = me._model;\n\t\t\tvar model = me._model = getBaseModel(opts);\n\t\t\tvar active = me._active;\n\t\n\t\t\tvar data = me._data;\n\t\n\t\t\t// In the case where active.length === 0 we need to keep these at existing values for good animations\n\t\t\tvar alignment = {\n\t\t\t\txAlign: existingModel.xAlign,\n\t\t\t\tyAlign: existingModel.yAlign\n\t\t\t};\n\t\t\tvar backgroundPoint = {\n\t\t\t\tx: existingModel.x,\n\t\t\t\ty: existingModel.y\n\t\t\t};\n\t\t\tvar tooltipSize = {\n\t\t\t\twidth: existingModel.width,\n\t\t\t\theight: existingModel.height\n\t\t\t};\n\t\t\tvar tooltipPosition = {\n\t\t\t\tx: existingModel.caretX,\n\t\t\t\ty: existingModel.caretY\n\t\t\t};\n\t\n\t\t\tvar i, len;\n\t\n\t\t\tif (active.length) {\n\t\t\t\tmodel.opacity = 1;\n\t\n\t\t\t\tvar labelColors = [];\n\t\t\t\tvar labelTextColors = [];\n\t\t\t\ttooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);\n\t\n\t\t\t\tvar tooltipItems = [];\n\t\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\n\t\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\n\t\t\t\t}\n\t\n\t\t\t\t// If the user provided a filter function, use it to modify the tooltip items\n\t\t\t\tif (opts.filter) {\n\t\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\n\t\t\t\t\t\treturn opts.filter(a, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\n\t\t\t\tif (opts.itemSort) {\n\t\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\n\t\t\t\t\t\treturn opts.itemSort(a, b, data);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\t// Determine colors for boxes\n\t\t\t\thelpers$1.each(tooltipItems, function(tooltipItem) {\n\t\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\n\t\t\t\t\tlabelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));\n\t\t\t\t});\n\t\n\t\n\t\t\t\t// Build the Text Lines\n\t\t\t\tmodel.title = me.getTitle(tooltipItems, data);\n\t\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\n\t\t\t\tmodel.body = me.getBody(tooltipItems, data);\n\t\t\t\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\n\t\t\t\tmodel.footer = me.getFooter(tooltipItems, data);\n\t\n\t\t\t\t// Initial positioning and colors\n\t\t\t\tmodel.x = tooltipPosition.x;\n\t\t\t\tmodel.y = tooltipPosition.y;\n\t\t\t\tmodel.caretPadding = opts.caretPadding;\n\t\t\t\tmodel.labelColors = labelColors;\n\t\t\t\tmodel.labelTextColors = labelTextColors;\n\t\n\t\t\t\t// data points\n\t\t\t\tmodel.dataPoints = tooltipItems;\n\t\n\t\t\t\t// We need to determine alignment of the tooltip\n\t\t\t\ttooltipSize = getTooltipSize(this, model);\n\t\t\t\talignment = determineAlignment(this, tooltipSize);\n\t\t\t\t// Final Size and Position\n\t\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);\n\t\t\t} else {\n\t\t\t\tmodel.opacity = 0;\n\t\t\t}\n\t\n\t\t\tmodel.xAlign = alignment.xAlign;\n\t\t\tmodel.yAlign = alignment.yAlign;\n\t\t\tmodel.x = backgroundPoint.x;\n\t\t\tmodel.y = backgroundPoint.y;\n\t\t\tmodel.width = tooltipSize.width;\n\t\t\tmodel.height = tooltipSize.height;\n\t\n\t\t\t// Point where the caret on the tooltip points to\n\t\t\tmodel.caretX = tooltipPosition.x;\n\t\t\tmodel.caretY = tooltipPosition.y;\n\t\n\t\t\tme._model = model;\n\t\n\t\t\tif (changed && opts.custom) {\n\t\t\t\topts.custom.call(me, model);\n\t\t\t}\n\t\n\t\t\treturn me;\n\t\t},\n\t\n\t\tdrawCaret: function(tooltipPoint, size) {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\t\t\tvar caretPosition = this.getCaretPosition(tooltipPoint, size, vm);\n\t\n\t\t\tctx.lineTo(caretPosition.x1, caretPosition.y1);\n\t\t\tctx.lineTo(caretPosition.x2, caretPosition.y2);\n\t\t\tctx.lineTo(caretPosition.x3, caretPosition.y3);\n\t\t},\n\t\tgetCaretPosition: function(tooltipPoint, size, vm) {\n\t\t\tvar x1, x2, x3, y1, y2, y3;\n\t\t\tvar caretSize = vm.caretSize;\n\t\t\tvar cornerRadius = vm.cornerRadius;\n\t\t\tvar xAlign = vm.xAlign;\n\t\t\tvar yAlign = vm.yAlign;\n\t\t\tvar ptX = tooltipPoint.x;\n\t\t\tvar ptY = tooltipPoint.y;\n\t\t\tvar width = size.width;\n\t\t\tvar height = size.height;\n\t\n\t\t\tif (yAlign === 'center') {\n\t\t\t\ty2 = ptY + (height / 2);\n\t\n\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\tx1 = ptX;\n\t\t\t\t\tx2 = x1 - caretSize;\n\t\t\t\t\tx3 = x1;\n\t\n\t\t\t\t\ty1 = y2 + caretSize;\n\t\t\t\t\ty3 = y2 - caretSize;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = ptX + width;\n\t\t\t\t\tx2 = x1 + caretSize;\n\t\t\t\t\tx3 = x1;\n\t\n\t\t\t\t\ty1 = y2 - caretSize;\n\t\t\t\t\ty3 = y2 + caretSize;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (xAlign === 'left') {\n\t\t\t\t\tx2 = ptX + cornerRadius + (caretSize);\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t} else if (xAlign === 'right') {\n\t\t\t\t\tx2 = ptX + width - cornerRadius - caretSize;\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t} else {\n\t\t\t\t\tx2 = vm.caretX;\n\t\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\t\tx3 = x2 + caretSize;\n\t\t\t\t}\n\t\t\t\tif (yAlign === 'top') {\n\t\t\t\t\ty1 = ptY;\n\t\t\t\t\ty2 = y1 - caretSize;\n\t\t\t\t\ty3 = y1;\n\t\t\t\t} else {\n\t\t\t\t\ty1 = ptY + height;\n\t\t\t\t\ty2 = y1 + caretSize;\n\t\t\t\t\ty3 = y1;\n\t\t\t\t\t// invert drawing order\n\t\t\t\t\tvar tmp = x3;\n\t\t\t\t\tx3 = x1;\n\t\t\t\t\tx1 = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};\n\t\t},\n\t\n\t\tdrawTitle: function(pt, vm, ctx) {\n\t\t\tvar title = vm.title;\n\t\n\t\t\tif (title.length) {\n\t\t\t\tpt.x = getAlignedX(vm, vm._titleAlign);\n\t\n\t\t\t\tctx.textAlign = vm._titleAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\t\n\t\t\t\tvar titleFontSize = vm.titleFontSize;\n\t\t\t\tvar titleSpacing = vm.titleSpacing;\n\t\n\t\t\t\tctx.fillStyle = vm.titleFontColor;\n\t\t\t\tctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\n\t\n\t\t\t\tvar i, len;\n\t\t\t\tfor (i = 0, len = title.length; i < len; ++i) {\n\t\t\t\t\tctx.fillText(title[i], pt.x, pt.y);\n\t\t\t\t\tpt.y += titleFontSize + titleSpacing; // Line Height and spacing\n\t\n\t\t\t\t\tif (i + 1 === title.length) {\n\t\t\t\t\t\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tdrawBody: function(pt, vm, ctx) {\n\t\t\tvar bodyFontSize = vm.bodyFontSize;\n\t\t\tvar bodySpacing = vm.bodySpacing;\n\t\t\tvar bodyAlign = vm._bodyAlign;\n\t\t\tvar body = vm.body;\n\t\t\tvar drawColorBoxes = vm.displayColors;\n\t\t\tvar labelColors = vm.labelColors;\n\t\t\tvar xLinePadding = 0;\n\t\t\tvar colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;\n\t\t\tvar textColor;\n\t\n\t\t\tctx.textAlign = bodyAlign;\n\t\t\tctx.textBaseline = 'top';\n\t\t\tctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n\t\n\t\t\tpt.x = getAlignedX(vm, bodyAlign);\n\t\n\t\t\t// Before Body\n\t\t\tvar fillLineOfText = function(line) {\n\t\t\t\tctx.fillText(line, pt.x + xLinePadding, pt.y);\n\t\t\t\tpt.y += bodyFontSize + bodySpacing;\n\t\t\t};\n\t\n\t\t\t// Before body lines\n\t\t\tctx.fillStyle = vm.bodyFontColor;\n\t\t\thelpers$1.each(vm.beforeBody, fillLineOfText);\n\t\n\t\t\txLinePadding = drawColorBoxes && bodyAlign !== 'right'\n\t\t\t\t? bodyAlign === 'center' ? (bodyFontSize / 2 + 1) : (bodyFontSize + 2)\n\t\t\t\t: 0;\n\t\n\t\t\t// Draw body lines now\n\t\t\thelpers$1.each(body, function(bodyItem, i) {\n\t\t\t\ttextColor = vm.labelTextColors[i];\n\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\thelpers$1.each(bodyItem.before, fillLineOfText);\n\t\n\t\t\t\thelpers$1.each(bodyItem.lines, function(line) {\n\t\t\t\t\t// Draw Legend-like boxes if needed\n\t\t\t\t\tif (drawColorBoxes) {\n\t\t\t\t\t\t// Fill a white rect so that colours merge nicely if the opacity is < 1\n\t\t\t\t\t\tctx.fillStyle = vm.legendColorBackground;\n\t\t\t\t\t\tctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize);\n\t\n\t\t\t\t\t\t// Border\n\t\t\t\t\t\tctx.lineWidth = 1;\n\t\t\t\t\t\tctx.strokeStyle = labelColors[i].borderColor;\n\t\t\t\t\t\tctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize);\n\t\n\t\t\t\t\t\t// Inner square\n\t\t\t\t\t\tctx.fillStyle = labelColors[i].backgroundColor;\n\t\t\t\t\t\tctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n\t\t\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfillLineOfText(line);\n\t\t\t\t});\n\t\n\t\t\t\thelpers$1.each(bodyItem.after, fillLineOfText);\n\t\t\t});\n\t\n\t\t\t// Reset back to 0 for after body\n\t\t\txLinePadding = 0;\n\t\n\t\t\t// After body lines\n\t\t\thelpers$1.each(vm.afterBody, fillLineOfText);\n\t\t\tpt.y -= bodySpacing; // Remove last body spacing\n\t\t},\n\t\n\t\tdrawFooter: function(pt, vm, ctx) {\n\t\t\tvar footer = vm.footer;\n\t\n\t\t\tif (footer.length) {\n\t\t\t\tpt.x = getAlignedX(vm, vm._footerAlign);\n\t\t\t\tpt.y += vm.footerMarginTop;\n\t\n\t\t\t\tctx.textAlign = vm._footerAlign;\n\t\t\t\tctx.textBaseline = 'top';\n\t\n\t\t\t\tctx.fillStyle = vm.footerFontColor;\n\t\t\t\tctx.font = helpers$1.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\n\t\n\t\t\t\thelpers$1.each(footer, function(line) {\n\t\t\t\t\tctx.fillText(line, pt.x, pt.y);\n\t\t\t\t\tpt.y += vm.footerFontSize + vm.footerSpacing;\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\n\t\tdrawBackground: function(pt, vm, ctx, tooltipSize) {\n\t\t\tctx.fillStyle = vm.backgroundColor;\n\t\t\tctx.strokeStyle = vm.borderColor;\n\t\t\tctx.lineWidth = vm.borderWidth;\n\t\t\tvar xAlign = vm.xAlign;\n\t\t\tvar yAlign = vm.yAlign;\n\t\t\tvar x = pt.x;\n\t\t\tvar y = pt.y;\n\t\t\tvar width = tooltipSize.width;\n\t\t\tvar height = tooltipSize.height;\n\t\t\tvar radius = vm.cornerRadius;\n\t\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(x + radius, y);\n\t\t\tif (yAlign === 'top') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + width - radius, y);\n\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\t\tif (yAlign === 'center' && xAlign === 'right') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + width, y + height - radius);\n\t\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\t\tif (yAlign === 'bottom') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x + radius, y + height);\n\t\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\t\tif (yAlign === 'center' && xAlign === 'left') {\n\t\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t\t}\n\t\t\tctx.lineTo(x, y + radius);\n\t\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\t\tctx.closePath();\n\t\n\t\t\tctx.fill();\n\t\n\t\t\tif (vm.borderWidth > 0) {\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t},\n\t\n\t\tdraw: function() {\n\t\t\tvar ctx = this._chart.ctx;\n\t\t\tvar vm = this._view;\n\t\n\t\t\tif (vm.opacity === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar tooltipSize = {\n\t\t\t\twidth: vm.width,\n\t\t\t\theight: vm.height\n\t\t\t};\n\t\t\tvar pt = {\n\t\t\t\tx: vm.x,\n\t\t\t\ty: vm.y\n\t\t\t};\n\t\n\t\t\t// IE11/Edge does not like very small opacities, so snap to 0\n\t\t\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\n\t\n\t\t\t// Truthy/falsey value for empty tooltip\n\t\t\tvar hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;\n\t\n\t\t\tif (this._options.enabled && hasTooltipContent) {\n\t\t\t\tctx.save();\n\t\t\t\tctx.globalAlpha = opacity;\n\t\n\t\t\t\t// Draw Background\n\t\t\t\tthis.drawBackground(pt, vm, ctx, tooltipSize);\n\t\n\t\t\t\t// Draw Title, Body, and Footer\n\t\t\t\tpt.y += vm.yPadding;\n\t\n\t\t\t\t// Titles\n\t\t\t\tthis.drawTitle(pt, vm, ctx);\n\t\n\t\t\t\t// Body\n\t\t\t\tthis.drawBody(pt, vm, ctx);\n\t\n\t\t\t\t// Footer\n\t\t\t\tthis.drawFooter(pt, vm, ctx);\n\t\n\t\t\t\tctx.restore();\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event - The event to handle\n\t\t * @returns {boolean} true if the tooltip changed\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar options = me._options;\n\t\t\tvar changed = false;\n\t\n\t\t\tme._lastActive = me._lastActive || [];\n\t\n\t\t\t// Find Active Elements for tooltips\n\t\t\tif (e.type === 'mouseout') {\n\t\t\t\tme._active = [];\n\t\t\t} else {\n\t\t\t\tme._active = me._chart.getElementsAtEventForMode(e, options.mode, options);\n\t\t\t}\n\t\n\t\t\t// Remember Last Actives\n\t\t\tchanged = !helpers$1.arrayEquals(me._active, me._lastActive);\n\t\n\t\t\t// Only handle target event on tooltip change\n\t\t\tif (changed) {\n\t\t\t\tme._lastActive = me._active;\n\t\n\t\t\t\tif (options.enabled || options.custom) {\n\t\t\t\t\tme._eventPosition = {\n\t\t\t\t\t\tx: e.x,\n\t\t\t\t\t\ty: e.y\n\t\t\t\t\t};\n\t\n\t\t\t\t\tme.update(true);\n\t\t\t\t\tme.pivot();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn changed;\n\t\t}\n\t});\n\t\n\t/**\n\t * @namespace Chart.Tooltip.positioners\n\t */\n\tvar positioners_1 = positioners;\n\t\n\tvar core_tooltip = exports$3;\n\tcore_tooltip.positioners = positioners_1;\n\t\n\tvar valueOrDefault$8 = helpers$1.valueOrDefault;\n\t\n\tcore_defaults._set('global', {\n\t\telements: {},\n\t\tevents: [\n\t\t\t'mousemove',\n\t\t\t'mouseout',\n\t\t\t'click',\n\t\t\t'touchstart',\n\t\t\t'touchmove'\n\t\t],\n\t\thover: {\n\t\t\tonHover: null,\n\t\t\tmode: 'nearest',\n\t\t\tintersect: true,\n\t\t\tanimationDuration: 400\n\t\t},\n\t\tonClick: null,\n\t\tmaintainAspectRatio: true,\n\t\tresponsive: true,\n\t\tresponsiveAnimationDuration: 0\n\t});\n\t\n\t/**\n\t * Recursively merge the given config objects representing the `scales` option\n\t * by incorporating scale defaults in `xAxes` and `yAxes` array items, then\n\t * returns a deep copy of the result, thus doesn't alter inputs.\n\t */\n\tfunction mergeScaleConfig(/* config objects ... */) {\n\t\treturn helpers$1.merge({}, [].slice.call(arguments), {\n\t\t\tmerger: function(key, target, source, options) {\n\t\t\t\tif (key === 'xAxes' || key === 'yAxes') {\n\t\t\t\t\tvar slen = source[key].length;\n\t\t\t\t\tvar i, type, scale;\n\t\n\t\t\t\t\tif (!target[key]) {\n\t\t\t\t\t\ttarget[key] = [];\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor (i = 0; i < slen; ++i) {\n\t\t\t\t\t\tscale = source[key][i];\n\t\t\t\t\t\ttype = valueOrDefault$8(scale.type, key === 'xAxes' ? 'category' : 'linear');\n\t\n\t\t\t\t\t\tif (i >= target[key].length) {\n\t\t\t\t\t\t\ttarget[key].push({});\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {\n\t\t\t\t\t\t\t// new/untyped scale or type changed: let's apply the new defaults\n\t\t\t\t\t\t\t// then merge source scale to correctly overwrite the defaults.\n\t\t\t\t\t\t\thelpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// scales type are the same\n\t\t\t\t\t\t\thelpers$1.merge(target[key][i], scale);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thelpers$1._merger(key, target, source, options);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\t\n\t/**\n\t * Recursively merge the given config objects as the root options by handling\n\t * default scale options for the `scales` and `scale` properties, then returns\n\t * a deep copy of the result, thus doesn't alter inputs.\n\t */\n\tfunction mergeConfig(/* config objects ... */) {\n\t\treturn helpers$1.merge({}, [].slice.call(arguments), {\n\t\t\tmerger: function(key, target, source, options) {\n\t\t\t\tvar tval = target[key] || {};\n\t\t\t\tvar sval = source[key];\n\t\n\t\t\t\tif (key === 'scales') {\n\t\t\t\t\t// scale config merging is complex. Add our own function here for that\n\t\t\t\t\ttarget[key] = mergeScaleConfig(tval, sval);\n\t\t\t\t} else if (key === 'scale') {\n\t\t\t\t\t// used in polar area & radar charts since there is only one scale\n\t\t\t\t\ttarget[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);\n\t\t\t\t} else {\n\t\t\t\t\thelpers$1._merger(key, target, source, options);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\t\n\tfunction initConfig(config) {\n\t\tconfig = config || {};\n\t\n\t\t// Do NOT use mergeConfig for the data object because this method merges arrays\n\t\t// and so would change references to labels and datasets, preventing data updates.\n\t\tvar data = config.data = config.data || {};\n\t\tdata.datasets = data.datasets || [];\n\t\tdata.labels = data.labels || [];\n\t\n\t\tconfig.options = mergeConfig(\n\t\t\tcore_defaults.global,\n\t\t\tcore_defaults[config.type],\n\t\t\tconfig.options || {});\n\t\n\t\treturn config;\n\t}\n\t\n\tfunction updateConfig(chart) {\n\t\tvar newOptions = chart.options;\n\t\n\t\thelpers$1.each(chart.scales, function(scale) {\n\t\t\tcore_layouts.removeBox(chart, scale);\n\t\t});\n\t\n\t\tnewOptions = mergeConfig(\n\t\t\tcore_defaults.global,\n\t\t\tcore_defaults[chart.config.type],\n\t\t\tnewOptions);\n\t\n\t\tchart.options = chart.config.options = newOptions;\n\t\tchart.ensureScalesHaveIDs();\n\t\tchart.buildOrUpdateScales();\n\t\n\t\t// Tooltip\n\t\tchart.tooltip._options = newOptions.tooltips;\n\t\tchart.tooltip.initialize();\n\t}\n\t\n\tfunction positionIsHorizontal(position) {\n\t\treturn position === 'top' || position === 'bottom';\n\t}\n\t\n\tvar Chart = function(item, config) {\n\t\tthis.construct(item, config);\n\t\treturn this;\n\t};\n\t\n\thelpers$1.extend(Chart.prototype, /** @lends Chart */ {\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tconstruct: function(item, config) {\n\t\t\tvar me = this;\n\t\n\t\t\tconfig = initConfig(config);\n\t\n\t\t\tvar context = platform.acquireContext(item, config);\n\t\t\tvar canvas = context && context.canvas;\n\t\t\tvar height = canvas && canvas.height;\n\t\t\tvar width = canvas && canvas.width;\n\t\n\t\t\tme.id = helpers$1.uid();\n\t\t\tme.ctx = context;\n\t\t\tme.canvas = canvas;\n\t\t\tme.config = config;\n\t\t\tme.width = width;\n\t\t\tme.height = height;\n\t\t\tme.aspectRatio = height ? width / height : null;\n\t\t\tme.options = config.options;\n\t\t\tme._bufferedRender = false;\n\t\n\t\t\t/**\n\t\t\t * Provided for backward compatibility, Chart and Chart.Controller have been merged,\n\t\t\t * the \"instance\" still need to be defined since it might be called from plugins.\n\t\t\t * @prop Chart#chart\n\t\t\t * @deprecated since version 2.6.0\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tme.chart = me;\n\t\t\tme.controller = me; // chart.chart.controller #inception\n\t\n\t\t\t// Add the chart instance to the global namespace\n\t\t\tChart.instances[me.id] = me;\n\t\n\t\t\t// Define alias to the config data: `chart.data === chart.config.data`\n\t\t\tObject.defineProperty(me, 'data', {\n\t\t\t\tget: function() {\n\t\t\t\t\treturn me.config.data;\n\t\t\t\t},\n\t\t\t\tset: function(value) {\n\t\t\t\t\tme.config.data = value;\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tif (!context || !canvas) {\n\t\t\t\t// The given item is not a compatible context2d element, let's return before finalizing\n\t\t\t\t// the chart initialization but after setting basic chart / controller properties that\n\t\t\t\t// can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n\t\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\t\t\tconsole.error(\"Failed to create chart: can't acquire context from the given item\");\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tme.initialize();\n\t\t\tme.update();\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tinitialize: function() {\n\t\t\tvar me = this;\n\t\n\t\t\t// Before init plugin notification\n\t\t\tcore_plugins.notify(me, 'beforeInit');\n\t\n\t\t\thelpers$1.retinaScale(me, me.options.devicePixelRatio);\n\t\n\t\t\tme.bindEvents();\n\t\n\t\t\tif (me.options.responsive) {\n\t\t\t\t// Initial resize before chart draws (must be silent to preserve initial animations).\n\t\t\t\tme.resize(true);\n\t\t\t}\n\t\n\t\t\t// Make sure scales have IDs and are built before we build any controllers.\n\t\t\tme.ensureScalesHaveIDs();\n\t\t\tme.buildOrUpdateScales();\n\t\t\tme.initToolTip();\n\t\n\t\t\t// After init plugin notification\n\t\t\tcore_plugins.notify(me, 'afterInit');\n\t\n\t\t\treturn me;\n\t\t},\n\t\n\t\tclear: function() {\n\t\t\thelpers$1.canvas.clear(this);\n\t\t\treturn this;\n\t\t},\n\t\n\t\tstop: function() {\n\t\t\t// Stops any current animation loop occurring\n\t\t\tcore_animations.cancelAnimation(this);\n\t\t\treturn this;\n\t\t},\n\t\n\t\tresize: function(silent) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar canvas = me.canvas;\n\t\t\tvar aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;\n\t\n\t\t\t// the canvas render width and height will be casted to integers so make sure that\n\t\t\t// the canvas display style uses the same integer values to avoid blurring effect.\n\t\n\t\t\t// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed\n\t\t\tvar newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));\n\t\t\tvar newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));\n\t\n\t\t\tif (me.width === newWidth && me.height === newHeight) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tcanvas.width = me.width = newWidth;\n\t\t\tcanvas.height = me.height = newHeight;\n\t\t\tcanvas.style.width = newWidth + 'px';\n\t\t\tcanvas.style.height = newHeight + 'px';\n\t\n\t\t\thelpers$1.retinaScale(me, options.devicePixelRatio);\n\t\n\t\t\tif (!silent) {\n\t\t\t\t// Notify any plugins about the resize\n\t\t\t\tvar newSize = {width: newWidth, height: newHeight};\n\t\t\t\tcore_plugins.notify(me, 'resize', [newSize]);\n\t\n\t\t\t\t// Notify of resize\n\t\t\t\tif (options.onResize) {\n\t\t\t\t\toptions.onResize(me, newSize);\n\t\t\t\t}\n\t\n\t\t\t\tme.stop();\n\t\t\t\tme.update({\n\t\t\t\t\tduration: options.responsiveAnimationDuration\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\n\t\tensureScalesHaveIDs: function() {\n\t\t\tvar options = this.options;\n\t\t\tvar scalesOptions = options.scales || {};\n\t\t\tvar scaleOptions = options.scale;\n\t\n\t\t\thelpers$1.each(scalesOptions.xAxes, function(xAxisOptions, index) {\n\t\t\t\txAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);\n\t\t\t});\n\t\n\t\t\thelpers$1.each(scalesOptions.yAxes, function(yAxisOptions, index) {\n\t\t\t\tyAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);\n\t\t\t});\n\t\n\t\t\tif (scaleOptions) {\n\t\t\t\tscaleOptions.id = scaleOptions.id || 'scale';\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * Builds a map of scale ID to scale object for future lookup.\n\t\t */\n\t\tbuildOrUpdateScales: function() {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar scales = me.scales || {};\n\t\t\tvar items = [];\n\t\t\tvar updated = Object.keys(scales).reduce(function(obj, id) {\n\t\t\t\tobj[id] = false;\n\t\t\t\treturn obj;\n\t\t\t}, {});\n\t\n\t\t\tif (options.scales) {\n\t\t\t\titems = items.concat(\n\t\t\t\t\t(options.scales.xAxes || []).map(function(xAxisOptions) {\n\t\t\t\t\t\treturn {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};\n\t\t\t\t\t}),\n\t\t\t\t\t(options.scales.yAxes || []).map(function(yAxisOptions) {\n\t\t\t\t\t\treturn {options: yAxisOptions, dtype: 'linear', dposition: 'left'};\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\n\t\t\tif (options.scale) {\n\t\t\t\titems.push({\n\t\t\t\t\toptions: options.scale,\n\t\t\t\t\tdtype: 'radialLinear',\n\t\t\t\t\tisDefault: true,\n\t\t\t\t\tdposition: 'chartArea'\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\thelpers$1.each(items, function(item) {\n\t\t\t\tvar scaleOptions = item.options;\n\t\t\t\tvar id = scaleOptions.id;\n\t\t\t\tvar scaleType = valueOrDefault$8(scaleOptions.type, item.dtype);\n\t\n\t\t\t\tif (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {\n\t\t\t\t\tscaleOptions.position = item.dposition;\n\t\t\t\t}\n\t\n\t\t\t\tupdated[id] = true;\n\t\t\t\tvar scale = null;\n\t\t\t\tif (id in scales && scales[id].type === scaleType) {\n\t\t\t\t\tscale = scales[id];\n\t\t\t\t\tscale.options = scaleOptions;\n\t\t\t\t\tscale.ctx = me.ctx;\n\t\t\t\t\tscale.chart = me;\n\t\t\t\t} else {\n\t\t\t\t\tvar scaleClass = core_scaleService.getScaleConstructor(scaleType);\n\t\t\t\t\tif (!scaleClass) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tscale = new scaleClass({\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\ttype: scaleType,\n\t\t\t\t\t\toptions: scaleOptions,\n\t\t\t\t\t\tctx: me.ctx,\n\t\t\t\t\t\tchart: me\n\t\t\t\t\t});\n\t\t\t\t\tscales[scale.id] = scale;\n\t\t\t\t}\n\t\n\t\t\t\tscale.mergeTicksOptions();\n\t\n\t\t\t\t// TODO(SB): I think we should be able to remove this custom case (options.scale)\n\t\t\t\t// and consider it as a regular scale part of the \"scales\"\" map only! This would\n\t\t\t\t// make the logic easier and remove some useless? custom code.\n\t\t\t\tif (item.isDefault) {\n\t\t\t\t\tme.scale = scale;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// clear up discarded scales\n\t\t\thelpers$1.each(updated, function(hasUpdated, id) {\n\t\t\t\tif (!hasUpdated) {\n\t\t\t\t\tdelete scales[id];\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tme.scales = scales;\n\t\n\t\t\tcore_scaleService.addScalesToLayout(this);\n\t\t},\n\t\n\t\tbuildOrUpdateControllers: function() {\n\t\t\tvar me = this;\n\t\t\tvar newControllers = [];\n\t\n\t\t\thelpers$1.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar meta = me.getDatasetMeta(datasetIndex);\n\t\t\t\tvar type = dataset.type || me.config.type;\n\t\n\t\t\t\tif (meta.type && meta.type !== type) {\n\t\t\t\t\tme.destroyDatasetMeta(datasetIndex);\n\t\t\t\t\tmeta = me.getDatasetMeta(datasetIndex);\n\t\t\t\t}\n\t\t\t\tmeta.type = type;\n\t\n\t\t\t\tif (meta.controller) {\n\t\t\t\t\tmeta.controller.updateIndex(datasetIndex);\n\t\t\t\t\tmeta.controller.linkScales();\n\t\t\t\t} else {\n\t\t\t\t\tvar ControllerClass = controllers[meta.type];\n\t\t\t\t\tif (ControllerClass === undefined) {\n\t\t\t\t\t\tthrow new Error('\"' + meta.type + '\" is not a chart type.');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tmeta.controller = new ControllerClass(me, datasetIndex);\n\t\t\t\t\tnewControllers.push(meta.controller);\n\t\t\t\t}\n\t\t\t}, me);\n\t\n\t\t\treturn newControllers;\n\t\t},\n\t\n\t\t/**\n\t\t * Reset the elements of all datasets\n\t\t * @private\n\t\t */\n\t\tresetElements: function() {\n\t\t\tvar me = this;\n\t\t\thelpers$1.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.reset();\n\t\t\t}, me);\n\t\t},\n\t\n\t\t/**\n\t\t* Resets the chart back to it's state before the initial animation\n\t\t*/\n\t\treset: function() {\n\t\t\tthis.resetElements();\n\t\t\tthis.tooltip.initialize();\n\t\t},\n\t\n\t\tupdate: function(config) {\n\t\t\tvar me = this;\n\t\n\t\t\tif (!config || typeof config !== 'object') {\n\t\t\t\t// backwards compatibility\n\t\t\t\tconfig = {\n\t\t\t\t\tduration: config,\n\t\t\t\t\tlazy: arguments[1]\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\tupdateConfig(me);\n\t\n\t\t\t// plugins options references might have change, let's invalidate the cache\n\t\t\t// https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n\t\t\tcore_plugins._invalidate(me);\n\t\n\t\t\tif (core_plugins.notify(me, 'beforeUpdate') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// In case the entire data object changed\n\t\t\tme.tooltip._data = me.data;\n\t\n\t\t\t// Make sure dataset controllers are updated and new controllers are reset\n\t\t\tvar newControllers = me.buildOrUpdateControllers();\n\t\n\t\t\t// Make sure all dataset controllers have correct meta data counts\n\t\t\thelpers$1.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tme.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\n\t\t\t}, me);\n\t\n\t\t\tme.updateLayout();\n\t\n\t\t\t// Can only reset the new controllers after the scales have been updated\n\t\t\tif (me.options.animation && me.options.animation.duration) {\n\t\t\t\thelpers$1.each(newControllers, function(controller) {\n\t\t\t\t\tcontroller.reset();\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tme.updateDatasets();\n\t\n\t\t\t// Need to reset tooltip in case it is displayed with elements that are removed\n\t\t\t// after update.\n\t\t\tme.tooltip.initialize();\n\t\n\t\t\t// Last active contains items that were previously in the tooltip.\n\t\t\t// When we reset the tooltip, we need to clear it\n\t\t\tme.lastActive = [];\n\t\n\t\t\t// Do this before render so that any plugins that need final scale updates can use it\n\t\t\tcore_plugins.notify(me, 'afterUpdate');\n\t\n\t\t\tif (me._bufferedRender) {\n\t\t\t\tme._bufferedRequest = {\n\t\t\t\t\tduration: config.duration,\n\t\t\t\t\teasing: config.easing,\n\t\t\t\t\tlazy: config.lazy\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tme.render(config);\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t\t * @private\n\t\t */\n\t\tupdateLayout: function() {\n\t\t\tvar me = this;\n\t\n\t\t\tif (core_plugins.notify(me, 'beforeLayout') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tcore_layouts.update(this, this.width, this.height);\n\t\n\t\t\t/**\n\t\t\t * Provided for backward compatibility, use `afterLayout` instead.\n\t\t\t * @method IPlugin#afterScaleUpdate\n\t\t\t * @deprecated since version 2.5.0\n\t\t\t * @todo remove at version 3\n\t\t\t * @private\n\t\t\t */\n\t\t\tcore_plugins.notify(me, 'afterScaleUpdate');\n\t\t\tcore_plugins.notify(me, 'afterLayout');\n\t\t},\n\t\n\t\t/**\n\t\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t\t * @private\n\t\t */\n\t\tupdateDatasets: function() {\n\t\t\tvar me = this;\n\t\n\t\t\tif (core_plugins.notify(me, 'beforeDatasetsUpdate') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tfor (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tme.updateDataset(i);\n\t\t\t}\n\t\n\t\t\tcore_plugins.notify(me, 'afterDatasetsUpdate');\n\t\t},\n\t\n\t\t/**\n\t\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t\t * @private\n\t\t */\n\t\tupdateDataset: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getDatasetMeta(index);\n\t\t\tvar args = {\n\t\t\t\tmeta: meta,\n\t\t\t\tindex: index\n\t\t\t};\n\t\n\t\t\tif (core_plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tmeta.controller.update();\n\t\n\t\t\tcore_plugins.notify(me, 'afterDatasetUpdate', [args]);\n\t\t},\n\t\n\t\trender: function(config) {\n\t\t\tvar me = this;\n\t\n\t\t\tif (!config || typeof config !== 'object') {\n\t\t\t\t// backwards compatibility\n\t\t\t\tconfig = {\n\t\t\t\t\tduration: config,\n\t\t\t\t\tlazy: arguments[1]\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\tvar animationOptions = me.options.animation;\n\t\t\tvar duration = valueOrDefault$8(config.duration, animationOptions && animationOptions.duration);\n\t\t\tvar lazy = config.lazy;\n\t\n\t\t\tif (core_plugins.notify(me, 'beforeRender') === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar onComplete = function(animation) {\n\t\t\t\tcore_plugins.notify(me, 'afterRender');\n\t\t\t\thelpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);\n\t\t\t};\n\t\n\t\t\tif (animationOptions && duration) {\n\t\t\t\tvar animation = new core_animation({\n\t\t\t\t\tnumSteps: duration / 16.66, // 60 fps\n\t\t\t\t\teasing: config.easing || animationOptions.easing,\n\t\n\t\t\t\t\trender: function(chart, animationObject) {\n\t\t\t\t\t\tvar easingFunction = helpers$1.easing.effects[animationObject.easing];\n\t\t\t\t\t\tvar currentStep = animationObject.currentStep;\n\t\t\t\t\t\tvar stepDecimal = currentStep / animationObject.numSteps;\n\t\n\t\t\t\t\t\tchart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);\n\t\t\t\t\t},\n\t\n\t\t\t\t\tonAnimationProgress: animationOptions.onProgress,\n\t\t\t\t\tonAnimationComplete: onComplete\n\t\t\t\t});\n\t\n\t\t\t\tcore_animations.addAnimation(me, animation, duration, lazy);\n\t\t\t} else {\n\t\t\t\tme.draw();\n\t\n\t\t\t\t// See https://github.com/chartjs/Chart.js/issues/3781\n\t\t\t\tonComplete(new core_animation({numSteps: 0, chart: me}));\n\t\t\t}\n\t\n\t\t\treturn me;\n\t\t},\n\t\n\t\tdraw: function(easingValue) {\n\t\t\tvar me = this;\n\t\n\t\t\tme.clear();\n\t\n\t\t\tif (helpers$1.isNullOrUndef(easingValue)) {\n\t\t\t\teasingValue = 1;\n\t\t\t}\n\t\n\t\t\tme.transition(easingValue);\n\t\n\t\t\tif (me.width <= 0 || me.height <= 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif (core_plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Draw all the scales\n\t\t\thelpers$1.each(me.boxes, function(box) {\n\t\t\t\tbox.draw(me.chartArea);\n\t\t\t}, me);\n\t\n\t\t\tme.drawDatasets(easingValue);\n\t\t\tme._drawTooltip(easingValue);\n\t\n\t\t\tcore_plugins.notify(me, 'afterDraw', [easingValue]);\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\ttransition: function(easingValue) {\n\t\t\tvar me = this;\n\t\n\t\t\tfor (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\t\tme.getDatasetMeta(i).controller.transition(easingValue);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tme.tooltip.transition(easingValue);\n\t\t},\n\t\n\t\t/**\n\t\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t\t * @private\n\t\t */\n\t\tdrawDatasets: function(easingValue) {\n\t\t\tvar me = this;\n\t\n\t\t\tif (core_plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Draw datasets reversed to support proper line stacking\n\t\t\tfor (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {\n\t\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\t\tme.drawDataset(i, easingValue);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tcore_plugins.notify(me, 'afterDatasetsDraw', [easingValue]);\n\t\t},\n\t\n\t\t/**\n\t\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t\t * @private\n\t\t */\n\t\tdrawDataset: function(index, easingValue) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getDatasetMeta(index);\n\t\t\tvar args = {\n\t\t\t\tmeta: meta,\n\t\t\t\tindex: index,\n\t\t\t\teasingValue: easingValue\n\t\t\t};\n\t\n\t\t\tif (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tmeta.controller.draw(easingValue);\n\t\n\t\t\tcore_plugins.notify(me, 'afterDatasetDraw', [args]);\n\t\t},\n\t\n\t\t/**\n\t\t * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`\n\t\t * hook, in which case, plugins will not be called on `afterTooltipDraw`.\n\t\t * @private\n\t\t */\n\t\t_drawTooltip: function(easingValue) {\n\t\t\tvar me = this;\n\t\t\tvar tooltip = me.tooltip;\n\t\t\tvar args = {\n\t\t\t\ttooltip: tooltip,\n\t\t\t\teasingValue: easingValue\n\t\t\t};\n\t\n\t\t\tif (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\ttooltip.draw();\n\t\n\t\t\tcore_plugins.notify(me, 'afterTooltipDraw', [args]);\n\t\t},\n\t\n\t\t/**\n\t\t * Get the single element that was clicked on\n\t\t * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\n\t\t */\n\t\tgetElementAtEvent: function(e) {\n\t\t\treturn core_interaction.modes.single(this, e);\n\t\t},\n\t\n\t\tgetElementsAtEvent: function(e) {\n\t\t\treturn core_interaction.modes.label(this, e, {intersect: true});\n\t\t},\n\t\n\t\tgetElementsAtXAxis: function(e) {\n\t\t\treturn core_interaction.modes['x-axis'](this, e, {intersect: true});\n\t\t},\n\t\n\t\tgetElementsAtEventForMode: function(e, mode, options) {\n\t\t\tvar method = core_interaction.modes[mode];\n\t\t\tif (typeof method === 'function') {\n\t\t\t\treturn method(this, e, options);\n\t\t\t}\n\t\n\t\t\treturn [];\n\t\t},\n\t\n\t\tgetDatasetAtEvent: function(e) {\n\t\t\treturn core_interaction.modes.dataset(this, e, {intersect: true});\n\t\t},\n\t\n\t\tgetDatasetMeta: function(datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.data.datasets[datasetIndex];\n\t\t\tif (!dataset._meta) {\n\t\t\t\tdataset._meta = {};\n\t\t\t}\n\t\n\t\t\tvar meta = dataset._meta[me.id];\n\t\t\tif (!meta) {\n\t\t\t\tmeta = dataset._meta[me.id] = {\n\t\t\t\t\ttype: null,\n\t\t\t\t\tdata: [],\n\t\t\t\t\tdataset: null,\n\t\t\t\t\tcontroller: null,\n\t\t\t\t\thidden: null,\t\t\t// See isDatasetVisible() comment\n\t\t\t\t\txAxisID: null,\n\t\t\t\t\tyAxisID: null\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\treturn meta;\n\t\t},\n\t\n\t\tgetVisibleDatasetCount: function() {\n\t\t\tvar count = 0;\n\t\t\tfor (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tif (this.isDatasetVisible(i)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count;\n\t\t},\n\t\n\t\tisDatasetVisible: function(datasetIndex) {\n\t\t\tvar meta = this.getDatasetMeta(datasetIndex);\n\t\n\t\t\t// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n\t\t\t// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n\t\t\treturn typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n\t\t},\n\t\n\t\tgenerateLegend: function() {\n\t\t\treturn this.options.legendCallback(this);\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tdestroyDatasetMeta: function(datasetIndex) {\n\t\t\tvar id = this.id;\n\t\t\tvar dataset = this.data.datasets[datasetIndex];\n\t\t\tvar meta = dataset._meta && dataset._meta[id];\n\t\n\t\t\tif (meta) {\n\t\t\t\tmeta.controller.destroy();\n\t\t\t\tdelete dataset._meta[id];\n\t\t\t}\n\t\t},\n\t\n\t\tdestroy: function() {\n\t\t\tvar me = this;\n\t\t\tvar canvas = me.canvas;\n\t\t\tvar i, ilen;\n\t\n\t\t\tme.stop();\n\t\n\t\t\t// dataset controllers need to cleanup associated data\n\t\t\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tme.destroyDatasetMeta(i);\n\t\t\t}\n\t\n\t\t\tif (canvas) {\n\t\t\t\tme.unbindEvents();\n\t\t\t\thelpers$1.canvas.clear(me);\n\t\t\t\tplatform.releaseContext(me.ctx);\n\t\t\t\tme.canvas = null;\n\t\t\t\tme.ctx = null;\n\t\t\t}\n\t\n\t\t\tcore_plugins.notify(me, 'destroy');\n\t\n\t\t\tdelete Chart.instances[me.id];\n\t\t},\n\t\n\t\ttoBase64Image: function() {\n\t\t\treturn this.canvas.toDataURL.apply(this.canvas, arguments);\n\t\t},\n\t\n\t\tinitToolTip: function() {\n\t\t\tvar me = this;\n\t\t\tme.tooltip = new core_tooltip({\n\t\t\t\t_chart: me,\n\t\t\t\t_chartInstance: me, // deprecated, backward compatibility\n\t\t\t\t_data: me.data,\n\t\t\t\t_options: me.options.tooltips\n\t\t\t}, me);\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tbindEvents: function() {\n\t\t\tvar me = this;\n\t\t\tvar listeners = me._listeners = {};\n\t\t\tvar listener = function() {\n\t\t\t\tme.eventHandler.apply(me, arguments);\n\t\t\t};\n\t\n\t\t\thelpers$1.each(me.options.events, function(type) {\n\t\t\t\tplatform.addEventListener(me, type, listener);\n\t\t\t\tlisteners[type] = listener;\n\t\t\t});\n\t\n\t\t\t// Elements used to detect size change should not be injected for non responsive charts.\n\t\t\t// See https://github.com/chartjs/Chart.js/issues/2210\n\t\t\tif (me.options.responsive) {\n\t\t\t\tlistener = function() {\n\t\t\t\t\tme.resize();\n\t\t\t\t};\n\t\n\t\t\t\tplatform.addEventListener(me, 'resize', listener);\n\t\t\t\tlisteners.resize = listener;\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tunbindEvents: function() {\n\t\t\tvar me = this;\n\t\t\tvar listeners = me._listeners;\n\t\t\tif (!listeners) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tdelete me._listeners;\n\t\t\thelpers$1.each(listeners, function(listener, type) {\n\t\t\t\tplatform.removeEventListener(me, type, listener);\n\t\t\t});\n\t\t},\n\t\n\t\tupdateHoverStyle: function(elements, mode, enabled) {\n\t\t\tvar method = enabled ? 'setHoverStyle' : 'removeHoverStyle';\n\t\t\tvar element, i, ilen;\n\t\n\t\t\tfor (i = 0, ilen = elements.length; i < ilen; ++i) {\n\t\t\t\telement = elements[i];\n\t\t\t\tif (element) {\n\t\t\t\t\tthis.getDatasetMeta(element._datasetIndex).controller[method](element);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\teventHandler: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar tooltip = me.tooltip;\n\t\n\t\t\tif (core_plugins.notify(me, 'beforeEvent', [e]) === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Buffer any update calls so that renders do not occur\n\t\t\tme._bufferedRender = true;\n\t\t\tme._bufferedRequest = null;\n\t\n\t\t\tvar changed = me.handleEvent(e);\n\t\t\t// for smooth tooltip animations issue #4989\n\t\t\t// the tooltip should be the source of change\n\t\t\t// Animation check workaround:\n\t\t\t// tooltip._start will be null when tooltip isn't animating\n\t\t\tif (tooltip) {\n\t\t\t\tchanged = tooltip._start\n\t\t\t\t\t? tooltip.handleEvent(e)\n\t\t\t\t\t: changed | tooltip.handleEvent(e);\n\t\t\t}\n\t\n\t\t\tcore_plugins.notify(me, 'afterEvent', [e]);\n\t\n\t\t\tvar bufferedRequest = me._bufferedRequest;\n\t\t\tif (bufferedRequest) {\n\t\t\t\t// If we have an update that was triggered, we need to do a normal render\n\t\t\t\tme.render(bufferedRequest);\n\t\t\t} else if (changed && !me.animating) {\n\t\t\t\t// If entering, leaving, or changing elements, animate the change via pivot\n\t\t\t\tme.stop();\n\t\n\t\t\t\t// We only need to render at this point. Updating will cause scales to be\n\t\t\t\t// recomputed generating flicker & using more memory than necessary.\n\t\t\t\tme.render({\n\t\t\t\t\tduration: me.options.hover.animationDuration,\n\t\t\t\t\tlazy: true\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tme._bufferedRender = false;\n\t\t\tme._bufferedRequest = null;\n\t\n\t\t\treturn me;\n\t\t},\n\t\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event the event to handle\n\t\t * @return {boolean} true if the chart needs to re-render\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options || {};\n\t\t\tvar hoverOptions = options.hover;\n\t\t\tvar changed = false;\n\t\n\t\t\tme.lastActive = me.lastActive || [];\n\t\n\t\t\t// Find Active Elements for hover and tooltips\n\t\t\tif (e.type === 'mouseout') {\n\t\t\t\tme.active = [];\n\t\t\t} else {\n\t\t\t\tme.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\n\t\t\t}\n\t\n\t\t\t// Invoke onHover hook\n\t\t\t// Need to call with native event here to not break backwards compatibility\n\t\t\thelpers$1.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);\n\t\n\t\t\tif (e.type === 'mouseup' || e.type === 'click') {\n\t\t\t\tif (options.onClick) {\n\t\t\t\t\t// Use e.native here for backwards compatibility\n\t\t\t\t\toptions.onClick.call(me, e.native, me.active);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Remove styling for last active (even if it may still be active)\n\t\t\tif (me.lastActive.length) {\n\t\t\t\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\n\t\t\t}\n\t\n\t\t\t// Built in hover styling\n\t\t\tif (me.active.length && hoverOptions.mode) {\n\t\t\t\tme.updateHoverStyle(me.active, hoverOptions.mode, true);\n\t\t\t}\n\t\n\t\t\tchanged = !helpers$1.arrayEquals(me.active, me.lastActive);\n\t\n\t\t\t// Remember Last Actives\n\t\t\tme.lastActive = me.active;\n\t\n\t\t\treturn changed;\n\t\t}\n\t});\n\t\n\t/**\n\t * NOTE(SB) We actually don't use this container anymore but we need to keep it\n\t * for backward compatibility. Though, it can still be useful for plugins that\n\t * would need to work on multiple charts?!\n\t */\n\tChart.instances = {};\n\t\n\tvar core_controller = Chart;\n\t\n\t// DEPRECATIONS\n\t\n\t/**\n\t * Provided for backward compatibility, use Chart instead.\n\t * @class Chart.Controller\n\t * @deprecated since version 2.6\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tChart.Controller = Chart;\n\t\n\t/**\n\t * Provided for backward compatibility, not available anymore.\n\t * @namespace Chart\n\t * @deprecated since version 2.8\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tChart.types = {};\n\t\n\t/**\n\t * Provided for backward compatibility, not available anymore.\n\t * @namespace Chart.helpers.configMerge\n\t * @deprecated since version 2.8.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\thelpers$1.configMerge = mergeConfig;\n\t\n\t/**\n\t * Provided for backward compatibility, not available anymore.\n\t * @namespace Chart.helpers.scaleMerge\n\t * @deprecated since version 2.8.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\thelpers$1.scaleMerge = mergeScaleConfig;\n\t\n\tvar core_helpers = function() {\n\t\n\t\t// -- Basic js utility methods\n\t\n\t\thelpers$1.where = function(collection, filterCallback) {\n\t\t\tif (helpers$1.isArray(collection) && Array.prototype.filter) {\n\t\t\t\treturn collection.filter(filterCallback);\n\t\t\t}\n\t\t\tvar filtered = [];\n\t\n\t\t\thelpers$1.each(collection, function(item) {\n\t\t\t\tif (filterCallback(item)) {\n\t\t\t\t\tfiltered.push(item);\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\treturn filtered;\n\t\t};\n\t\thelpers$1.findIndex = Array.prototype.findIndex ?\n\t\t\tfunction(array, callback, scope) {\n\t\t\t\treturn array.findIndex(callback, scope);\n\t\t\t} :\n\t\t\tfunction(array, callback, scope) {\n\t\t\t\tscope = scope === undefined ? array : scope;\n\t\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\n\t\t\t\t\tif (callback.call(scope, array[i], i, array)) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t};\n\t\thelpers$1.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t\t// Default to start of the array\n\t\t\tif (helpers$1.isNullOrUndef(startIndex)) {\n\t\t\t\tstartIndex = -1;\n\t\t\t}\n\t\t\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++) {\n\t\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\t\treturn currentItem;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\thelpers$1.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t\t// Default to end of the array\n\t\t\tif (helpers$1.isNullOrUndef(startIndex)) {\n\t\t\t\tstartIndex = arrayToSearch.length;\n\t\t\t}\n\t\t\tfor (var i = startIndex - 1; i >= 0; i--) {\n\t\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\t\treturn currentItem;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\t// -- Math methods\n\t\thelpers$1.isNumber = function(n) {\n\t\t\treturn !isNaN(parseFloat(n)) && isFinite(n);\n\t\t};\n\t\thelpers$1.almostEquals = function(x, y, epsilon) {\n\t\t\treturn Math.abs(x - y) < epsilon;\n\t\t};\n\t\thelpers$1.almostWhole = function(x, epsilon) {\n\t\t\tvar rounded = Math.round(x);\n\t\t\treturn (((rounded - epsilon) < x) && ((rounded + epsilon) > x));\n\t\t};\n\t\thelpers$1.max = function(array) {\n\t\t\treturn array.reduce(function(max, value) {\n\t\t\t\tif (!isNaN(value)) {\n\t\t\t\t\treturn Math.max(max, value);\n\t\t\t\t}\n\t\t\t\treturn max;\n\t\t\t}, Number.NEGATIVE_INFINITY);\n\t\t};\n\t\thelpers$1.min = function(array) {\n\t\t\treturn array.reduce(function(min, value) {\n\t\t\t\tif (!isNaN(value)) {\n\t\t\t\t\treturn Math.min(min, value);\n\t\t\t\t}\n\t\t\t\treturn min;\n\t\t\t}, Number.POSITIVE_INFINITY);\n\t\t};\n\t\thelpers$1.sign = Math.sign ?\n\t\t\tfunction(x) {\n\t\t\t\treturn Math.sign(x);\n\t\t\t} :\n\t\t\tfunction(x) {\n\t\t\t\tx = +x; // convert to a number\n\t\t\t\tif (x === 0 || isNaN(x)) {\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t\treturn x > 0 ? 1 : -1;\n\t\t\t};\n\t\thelpers$1.log10 = Math.log10 ?\n\t\t\tfunction(x) {\n\t\t\t\treturn Math.log10(x);\n\t\t\t} :\n\t\t\tfunction(x) {\n\t\t\t\tvar exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.\n\t\t\t\t// Check for whole powers of 10,\n\t\t\t\t// which due to floating point rounding error should be corrected.\n\t\t\t\tvar powerOf10 = Math.round(exponent);\n\t\t\t\tvar isPowerOf10 = x === Math.pow(10, powerOf10);\n\t\n\t\t\t\treturn isPowerOf10 ? powerOf10 : exponent;\n\t\t\t};\n\t\thelpers$1.toRadians = function(degrees) {\n\t\t\treturn degrees * (Math.PI / 180);\n\t\t};\n\t\thelpers$1.toDegrees = function(radians) {\n\t\t\treturn radians * (180 / Math.PI);\n\t\t};\n\t\n\t\t/**\n\t\t * Returns the number of decimal places\n\t\t * i.e. the number of digits after the decimal point, of the value of this Number.\n\t\t * @param {number} x - A number.\n\t\t * @returns {number} The number of decimal places.\n\t\t * @private\n\t\t */\n\t\thelpers$1._decimalPlaces = function(x) {\n\t\t\tif (!helpers$1.isFinite(x)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar e = 1;\n\t\t\tvar p = 0;\n\t\t\twhile (Math.round(x * e) / e !== x) {\n\t\t\t\te *= 10;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\treturn p;\n\t\t};\n\t\n\t\t// Gets the angle from vertical upright to the point about a centre.\n\t\thelpers$1.getAngleFromPoint = function(centrePoint, anglePoint) {\n\t\t\tvar distanceFromXCenter = anglePoint.x - centrePoint.x;\n\t\t\tvar distanceFromYCenter = anglePoint.y - centrePoint.y;\n\t\t\tvar radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\t\n\t\t\tvar angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\t\n\t\t\tif (angle < (-0.5 * Math.PI)) {\n\t\t\t\tangle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n\t\t\t}\n\t\n\t\t\treturn {\n\t\t\t\tangle: angle,\n\t\t\t\tdistance: radialDistanceFromCenter\n\t\t\t};\n\t\t};\n\t\thelpers$1.distanceBetweenPoints = function(pt1, pt2) {\n\t\t\treturn Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n\t\t};\n\t\n\t\t/**\n\t\t * Provided for backward compatibility, not available anymore\n\t\t * @function Chart.helpers.aliasPixel\n\t\t * @deprecated since version 2.8.0\n\t\t * @todo remove at version 3\n\t\t */\n\t\thelpers$1.aliasPixel = function(pixelWidth) {\n\t\t\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;\n\t\t};\n\t\n\t\t/**\n\t\t * Returns the aligned pixel value to avoid anti-aliasing blur\n\t\t * @param {Chart} chart - The chart instance.\n\t\t * @param {number} pixel - A pixel value.\n\t\t * @param {number} width - The width of the element.\n\t\t * @returns {number} The aligned pixel value.\n\t\t * @private\n\t\t */\n\t\thelpers$1._alignPixel = function(chart, pixel, width) {\n\t\t\tvar devicePixelRatio = chart.currentDevicePixelRatio;\n\t\t\tvar halfWidth = width / 2;\n\t\t\treturn Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n\t\t};\n\t\n\t\thelpers$1.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {\n\t\t\t// Props to Rob Spencer at scaled innovation for his post on splining between points\n\t\t\t// http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\t\n\t\t\t// This function must also respect \"skipped\" points\n\t\n\t\t\tvar previous = firstPoint.skip ? middlePoint : firstPoint;\n\t\t\tvar current = middlePoint;\n\t\t\tvar next = afterPoint.skip ? middlePoint : afterPoint;\n\t\n\t\t\tvar d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\n\t\t\tvar d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n\t\n\t\t\tvar s01 = d01 / (d01 + d12);\n\t\t\tvar s12 = d12 / (d01 + d12);\n\t\n\t\t\t// If all points are the same, s01 & s02 will be inf\n\t\t\ts01 = isNaN(s01) ? 0 : s01;\n\t\t\ts12 = isNaN(s12) ? 0 : s12;\n\t\n\t\t\tvar fa = t * s01; // scaling factor for triangle Ta\n\t\t\tvar fb = t * s12;\n\t\n\t\t\treturn {\n\t\t\t\tprevious: {\n\t\t\t\t\tx: current.x - fa * (next.x - previous.x),\n\t\t\t\t\ty: current.y - fa * (next.y - previous.y)\n\t\t\t\t},\n\t\t\t\tnext: {\n\t\t\t\t\tx: current.x + fb * (next.x - previous.x),\n\t\t\t\t\ty: current.y + fb * (next.y - previous.y)\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\thelpers$1.EPSILON = Number.EPSILON || 1e-14;\n\t\thelpers$1.splineCurveMonotone = function(points) {\n\t\t\t// This function calculates Bzier control points in a similar way than |splineCurve|,\n\t\t\t// but preserves monotonicity of the provided data and ensures no local extremums are added\n\t\t\t// between the dataset discrete points due to the interpolation.\n\t\t\t// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n\t\n\t\t\tvar pointsWithTangents = (points || []).map(function(point) {\n\t\t\t\treturn {\n\t\t\t\t\tmodel: point._model,\n\t\t\t\t\tdeltaK: 0,\n\t\t\t\t\tmK: 0\n\t\t\t\t};\n\t\t\t});\n\t\n\t\t\t// Calculate slopes (deltaK) and initialize tangents (mK)\n\t\t\tvar pointsLen = pointsWithTangents.length;\n\t\t\tvar i, pointBefore, pointCurrent, pointAfter;\n\t\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\t\tvar slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);\n\t\n\t\t\t\t\t// In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n\t\t\t\t\tpointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\n\t\t\t\t}\n\t\n\t\t\t\tif (!pointBefore || pointBefore.model.skip) {\n\t\t\t\t\tpointCurrent.mK = pointCurrent.deltaK;\n\t\t\t\t} else if (!pointAfter || pointAfter.model.skip) {\n\t\t\t\t\tpointCurrent.mK = pointBefore.deltaK;\n\t\t\t\t} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\n\t\t\t\t\tpointCurrent.mK = 0;\n\t\t\t\t} else {\n\t\t\t\t\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Adjust tangents to ensure monotonic properties\n\t\t\tvar alphaK, betaK, tauK, squaredMagnitude;\n\t\t\tfor (i = 0; i < pointsLen - 1; ++i) {\n\t\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\t\tpointAfter = pointsWithTangents[i + 1];\n\t\t\t\tif (pointCurrent.model.skip || pointAfter.model.skip) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tif (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\n\t\t\t\t\tpointCurrent.mK = pointAfter.mK = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\talphaK = pointCurrent.mK / pointCurrent.deltaK;\n\t\t\t\tbetaK = pointAfter.mK / pointCurrent.deltaK;\n\t\t\t\tsquaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\t\t\t\tif (squaredMagnitude <= 9) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\ttauK = 3 / Math.sqrt(squaredMagnitude);\n\t\t\t\tpointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\n\t\t\t\tpointAfter.mK = betaK * tauK * pointCurrent.deltaK;\n\t\t\t}\n\t\n\t\t\t// Compute control points\n\t\t\tvar deltaX;\n\t\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\t\tif (pointBefore && !pointBefore.model.skip) {\n\t\t\t\t\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\n\t\t\t\t\tpointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\n\t\t\t\t\tpointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\n\t\t\t\t}\n\t\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\t\tdeltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\n\t\t\t\t\tpointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\n\t\t\t\t\tpointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\thelpers$1.nextItem = function(collection, index, loop) {\n\t\t\tif (loop) {\n\t\t\t\treturn index >= collection.length - 1 ? collection[0] : collection[index + 1];\n\t\t\t}\n\t\t\treturn index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\n\t\t};\n\t\thelpers$1.previousItem = function(collection, index, loop) {\n\t\t\tif (loop) {\n\t\t\t\treturn index <= 0 ? collection[collection.length - 1] : collection[index - 1];\n\t\t\t}\n\t\t\treturn index <= 0 ? collection[0] : collection[index - 1];\n\t\t};\n\t\t// Implementation of the nice number algorithm used in determining where axis labels will go\n\t\thelpers$1.niceNum = function(range, round) {\n\t\t\tvar exponent = Math.floor(helpers$1.log10(range));\n\t\t\tvar fraction = range / Math.pow(10, exponent);\n\t\t\tvar niceFraction;\n\t\n\t\t\tif (round) {\n\t\t\t\tif (fraction < 1.5) {\n\t\t\t\t\tniceFraction = 1;\n\t\t\t\t} else if (fraction < 3) {\n\t\t\t\t\tniceFraction = 2;\n\t\t\t\t} else if (fraction < 7) {\n\t\t\t\t\tniceFraction = 5;\n\t\t\t\t} else {\n\t\t\t\t\tniceFraction = 10;\n\t\t\t\t}\n\t\t\t} else if (fraction <= 1.0) {\n\t\t\t\tniceFraction = 1;\n\t\t\t} else if (fraction <= 2) {\n\t\t\t\tniceFraction = 2;\n\t\t\t} else if (fraction <= 5) {\n\t\t\t\tniceFraction = 5;\n\t\t\t} else {\n\t\t\t\tniceFraction = 10;\n\t\t\t}\n\t\n\t\t\treturn niceFraction * Math.pow(10, exponent);\n\t\t};\n\t\t// Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n\t\thelpers$1.requestAnimFrame = (function() {\n\t\t\tif (typeof window === 'undefined') {\n\t\t\t\treturn function(callback) {\n\t\t\t\t\tcallback();\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn window.requestAnimationFrame ||\n\t\t\t\twindow.webkitRequestAnimationFrame ||\n\t\t\t\twindow.mozRequestAnimationFrame ||\n\t\t\t\twindow.oRequestAnimationFrame ||\n\t\t\t\twindow.msRequestAnimationFrame ||\n\t\t\t\tfunction(callback) {\n\t\t\t\t\treturn window.setTimeout(callback, 1000 / 60);\n\t\t\t\t};\n\t\t}());\n\t\t// -- DOM methods\n\t\thelpers$1.getRelativePosition = function(evt, chart) {\n\t\t\tvar mouseX, mouseY;\n\t\t\tvar e = evt.originalEvent || evt;\n\t\t\tvar canvas = evt.target || evt.srcElement;\n\t\t\tvar boundingRect = canvas.getBoundingClientRect();\n\t\n\t\t\tvar touches = e.touches;\n\t\t\tif (touches && touches.length > 0) {\n\t\t\t\tmouseX = touches[0].clientX;\n\t\t\t\tmouseY = touches[0].clientY;\n\t\n\t\t\t} else {\n\t\t\t\tmouseX = e.clientX;\n\t\t\t\tmouseY = e.clientY;\n\t\t\t}\n\t\n\t\t\t// Scale mouse coordinates into canvas coordinates\n\t\t\t// by following the pattern laid out by 'jerryj' in the comments of\n\t\t\t// https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\n\t\t\tvar paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));\n\t\t\tvar paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));\n\t\t\tvar paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));\n\t\t\tvar paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));\n\t\t\tvar width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\n\t\t\tvar height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\n\t\n\t\t\t// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\n\t\t\t// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\n\t\t\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);\n\t\t\tmouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\n\t\n\t\t\treturn {\n\t\t\t\tx: mouseX,\n\t\t\t\ty: mouseY\n\t\t\t};\n\t\n\t\t};\n\t\n\t\t// Private helper function to convert max-width/max-height values that may be percentages into a number\n\t\tfunction parseMaxStyle(styleValue, node, parentProperty) {\n\t\t\tvar valueInPixels;\n\t\t\tif (typeof styleValue === 'string') {\n\t\t\t\tvalueInPixels = parseInt(styleValue, 10);\n\t\n\t\t\t\tif (styleValue.indexOf('%') !== -1) {\n\t\t\t\t\t// percentage * size in dimension\n\t\t\t\t\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvalueInPixels = styleValue;\n\t\t\t}\n\t\n\t\t\treturn valueInPixels;\n\t\t}\n\t\n\t\t/**\n\t\t * Returns if the given value contains an effective constraint.\n\t\t * @private\n\t\t */\n\t\tfunction isConstrainedValue(value) {\n\t\t\treturn value !== undefined && value !== null && value !== 'none';\n\t\t}\n\t\n\t\t/**\n\t\t * Returns the max width or height of the given DOM node in a cross-browser compatible fashion\n\t\t * @param {HTMLElement} domNode - the node to check the constraint on\n\t\t * @param {string} maxStyle - the style that defines the maximum for the direction we are using ('max-width' / 'max-height')\n\t\t * @param {string} percentageProperty - property of parent to use when calculating width as a percentage\n\t\t * @see {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}\n\t\t */\n\t\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\n\t\t\tvar view = document.defaultView;\n\t\t\tvar parentNode = helpers$1._getParentNode(domNode);\n\t\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\n\t\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\n\t\t\tvar hasCNode = isConstrainedValue(constrainedNode);\n\t\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);\n\t\t\tvar infinity = Number.POSITIVE_INFINITY;\n\t\n\t\t\tif (hasCNode || hasCContainer) {\n\t\t\t\treturn Math.min(\n\t\t\t\t\thasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\n\t\t\t\t\thasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\n\t\t\t}\n\t\n\t\t\treturn 'none';\n\t\t}\n\t\t// returns Number or undefined if no constraint\n\t\thelpers$1.getConstraintWidth = function(domNode) {\n\t\t\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');\n\t\t};\n\t\t// returns Number or undefined if no constraint\n\t\thelpers$1.getConstraintHeight = function(domNode) {\n\t\t\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');\n\t\t};\n\t\t/**\n\t\t * @private\n\t \t */\n\t\thelpers$1._calculatePadding = function(container, padding, parentDimension) {\n\t\t\tpadding = helpers$1.getStyle(container, padding);\n\t\n\t\t\treturn padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);\n\t\t};\n\t\t/**\n\t\t * @private\n\t\t */\n\t\thelpers$1._getParentNode = function(domNode) {\n\t\t\tvar parent = domNode.parentNode;\n\t\t\tif (parent && parent.toString() === '[object ShadowRoot]') {\n\t\t\t\tparent = parent.host;\n\t\t\t}\n\t\t\treturn parent;\n\t\t};\n\t\thelpers$1.getMaximumWidth = function(domNode) {\n\t\t\tvar container = helpers$1._getParentNode(domNode);\n\t\t\tif (!container) {\n\t\t\t\treturn domNode.clientWidth;\n\t\t\t}\n\t\n\t\t\tvar clientWidth = container.clientWidth;\n\t\t\tvar paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);\n\t\t\tvar paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);\n\t\n\t\t\tvar w = clientWidth - paddingLeft - paddingRight;\n\t\t\tvar cw = helpers$1.getConstraintWidth(domNode);\n\t\t\treturn isNaN(cw) ? w : Math.min(w, cw);\n\t\t};\n\t\thelpers$1.getMaximumHeight = function(domNode) {\n\t\t\tvar container = helpers$1._getParentNode(domNode);\n\t\t\tif (!container) {\n\t\t\t\treturn domNode.clientHeight;\n\t\t\t}\n\t\n\t\t\tvar clientHeight = container.clientHeight;\n\t\t\tvar paddingTop = helpers$1._calculatePadding(container, 'padding-top', clientHeight);\n\t\t\tvar paddingBottom = helpers$1._calculatePadding(container, 'padding-bottom', clientHeight);\n\t\n\t\t\tvar h = clientHeight - paddingTop - paddingBottom;\n\t\t\tvar ch = helpers$1.getConstraintHeight(domNode);\n\t\t\treturn isNaN(ch) ? h : Math.min(h, ch);\n\t\t};\n\t\thelpers$1.getStyle = function(el, property) {\n\t\t\treturn el.currentStyle ?\n\t\t\t\tel.currentStyle[property] :\n\t\t\t\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);\n\t\t};\n\t\thelpers$1.retinaScale = function(chart, forceRatio) {\n\t\t\tvar pixelRatio = chart.currentDevicePixelRatio = forceRatio || (typeof window !== 'undefined' && window.devicePixelRatio) || 1;\n\t\t\tif (pixelRatio === 1) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar canvas = chart.canvas;\n\t\t\tvar height = chart.height;\n\t\t\tvar width = chart.width;\n\t\n\t\t\tcanvas.height = height * pixelRatio;\n\t\t\tcanvas.width = width * pixelRatio;\n\t\t\tchart.ctx.scale(pixelRatio, pixelRatio);\n\t\n\t\t\t// If no style has been set on the canvas, the render size is used as display size,\n\t\t\t// making the chart visually bigger, so let's enforce it to the \"correct\" values.\n\t\t\t// See https://github.com/chartjs/Chart.js/issues/3575\n\t\t\tif (!canvas.style.height && !canvas.style.width) {\n\t\t\t\tcanvas.style.height = height + 'px';\n\t\t\t\tcanvas.style.width = width + 'px';\n\t\t\t}\n\t\t};\n\t\t// -- Canvas methods\n\t\thelpers$1.fontString = function(pixelSize, fontStyle, fontFamily) {\n\t\t\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n\t\t};\n\t\thelpers$1.longestText = function(ctx, font, arrayOfThings, cache) {\n\t\t\tcache = cache || {};\n\t\t\tvar data = cache.data = cache.data || {};\n\t\t\tvar gc = cache.garbageCollect = cache.garbageCollect || [];\n\t\n\t\t\tif (cache.font !== font) {\n\t\t\t\tdata = cache.data = {};\n\t\t\t\tgc = cache.garbageCollect = [];\n\t\t\t\tcache.font = font;\n\t\t\t}\n\t\n\t\t\tctx.font = font;\n\t\t\tvar longest = 0;\n\t\t\thelpers$1.each(arrayOfThings, function(thing) {\n\t\t\t\t// Undefined strings and arrays should not be measured\n\t\t\t\tif (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {\n\t\t\t\t\tlongest = helpers$1.measureText(ctx, data, gc, longest, thing);\n\t\t\t\t} else if (helpers$1.isArray(thing)) {\n\t\t\t\t\t// if it is an array lets measure each element\n\t\t\t\t\t// to do maybe simplify this function a bit so we can do this more recursively?\n\t\t\t\t\thelpers$1.each(thing, function(nestedThing) {\n\t\t\t\t\t\t// Undefined strings and arrays should not be measured\n\t\t\t\t\t\tif (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {\n\t\t\t\t\t\t\tlongest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tvar gcLen = gc.length / 2;\n\t\t\tif (gcLen > arrayOfThings.length) {\n\t\t\t\tfor (var i = 0; i < gcLen; i++) {\n\t\t\t\t\tdelete data[gc[i]];\n\t\t\t\t}\n\t\t\t\tgc.splice(0, gcLen);\n\t\t\t}\n\t\t\treturn longest;\n\t\t};\n\t\thelpers$1.measureText = function(ctx, data, gc, longest, string) {\n\t\t\tvar textWidth = data[string];\n\t\t\tif (!textWidth) {\n\t\t\t\ttextWidth = data[string] = ctx.measureText(string).width;\n\t\t\t\tgc.push(string);\n\t\t\t}\n\t\t\tif (textWidth > longest) {\n\t\t\t\tlongest = textWidth;\n\t\t\t}\n\t\t\treturn longest;\n\t\t};\n\t\thelpers$1.numberOfLabelLines = function(arrayOfThings) {\n\t\t\tvar numberOfLines = 1;\n\t\t\thelpers$1.each(arrayOfThings, function(thing) {\n\t\t\t\tif (helpers$1.isArray(thing)) {\n\t\t\t\t\tif (thing.length > numberOfLines) {\n\t\t\t\t\t\tnumberOfLines = thing.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn numberOfLines;\n\t\t};\n\t\n\t\thelpers$1.color = !chartjsColor ?\n\t\t\tfunction(value) {\n\t\t\t\tconsole.error('Color.js not found!');\n\t\t\t\treturn value;\n\t\t\t} :\n\t\t\tfunction(value) {\n\t\t\t\t/* global CanvasGradient */\n\t\t\t\tif (value instanceof CanvasGradient) {\n\t\t\t\t\tvalue = core_defaults.global.defaultColor;\n\t\t\t\t}\n\t\n\t\t\t\treturn chartjsColor(value);\n\t\t\t};\n\t\n\t\thelpers$1.getHoverColor = function(colorValue) {\n\t\t\t/* global CanvasPattern */\n\t\t\treturn (colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient) ?\n\t\t\t\tcolorValue :\n\t\t\t\thelpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();\n\t\t};\n\t};\n\t\n\tfunction abstract() {\n\t\tthrow new Error(\n\t\t\t'This method is not implemented: either no adapter can ' +\n\t\t\t'be found or an incomplete integration was provided.'\n\t\t);\n\t}\n\t\n\t/**\n\t * Date adapter (current used by the time scale)\n\t * @namespace Chart._adapters._date\n\t * @memberof Chart._adapters\n\t * @private\n\t */\n\t\n\t/**\n\t * Currently supported unit string values.\n\t * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}\n\t * @memberof Chart._adapters._date\n\t * @name Unit\n\t */\n\t\n\t/**\n\t * @class\n\t */\n\tfunction DateAdapter(options) {\n\t\tthis.options = options || {};\n\t}\n\t\n\thelpers$1.extend(DateAdapter.prototype, /** @lends DateAdapter */ {\n\t\t/**\n\t\t * Returns a map of time formats for the supported formatting units defined\n\t\t * in Unit as well as 'datetime' representing a detailed date/time string.\n\t\t * @returns {{string: string}}\n\t\t */\n\t\tformats: abstract,\n\t\n\t\t/**\n\t\t * Parses the given `value` and return the associated timestamp.\n\t\t * @param {any} value - the value to parse (usually comes from the data)\n\t\t * @param {string} [format] - the expected data format\n\t\t * @returns {(number|null)}\n\t\t * @function\n\t\t */\n\t\tparse: abstract,\n\t\n\t\t/**\n\t\t * Returns the formatted date in the specified `format` for a given `timestamp`.\n\t\t * @param {number} timestamp - the timestamp to format\n\t\t * @param {string} format - the date/time token\n\t\t * @return {string}\n\t\t * @function\n\t\t */\n\t\tformat: abstract,\n\t\n\t\t/**\n\t\t * Adds the specified `amount` of `unit` to the given `timestamp`.\n\t\t * @param {number} timestamp - the input timestamp\n\t\t * @param {number} amount - the amount to add\n\t\t * @param {Unit} unit - the unit as string\n\t\t * @return {number}\n\t\t * @function\n\t\t */\n\t\tadd: abstract,\n\t\n\t\t/**\n\t\t * Returns the number of `unit` between the given timestamps.\n\t\t * @param {number} max - the input timestamp (reference)\n\t\t * @param {number} min - the timestamp to substract\n\t\t * @param {Unit} unit - the unit as string\n\t\t * @return {number}\n\t\t * @function\n\t\t */\n\t\tdiff: abstract,\n\t\n\t\t/**\n\t\t * Returns start of `unit` for the given `timestamp`.\n\t\t * @param {number} timestamp - the input timestamp\n\t\t * @param {Unit} unit - the unit as string\n\t\t * @param {number} [weekday] - the ISO day of the week with 1 being Monday\n\t\t * and 7 being Sunday (only needed if param *unit* is `isoWeek`).\n\t\t * @function\n\t\t */\n\t\tstartOf: abstract,\n\t\n\t\t/**\n\t\t * Returns end of `unit` for the given `timestamp`.\n\t\t * @param {number} timestamp - the input timestamp\n\t\t * @param {Unit} unit - the unit as string\n\t\t * @function\n\t\t */\n\t\tendOf: abstract,\n\t\n\t\t// DEPRECATIONS\n\t\n\t\t/**\n\t\t * Provided for backward compatibility for scale.getValueForPixel(),\n\t\t * this method should be overridden only by the moment adapter.\n\t\t * @deprecated since version 2.8.0\n\t\t * @todo remove at version 3\n\t\t * @private\n\t\t */\n\t\t_create: function(value) {\n\t\t\treturn value;\n\t\t}\n\t});\n\t\n\tDateAdapter.override = function(members) {\n\t\thelpers$1.extend(DateAdapter.prototype, members);\n\t};\n\t\n\tvar _date = DateAdapter;\n\t\n\tvar core_adapters = {\n\t\t_date: _date\n\t};\n\t\n\t/**\n\t * Namespace to hold static tick generation functions\n\t * @namespace Chart.Ticks\n\t */\n\tvar core_ticks = {\n\t\t/**\n\t\t * Namespace to hold formatters for different types of ticks\n\t\t * @namespace Chart.Ticks.formatters\n\t\t */\n\t\tformatters: {\n\t\t\t/**\n\t\t\t * Formatter for value labels\n\t\t\t * @method Chart.Ticks.formatters.values\n\t\t\t * @param value the value to display\n\t\t\t * @return {string|string[]} the label to display\n\t\t\t */\n\t\t\tvalues: function(value) {\n\t\t\t\treturn helpers$1.isArray(value) ? value : '' + value;\n\t\t\t},\n\t\n\t\t\t/**\n\t\t\t * Formatter for linear numeric ticks\n\t\t\t * @method Chart.Ticks.formatters.linear\n\t\t\t * @param tickValue {number} the value to be formatted\n\t\t\t * @param index {number} the position of the tickValue parameter in the ticks array\n\t\t\t * @param ticks {number[]} the list of ticks being converted\n\t\t\t * @return {string} string representation of the tickValue parameter\n\t\t\t */\n\t\t\tlinear: function(tickValue, index, ticks) {\n\t\t\t\t// If we have lots of ticks, don't use the ones\n\t\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n\t\n\t\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\t\t\t\tif (Math.abs(delta) > 1) {\n\t\t\t\t\tif (tickValue !== Math.floor(tickValue)) {\n\t\t\t\t\t\t// not an integer\n\t\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tvar logDelta = helpers$1.log10(Math.abs(delta));\n\t\t\t\tvar tickString = '';\n\t\n\t\t\t\tif (tickValue !== 0) {\n\t\t\t\t\tvar maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));\n\t\t\t\t\tif (maxTick < 1e-4) { // all ticks are small numbers; use scientific notation\n\t\t\t\t\t\tvar logTick = helpers$1.log10(Math.abs(tickValue));\n\t\t\t\t\t\ttickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\n\t\t\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\t\t\t\t\t\ttickString = tickValue.toFixed(numDecimal);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttickString = '0'; // never show decimal places for 0\n\t\t\t\t}\n\t\n\t\t\t\treturn tickString;\n\t\t\t},\n\t\n\t\t\tlogarithmic: function(tickValue, index, ticks) {\n\t\t\t\tvar remain = tickValue / (Math.pow(10, Math.floor(helpers$1.log10(tickValue))));\n\t\n\t\t\t\tif (tickValue === 0) {\n\t\t\t\t\treturn '0';\n\t\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n\t\t\t\t\treturn tickValue.toExponential();\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\t\t}\n\t};\n\t\n\tvar valueOrDefault$9 = helpers$1.valueOrDefault;\n\tvar valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;\n\t\n\tcore_defaults._set('scale', {\n\t\tdisplay: true,\n\t\tposition: 'left',\n\t\toffset: false,\n\t\n\t\t// grid line settings\n\t\tgridLines: {\n\t\t\tdisplay: true,\n\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\tlineWidth: 1,\n\t\t\tdrawBorder: true,\n\t\t\tdrawOnChartArea: true,\n\t\t\tdrawTicks: true,\n\t\t\ttickMarkLength: 10,\n\t\t\tzeroLineWidth: 1,\n\t\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\n\t\t\tzeroLineBorderDash: [],\n\t\t\tzeroLineBorderDashOffset: 0.0,\n\t\t\toffsetGridLines: false,\n\t\t\tborderDash: [],\n\t\t\tborderDashOffset: 0.0\n\t\t},\n\t\n\t\t// scale label\n\t\tscaleLabel: {\n\t\t\t// display property\n\t\t\tdisplay: false,\n\t\n\t\t\t// actual label\n\t\t\tlabelString: '',\n\t\n\t\t\t// top/bottom padding\n\t\t\tpadding: {\n\t\t\t\ttop: 4,\n\t\t\t\tbottom: 4\n\t\t\t}\n\t\t},\n\t\n\t\t// label settings\n\t\tticks: {\n\t\t\tbeginAtZero: false,\n\t\t\tminRotation: 0,\n\t\t\tmaxRotation: 50,\n\t\t\tmirror: false,\n\t\t\tpadding: 0,\n\t\t\treverse: false,\n\t\t\tdisplay: true,\n\t\t\tautoSkip: true,\n\t\t\tautoSkipPadding: 0,\n\t\t\tlabelOffset: 0,\n\t\t\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n\t\t\tcallback: core_ticks.formatters.values,\n\t\t\tminor: {},\n\t\t\tmajor: {}\n\t\t}\n\t});\n\t\n\tfunction labelsFromTicks(ticks) {\n\t\tvar labels = [];\n\t\tvar i, ilen;\n\t\n\t\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\t\tlabels.push(ticks[i].label);\n\t\t}\n\t\n\t\treturn labels;\n\t}\n\t\n\tfunction getPixelForGridLine(scale, index, offsetGridLines) {\n\t\tvar lineValue = scale.getPixelForTick(index);\n\t\n\t\tif (offsetGridLines) {\n\t\t\tif (scale.getTicks().length === 1) {\n\t\t\t\tlineValue -= scale.isHorizontal() ?\n\t\t\t\t\tMath.max(lineValue - scale.left, scale.right - lineValue) :\n\t\t\t\t\tMath.max(lineValue - scale.top, scale.bottom - lineValue);\n\t\t\t} else if (index === 0) {\n\t\t\t\tlineValue -= (scale.getPixelForTick(1) - lineValue) / 2;\n\t\t\t} else {\n\t\t\t\tlineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;\n\t\t\t}\n\t\t}\n\t\treturn lineValue;\n\t}\n\t\n\tfunction computeTextSize(context, tick, font) {\n\t\treturn helpers$1.isArray(tick) ?\n\t\t\thelpers$1.longestText(context, font, tick) :\n\t\t\tcontext.measureText(tick).width;\n\t}\n\t\n\tvar core_scale = core_element.extend({\n\t\t/**\n\t\t * Get the padding needed for the scale\n\t\t * @method getPadding\n\t\t * @private\n\t\t * @returns {Padding} the necessary padding\n\t\t */\n\t\tgetPadding: function() {\n\t\t\tvar me = this;\n\t\t\treturn {\n\t\t\t\tleft: me.paddingLeft || 0,\n\t\t\t\ttop: me.paddingTop || 0,\n\t\t\t\tright: me.paddingRight || 0,\n\t\t\t\tbottom: me.paddingBottom || 0\n\t\t\t};\n\t\t},\n\t\n\t\t/**\n\t\t * Returns the scale tick objects ({label, major})\n\t\t * @since 2.7\n\t\t */\n\t\tgetTicks: function() {\n\t\t\treturn this._ticks;\n\t\t},\n\t\n\t\t// These methods are ordered by lifecyle. Utilities then follow.\n\t\t// Any function defined here is inherited by all scale types.\n\t\t// Any function can be extended by the scale type\n\t\n\t\tmergeTicksOptions: function() {\n\t\t\tvar ticks = this.options.ticks;\n\t\t\tif (ticks.minor === false) {\n\t\t\t\tticks.minor = {\n\t\t\t\t\tdisplay: false\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (ticks.major === false) {\n\t\t\t\tticks.major = {\n\t\t\t\t\tdisplay: false\n\t\t\t\t};\n\t\t\t}\n\t\t\tfor (var key in ticks) {\n\t\t\t\tif (key !== 'major' && key !== 'minor') {\n\t\t\t\t\tif (typeof ticks.minor[key] === 'undefined') {\n\t\t\t\t\t\tticks.minor[key] = ticks[key];\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof ticks.major[key] === 'undefined') {\n\t\t\t\t\t\tticks.major[key] = ticks[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbeforeUpdate: function() {\n\t\t\thelpers$1.callback(this.options.beforeUpdate, [this]);\n\t\t},\n\t\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\t\t\tvar i, ilen, labels, label, ticks, tick;\n\t\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\t\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = helpers$1.extend({\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttop: 0,\n\t\t\t\tbottom: 0\n\t\t\t}, margins);\n\t\n\t\t\tme._maxLabelLines = 0;\n\t\t\tme.longestLabelWidth = 0;\n\t\t\tme.longestTextCache = me.longestTextCache || {};\n\t\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\t\n\t\t\t// Data min/max\n\t\t\tme.beforeDataLimits();\n\t\t\tme.determineDataLimits();\n\t\t\tme.afterDataLimits();\n\t\n\t\t\t// Ticks - `this.ticks` is now DEPRECATED!\n\t\t\t// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member\n\t\t\t// and must not be accessed directly from outside this class. `this.ticks` being\n\t\t\t// around for long time and not marked as private, we can't change its structure\n\t\t\t// without unexpected breaking changes. If you need to access the scale ticks,\n\t\t\t// use scale.getTicks() instead.\n\t\n\t\t\tme.beforeBuildTicks();\n\t\n\t\t\t// New implementations should return an array of objects but for BACKWARD COMPAT,\n\t\t\t// we still support no return (`this.ticks` internally set by calling this method).\n\t\t\tticks = me.buildTicks() || [];\n\t\n\t\t\t// Allow modification of ticks in callback.\n\t\t\tticks = me.afterBuildTicks(ticks) || ticks;\n\t\n\t\t\tme.beforeTickToLabelConversion();\n\t\n\t\t\t// New implementations should return the formatted tick labels but for BACKWARD\n\t\t\t// COMPAT, we still support no return (`this.ticks` internally changed by calling\n\t\t\t// this method and supposed to contain only string values).\n\t\t\tlabels = me.convertTicksToLabels(ticks) || me.ticks;\n\t\n\t\t\tme.afterTickToLabelConversion();\n\t\n\t\t\tme.ticks = labels;   // BACKWARD COMPATIBILITY\n\t\n\t\t\t// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!\n\t\n\t\t\t// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)\n\t\t\tfor (i = 0, ilen = labels.length; i < ilen; ++i) {\n\t\t\t\tlabel = labels[i];\n\t\t\t\ttick = ticks[i];\n\t\t\t\tif (!tick) {\n\t\t\t\t\tticks.push(tick = {\n\t\t\t\t\t\tlabel: label,\n\t\t\t\t\t\tmajor: false\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttick.label = label;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tme._ticks = ticks;\n\t\n\t\t\t// Tick Rotation\n\t\t\tme.beforeCalculateTickRotation();\n\t\t\tme.calculateTickRotation();\n\t\t\tme.afterCalculateTickRotation();\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\t\n\t\t\treturn me.minSize;\n\t\n\t\t},\n\t\tafterUpdate: function() {\n\t\t\thelpers$1.callback(this.options.afterUpdate, [this]);\n\t\t},\n\t\n\t\t//\n\t\n\t\tbeforeSetDimensions: function() {\n\t\t\thelpers$1.callback(this.options.beforeSetDimensions, [this]);\n\t\t},\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\t\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\t\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\t\t},\n\t\tafterSetDimensions: function() {\n\t\t\thelpers$1.callback(this.options.afterSetDimensions, [this]);\n\t\t},\n\t\n\t\t// Data limits\n\t\tbeforeDataLimits: function() {\n\t\t\thelpers$1.callback(this.options.beforeDataLimits, [this]);\n\t\t},\n\t\tdetermineDataLimits: helpers$1.noop,\n\t\tafterDataLimits: function() {\n\t\t\thelpers$1.callback(this.options.afterDataLimits, [this]);\n\t\t},\n\t\n\t\t//\n\t\tbeforeBuildTicks: function() {\n\t\t\thelpers$1.callback(this.options.beforeBuildTicks, [this]);\n\t\t},\n\t\tbuildTicks: helpers$1.noop,\n\t\tafterBuildTicks: function(ticks) {\n\t\t\tvar me = this;\n\t\t\t// ticks is empty for old axis implementations here\n\t\t\tif (helpers$1.isArray(ticks) && ticks.length) {\n\t\t\t\treturn helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);\n\t\t\t}\n\t\t\t// Support old implementations (that modified `this.ticks` directly in buildTicks)\n\t\t\tme.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;\n\t\t\treturn ticks;\n\t\t},\n\t\n\t\tbeforeTickToLabelConversion: function() {\n\t\t\thelpers$1.callback(this.options.beforeTickToLabelConversion, [this]);\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\t// Convert ticks to strings\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tme.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\n\t\t},\n\t\tafterTickToLabelConversion: function() {\n\t\t\thelpers$1.callback(this.options.afterTickToLabelConversion, [this]);\n\t\t},\n\t\n\t\t//\n\t\n\t\tbeforeCalculateTickRotation: function() {\n\t\t\thelpers$1.callback(this.options.beforeCalculateTickRotation, [this]);\n\t\t},\n\t\tcalculateTickRotation: function() {\n\t\t\tvar me = this;\n\t\t\tvar context = me.ctx;\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tvar labels = labelsFromTicks(me._ticks);\n\t\n\t\t\t// Get the width of each grid by calculating the difference\n\t\t\t// between x offsets between 0 and 1.\n\t\t\tvar tickFont = helpers$1.options._parseFont(tickOpts);\n\t\t\tcontext.font = tickFont.string;\n\t\n\t\t\tvar labelRotation = tickOpts.minRotation || 0;\n\t\n\t\t\tif (labels.length && me.options.display && me.isHorizontal()) {\n\t\t\t\tvar originalLabelWidth = helpers$1.longestText(context, tickFont.string, labels, me.longestTextCache);\n\t\t\t\tvar labelWidth = originalLabelWidth;\n\t\t\t\tvar cosRotation, sinRotation;\n\t\n\t\t\t\t// Allow 3 pixels x2 padding either side for label readability\n\t\t\t\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n\t\n\t\t\t\t// Max label rotation can be set or default to 90 - also act as a loop counter\n\t\t\t\twhile (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n\t\t\t\t\tvar angleRadians = helpers$1.toRadians(labelRotation);\n\t\t\t\t\tcosRotation = Math.cos(angleRadians);\n\t\t\t\t\tsinRotation = Math.sin(angleRadians);\n\t\n\t\t\t\t\tif (sinRotation * originalLabelWidth > me.maxHeight) {\n\t\t\t\t\t\t// go back one step\n\t\t\t\t\t\tlabelRotation--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tlabelRotation++;\n\t\t\t\t\tlabelWidth = cosRotation * originalLabelWidth;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tme.labelRotation = labelRotation;\n\t\t},\n\t\tafterCalculateTickRotation: function() {\n\t\t\thelpers$1.callback(this.options.afterCalculateTickRotation, [this]);\n\t\t},\n\t\n\t\t//\n\t\n\t\tbeforeFit: function() {\n\t\t\thelpers$1.callback(this.options.beforeFit, [this]);\n\t\t},\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\t// Reset\n\t\t\tvar minSize = me.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\n\t\t\tvar labels = labelsFromTicks(me._ticks);\n\t\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar scaleLabelOpts = opts.scaleLabel;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar display = me._isVisible();\n\t\t\tvar position = opts.position;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\n\t\t\tvar parseFont = helpers$1.options._parseFont;\n\t\t\tvar tickFont = parseFont(tickOpts);\n\t\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\n\t\n\t\t\t// Width\n\t\t\tif (isHorizontal) {\n\t\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\n\t\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n\t\t\t} else {\n\t\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t}\n\t\n\t\t\t// height\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t} else {\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\t\n\t\t\t// Are we showing a title for the scale?\n\t\t\tif (scaleLabelOpts.display && display) {\n\t\t\t\tvar scaleLabelFont = parseFont(scaleLabelOpts);\n\t\t\t\tvar scaleLabelPadding = helpers$1.options.toPadding(scaleLabelOpts.padding);\n\t\t\t\tvar deltaHeight = scaleLabelFont.lineHeight + scaleLabelPadding.height;\n\t\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize.height += deltaHeight;\n\t\t\t\t} else {\n\t\t\t\t\tminSize.width += deltaHeight;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Don't bother fitting the ticks if we are not showing the labels\n\t\t\tif (tickOpts.display && display) {\n\t\t\t\tvar largestTextWidth = helpers$1.longestText(me.ctx, tickFont.string, labels, me.longestTextCache);\n\t\t\t\tvar tallestLabelHeightInLines = helpers$1.numberOfLabelLines(labels);\n\t\t\t\tvar lineSpace = tickFont.size * 0.5;\n\t\t\t\tvar tickPadding = me.options.ticks.padding;\n\t\n\t\t\t\t// Store max number of lines and widest label for _autoSkip\n\t\t\t\tme._maxLabelLines = tallestLabelHeightInLines;\n\t\t\t\tme.longestLabelWidth = largestTextWidth;\n\t\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tvar angleRadians = helpers$1.toRadians(me.labelRotation);\n\t\t\t\t\tvar cosRotation = Math.cos(angleRadians);\n\t\t\t\t\tvar sinRotation = Math.sin(angleRadians);\n\t\n\t\t\t\t\t// TODO - improve this calculation\n\t\t\t\t\tvar labelHeight = (sinRotation * largestTextWidth)\n\t\t\t\t\t\t+ (tickFont.lineHeight * tallestLabelHeightInLines)\n\t\t\t\t\t\t+ lineSpace; // padding\n\t\n\t\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n\t\n\t\t\t\t\tme.ctx.font = tickFont.string;\n\t\t\t\t\tvar firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.string);\n\t\t\t\t\tvar lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.string);\n\t\t\t\t\tvar offsetLeft = me.getPixelForTick(0) - me.left;\n\t\t\t\t\tvar offsetRight = me.right - me.getPixelForTick(labels.length - 1);\n\t\t\t\t\tvar paddingLeft, paddingRight;\n\t\n\t\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n\t\t\t\t\t// which means that the right padding is dominated by the font height\n\t\t\t\t\tif (me.labelRotation !== 0) {\n\t\t\t\t\t\tpaddingLeft = position === 'bottom' ? (cosRotation * firstLabelWidth) : (cosRotation * lineSpace);\n\t\t\t\t\t\tpaddingRight = position === 'bottom' ? (cosRotation * lineSpace) : (cosRotation * lastLabelWidth);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpaddingLeft = firstLabelWidth / 2;\n\t\t\t\t\t\tpaddingRight = lastLabelWidth / 2;\n\t\t\t\t\t}\n\t\t\t\t\tme.paddingLeft = Math.max(paddingLeft - offsetLeft, 0) + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\tme.paddingRight = Math.max(paddingRight - offsetRight, 0) + 3;\n\t\t\t\t} else {\n\t\t\t\t\t// A vertical axis is more constrained by the width. Labels are the\n\t\t\t\t\t// dominant factor here, so get that length first and account for padding\n\t\t\t\t\tif (tickOpts.mirror) {\n\t\t\t\t\t\tlargestTextWidth = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// use lineSpace for consistency with horizontal axis\n\t\t\t\t\t\t// tickPadding is not implemented for horizontal\n\t\t\t\t\t\tlargestTextWidth += tickPadding + lineSpace;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tminSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\n\t\n\t\t\t\t\tme.paddingTop = tickFont.size / 2;\n\t\t\t\t\tme.paddingBottom = tickFont.size / 2;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tme.handleMargins();\n\t\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\t},\n\t\n\t\t/**\n\t\t * Handle margins and padding interactions\n\t\t * @private\n\t\t */\n\t\thandleMargins: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.margins) {\n\t\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n\t\t\t\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n\t\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n\t\t\t\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n\t\t\t}\n\t\t},\n\t\n\t\tafterFit: function() {\n\t\t\thelpers$1.callback(this.options.afterFit, [this]);\n\t\t},\n\t\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t},\n\t\tisFullWidth: function() {\n\t\t\treturn (this.options.fullWidth);\n\t\t},\n\t\n\t\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n\t\tgetRightValue: function(rawValue) {\n\t\t\t// Null and undefined values first\n\t\t\tif (helpers$1.isNullOrUndef(rawValue)) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\t\t\tif ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// If it is in fact an object, dive in one more level\n\t\t\tif (rawValue) {\n\t\t\t\tif (this.isHorizontal()) {\n\t\t\t\t\tif (rawValue.x !== undefined) {\n\t\t\t\t\t\treturn this.getRightValue(rawValue.x);\n\t\t\t\t\t}\n\t\t\t\t} else if (rawValue.y !== undefined) {\n\t\t\t\t\treturn this.getRightValue(rawValue.y);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Value is good, return it\n\t\t\treturn rawValue;\n\t\t},\n\t\n\t\t/**\n\t\t * Used to get the value to display in the tooltip for the data at the given index\n\t\t * @param index\n\t\t * @param datasetIndex\n\t\t */\n\t\tgetLabelForIndex: helpers$1.noop,\n\t\n\t\t/**\n\t\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t * @param value\n\t\t * @param index\n\t\t * @param datasetIndex\n\t\t */\n\t\tgetPixelForValue: helpers$1.noop,\n\t\n\t\t/**\n\t\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t * @param pixel\n\t\t */\n\t\tgetValueForPixel: helpers$1.noop,\n\t\n\t\t/**\n\t\t * Returns the location of the tick at the given index\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetPixelForTick: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n\t\t\t\tvar pixel = (tickWidth * index) + me.paddingLeft;\n\t\n\t\t\t\tif (offset) {\n\t\t\t\t\tpixel += tickWidth / 2;\n\t\t\t\t}\n\t\n\t\t\t\tvar finalVal = me.left + pixel;\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\t\treturn me.top + (index * (innerHeight / (me._ticks.length - 1)));\n\t\t},\n\t\n\t\t/**\n\t\t * Utility for getting the pixel location of a percentage of scale\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetPixelForDecimal: function(decimal) {\n\t\t\tvar me = this;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;\n\t\n\t\t\t\tvar finalVal = me.left + valueOffset;\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\treturn me.top + (decimal * me.height);\n\t\t},\n\t\n\t\t/**\n\t\t * Returns the pixel for the minimum chart value\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetBasePixel: function() {\n\t\t\treturn this.getPixelForValue(this.getBaseValue());\n\t\t},\n\t\n\t\tgetBaseValue: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\t\n\t\t\treturn me.beginAtZero ? 0 :\n\t\t\t\tmin < 0 && max < 0 ? max :\n\t\t\t\tmin > 0 && max > 0 ? min :\n\t\t\t\t0;\n\t\t},\n\t\n\t\t/**\n\t\t * Returns a subset of ticks to be plotted to avoid overlapping labels.\n\t\t * @private\n\t\t */\n\t\t_autoSkip: function(ticks) {\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar optionTicks = me.options.ticks.minor;\n\t\t\tvar tickCount = ticks.length;\n\t\t\tvar skipRatio = false;\n\t\t\tvar maxTicks = optionTicks.maxTicksLimit;\n\t\n\t\t\t// Total space needed to display all ticks. First and last ticks are\n\t\t\t// drawn as their center at end of axis, so tickCount-1\n\t\t\tvar ticksLength = me._tickSize() * (tickCount - 1);\n\t\n\t\t\t// Axis length\n\t\t\tvar axisLength = isHorizontal\n\t\t\t\t? me.width - (me.paddingLeft + me.paddingRight)\n\t\t\t\t: me.height - (me.paddingTop + me.PaddingBottom);\n\t\n\t\t\tvar result = [];\n\t\t\tvar i, tick;\n\t\n\t\t\tif (ticksLength > axisLength) {\n\t\t\t\tskipRatio = 1 + Math.floor(ticksLength / axisLength);\n\t\t\t}\n\t\n\t\t\t// if they defined a max number of optionTicks,\n\t\t\t// increase skipRatio until that number is met\n\t\t\tif (tickCount > maxTicks) {\n\t\t\t\tskipRatio = Math.max(skipRatio, 1 + Math.floor(tickCount / maxTicks));\n\t\t\t}\n\t\n\t\t\tfor (i = 0; i < tickCount; i++) {\n\t\t\t\ttick = ticks[i];\n\t\n\t\t\t\tif (skipRatio > 1 && i % skipRatio > 0) {\n\t\t\t\t\t// leave tick in place but make sure it's not displayed (#4635)\n\t\t\t\t\tdelete tick.label;\n\t\t\t\t}\n\t\t\t\tresult.push(tick);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_tickSize: function() {\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar optionTicks = me.options.ticks.minor;\n\t\n\t\t\t// Calculate space needed by label in axis direction.\n\t\t\tvar rot = helpers$1.toRadians(me.labelRotation);\n\t\t\tvar cos = Math.abs(Math.cos(rot));\n\t\t\tvar sin = Math.abs(Math.sin(rot));\n\t\n\t\t\tvar padding = optionTicks.autoSkipPadding || 0;\n\t\t\tvar w = (me.longestLabelWidth + padding) || 0;\n\t\n\t\t\tvar tickFont = helpers$1.options._parseFont(optionTicks);\n\t\t\tvar h = (me._maxLabelLines * tickFont.lineHeight + padding) || 0;\n\t\n\t\t\t// Calculate space needed for 1 tick in axis direction.\n\t\t\treturn isHorizontal\n\t\t\t\t? h * cos > w * sin ? w / cos : h / sin\n\t\t\t\t: h * sin < w * cos ? h / cos : w / sin;\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_isVisible: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar display = me.options.display;\n\t\t\tvar i, ilen, meta;\n\t\n\t\t\tif (display !== 'auto') {\n\t\t\t\treturn !!display;\n\t\t\t}\n\t\n\t\t\t// When 'auto', the scale is visible if at least one associated dataset is visible.\n\t\t\tfor (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tif (chart.isDatasetVisible(i)) {\n\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\tif (meta.xAxisID === me.id || meta.yAxisID === me.id) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\t},\n\t\n\t\t/**\n\t\t * Actually draw the scale on the canvas\n\t\t * @param {object} chartArea - the area of the chart to draw full grid lines on\n\t\t */\n\t\tdraw: function(chartArea) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\n\t\t\tif (!me._isVisible()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar chart = me.chart;\n\t\t\tvar context = me.ctx;\n\t\t\tvar globalDefaults = core_defaults.global;\n\t\t\tvar defaultFontColor = globalDefaults.defaultFontColor;\n\t\t\tvar optionTicks = options.ticks.minor;\n\t\t\tvar optionMajorTicks = options.ticks.major || optionTicks;\n\t\t\tvar gridLines = options.gridLines;\n\t\t\tvar scaleLabel = options.scaleLabel;\n\t\t\tvar position = options.position;\n\t\n\t\t\tvar isRotated = me.labelRotation !== 0;\n\t\t\tvar isMirrored = optionTicks.mirror;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\n\t\t\tvar parseFont = helpers$1.options._parseFont;\n\t\t\tvar ticks = optionTicks.display && optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();\n\t\t\tvar tickFontColor = valueOrDefault$9(optionTicks.fontColor, defaultFontColor);\n\t\t\tvar tickFont = parseFont(optionTicks);\n\t\t\tvar lineHeight = tickFont.lineHeight;\n\t\t\tvar majorTickFontColor = valueOrDefault$9(optionMajorTicks.fontColor, defaultFontColor);\n\t\t\tvar majorTickFont = parseFont(optionMajorTicks);\n\t\t\tvar tickPadding = optionTicks.padding;\n\t\t\tvar labelOffset = optionTicks.labelOffset;\n\t\n\t\t\tvar tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n\t\n\t\t\tvar scaleLabelFontColor = valueOrDefault$9(scaleLabel.fontColor, defaultFontColor);\n\t\t\tvar scaleLabelFont = parseFont(scaleLabel);\n\t\t\tvar scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);\n\t\t\tvar labelRotationRadians = helpers$1.toRadians(me.labelRotation);\n\t\n\t\t\tvar itemsToDraw = [];\n\t\n\t\t\tvar axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;\n\t\t\tvar alignPixel = helpers$1._alignPixel;\n\t\t\tvar borderValue, tickStart, tickEnd;\n\t\n\t\t\tif (position === 'top') {\n\t\t\t\tborderValue = alignPixel(chart, me.bottom, axisWidth);\n\t\t\t\ttickStart = me.bottom - tl;\n\t\t\t\ttickEnd = borderValue - axisWidth / 2;\n\t\t\t} else if (position === 'bottom') {\n\t\t\t\tborderValue = alignPixel(chart, me.top, axisWidth);\n\t\t\t\ttickStart = borderValue + axisWidth / 2;\n\t\t\t\ttickEnd = me.top + tl;\n\t\t\t} else if (position === 'left') {\n\t\t\t\tborderValue = alignPixel(chart, me.right, axisWidth);\n\t\t\t\ttickStart = me.right - tl;\n\t\t\t\ttickEnd = borderValue - axisWidth / 2;\n\t\t\t} else {\n\t\t\t\tborderValue = alignPixel(chart, me.left, axisWidth);\n\t\t\t\ttickStart = borderValue + axisWidth / 2;\n\t\t\t\ttickEnd = me.left + tl;\n\t\t\t}\n\t\n\t\t\tvar epsilon = 0.0000001; // 0.0000001 is margin in pixels for Accumulated error.\n\t\n\t\t\thelpers$1.each(ticks, function(tick, index) {\n\t\t\t\t// autoskipper skipped this tick (#4635)\n\t\t\t\tif (helpers$1.isNullOrUndef(tick.label)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tvar label = tick.label;\n\t\t\t\tvar lineWidth, lineColor, borderDash, borderDashOffset;\n\t\t\t\tif (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {\n\t\t\t\t\t// Draw the first index specially\n\t\t\t\t\tlineWidth = gridLines.zeroLineWidth;\n\t\t\t\t\tlineColor = gridLines.zeroLineColor;\n\t\t\t\t\tborderDash = gridLines.zeroLineBorderDash || [];\n\t\t\t\t\tborderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;\n\t\t\t\t} else {\n\t\t\t\t\tlineWidth = valueAtIndexOrDefault(gridLines.lineWidth, index);\n\t\t\t\t\tlineColor = valueAtIndexOrDefault(gridLines.color, index);\n\t\t\t\t\tborderDash = gridLines.borderDash || [];\n\t\t\t\t\tborderDashOffset = gridLines.borderDashOffset || 0.0;\n\t\t\t\t}\n\t\n\t\t\t\t// Common properties\n\t\t\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY, textOffset, textAlign;\n\t\t\t\tvar labelCount = helpers$1.isArray(label) ? label.length : 1;\n\t\t\t\tvar lineValue = getPixelForGridLine(me, index, gridLines.offsetGridLines);\n\t\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tvar labelYOffset = tl + tickPadding;\n\t\n\t\t\t\t\tif (lineValue < me.left - epsilon) {\n\t\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttx1 = tx2 = x1 = x2 = alignPixel(chart, lineValue, lineWidth);\n\t\t\t\t\tty1 = tickStart;\n\t\t\t\t\tty2 = tickEnd;\n\t\t\t\t\tlabelX = me.getPixelForTick(index) + labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\t\n\t\t\t\t\tif (position === 'top') {\n\t\t\t\t\t\ty1 = alignPixel(chart, chartArea.top, axisWidth) + axisWidth / 2;\n\t\t\t\t\t\ty2 = chartArea.bottom;\n\t\t\t\t\t\ttextOffset = ((!isRotated ? 0.5 : 1) - labelCount) * lineHeight;\n\t\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'left';\n\t\t\t\t\t\tlabelY = me.bottom - labelYOffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty1 = chartArea.top;\n\t\t\t\t\t\ty2 = alignPixel(chart, chartArea.bottom, axisWidth) - axisWidth / 2;\n\t\t\t\t\t\ttextOffset = (!isRotated ? 0.5 : 0) * lineHeight;\n\t\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'right';\n\t\t\t\t\t\tlabelY = me.top + labelYOffset;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar labelXOffset = (isMirrored ? 0 : tl) + tickPadding;\n\t\n\t\t\t\t\tif (lineValue < me.top - epsilon) {\n\t\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\n\t\t\t\t\t}\n\t\n\t\t\t\t\ttx1 = tickStart;\n\t\t\t\t\ttx2 = tickEnd;\n\t\t\t\t\tty1 = ty2 = y1 = y2 = alignPixel(chart, lineValue, lineWidth);\n\t\t\t\t\tlabelY = me.getPixelForTick(index) + labelOffset;\n\t\t\t\t\ttextOffset = (1 - labelCount) * lineHeight / 2;\n\t\n\t\t\t\t\tif (position === 'left') {\n\t\t\t\t\t\tx1 = alignPixel(chart, chartArea.left, axisWidth) + axisWidth / 2;\n\t\t\t\t\t\tx2 = chartArea.right;\n\t\t\t\t\t\ttextAlign = isMirrored ? 'left' : 'right';\n\t\t\t\t\t\tlabelX = me.right - labelXOffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx1 = chartArea.left;\n\t\t\t\t\t\tx2 = alignPixel(chart, chartArea.right, axisWidth) - axisWidth / 2;\n\t\t\t\t\t\ttextAlign = isMirrored ? 'right' : 'left';\n\t\t\t\t\t\tlabelX = me.left + labelXOffset;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\titemsToDraw.push({\n\t\t\t\t\ttx1: tx1,\n\t\t\t\t\tty1: ty1,\n\t\t\t\t\ttx2: tx2,\n\t\t\t\t\tty2: ty2,\n\t\t\t\t\tx1: x1,\n\t\t\t\t\ty1: y1,\n\t\t\t\t\tx2: x2,\n\t\t\t\t\ty2: y2,\n\t\t\t\t\tlabelX: labelX,\n\t\t\t\t\tlabelY: labelY,\n\t\t\t\t\tglWidth: lineWidth,\n\t\t\t\t\tglColor: lineColor,\n\t\t\t\t\tglBorderDash: borderDash,\n\t\t\t\t\tglBorderDashOffset: borderDashOffset,\n\t\t\t\t\trotation: -1 * labelRotationRadians,\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tmajor: tick.major,\n\t\t\t\t\ttextOffset: textOffset,\n\t\t\t\t\ttextAlign: textAlign\n\t\t\t\t});\n\t\t\t});\n\t\n\t\t\t// Draw all of the tick labels, tick marks, and grid lines at the correct places\n\t\t\thelpers$1.each(itemsToDraw, function(itemToDraw) {\n\t\t\t\tvar glWidth = itemToDraw.glWidth;\n\t\t\t\tvar glColor = itemToDraw.glColor;\n\t\n\t\t\t\tif (gridLines.display && glWidth && glColor) {\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.lineWidth = glWidth;\n\t\t\t\t\tcontext.strokeStyle = glColor;\n\t\t\t\t\tif (context.setLineDash) {\n\t\t\t\t\t\tcontext.setLineDash(itemToDraw.glBorderDash);\n\t\t\t\t\t\tcontext.lineDashOffset = itemToDraw.glBorderDashOffset;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcontext.beginPath();\n\t\n\t\t\t\t\tif (gridLines.drawTicks) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (gridLines.drawOnChartArea) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tcontext.stroke();\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\t\n\t\t\t\tif (optionTicks.display) {\n\t\t\t\t\t// Make sure we draw text in the correct color and font\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);\n\t\t\t\t\tcontext.rotate(itemToDraw.rotation);\n\t\t\t\t\tcontext.font = itemToDraw.major ? majorTickFont.string : tickFont.string;\n\t\t\t\t\tcontext.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;\n\t\t\t\t\tcontext.textBaseline = 'middle';\n\t\t\t\t\tcontext.textAlign = itemToDraw.textAlign;\n\t\n\t\t\t\t\tvar label = itemToDraw.label;\n\t\t\t\t\tvar y = itemToDraw.textOffset;\n\t\t\t\t\tif (helpers$1.isArray(label)) {\n\t\t\t\t\t\tfor (var i = 0; i < label.length; ++i) {\n\t\t\t\t\t\t\t// We just make sure the multiline element is a string here..\n\t\t\t\t\t\t\tcontext.fillText('' + label[i], 0, y);\n\t\t\t\t\t\t\ty += lineHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.fillText(label, 0, y);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tif (scaleLabel.display) {\n\t\t\t\t// Draw the scale label\n\t\t\t\tvar scaleLabelX;\n\t\t\t\tvar scaleLabelY;\n\t\t\t\tvar rotation = 0;\n\t\t\t\tvar halfLineHeight = scaleLabelFont.lineHeight / 2;\n\t\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tscaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\n\t\t\t\t\tscaleLabelY = position === 'bottom'\n\t\t\t\t\t\t? me.bottom - halfLineHeight - scaleLabelPadding.bottom\n\t\t\t\t\t\t: me.top + halfLineHeight + scaleLabelPadding.top;\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = position === 'left';\n\t\t\t\t\tscaleLabelX = isLeft\n\t\t\t\t\t\t? me.left + halfLineHeight + scaleLabelPadding.top\n\t\t\t\t\t\t: me.right - halfLineHeight - scaleLabelPadding.top;\n\t\t\t\t\tscaleLabelY = me.top + ((me.bottom - me.top) / 2);\n\t\t\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n\t\t\t\t}\n\t\n\t\t\t\tcontext.save();\n\t\t\t\tcontext.translate(scaleLabelX, scaleLabelY);\n\t\t\t\tcontext.rotate(rotation);\n\t\t\t\tcontext.textAlign = 'center';\n\t\t\t\tcontext.textBaseline = 'middle';\n\t\t\t\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour\n\t\t\t\tcontext.font = scaleLabelFont.string;\n\t\t\t\tcontext.fillText(scaleLabel.labelString, 0, 0);\n\t\t\t\tcontext.restore();\n\t\t\t}\n\t\n\t\t\tif (axisWidth) {\n\t\t\t\t// Draw the line at the edge of the axis\n\t\t\t\tvar firstLineWidth = axisWidth;\n\t\t\t\tvar lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, ticks.length - 1, 0);\n\t\t\t\tvar x1, x2, y1, y2;\n\t\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tx1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;\n\t\t\t\t\tx2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;\n\t\t\t\t\ty1 = y2 = borderValue;\n\t\t\t\t} else {\n\t\t\t\t\ty1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;\n\t\t\t\t\ty2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;\n\t\t\t\t\tx1 = x2 = borderValue;\n\t\t\t\t}\n\t\n\t\t\t\tcontext.lineWidth = axisWidth;\n\t\t\t\tcontext.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.moveTo(x1, y1);\n\t\t\t\tcontext.lineTo(x2, y2);\n\t\t\t\tcontext.stroke();\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar defaultConfig = {\n\t\tposition: 'bottom'\n\t};\n\t\n\tvar scale_category = core_scale.extend({\n\t\t/**\n\t\t* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n\t\t* else fall back to data.labels\n\t\t* @private\n\t\t*/\n\t\tgetLabels: function() {\n\t\t\tvar data = this.chart.data;\n\t\t\treturn this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n\t\t},\n\t\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\tme.minIndex = 0;\n\t\t\tme.maxIndex = labels.length - 1;\n\t\t\tvar findIndex;\n\t\n\t\t\tif (me.options.ticks.min !== undefined) {\n\t\t\t\t// user specified min value\n\t\t\t\tfindIndex = labels.indexOf(me.options.ticks.min);\n\t\t\t\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n\t\t\t}\n\t\n\t\t\tif (me.options.ticks.max !== undefined) {\n\t\t\t\t// user specified max value\n\t\t\t\tfindIndex = labels.indexOf(me.options.ticks.max);\n\t\t\t\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n\t\t\t}\n\t\n\t\t\tme.min = labels[me.minIndex];\n\t\t\tme.max = labels[me.maxIndex];\n\t\t},\n\t\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar labels = me.getLabels();\n\t\t\t// If we are viewing some subset of labels, slice the original array\n\t\t\tme.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n\t\t},\n\t\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\n\t\t\tif (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {\n\t\t\t\treturn me.getRightValue(chart.data.datasets[datasetIndex].data[index]);\n\t\t\t}\n\t\n\t\t\treturn me.ticks[index - me.minIndex];\n\t\t},\n\t\n\t\t// Used to get data value locations.  Value can either be an index or a numerical value\n\t\tgetPixelForValue: function(value, index) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\t// 1 is added because we need the length but we have the indexes\n\t\t\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);\n\t\n\t\t\t// If value is a data object, then index is the index in the data array,\n\t\t\t// not the index of the scale. We need to change that.\n\t\t\tvar valueCategory;\n\t\t\tif (value !== undefined && value !== null) {\n\t\t\t\tvalueCategory = me.isHorizontal() ? value.x : value.y;\n\t\t\t}\n\t\t\tif (valueCategory !== undefined || (value !== undefined && isNaN(index))) {\n\t\t\t\tvar labels = me.getLabels();\n\t\t\t\tvalue = valueCategory || value;\n\t\t\t\tvar idx = labels.indexOf(value);\n\t\t\t\tindex = idx !== -1 ? idx : index;\n\t\t\t}\n\t\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar valueWidth = me.width / offsetAmt;\n\t\t\t\tvar widthOffset = (valueWidth * (index - me.minIndex));\n\t\n\t\t\t\tif (offset) {\n\t\t\t\t\twidthOffset += (valueWidth / 2);\n\t\t\t\t}\n\t\n\t\t\t\treturn me.left + widthOffset;\n\t\t\t}\n\t\t\tvar valueHeight = me.height / offsetAmt;\n\t\t\tvar heightOffset = (valueHeight * (index - me.minIndex));\n\t\n\t\t\tif (offset) {\n\t\t\t\theightOffset += (valueHeight / 2);\n\t\t\t}\n\t\n\t\t\treturn me.top + heightOffset;\n\t\t},\n\t\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null);\n\t\t},\n\t\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\tvar value;\n\t\t\tvar offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n\t\t\tvar horz = me.isHorizontal();\n\t\t\tvar valueDimension = (horz ? me.width : me.height) / offsetAmt;\n\t\n\t\t\tpixel -= horz ? me.left : me.top;\n\t\n\t\t\tif (offset) {\n\t\t\t\tpixel -= (valueDimension / 2);\n\t\t\t}\n\t\n\t\t\tif (pixel <= 0) {\n\t\t\t\tvalue = 0;\n\t\t\t} else {\n\t\t\t\tvalue = Math.round(pixel / valueDimension);\n\t\t\t}\n\t\n\t\t\treturn value + me.minIndex;\n\t\t},\n\t\n\t\tgetBasePixel: function() {\n\t\t\treturn this.bottom;\n\t\t}\n\t});\n\t\n\t// INTERNAL: static default options, registered in src/index.js\n\tvar _defaults = defaultConfig;\n\tscale_category._defaults = _defaults;\n\t\n\tvar noop = helpers$1.noop;\n\tvar isNullOrUndef = helpers$1.isNullOrUndef;\n\t\n\t/**\n\t * Generate a set of linear ticks\n\t * @param generationOptions the options used to generate the ticks\n\t * @param dataRange the range of the data\n\t * @returns {number[]} array of tick values\n\t */\n\tfunction generateTicks(generationOptions, dataRange) {\n\t\tvar ticks = [];\n\t\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\n\t\t// \"nice number\" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n\t\t// for details.\n\t\n\t\tvar MIN_SPACING = 1e-14;\n\t\tvar stepSize = generationOptions.stepSize;\n\t\tvar unit = stepSize || 1;\n\t\tvar maxNumSpaces = generationOptions.maxTicks - 1;\n\t\tvar min = generationOptions.min;\n\t\tvar max = generationOptions.max;\n\t\tvar precision = generationOptions.precision;\n\t\tvar rmin = dataRange.min;\n\t\tvar rmax = dataRange.max;\n\t\tvar spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;\n\t\tvar factor, niceMin, niceMax, numSpaces;\n\t\n\t\t// Beyond MIN_SPACING floating point numbers being to lose precision\n\t\t// such that we can't do the math necessary to generate ticks\n\t\tif (spacing < MIN_SPACING && isNullOrUndef(min) && isNullOrUndef(max)) {\n\t\t\treturn [rmin, rmax];\n\t\t}\n\t\n\t\tnumSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n\t\tif (numSpaces > maxNumSpaces) {\n\t\t\t// If the calculated num of spaces exceeds maxNumSpaces, recalculate it\n\t\t\tspacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;\n\t\t}\n\t\n\t\tif (stepSize || isNullOrUndef(precision)) {\n\t\t\t// If a precision is not specified, calculate factor based on spacing\n\t\t\tfactor = Math.pow(10, helpers$1._decimalPlaces(spacing));\n\t\t} else {\n\t\t\t// If the user specified a precision, round to that number of decimal places\n\t\t\tfactor = Math.pow(10, precision);\n\t\t\tspacing = Math.ceil(spacing * factor) / factor;\n\t\t}\n\t\n\t\tniceMin = Math.floor(rmin / spacing) * spacing;\n\t\tniceMax = Math.ceil(rmax / spacing) * spacing;\n\t\n\t\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\n\t\tif (stepSize) {\n\t\t\t// If very close to our whole number, use it.\n\t\t\tif (!isNullOrUndef(min) && helpers$1.almostWhole(min / spacing, spacing / 1000)) {\n\t\t\t\tniceMin = min;\n\t\t\t}\n\t\t\tif (!isNullOrUndef(max) && helpers$1.almostWhole(max / spacing, spacing / 1000)) {\n\t\t\t\tniceMax = max;\n\t\t\t}\n\t\t}\n\t\n\t\tnumSpaces = (niceMax - niceMin) / spacing;\n\t\t// If very close to our rounded value, use it.\n\t\tif (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\t\tnumSpaces = Math.round(numSpaces);\n\t\t} else {\n\t\t\tnumSpaces = Math.ceil(numSpaces);\n\t\t}\n\t\n\t\tniceMin = Math.round(niceMin * factor) / factor;\n\t\tniceMax = Math.round(niceMax * factor) / factor;\n\t\tticks.push(isNullOrUndef(min) ? niceMin : min);\n\t\tfor (var j = 1; j < numSpaces; ++j) {\n\t\t\tticks.push(Math.round((niceMin + j * spacing) * factor) / factor);\n\t\t}\n\t\tticks.push(isNullOrUndef(max) ? niceMax : max);\n\t\n\t\treturn ticks;\n\t}\n\t\n\tvar scale_linearbase = core_scale.extend({\n\t\tgetRightValue: function(value) {\n\t\t\tif (typeof value === 'string') {\n\t\t\t\treturn +value;\n\t\t\t}\n\t\t\treturn core_scale.prototype.getRightValue.call(this, value);\n\t\t},\n\t\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\n\t\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n\t\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart\n\t\t\t// axis, they can manually override it\n\t\t\tif (tickOpts.beginAtZero) {\n\t\t\t\tvar minSign = helpers$1.sign(me.min);\n\t\t\t\tvar maxSign = helpers$1.sign(me.max);\n\t\n\t\t\t\tif (minSign < 0 && maxSign < 0) {\n\t\t\t\t\t// move the top up to 0\n\t\t\t\t\tme.max = 0;\n\t\t\t\t} else if (minSign > 0 && maxSign > 0) {\n\t\t\t\t\t// move the bottom down to 0\n\t\t\t\t\tme.min = 0;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\n\t\t\tvar setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\n\t\n\t\t\tif (tickOpts.min !== undefined) {\n\t\t\t\tme.min = tickOpts.min;\n\t\t\t} else if (tickOpts.suggestedMin !== undefined) {\n\t\t\t\tif (me.min === null) {\n\t\t\t\t\tme.min = tickOpts.suggestedMin;\n\t\t\t\t} else {\n\t\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (tickOpts.max !== undefined) {\n\t\t\t\tme.max = tickOpts.max;\n\t\t\t} else if (tickOpts.suggestedMax !== undefined) {\n\t\t\t\tif (me.max === null) {\n\t\t\t\t\tme.max = tickOpts.suggestedMax;\n\t\t\t\t} else {\n\t\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (setMin !== setMax) {\n\t\t\t\t// We set the min or the max but not both.\n\t\t\t\t// So ensure that our range is good\n\t\t\t\t// Inverted or 0 length range can happen when\n\t\t\t\t// ticks.min is set, and no datasets are visible\n\t\t\t\tif (me.min >= me.max) {\n\t\t\t\t\tif (setMin) {\n\t\t\t\t\t\tme.max = me.min + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.min = me.max - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (me.min === me.max) {\n\t\t\t\tme.max++;\n\t\n\t\t\t\tif (!tickOpts.beginAtZero) {\n\t\t\t\t\tme.min--;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tgetTickLimit: function() {\n\t\t\tvar me = this;\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tvar stepSize = tickOpts.stepSize;\n\t\t\tvar maxTicksLimit = tickOpts.maxTicksLimit;\n\t\t\tvar maxTicks;\n\t\n\t\t\tif (stepSize) {\n\t\t\t\tmaxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;\n\t\t\t} else {\n\t\t\t\tmaxTicks = me._computeTickLimit();\n\t\t\t\tmaxTicksLimit = maxTicksLimit || 11;\n\t\t\t}\n\t\n\t\t\tif (maxTicksLimit) {\n\t\t\t\tmaxTicks = Math.min(maxTicksLimit, maxTicks);\n\t\t\t}\n\t\n\t\t\treturn maxTicks;\n\t\t},\n\t\n\t\t_computeTickLimit: function() {\n\t\t\treturn Number.POSITIVE_INFINITY;\n\t\t},\n\t\n\t\thandleDirectionalChanges: noop,\n\t\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\n\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 40\n\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t// the graph. Make sure we always have at least 2 ticks\n\t\t\tvar maxTicks = me.getTickLimit();\n\t\t\tmaxTicks = Math.max(2, maxTicks);\n\t\n\t\t\tvar numericGeneratorOptions = {\n\t\t\t\tmaxTicks: maxTicks,\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max,\n\t\t\t\tprecision: tickOpts.precision,\n\t\t\t\tstepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n\t\t\t};\n\t\t\tvar ticks = me.ticks = generateTicks(numericGeneratorOptions, me);\n\t\n\t\t\tme.handleDirectionalChanges();\n\t\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers$1.max(ticks);\n\t\t\tme.min = helpers$1.min(ticks);\n\t\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\t\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tme.ticksAsNumbers = me.ticks.slice();\n\t\t\tme.zeroLineIndex = me.ticks.indexOf(0);\n\t\n\t\t\tcore_scale.prototype.convertTicksToLabels.call(me);\n\t\t}\n\t});\n\t\n\tvar defaultConfig$1 = {\n\t\tposition: 'left',\n\t\tticks: {\n\t\t\tcallback: core_ticks.formatters.linear\n\t\t}\n\t};\n\t\n\tvar scale_linear = scale_linearbase.extend({\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar DEFAULT_MIN = 0;\n\t\t\tvar DEFAULT_MAX = 1;\n\t\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\t\n\t\t\t// First Calculate the range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\t\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers$1.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\t\n\t\t\t\thelpers$1.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\t\n\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\tvaluesPerStack[key] = {\n\t\t\t\t\t\t\tpositiveValues: [],\n\t\t\t\t\t\t\tnegativeValues: []\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Store these per type\n\t\t\t\t\tvar positiveValues = valuesPerStack[key].positiveValues;\n\t\t\t\t\tvar negativeValues = valuesPerStack[key].negativeValues;\n\t\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers$1.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tpositiveValues[index] = positiveValues[index] || 0;\n\t\t\t\t\t\t\tnegativeValues[index] = negativeValues[index] || 0;\n\t\n\t\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\t\tpositiveValues[index] = 100;\n\t\t\t\t\t\t\t} else if (value < 0) {\n\t\t\t\t\t\t\t\tnegativeValues[index] += value;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tpositiveValues[index] += value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\thelpers$1.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tvar values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n\t\t\t\t\tvar minVal = helpers$1.min(values);\n\t\t\t\t\tvar maxVal = helpers$1.max(values);\n\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t});\n\t\n\t\t\t} else {\n\t\t\t\thelpers$1.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers$1.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tme.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;\n\t\t\tme.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;\n\t\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\n\t\t// Returns the maximum number of ticks based on the scale dimension\n\t\t_computeTickLimit: function() {\n\t\t\tvar me = this;\n\t\t\tvar tickFont;\n\t\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\treturn Math.ceil(me.width / 40);\n\t\t\t}\n\t\t\ttickFont = helpers$1.options._parseFont(me.options.ticks);\n\t\t\treturn Math.ceil(me.height / tickFont.lineHeight);\n\t\t},\n\t\n\t\t// Called after the ticks are built. We need\n\t\thandleDirectionalChanges: function() {\n\t\t\tif (!this.isHorizontal()) {\n\t\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\t\tthis.ticks.reverse();\n\t\t\t}\n\t\t},\n\t\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\n\t\t// Utils\n\t\tgetPixelForValue: function(value) {\n\t\t\t// This must be called after fit has been run so that\n\t\t\t// this.left, this.top, this.right, and this.bottom have been defined\n\t\t\tvar me = this;\n\t\t\tvar start = me.start;\n\t\n\t\t\tvar rightValue = +me.getRightValue(value);\n\t\t\tvar pixel;\n\t\t\tvar range = me.end - start;\n\t\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tpixel = me.left + (me.width / range * (rightValue - start));\n\t\t\t} else {\n\t\t\t\tpixel = me.bottom - (me.height / range * (rightValue - start));\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar innerDimension = isHorizontal ? me.width : me.height;\n\t\t\tvar offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n\t\t\treturn me.start + ((me.end - me.start) * offset);\n\t\t},\n\t\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.ticksAsNumbers[index]);\n\t\t}\n\t});\n\t\n\t// INTERNAL: static default options, registered in src/index.js\n\tvar _defaults$1 = defaultConfig$1;\n\tscale_linear._defaults = _defaults$1;\n\t\n\tvar valueOrDefault$a = helpers$1.valueOrDefault;\n\t\n\t/**\n\t * Generate a set of logarithmic ticks\n\t * @param generationOptions the options used to generate the ticks\n\t * @param dataRange the range of the data\n\t * @returns {number[]} array of tick values\n\t */\n\tfunction generateTicks$1(generationOptions, dataRange) {\n\t\tvar ticks = [];\n\t\n\t\tvar tickVal = valueOrDefault$a(generationOptions.min, Math.pow(10, Math.floor(helpers$1.log10(dataRange.min))));\n\t\n\t\tvar endExp = Math.floor(helpers$1.log10(dataRange.max));\n\t\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n\t\tvar exp, significand;\n\t\n\t\tif (tickVal === 0) {\n\t\t\texp = Math.floor(helpers$1.log10(dataRange.minNotZero));\n\t\t\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n\t\n\t\t\tticks.push(tickVal);\n\t\t\ttickVal = significand * Math.pow(10, exp);\n\t\t} else {\n\t\t\texp = Math.floor(helpers$1.log10(tickVal));\n\t\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\n\t\t}\n\t\tvar precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n\t\n\t\tdo {\n\t\t\tticks.push(tickVal);\n\t\n\t\t\t++significand;\n\t\t\tif (significand === 10) {\n\t\t\t\tsignificand = 1;\n\t\t\t\t++exp;\n\t\t\t\tprecision = exp >= 0 ? 1 : precision;\n\t\t\t}\n\t\n\t\t\ttickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n\t\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\n\t\n\t\tvar lastTick = valueOrDefault$a(generationOptions.max, tickVal);\n\t\tticks.push(lastTick);\n\t\n\t\treturn ticks;\n\t}\n\t\n\tvar defaultConfig$2 = {\n\t\tposition: 'left',\n\t\n\t\t// label settings\n\t\tticks: {\n\t\t\tcallback: core_ticks.formatters.logarithmic\n\t\t}\n\t};\n\t\n\t// TODO(v3): change this to positiveOrDefault\n\tfunction nonNegativeOrDefault(value, defaultValue) {\n\t\treturn helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;\n\t}\n\t\n\tvar scale_logarithmic = core_scale.extend({\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar chart = me.chart;\n\t\t\tvar data = chart.data;\n\t\t\tvar datasets = data.datasets;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tfunction IDMatches(meta) {\n\t\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t\t}\n\t\n\t\t\t// Calculate Range\n\t\t\tme.min = null;\n\t\t\tme.max = null;\n\t\t\tme.minNotZero = null;\n\t\n\t\t\tvar hasStacks = opts.stacked;\n\t\t\tif (hasStacks === undefined) {\n\t\t\t\thelpers$1.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tif (hasStacks) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\t\thasStacks = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tif (opts.stacked || hasStacks) {\n\t\t\t\tvar valuesPerStack = {};\n\t\n\t\t\t\thelpers$1.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tvar key = [\n\t\t\t\t\t\tmeta.type,\n\t\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\t\tmeta.stack\n\t\t\t\t\t].join('.');\n\t\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\t\tvaluesPerStack[key] = [];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\thelpers$1.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar values = valuesPerStack[key];\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t// invalid, hidden and negative values are ignored\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalues[index] = values[index] || 0;\n\t\t\t\t\t\t\tvalues[index] += value;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t\thelpers$1.each(valuesPerStack, function(valuesForType) {\n\t\t\t\t\tif (valuesForType.length > 0) {\n\t\t\t\t\t\tvar minVal = helpers$1.min(valuesForType);\n\t\t\t\t\t\tvar maxVal = helpers$1.max(valuesForType);\n\t\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\n\t\t\t} else {\n\t\t\t\thelpers$1.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\t\thelpers$1.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t\t// invalid, hidden and negative values are ignored\n\t\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n\t\t\t\t\t\t\t\tme.minNotZero = value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t// Common base implementation to handle ticks.min, ticks.max\n\t\t\tthis.handleTickRangeOptions();\n\t\t},\n\t\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tvar DEFAULT_MIN = 1;\n\t\t\tvar DEFAULT_MAX = 10;\n\t\n\t\t\tme.min = nonNegativeOrDefault(tickOpts.min, me.min);\n\t\t\tme.max = nonNegativeOrDefault(tickOpts.max, me.max);\n\t\n\t\t\tif (me.min === me.max) {\n\t\t\t\tif (me.min !== 0 && me.min !== null) {\n\t\t\t\t\tme.min = Math.pow(10, Math.floor(helpers$1.log10(me.min)) - 1);\n\t\t\t\t\tme.max = Math.pow(10, Math.floor(helpers$1.log10(me.max)) + 1);\n\t\t\t\t} else {\n\t\t\t\t\tme.min = DEFAULT_MIN;\n\t\t\t\t\tme.max = DEFAULT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (me.min === null) {\n\t\t\t\tme.min = Math.pow(10, Math.floor(helpers$1.log10(me.max)) - 1);\n\t\t\t}\n\t\t\tif (me.max === null) {\n\t\t\t\tme.max = me.min !== 0\n\t\t\t\t\t? Math.pow(10, Math.floor(helpers$1.log10(me.min)) + 1)\n\t\t\t\t\t: DEFAULT_MAX;\n\t\t\t}\n\t\t\tif (me.minNotZero === null) {\n\t\t\t\tif (me.min > 0) {\n\t\t\t\t\tme.minNotZero = me.min;\n\t\t\t\t} else if (me.max < 1) {\n\t\t\t\t\tme.minNotZero = Math.pow(10, Math.floor(helpers$1.log10(me.max)));\n\t\t\t\t} else {\n\t\t\t\t\tme.minNotZero = DEFAULT_MIN;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tvar reverse = !me.isHorizontal();\n\t\n\t\t\tvar generationOptions = {\n\t\t\t\tmin: nonNegativeOrDefault(tickOpts.min),\n\t\t\t\tmax: nonNegativeOrDefault(tickOpts.max)\n\t\t\t};\n\t\t\tvar ticks = me.ticks = generateTicks$1(generationOptions, me);\n\t\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers$1.max(ticks);\n\t\t\tme.min = helpers$1.min(ticks);\n\t\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\treverse = !reverse;\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t\tif (reverse) {\n\t\t\t\tticks.reverse();\n\t\t\t}\n\t\t},\n\t\n\t\tconvertTicksToLabels: function() {\n\t\t\tthis.tickValues = this.ticks.slice();\n\t\n\t\t\tcore_scale.prototype.convertTicksToLabels.call(this);\n\t\t},\n\t\n\t\t// Get the correct tooltip label\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\n\t\tgetPixelForTick: function(index) {\n\t\t\treturn this.getPixelForValue(this.tickValues[index]);\n\t\t},\n\t\n\t\t/**\n\t\t * Returns the value of the first tick.\n\t\t * @param {number} value - The minimum not zero value.\n\t\t * @return {number} The first tick value.\n\t\t * @private\n\t\t */\n\t\t_getFirstTickValue: function(value) {\n\t\t\tvar exp = Math.floor(helpers$1.log10(value));\n\t\t\tvar significand = Math.floor(value / Math.pow(10, exp));\n\t\n\t\t\treturn significand * Math.pow(10, exp);\n\t\t},\n\t\n\t\tgetPixelForValue: function(value) {\n\t\t\tvar me = this;\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tvar reverse = tickOpts.reverse;\n\t\t\tvar log10 = helpers$1.log10;\n\t\t\tvar firstTickValue = me._getFirstTickValue(me.minNotZero);\n\t\t\tvar offset = 0;\n\t\t\tvar innerDimension, pixel, start, end, sign;\n\t\n\t\t\tvalue = +me.getRightValue(value);\n\t\t\tif (reverse) {\n\t\t\t\tstart = me.end;\n\t\t\t\tend = me.start;\n\t\t\t\tsign = -1;\n\t\t\t} else {\n\t\t\t\tstart = me.start;\n\t\t\t\tend = me.end;\n\t\t\t\tsign = 1;\n\t\t\t}\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tpixel = reverse ? me.right : me.left;\n\t\t\t} else {\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tsign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)\n\t\t\t\tpixel = reverse ? me.top : me.bottom;\n\t\t\t}\n\t\t\tif (value !== start) {\n\t\t\t\tif (start === 0) { // include zero tick\n\t\t\t\t\toffset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);\n\t\t\t\t\tinnerDimension -= offset;\n\t\t\t\t\tstart = firstTickValue;\n\t\t\t\t}\n\t\t\t\tif (value !== 0) {\n\t\t\t\t\toffset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));\n\t\t\t\t}\n\t\t\t\tpixel += sign * offset;\n\t\t\t}\n\t\t\treturn pixel;\n\t\t},\n\t\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tvar reverse = tickOpts.reverse;\n\t\t\tvar log10 = helpers$1.log10;\n\t\t\tvar firstTickValue = me._getFirstTickValue(me.minNotZero);\n\t\t\tvar innerDimension, start, end, value;\n\t\n\t\t\tif (reverse) {\n\t\t\t\tstart = me.end;\n\t\t\t\tend = me.start;\n\t\t\t} else {\n\t\t\t\tstart = me.start;\n\t\t\t\tend = me.end;\n\t\t\t}\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tinnerDimension = me.width;\n\t\t\t\tvalue = reverse ? me.right - pixel : pixel - me.left;\n\t\t\t} else {\n\t\t\t\tinnerDimension = me.height;\n\t\t\t\tvalue = reverse ? pixel - me.top : me.bottom - pixel;\n\t\t\t}\n\t\t\tif (value !== start) {\n\t\t\t\tif (start === 0) { // include zero tick\n\t\t\t\t\tvar offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);\n\t\t\t\t\tvalue -= offset;\n\t\t\t\t\tinnerDimension -= offset;\n\t\t\t\t\tstart = firstTickValue;\n\t\t\t\t}\n\t\t\t\tvalue *= log10(end) - log10(start);\n\t\t\t\tvalue /= innerDimension;\n\t\t\t\tvalue = Math.pow(10, log10(start) + value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t});\n\t\n\t// INTERNAL: static default options, registered in src/index.js\n\tvar _defaults$2 = defaultConfig$2;\n\tscale_logarithmic._defaults = _defaults$2;\n\t\n\tvar valueOrDefault$b = helpers$1.valueOrDefault;\n\tvar valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;\n\tvar resolve$7 = helpers$1.options.resolve;\n\t\n\tvar defaultConfig$3 = {\n\t\tdisplay: true,\n\t\n\t\t// Boolean - Whether to animate scaling the chart from the centre\n\t\tanimate: true,\n\t\tposition: 'chartArea',\n\t\n\t\tangleLines: {\n\t\t\tdisplay: true,\n\t\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\t\tlineWidth: 1,\n\t\t\tborderDash: [],\n\t\t\tborderDashOffset: 0.0\n\t\t},\n\t\n\t\tgridLines: {\n\t\t\tcircular: false\n\t\t},\n\t\n\t\t// label settings\n\t\tticks: {\n\t\t\t// Boolean - Show a backdrop to the scale label\n\t\t\tshowLabelBackdrop: true,\n\t\n\t\t\t// String - The colour of the label backdrop\n\t\t\tbackdropColor: 'rgba(255,255,255,0.75)',\n\t\n\t\t\t// Number - The backdrop padding above & below the label in pixels\n\t\t\tbackdropPaddingY: 2,\n\t\n\t\t\t// Number - The backdrop padding to the side of the label in pixels\n\t\t\tbackdropPaddingX: 2,\n\t\n\t\t\tcallback: core_ticks.formatters.linear\n\t\t},\n\t\n\t\tpointLabels: {\n\t\t\t// Boolean - if true, show point labels\n\t\t\tdisplay: true,\n\t\n\t\t\t// Number - Point label font size in pixels\n\t\t\tfontSize: 10,\n\t\n\t\t\t// Function - Used to convert point labels\n\t\t\tcallback: function(label) {\n\t\t\t\treturn label;\n\t\t\t}\n\t\t}\n\t};\n\t\n\tfunction getValueCount(scale) {\n\t\tvar opts = scale.options;\n\t\treturn opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;\n\t}\n\t\n\tfunction getTickBackdropHeight(opts) {\n\t\tvar tickOpts = opts.ticks;\n\t\n\t\tif (tickOpts.display && opts.display) {\n\t\t\treturn valueOrDefault$b(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tfunction measureLabelSize(ctx, lineHeight, label) {\n\t\tif (helpers$1.isArray(label)) {\n\t\t\treturn {\n\t\t\t\tw: helpers$1.longestText(ctx, ctx.font, label),\n\t\t\t\th: label.length * lineHeight\n\t\t\t};\n\t\t}\n\t\n\t\treturn {\n\t\t\tw: ctx.measureText(label).width,\n\t\t\th: lineHeight\n\t\t};\n\t}\n\t\n\tfunction determineLimits(angle, pos, size, min, max) {\n\t\tif (angle === min || angle === max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - (size / 2),\n\t\t\t\tend: pos + (size / 2)\n\t\t\t};\n\t\t} else if (angle < min || angle > max) {\n\t\t\treturn {\n\t\t\t\tstart: pos - size,\n\t\t\t\tend: pos\n\t\t\t};\n\t\t}\n\t\n\t\treturn {\n\t\t\tstart: pos,\n\t\t\tend: pos + size\n\t\t};\n\t}\n\t\n\t/**\n\t * Helper function to fit a radial linear scale with point labels\n\t */\n\tfunction fitWithPointLabels(scale) {\n\t\n\t\t// Right, this is really confusing and there is a lot of maths going on here\n\t\t// The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n\t\t//\n\t\t// Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n\t\t//\n\t\t// Solution:\n\t\t//\n\t\t// We assume the radius of the polygon is half the size of the canvas at first\n\t\t// at each index we check if the text overlaps.\n\t\t//\n\t\t// Where it does, we store that angle and that index.\n\t\t//\n\t\t// After finding the largest index and angle we calculate how much we need to remove\n\t\t// from the shape radius to move the point inwards by that x.\n\t\t//\n\t\t// We average the left and right distances to get the maximum shape radius that can fit in the box\n\t\t// along with labels.\n\t\t//\n\t\t// Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n\t\t// on each side, removing that from the size, halving it and adding the left x protrusion width.\n\t\t//\n\t\t// This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n\t\t// and position it in the most space efficient manner\n\t\t//\n\t\t// https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\t\n\t\tvar plFont = helpers$1.options._parseFont(scale.options.pointLabels);\n\t\n\t\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n\t\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\t\tvar furthestLimits = {\n\t\t\tl: 0,\n\t\t\tr: scale.width,\n\t\t\tt: 0,\n\t\t\tb: scale.height - scale.paddingTop\n\t\t};\n\t\tvar furthestAngles = {};\n\t\tvar i, textSize, pointPosition;\n\t\n\t\tscale.ctx.font = plFont.string;\n\t\tscale._pointLabelSizes = [];\n\t\n\t\tvar valueCount = getValueCount(scale);\n\t\tfor (i = 0; i < valueCount; i++) {\n\t\t\tpointPosition = scale.getPointPosition(i, scale.drawingArea + 5);\n\t\t\ttextSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');\n\t\t\tscale._pointLabelSizes[i] = textSize;\n\t\n\t\t\t// Add quarter circle to make degree 0 mean top of circle\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\tvar angle = helpers$1.toDegrees(angleRadians) % 360;\n\t\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n\t\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\t\n\t\t\tif (hLimits.start < furthestLimits.l) {\n\t\t\t\tfurthestLimits.l = hLimits.start;\n\t\t\t\tfurthestAngles.l = angleRadians;\n\t\t\t}\n\t\n\t\t\tif (hLimits.end > furthestLimits.r) {\n\t\t\t\tfurthestLimits.r = hLimits.end;\n\t\t\t\tfurthestAngles.r = angleRadians;\n\t\t\t}\n\t\n\t\t\tif (vLimits.start < furthestLimits.t) {\n\t\t\t\tfurthestLimits.t = vLimits.start;\n\t\t\t\tfurthestAngles.t = angleRadians;\n\t\t\t}\n\t\n\t\t\tif (vLimits.end > furthestLimits.b) {\n\t\t\t\tfurthestLimits.b = vLimits.end;\n\t\t\t\tfurthestAngles.b = angleRadians;\n\t\t\t}\n\t\t}\n\t\n\t\tscale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);\n\t}\n\t\n\tfunction getTextAlignForAngle(angle) {\n\t\tif (angle === 0 || angle === 180) {\n\t\t\treturn 'center';\n\t\t} else if (angle < 180) {\n\t\t\treturn 'left';\n\t\t}\n\t\n\t\treturn 'right';\n\t}\n\t\n\tfunction fillText(ctx, text, position, lineHeight) {\n\t\tvar y = position.y + lineHeight / 2;\n\t\tvar i, ilen;\n\t\n\t\tif (helpers$1.isArray(text)) {\n\t\t\tfor (i = 0, ilen = text.length; i < ilen; ++i) {\n\t\t\t\tctx.fillText(text[i], position.x, y);\n\t\t\t\ty += lineHeight;\n\t\t\t}\n\t\t} else {\n\t\t\tctx.fillText(text, position.x, y);\n\t\t}\n\t}\n\t\n\tfunction adjustPointPositionForLabelHeight(angle, textSize, position) {\n\t\tif (angle === 90 || angle === 270) {\n\t\t\tposition.y -= (textSize.h / 2);\n\t\t} else if (angle > 270 || angle < 90) {\n\t\t\tposition.y -= textSize.h;\n\t\t}\n\t}\n\t\n\tfunction drawPointLabels(scale) {\n\t\tvar ctx = scale.ctx;\n\t\tvar opts = scale.options;\n\t\tvar angleLineOpts = opts.angleLines;\n\t\tvar gridLineOpts = opts.gridLines;\n\t\tvar pointLabelOpts = opts.pointLabels;\n\t\tvar lineWidth = valueOrDefault$b(angleLineOpts.lineWidth, gridLineOpts.lineWidth);\n\t\tvar lineColor = valueOrDefault$b(angleLineOpts.color, gridLineOpts.color);\n\t\tvar tickBackdropHeight = getTickBackdropHeight(opts);\n\t\n\t\tctx.save();\n\t\tctx.lineWidth = lineWidth;\n\t\tctx.strokeStyle = lineColor;\n\t\tif (ctx.setLineDash) {\n\t\t\tctx.setLineDash(resolve$7([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));\n\t\t\tctx.lineDashOffset = resolve$7([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0]);\n\t\t}\n\t\n\t\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\n\t\n\t\t// Point Label Font\n\t\tvar plFont = helpers$1.options._parseFont(pointLabelOpts);\n\t\n\t\tctx.font = plFont.string;\n\t\tctx.textBaseline = 'middle';\n\t\n\t\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\n\t\t\tif (angleLineOpts.display && lineWidth && lineColor) {\n\t\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\n\t\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\n\t\t\tif (pointLabelOpts.display) {\n\t\t\t\t// Extra pixels out for some label spacing\n\t\t\t\tvar extra = (i === 0 ? tickBackdropHeight / 2 : 0);\n\t\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5);\n\t\n\t\t\t\t// Keep this in loop since we may support array properties here\n\t\t\t\tvar pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);\n\t\t\t\tctx.fillStyle = pointLabelFontColor;\n\t\n\t\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\t\tvar angle = helpers$1.toDegrees(angleRadians);\n\t\t\t\tctx.textAlign = getTextAlignForAngle(angle);\n\t\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n\t\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);\n\t\t\t}\n\t\t}\n\t\tctx.restore();\n\t}\n\t\n\tfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\n\t\tvar ctx = scale.ctx;\n\t\tvar circular = gridLineOpts.circular;\n\t\tvar valueCount = getValueCount(scale);\n\t\tvar lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);\n\t\tvar lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);\n\t\tvar pointPosition;\n\t\n\t\tif ((!circular && !valueCount) || !lineColor || !lineWidth) {\n\t\t\treturn;\n\t\t}\n\t\n\t\tctx.save();\n\t\tctx.strokeStyle = lineColor;\n\t\tctx.lineWidth = lineWidth;\n\t\tif (ctx.setLineDash) {\n\t\t\tctx.setLineDash(gridLineOpts.borderDash || []);\n\t\t\tctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;\n\t\t}\n\t\n\t\tctx.beginPath();\n\t\tif (circular) {\n\t\t\t// Draw circular arcs between the points\n\t\t\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n\t\t} else {\n\t\t\t// Draw straight lines connecting each index\n\t\t\tpointPosition = scale.getPointPosition(0, radius);\n\t\t\tctx.moveTo(pointPosition.x, pointPosition.y);\n\t\n\t\t\tfor (var i = 1; i < valueCount; i++) {\n\t\t\t\tpointPosition = scale.getPointPosition(i, radius);\n\t\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\n\t\t\t}\n\t\t}\n\t\tctx.closePath();\n\t\tctx.stroke();\n\t\tctx.restore();\n\t}\n\t\n\tfunction numberOrZero(param) {\n\t\treturn helpers$1.isNumber(param) ? param : 0;\n\t}\n\t\n\tvar scale_radialLinear = scale_linearbase.extend({\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.height = me.maxHeight;\n\t\t\tme.paddingTop = getTickBackdropHeight(me.options) / 2;\n\t\t\tme.xCenter = Math.floor(me.width / 2);\n\t\t\tme.yCenter = Math.floor((me.height - me.paddingTop) / 2);\n\t\t\tme.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;\n\t\t},\n\t\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar min = Number.POSITIVE_INFINITY;\n\t\t\tvar max = Number.NEGATIVE_INFINITY;\n\t\n\t\t\thelpers$1.each(chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\n\t\t\t\t\thelpers$1.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tmin = Math.min(value, min);\n\t\t\t\t\t\tmax = Math.max(value, max);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tme.min = (min === Number.POSITIVE_INFINITY ? 0 : min);\n\t\t\tme.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);\n\t\n\t\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\t\tme.handleTickRangeOptions();\n\t\t},\n\t\n\t\t// Returns the maximum number of ticks based on the scale dimension\n\t\t_computeTickLimit: function() {\n\t\t\treturn Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n\t\t},\n\t\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\n\t\t\tscale_linearbase.prototype.convertTicksToLabels.call(me);\n\t\n\t\t\t// Point labels\n\t\t\tme.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n\t\t},\n\t\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t\t},\n\t\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\n\t\t\tif (opts.display && opts.pointLabels.display) {\n\t\t\t\tfitWithPointLabels(me);\n\t\t\t} else {\n\t\t\t\tme.setCenterPoint(0, 0, 0, 0);\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * Set radius reductions and determine new radius and center point\n\t\t * @private\n\t\t */\n\t\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\n\t\t\tvar me = this;\n\t\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n\t\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n\t\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n\t\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);\n\t\n\t\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\n\t\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\n\t\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\n\t\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\n\t\n\t\t\tme.drawingArea = Math.min(\n\t\t\t\tMath.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\n\t\t\t\tMath.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n\t\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n\t\t},\n\t\n\t\tsetCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {\n\t\t\tvar me = this;\n\t\t\tvar maxRight = me.width - rightMovement - me.drawingArea;\n\t\t\tvar maxLeft = leftMovement + me.drawingArea;\n\t\t\tvar maxTop = topMovement + me.drawingArea;\n\t\t\tvar maxBottom = (me.height - me.paddingTop) - bottomMovement - me.drawingArea;\n\t\n\t\t\tme.xCenter = Math.floor(((maxLeft + maxRight) / 2) + me.left);\n\t\t\tme.yCenter = Math.floor(((maxTop + maxBottom) / 2) + me.top + me.paddingTop);\n\t\t},\n\t\n\t\tgetIndexAngle: function(index) {\n\t\t\tvar angleMultiplier = (Math.PI * 2) / getValueCount(this);\n\t\t\tvar startAngle = this.chart.options && this.chart.options.startAngle ?\n\t\t\t\tthis.chart.options.startAngle :\n\t\t\t\t0;\n\t\n\t\t\tvar startAngleRadians = startAngle * Math.PI * 2 / 360;\n\t\n\t\t\t// Start from the top instead of right, so remove a quarter of the circle\n\t\t\treturn index * angleMultiplier + startAngleRadians;\n\t\t},\n\t\n\t\tgetDistanceFromCenterForValue: function(value) {\n\t\t\tvar me = this;\n\t\n\t\t\tif (value === null) {\n\t\t\t\treturn 0; // null always in center\n\t\t\t}\n\t\n\t\t\t// Take into account half font size + the yPadding of the top value\n\t\t\tvar scalingFactor = me.drawingArea / (me.max - me.min);\n\t\t\tif (me.options.ticks.reverse) {\n\t\t\t\treturn (me.max - value) * scalingFactor;\n\t\t\t}\n\t\t\treturn (value - me.min) * scalingFactor;\n\t\t},\n\t\n\t\tgetPointPosition: function(index, distanceFromCenter) {\n\t\t\tvar me = this;\n\t\t\tvar thisAngle = me.getIndexAngle(index) - (Math.PI / 2);\n\t\t\treturn {\n\t\t\t\tx: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,\n\t\t\t\ty: Math.sin(thisAngle) * distanceFromCenter + me.yCenter\n\t\t\t};\n\t\t},\n\t\n\t\tgetPointPositionForValue: function(index, value) {\n\t\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n\t\t},\n\t\n\t\tgetBasePosition: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\t\n\t\t\treturn me.getPointPositionForValue(0,\n\t\t\t\tme.beginAtZero ? 0 :\n\t\t\t\tmin < 0 && max < 0 ? max :\n\t\t\t\tmin > 0 && max > 0 ? min :\n\t\t\t\t0);\n\t\t},\n\t\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar tickOpts = opts.ticks;\n\t\n\t\t\tif (opts.display) {\n\t\t\t\tvar ctx = me.ctx;\n\t\t\t\tvar startAngle = this.getIndexAngle(0);\n\t\t\t\tvar tickFont = helpers$1.options._parseFont(tickOpts);\n\t\n\t\t\t\tif (opts.angleLines.display || opts.pointLabels.display) {\n\t\t\t\t\tdrawPointLabels(me);\n\t\t\t\t}\n\t\n\t\t\t\thelpers$1.each(me.ticks, function(label, index) {\n\t\t\t\t\t// Don't draw a centre value (if it is minimum)\n\t\t\t\t\tif (index > 0 || tickOpts.reverse) {\n\t\t\t\t\t\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n\t\n\t\t\t\t\t\t// Draw circular lines around the scale\n\t\t\t\t\t\tif (gridLineOpts.display && index !== 0) {\n\t\t\t\t\t\t\tdrawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (tickOpts.display) {\n\t\t\t\t\t\t\tvar tickFontColor = valueOrDefault$b(tickOpts.fontColor, core_defaults.global.defaultFontColor);\n\t\t\t\t\t\t\tctx.font = tickFont.string;\n\t\n\t\t\t\t\t\t\tctx.save();\n\t\t\t\t\t\t\tctx.translate(me.xCenter, me.yCenter);\n\t\t\t\t\t\t\tctx.rotate(startAngle);\n\t\n\t\t\t\t\t\t\tif (tickOpts.showLabelBackdrop) {\n\t\t\t\t\t\t\t\tvar labelWidth = ctx.measureText(label).width;\n\t\t\t\t\t\t\t\tctx.fillStyle = tickOpts.backdropColor;\n\t\t\t\t\t\t\t\tctx.fillRect(\n\t\t\t\t\t\t\t\t\t-labelWidth / 2 - tickOpts.backdropPaddingX,\n\t\t\t\t\t\t\t\t\t-yCenterOffset - tickFont.size / 2 - tickOpts.backdropPaddingY,\n\t\t\t\t\t\t\t\t\tlabelWidth + tickOpts.backdropPaddingX * 2,\n\t\t\t\t\t\t\t\t\ttickFont.size + tickOpts.backdropPaddingY * 2\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\t\t\t\tctx.fillStyle = tickFontColor;\n\t\t\t\t\t\t\tctx.fillText(label, 0, -yCenterOffset);\n\t\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\t\n\t// INTERNAL: static default options, registered in src/index.js\n\tvar _defaults$3 = defaultConfig$3;\n\tscale_radialLinear._defaults = _defaults$3;\n\t\n\tvar valueOrDefault$c = helpers$1.valueOrDefault;\n\t\n\t// Integer constants are from the ES6 spec.\n\tvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;\n\tvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\t\n\tvar INTERVALS = {\n\t\tmillisecond: {\n\t\t\tcommon: true,\n\t\t\tsize: 1,\n\t\t\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n\t\t},\n\t\tsecond: {\n\t\t\tcommon: true,\n\t\t\tsize: 1000,\n\t\t\tsteps: [1, 2, 5, 10, 15, 30]\n\t\t},\n\t\tminute: {\n\t\t\tcommon: true,\n\t\t\tsize: 60000,\n\t\t\tsteps: [1, 2, 5, 10, 15, 30]\n\t\t},\n\t\thour: {\n\t\t\tcommon: true,\n\t\t\tsize: 3600000,\n\t\t\tsteps: [1, 2, 3, 6, 12]\n\t\t},\n\t\tday: {\n\t\t\tcommon: true,\n\t\t\tsize: 86400000,\n\t\t\tsteps: [1, 2, 5]\n\t\t},\n\t\tweek: {\n\t\t\tcommon: false,\n\t\t\tsize: 604800000,\n\t\t\tsteps: [1, 2, 3, 4]\n\t\t},\n\t\tmonth: {\n\t\t\tcommon: true,\n\t\t\tsize: 2.628e9,\n\t\t\tsteps: [1, 2, 3]\n\t\t},\n\t\tquarter: {\n\t\t\tcommon: false,\n\t\t\tsize: 7.884e9,\n\t\t\tsteps: [1, 2, 3, 4]\n\t\t},\n\t\tyear: {\n\t\t\tcommon: true,\n\t\t\tsize: 3.154e10\n\t\t}\n\t};\n\t\n\tvar UNITS = Object.keys(INTERVALS);\n\t\n\tfunction sorter(a, b) {\n\t\treturn a - b;\n\t}\n\t\n\tfunction arrayUnique(items) {\n\t\tvar hash = {};\n\t\tvar out = [];\n\t\tvar i, ilen, item;\n\t\n\t\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\t\titem = items[i];\n\t\t\tif (!hash[item]) {\n\t\t\t\thash[item] = true;\n\t\t\t\tout.push(item);\n\t\t\t}\n\t\t}\n\t\n\t\treturn out;\n\t}\n\t\n\t/**\n\t * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n\t * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n\t * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n\t * extremity (left + width or top + height). Note that it would be more optimized to directly\n\t * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n\t * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n\t *\n\t * @param {number[]} timestamps - timestamps sorted from lowest to highest.\n\t * @param {string} distribution - If 'linear', timestamps will be spread linearly along the min\n\t * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.\n\t * If 'series', timestamps will be positioned at the same distance from each other. In this\n\t * case, only timestamps that break the time linearity are registered, meaning that in the\n\t * best case, all timestamps are linear, the table contains only min and max.\n\t */\n\tfunction buildLookupTable(timestamps, min, max, distribution) {\n\t\tif (distribution === 'linear' || !timestamps.length) {\n\t\t\treturn [\n\t\t\t\t{time: min, pos: 0},\n\t\t\t\t{time: max, pos: 1}\n\t\t\t];\n\t\t}\n\t\n\t\tvar table = [];\n\t\tvar items = [min];\n\t\tvar i, ilen, prev, curr, next;\n\t\n\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\t\tcurr = timestamps[i];\n\t\t\tif (curr > min && curr < max) {\n\t\t\t\titems.push(curr);\n\t\t\t}\n\t\t}\n\t\n\t\titems.push(max);\n\t\n\t\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\t\tnext = items[i + 1];\n\t\t\tprev = items[i - 1];\n\t\t\tcurr = items[i];\n\t\n\t\t\t// only add points that breaks the scale linearity\n\t\t\tif (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {\n\t\t\t\ttable.push({time: curr, pos: i / (ilen - 1)});\n\t\t\t}\n\t\t}\n\t\n\t\treturn table;\n\t}\n\t\n\t// @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/\n\tfunction lookup(table, key, value) {\n\t\tvar lo = 0;\n\t\tvar hi = table.length - 1;\n\t\tvar mid, i0, i1;\n\t\n\t\twhile (lo >= 0 && lo <= hi) {\n\t\t\tmid = (lo + hi) >> 1;\n\t\t\ti0 = table[mid - 1] || null;\n\t\t\ti1 = table[mid];\n\t\n\t\t\tif (!i0) {\n\t\t\t\t// given value is outside table (before first item)\n\t\t\t\treturn {lo: null, hi: i1};\n\t\t\t} else if (i1[key] < value) {\n\t\t\t\tlo = mid + 1;\n\t\t\t} else if (i0[key] > value) {\n\t\t\t\thi = mid - 1;\n\t\t\t} else {\n\t\t\t\treturn {lo: i0, hi: i1};\n\t\t\t}\n\t\t}\n\t\n\t\t// given value is outside table (after last item)\n\t\treturn {lo: i1, hi: null};\n\t}\n\t\n\t/**\n\t * Linearly interpolates the given source `value` using the table items `skey` values and\n\t * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\n\t * returns the position for a timestamp equal to 42. If value is out of bounds, values at\n\t * index [0, 1] or [n - 1, n] are used for the interpolation.\n\t */\n\tfunction interpolate$1(table, skey, sval, tkey) {\n\t\tvar range = lookup(table, skey, sval);\n\t\n\t\t// Note: the lookup table ALWAYS contains at least 2 items (min and max)\n\t\tvar prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;\n\t\tvar next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;\n\t\n\t\tvar span = next[skey] - prev[skey];\n\t\tvar ratio = span ? (sval - prev[skey]) / span : 0;\n\t\tvar offset = (next[tkey] - prev[tkey]) * ratio;\n\t\n\t\treturn prev[tkey] + offset;\n\t}\n\t\n\tfunction toTimestamp(scale, input) {\n\t\tvar adapter = scale._adapter;\n\t\tvar options = scale.options.time;\n\t\tvar parser = options.parser;\n\t\tvar format = parser || options.format;\n\t\tvar value = input;\n\t\n\t\tif (typeof parser === 'function') {\n\t\t\tvalue = parser(value);\n\t\t}\n\t\n\t\t// Only parse if its not a timestamp already\n\t\tif (!helpers$1.isFinite(value)) {\n\t\t\tvalue = typeof format === 'string'\n\t\t\t\t? adapter.parse(value, format)\n\t\t\t\t: adapter.parse(value);\n\t\t}\n\t\n\t\tif (value !== null) {\n\t\t\treturn +value;\n\t\t}\n\t\n\t\t// Labels are in an incompatible format and no `parser` has been provided.\n\t\t// The user might still use the deprecated `format` option for parsing.\n\t\tif (!parser && typeof format === 'function') {\n\t\t\tvalue = format(input);\n\t\n\t\t\t// `format` could return something else than a timestamp, if so, parse it\n\t\t\tif (!helpers$1.isFinite(value)) {\n\t\t\t\tvalue = adapter.parse(value);\n\t\t\t}\n\t\t}\n\t\n\t\treturn value;\n\t}\n\t\n\tfunction parse(scale, input) {\n\t\tif (helpers$1.isNullOrUndef(input)) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\tvar options = scale.options.time;\n\t\tvar value = toTimestamp(scale, scale.getRightValue(input));\n\t\tif (value === null) {\n\t\t\treturn value;\n\t\t}\n\t\n\t\tif (options.round) {\n\t\t\tvalue = +scale._adapter.startOf(value, options.round);\n\t\t}\n\t\n\t\treturn value;\n\t}\n\t\n\t/**\n\t * Returns the number of unit to skip to be able to display up to `capacity` number of ticks\n\t * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.\n\t */\n\tfunction determineStepSize(min, max, unit, capacity) {\n\t\tvar range = max - min;\n\t\tvar interval = INTERVALS[unit];\n\t\tvar milliseconds = interval.size;\n\t\tvar steps = interval.steps;\n\t\tvar i, ilen, factor;\n\t\n\t\tif (!steps) {\n\t\t\treturn Math.ceil(range / (capacity * milliseconds));\n\t\t}\n\t\n\t\tfor (i = 0, ilen = steps.length; i < ilen; ++i) {\n\t\t\tfactor = steps[i];\n\t\t\tif (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\treturn factor;\n\t}\n\t\n\t/**\n\t * Figures out what unit results in an appropriate number of auto-generated ticks\n\t */\n\tfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n\t\tvar ilen = UNITS.length;\n\t\tvar i, interval, factor;\n\t\n\t\tfor (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n\t\t\tinterval = INTERVALS[UNITS[i]];\n\t\t\tfactor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;\n\t\n\t\t\tif (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n\t\t\t\treturn UNITS[i];\n\t\t\t}\n\t\t}\n\t\n\t\treturn UNITS[ilen - 1];\n\t}\n\t\n\t/**\n\t * Figures out what unit to format a set of ticks with\n\t */\n\tfunction determineUnitForFormatting(scale, ticks, minUnit, min, max) {\n\t\tvar ilen = UNITS.length;\n\t\tvar i, unit;\n\t\n\t\tfor (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {\n\t\t\tunit = UNITS[i];\n\t\t\tif (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= ticks.length) {\n\t\t\t\treturn unit;\n\t\t\t}\n\t\t}\n\t\n\t\treturn UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n\t}\n\t\n\tfunction determineMajorUnit(unit) {\n\t\tfor (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n\t\t\tif (INTERVALS[UNITS[i]].common) {\n\t\t\t\treturn UNITS[i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n\t * `minor` unit, aligned on the `major` unit and using the given scale time `options`.\n\t * Important: this method can return ticks outside the min and max range, it's the\n\t * responsibility of the calling code to clamp values if needed.\n\t */\n\tfunction generate(scale, min, max, capacity) {\n\t\tvar adapter = scale._adapter;\n\t\tvar options = scale.options;\n\t\tvar timeOpts = options.time;\n\t\tvar minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n\t\tvar major = determineMajorUnit(minor);\n\t\tvar stepSize = valueOrDefault$c(timeOpts.stepSize, timeOpts.unitStepSize);\n\t\tvar weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n\t\tvar majorTicksEnabled = options.ticks.major.enabled;\n\t\tvar interval = INTERVALS[minor];\n\t\tvar first = min;\n\t\tvar last = max;\n\t\tvar ticks = [];\n\t\tvar time;\n\t\n\t\tif (!stepSize) {\n\t\t\tstepSize = determineStepSize(min, max, minor, capacity);\n\t\t}\n\t\n\t\t// For 'week' unit, handle the first day of week option\n\t\tif (weekday) {\n\t\t\tfirst = +adapter.startOf(first, 'isoWeek', weekday);\n\t\t\tlast = +adapter.startOf(last, 'isoWeek', weekday);\n\t\t}\n\t\n\t\t// Align first/last ticks on unit\n\t\tfirst = +adapter.startOf(first, weekday ? 'day' : minor);\n\t\tlast = +adapter.startOf(last, weekday ? 'day' : minor);\n\t\n\t\t// Make sure that the last tick include max\n\t\tif (last < max) {\n\t\t\tlast = +adapter.add(last, 1, minor);\n\t\t}\n\t\n\t\ttime = first;\n\t\n\t\tif (majorTicksEnabled && major && !weekday && !timeOpts.round) {\n\t\t\t// Align the first tick on the previous `minor` unit aligned on the `major` unit:\n\t\t\t// we first aligned time on the previous `major` unit then add the number of full\n\t\t\t// stepSize there is between first and the previous major time.\n\t\t\ttime = +adapter.startOf(time, major);\n\t\t\ttime = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n\t\t}\n\t\n\t\tfor (; time < last; time = +adapter.add(time, stepSize, minor)) {\n\t\t\tticks.push(+time);\n\t\t}\n\t\n\t\tticks.push(+time);\n\t\n\t\treturn ticks;\n\t}\n\t\n\t/**\n\t * Returns the start and end offsets from edges in the form of {start, end}\n\t * where each value is a relative width to the scale and ranges between 0 and 1.\n\t * They add extra margins on the both sides by scaling down the original scale.\n\t * Offsets are added when the `offset` option is true.\n\t */\n\tfunction computeOffsets(table, ticks, min, max, options) {\n\t\tvar start = 0;\n\t\tvar end = 0;\n\t\tvar first, last;\n\t\n\t\tif (options.offset && ticks.length) {\n\t\t\tif (!options.time.min) {\n\t\t\t\tfirst = interpolate$1(table, 'time', ticks[0], 'pos');\n\t\t\t\tif (ticks.length === 1) {\n\t\t\t\t\tstart = 1 - first;\n\t\t\t\t} else {\n\t\t\t\t\tstart = (interpolate$1(table, 'time', ticks[1], 'pos') - first) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!options.time.max) {\n\t\t\t\tlast = interpolate$1(table, 'time', ticks[ticks.length - 1], 'pos');\n\t\t\t\tif (ticks.length === 1) {\n\t\t\t\t\tend = last;\n\t\t\t\t} else {\n\t\t\t\t\tend = (last - interpolate$1(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\treturn {start: start, end: end};\n\t}\n\t\n\tfunction ticksFromTimestamps(scale, values, majorUnit) {\n\t\tvar ticks = [];\n\t\tvar i, ilen, value, major;\n\t\n\t\tfor (i = 0, ilen = values.length; i < ilen; ++i) {\n\t\t\tvalue = values[i];\n\t\t\tmajor = majorUnit ? value === +scale._adapter.startOf(value, majorUnit) : false;\n\t\n\t\t\tticks.push({\n\t\t\t\tvalue: value,\n\t\t\t\tmajor: major\n\t\t\t});\n\t\t}\n\t\n\t\treturn ticks;\n\t}\n\t\n\tvar defaultConfig$4 = {\n\t\tposition: 'bottom',\n\t\n\t\t/**\n\t\t * Data distribution along the scale:\n\t\t * - 'linear': data are spread according to their time (distances can vary),\n\t\t * - 'series': data are spread at the same distance from each other.\n\t\t * @see https://github.com/chartjs/Chart.js/pull/4507\n\t\t * @since 2.7.0\n\t\t */\n\t\tdistribution: 'linear',\n\t\n\t\t/**\n\t\t * Scale boundary strategy (bypassed by min/max time options)\n\t\t * - `data`: make sure data are fully visible, ticks outside are removed\n\t\t * - `ticks`: make sure ticks are fully visible, data outside are truncated\n\t\t * @see https://github.com/chartjs/Chart.js/pull/4556\n\t\t * @since 2.7.0\n\t\t */\n\t\tbounds: 'data',\n\t\n\t\tadapters: {},\n\t\ttime: {\n\t\t\tparser: false, // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n\t\t\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from https://momentjs.com/docs/#/parsing/string-format/\n\t\t\tunit: false, // false == automatic or override with week, month, year, etc.\n\t\t\tround: false, // none, or override with week, month, year, etc.\n\t\t\tdisplayFormat: false, // DEPRECATED\n\t\t\tisoWeekday: false, // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/\n\t\t\tminUnit: 'millisecond',\n\t\t\tdisplayFormats: {}\n\t\t},\n\t\tticks: {\n\t\t\tautoSkip: false,\n\t\n\t\t\t/**\n\t\t\t * Ticks generation input values:\n\t\t\t * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n\t\t\t * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n\t\t\t * - 'labels': generates ticks from user given `data.labels` values ONLY.\n\t\t\t * @see https://github.com/chartjs/Chart.js/pull/4507\n\t\t\t * @since 2.7.0\n\t\t\t */\n\t\t\tsource: 'auto',\n\t\n\t\t\tmajor: {\n\t\t\t\tenabled: false\n\t\t\t}\n\t\t}\n\t};\n\t\n\tvar scale_time = core_scale.extend({\n\t\tinitialize: function() {\n\t\t\tthis.mergeTicksOptions();\n\t\t\tcore_scale.prototype.initialize.call(this);\n\t\t},\n\t\n\t\tupdate: function() {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tvar time = options.time || (options.time = {});\n\t\t\tvar adapter = me._adapter = new core_adapters._date(options.adapters.date);\n\t\n\t\t\t// DEPRECATIONS: output a message only one time per update\n\t\t\tif (time.format) {\n\t\t\t\tconsole.warn('options.time.format is deprecated and replaced by options.time.parser.');\n\t\t\t}\n\t\n\t\t\t// Backward compatibility: before introducing adapter, `displayFormats` was\n\t\t\t// supposed to contain *all* unit/string pairs but this can't be resolved\n\t\t\t// when loading the scale (adapters are loaded afterward), so let's populate\n\t\t\t// missing formats on update\n\t\t\thelpers$1.mergeIf(time.displayFormats, adapter.formats());\n\t\n\t\t\treturn core_scale.prototype.update.apply(me, arguments);\n\t\t},\n\t\n\t\t/**\n\t\t * Allows data to be referenced via 't' attribute\n\t\t */\n\t\tgetRightValue: function(rawValue) {\n\t\t\tif (rawValue && rawValue.t !== undefined) {\n\t\t\t\trawValue = rawValue.t;\n\t\t\t}\n\t\t\treturn core_scale.prototype.getRightValue.call(this, rawValue);\n\t\t},\n\t\n\t\tdetermineDataLimits: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar adapter = me._adapter;\n\t\t\tvar timeOpts = me.options.time;\n\t\t\tvar unit = timeOpts.unit || 'day';\n\t\t\tvar min = MAX_INTEGER;\n\t\t\tvar max = MIN_INTEGER;\n\t\t\tvar timestamps = [];\n\t\t\tvar datasets = [];\n\t\t\tvar labels = [];\n\t\t\tvar i, j, ilen, jlen, data, timestamp;\n\t\t\tvar dataLabels = chart.data.labels || [];\n\t\n\t\t\t// Convert labels to timestamps\n\t\t\tfor (i = 0, ilen = dataLabels.length; i < ilen; ++i) {\n\t\t\t\tlabels.push(parse(me, dataLabels[i]));\n\t\t\t}\n\t\n\t\t\t// Convert data to timestamps\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tif (chart.isDatasetVisible(i)) {\n\t\t\t\t\tdata = chart.data.datasets[i].data;\n\t\n\t\t\t\t\t// Let's consider that all data have the same format.\n\t\t\t\t\tif (helpers$1.isObject(data[0])) {\n\t\t\t\t\t\tdatasets[i] = [];\n\t\n\t\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\n\t\t\t\t\t\t\ttimestamp = parse(me, data[j]);\n\t\t\t\t\t\t\ttimestamps.push(timestamp);\n\t\t\t\t\t\t\tdatasets[i][j] = timestamp;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (j = 0, jlen = labels.length; j < jlen; ++j) {\n\t\t\t\t\t\t\ttimestamps.push(labels[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdatasets[i] = labels.slice(0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdatasets[i] = [];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (labels.length) {\n\t\t\t\t// Sort labels **after** data have been converted\n\t\t\t\tlabels = arrayUnique(labels).sort(sorter);\n\t\t\t\tmin = Math.min(min, labels[0]);\n\t\t\t\tmax = Math.max(max, labels[labels.length - 1]);\n\t\t\t}\n\t\n\t\t\tif (timestamps.length) {\n\t\t\t\ttimestamps = arrayUnique(timestamps).sort(sorter);\n\t\t\t\tmin = Math.min(min, timestamps[0]);\n\t\t\t\tmax = Math.max(max, timestamps[timestamps.length - 1]);\n\t\t\t}\n\t\n\t\t\tmin = parse(me, timeOpts.min) || min;\n\t\t\tmax = parse(me, timeOpts.max) || max;\n\t\n\t\t\t// In case there is no valid min/max, set limits based on unit time option\n\t\t\tmin = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;\n\t\t\tmax = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max;\n\t\n\t\t\t// Make sure that max is strictly higher than min (required by the lookup table)\n\t\t\tme.min = Math.min(min, max);\n\t\t\tme.max = Math.max(min + 1, max);\n\t\n\t\t\t// PRIVATE\n\t\t\tme._horizontal = me.isHorizontal();\n\t\t\tme._table = [];\n\t\t\tme._timestamps = {\n\t\t\t\tdata: timestamps,\n\t\t\t\tdatasets: datasets,\n\t\t\t\tlabels: labels\n\t\t\t};\n\t\t},\n\t\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\t\t\tvar options = me.options;\n\t\t\tvar timeOpts = options.time;\n\t\t\tvar timestamps = [];\n\t\t\tvar ticks = [];\n\t\t\tvar i, ilen, timestamp;\n\t\n\t\t\tswitch (options.ticks.source) {\n\t\t\tcase 'data':\n\t\t\t\ttimestamps = me._timestamps.data;\n\t\t\t\tbreak;\n\t\t\tcase 'labels':\n\t\t\t\ttimestamps = me._timestamps.labels;\n\t\t\t\tbreak;\n\t\t\tcase 'auto':\n\t\t\tdefault:\n\t\t\t\ttimestamps = generate(me, min, max, me.getLabelCapacity(min), options);\n\t\t\t}\n\t\n\t\t\tif (options.bounds === 'ticks' && timestamps.length) {\n\t\t\t\tmin = timestamps[0];\n\t\t\t\tmax = timestamps[timestamps.length - 1];\n\t\t\t}\n\t\n\t\t\t// Enforce limits with user min/max options\n\t\t\tmin = parse(me, timeOpts.min) || min;\n\t\t\tmax = parse(me, timeOpts.max) || max;\n\t\n\t\t\t// Remove ticks outside the min/max range\n\t\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\t\t\ttimestamp = timestamps[i];\n\t\t\t\tif (timestamp >= min && timestamp <= max) {\n\t\t\t\t\tticks.push(timestamp);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tme.min = min;\n\t\t\tme.max = max;\n\t\n\t\t\t// PRIVATE\n\t\t\tme._unit = timeOpts.unit || determineUnitForFormatting(me, ticks, timeOpts.minUnit, me.min, me.max);\n\t\t\tme._majorUnit = determineMajorUnit(me._unit);\n\t\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\n\t\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\n\t\n\t\t\tif (options.ticks.reverse) {\n\t\t\t\tticks.reverse();\n\t\t\t}\n\t\n\t\t\treturn ticksFromTimestamps(me, ticks, me._majorUnit);\n\t\t},\n\t\n\t\tgetLabelForIndex: function(index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar adapter = me._adapter;\n\t\t\tvar data = me.chart.data;\n\t\t\tvar timeOpts = me.options.time;\n\t\t\tvar label = data.labels && index < data.labels.length ? data.labels[index] : '';\n\t\t\tvar value = data.datasets[datasetIndex].data[index];\n\t\n\t\t\tif (helpers$1.isObject(value)) {\n\t\t\t\tlabel = me.getRightValue(value);\n\t\t\t}\n\t\t\tif (timeOpts.tooltipFormat) {\n\t\t\t\treturn adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);\n\t\t\t}\n\t\t\tif (typeof label === 'string') {\n\t\t\t\treturn label;\n\t\t\t}\n\t\t\treturn adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);\n\t\t},\n\t\n\t\t/**\n\t\t * Function to format an individual tick mark\n\t\t * @private\n\t\t */\n\t\ttickFormatFunction: function(time, index, ticks, format) {\n\t\t\tvar me = this;\n\t\t\tvar adapter = me._adapter;\n\t\t\tvar options = me.options;\n\t\t\tvar formats = options.time.displayFormats;\n\t\t\tvar minorFormat = formats[me._unit];\n\t\t\tvar majorUnit = me._majorUnit;\n\t\t\tvar majorFormat = formats[majorUnit];\n\t\t\tvar majorTime = +adapter.startOf(time, majorUnit);\n\t\t\tvar majorTickOpts = options.ticks.major;\n\t\t\tvar major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;\n\t\t\tvar label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);\n\t\t\tvar tickOpts = major ? majorTickOpts : options.ticks.minor;\n\t\t\tvar formatter = valueOrDefault$c(tickOpts.callback, tickOpts.userCallback);\n\t\n\t\t\treturn formatter ? formatter(label, index, ticks) : label;\n\t\t},\n\t\n\t\tconvertTicksToLabels: function(ticks) {\n\t\t\tvar labels = [];\n\t\t\tvar i, ilen;\n\t\n\t\t\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\t\t\tlabels.push(this.tickFormatFunction(ticks[i].value, i, ticks));\n\t\t\t}\n\t\n\t\t\treturn labels;\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetPixelForOffset: function(time) {\n\t\t\tvar me = this;\n\t\t\tvar isReverse = me.options.ticks.reverse;\n\t\t\tvar size = me._horizontal ? me.width : me.height;\n\t\t\tvar start = me._horizontal ? isReverse ? me.right : me.left : isReverse ? me.bottom : me.top;\n\t\t\tvar pos = interpolate$1(me._table, 'time', time, 'pos');\n\t\t\tvar offset = size * (me._offsets.start + pos) / (me._offsets.start + 1 + me._offsets.end);\n\t\n\t\t\treturn isReverse ? start - offset : start + offset;\n\t\t},\n\t\n\t\tgetPixelForValue: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar time = null;\n\t\n\t\t\tif (index !== undefined && datasetIndex !== undefined) {\n\t\t\t\ttime = me._timestamps.datasets[datasetIndex][index];\n\t\t\t}\n\t\n\t\t\tif (time === null) {\n\t\t\t\ttime = parse(me, value);\n\t\t\t}\n\t\n\t\t\tif (time !== null) {\n\t\t\t\treturn me.getPixelForOffset(time);\n\t\t\t}\n\t\t},\n\t\n\t\tgetPixelForTick: function(index) {\n\t\t\tvar ticks = this.getTicks();\n\t\t\treturn index >= 0 && index < ticks.length ?\n\t\t\t\tthis.getPixelForOffset(ticks[index].value) :\n\t\t\t\tnull;\n\t\t},\n\t\n\t\tgetValueForPixel: function(pixel) {\n\t\t\tvar me = this;\n\t\t\tvar size = me._horizontal ? me.width : me.height;\n\t\t\tvar start = me._horizontal ? me.left : me.top;\n\t\t\tvar pos = (size ? (pixel - start) / size : 0) * (me._offsets.start + 1 + me._offsets.start) - me._offsets.end;\n\t\t\tvar time = interpolate$1(me._table, 'pos', pos, 'time');\n\t\n\t\t\t// DEPRECATION, we should return time directly\n\t\t\treturn me._adapter._create(time);\n\t\t},\n\t\n\t\t/**\n\t\t * Crude approximation of what the label width might be\n\t\t * @private\n\t\t */\n\t\tgetLabelWidth: function(label) {\n\t\t\tvar me = this;\n\t\t\tvar ticksOpts = me.options.ticks;\n\t\t\tvar tickLabelWidth = me.ctx.measureText(label).width;\n\t\t\tvar angle = helpers$1.toRadians(ticksOpts.maxRotation);\n\t\t\tvar cosRotation = Math.cos(angle);\n\t\t\tvar sinRotation = Math.sin(angle);\n\t\t\tvar tickFontSize = valueOrDefault$c(ticksOpts.fontSize, core_defaults.global.defaultFontSize);\n\t\n\t\t\treturn (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\tgetLabelCapacity: function(exampleTime) {\n\t\t\tvar me = this;\n\t\n\t\t\t// pick the longest format (milliseconds) for guestimation\n\t\t\tvar format = me.options.time.displayFormats.millisecond;\n\t\t\tvar exampleLabel = me.tickFormatFunction(exampleTime, 0, [], format);\n\t\t\tvar tickLabelWidth = me.getLabelWidth(exampleLabel);\n\t\t\tvar innerWidth = me.isHorizontal() ? me.width : me.height;\n\t\t\tvar capacity = Math.floor(innerWidth / tickLabelWidth);\n\t\n\t\t\treturn capacity > 0 ? capacity : 1;\n\t\t}\n\t});\n\t\n\t// INTERNAL: static default options, registered in src/index.js\n\tvar _defaults$4 = defaultConfig$4;\n\tscale_time._defaults = _defaults$4;\n\t\n\tvar scales = {\n\t\tcategory: scale_category,\n\t\tlinear: scale_linear,\n\t\tlogarithmic: scale_logarithmic,\n\t\tradialLinear: scale_radialLinear,\n\t\ttime: scale_time\n\t};\n\t\n\tvar FORMATS = {\n\t\tdatetime: 'MMM D, YYYY, h:mm:ss a',\n\t\tmillisecond: 'h:mm:ss.SSS a',\n\t\tsecond: 'h:mm:ss a',\n\t\tminute: 'h:mm a',\n\t\thour: 'hA',\n\t\tday: 'MMM D',\n\t\tweek: 'll',\n\t\tmonth: 'MMM YYYY',\n\t\tquarter: '[Q]Q - YYYY',\n\t\tyear: 'YYYY'\n\t};\n\t\n\tcore_adapters._date.override(typeof moment === 'function' ? {\n\t\t_id: 'moment', // DEBUG ONLY\n\t\n\t\tformats: function() {\n\t\t\treturn FORMATS;\n\t\t},\n\t\n\t\tparse: function(value, format) {\n\t\t\tif (typeof value === 'string' && typeof format === 'string') {\n\t\t\t\tvalue = moment(value, format);\n\t\t\t} else if (!(value instanceof moment)) {\n\t\t\t\tvalue = moment(value);\n\t\t\t}\n\t\t\treturn value.isValid() ? value.valueOf() : null;\n\t\t},\n\t\n\t\tformat: function(time, format) {\n\t\t\treturn moment(time).format(format);\n\t\t},\n\t\n\t\tadd: function(time, amount, unit) {\n\t\t\treturn moment(time).add(amount, unit).valueOf();\n\t\t},\n\t\n\t\tdiff: function(max, min, unit) {\n\t\t\treturn moment.duration(moment(max).diff(moment(min))).as(unit);\n\t\t},\n\t\n\t\tstartOf: function(time, unit, weekday) {\n\t\t\ttime = moment(time);\n\t\t\tif (unit === 'isoWeek') {\n\t\t\t\treturn time.isoWeekday(weekday).valueOf();\n\t\t\t}\n\t\t\treturn time.startOf(unit).valueOf();\n\t\t},\n\t\n\t\tendOf: function(time, unit) {\n\t\t\treturn moment(time).endOf(unit).valueOf();\n\t\t},\n\t\n\t\t// DEPRECATIONS\n\t\n\t\t/**\n\t\t * Provided for backward compatibility with scale.getValueForPixel().\n\t\t * @deprecated since version 2.8.0\n\t\t * @todo remove at version 3\n\t\t * @private\n\t\t */\n\t\t_create: function(time) {\n\t\t\treturn moment(time);\n\t\t},\n\t} : {});\n\t\n\tcore_defaults._set('global', {\n\t\tplugins: {\n\t\t\tfiller: {\n\t\t\t\tpropagate: true\n\t\t\t}\n\t\t}\n\t});\n\t\n\tvar mappers = {\n\t\tdataset: function(source) {\n\t\t\tvar index = source.fill;\n\t\t\tvar chart = source.chart;\n\t\t\tvar meta = chart.getDatasetMeta(index);\n\t\t\tvar visible = meta && chart.isDatasetVisible(index);\n\t\t\tvar points = (visible && meta.dataset._children) || [];\n\t\t\tvar length = points.length || 0;\n\t\n\t\t\treturn !length ? null : function(point, i) {\n\t\t\t\treturn (i < length && points[i]._view) || null;\n\t\t\t};\n\t\t},\n\t\n\t\tboundary: function(source) {\n\t\t\tvar boundary = source.boundary;\n\t\t\tvar x = boundary ? boundary.x : null;\n\t\t\tvar y = boundary ? boundary.y : null;\n\t\n\t\t\treturn function(point) {\n\t\t\t\treturn {\n\t\t\t\t\tx: x === null ? point.x : x,\n\t\t\t\t\ty: y === null ? point.y : y,\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\t};\n\t\n\t// @todo if (fill[0] === '#')\n\tfunction decodeFill(el, index, count) {\n\t\tvar model = el._model || {};\n\t\tvar fill = model.fill;\n\t\tvar target;\n\t\n\t\tif (fill === undefined) {\n\t\t\tfill = !!model.backgroundColor;\n\t\t}\n\t\n\t\tif (fill === false || fill === null) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tif (fill === true) {\n\t\t\treturn 'origin';\n\t\t}\n\t\n\t\ttarget = parseFloat(fill, 10);\n\t\tif (isFinite(target) && Math.floor(target) === target) {\n\t\t\tif (fill[0] === '-' || fill[0] === '+') {\n\t\t\t\ttarget = index + target;\n\t\t\t}\n\t\n\t\t\tif (target === index || target < 0 || target >= count) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\treturn target;\n\t\t}\n\t\n\t\tswitch (fill) {\n\t\t// compatibility\n\t\tcase 'bottom':\n\t\t\treturn 'start';\n\t\tcase 'top':\n\t\t\treturn 'end';\n\t\tcase 'zero':\n\t\t\treturn 'origin';\n\t\t// supported boundaries\n\t\tcase 'origin':\n\t\tcase 'start':\n\t\tcase 'end':\n\t\t\treturn fill;\n\t\t// invalid fill values\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tfunction computeBoundary(source) {\n\t\tvar model = source.el._model || {};\n\t\tvar scale = source.el._scale || {};\n\t\tvar fill = source.fill;\n\t\tvar target = null;\n\t\tvar horizontal;\n\t\n\t\tif (isFinite(fill)) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\t// Backward compatibility: until v3, we still need to support boundary values set on\n\t\t// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and\n\t\t// controllers might still use it (e.g. the Smith chart).\n\t\n\t\tif (fill === 'start') {\n\t\t\ttarget = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\n\t\t} else if (fill === 'end') {\n\t\t\ttarget = model.scaleTop === undefined ? scale.top : model.scaleTop;\n\t\t} else if (model.scaleZero !== undefined) {\n\t\t\ttarget = model.scaleZero;\n\t\t} else if (scale.getBasePosition) {\n\t\t\ttarget = scale.getBasePosition();\n\t\t} else if (scale.getBasePixel) {\n\t\t\ttarget = scale.getBasePixel();\n\t\t}\n\t\n\t\tif (target !== undefined && target !== null) {\n\t\t\tif (target.x !== undefined && target.y !== undefined) {\n\t\t\t\treturn target;\n\t\t\t}\n\t\n\t\t\tif (helpers$1.isFinite(target)) {\n\t\t\t\thorizontal = scale.isHorizontal();\n\t\t\t\treturn {\n\t\t\t\t\tx: horizontal ? target : null,\n\t\t\t\t\ty: horizontal ? null : target\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\n\t\treturn null;\n\t}\n\t\n\tfunction resolveTarget(sources, index, propagate) {\n\t\tvar source = sources[index];\n\t\tvar fill = source.fill;\n\t\tvar visited = [index];\n\t\tvar target;\n\t\n\t\tif (!propagate) {\n\t\t\treturn fill;\n\t\t}\n\t\n\t\twhile (fill !== false && visited.indexOf(fill) === -1) {\n\t\t\tif (!isFinite(fill)) {\n\t\t\t\treturn fill;\n\t\t\t}\n\t\n\t\t\ttarget = sources[fill];\n\t\t\tif (!target) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tif (target.visible) {\n\t\t\t\treturn fill;\n\t\t\t}\n\t\n\t\t\tvisited.push(fill);\n\t\t\tfill = target.fill;\n\t\t}\n\t\n\t\treturn false;\n\t}\n\t\n\tfunction createMapper(source) {\n\t\tvar fill = source.fill;\n\t\tvar type = 'dataset';\n\t\n\t\tif (fill === false) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\tif (!isFinite(fill)) {\n\t\t\ttype = 'boundary';\n\t\t}\n\t\n\t\treturn mappers[type](source);\n\t}\n\t\n\tfunction isDrawable(point) {\n\t\treturn point && !point.skip;\n\t}\n\t\n\tfunction drawArea(ctx, curve0, curve1, len0, len1) {\n\t\tvar i;\n\t\n\t\tif (!len0 || !len1) {\n\t\t\treturn;\n\t\t}\n\t\n\t\t// building first area curve (normal)\n\t\tctx.moveTo(curve0[0].x, curve0[0].y);\n\t\tfor (i = 1; i < len0; ++i) {\n\t\t\thelpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);\n\t\t}\n\t\n\t\t// joining the two area curves\n\t\tctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);\n\t\n\t\t// building opposite area curve (reverse)\n\t\tfor (i = len1 - 1; i > 0; --i) {\n\t\t\thelpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);\n\t\t}\n\t}\n\t\n\tfunction doFill(ctx, points, mapper, view, color, loop) {\n\t\tvar count = points.length;\n\t\tvar span = view.spanGaps;\n\t\tvar curve0 = [];\n\t\tvar curve1 = [];\n\t\tvar len0 = 0;\n\t\tvar len1 = 0;\n\t\tvar i, ilen, index, p0, p1, d0, d1;\n\t\n\t\tctx.beginPath();\n\t\n\t\tfor (i = 0, ilen = (count + !!loop); i < ilen; ++i) {\n\t\t\tindex = i % count;\n\t\t\tp0 = points[index]._view;\n\t\t\tp1 = mapper(p0, index, view);\n\t\t\td0 = isDrawable(p0);\n\t\t\td1 = isDrawable(p1);\n\t\n\t\t\tif (d0 && d1) {\n\t\t\t\tlen0 = curve0.push(p0);\n\t\t\t\tlen1 = curve1.push(p1);\n\t\t\t} else if (len0 && len1) {\n\t\t\t\tif (!span) {\n\t\t\t\t\tdrawArea(ctx, curve0, curve1, len0, len1);\n\t\t\t\t\tlen0 = len1 = 0;\n\t\t\t\t\tcurve0 = [];\n\t\t\t\t\tcurve1 = [];\n\t\t\t\t} else {\n\t\t\t\t\tif (d0) {\n\t\t\t\t\t\tcurve0.push(p0);\n\t\t\t\t\t}\n\t\t\t\t\tif (d1) {\n\t\t\t\t\t\tcurve1.push(p1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tdrawArea(ctx, curve0, curve1, len0, len1);\n\t\n\t\tctx.closePath();\n\t\tctx.fillStyle = color;\n\t\tctx.fill();\n\t}\n\t\n\tvar plugin_filler = {\n\t\tid: 'filler',\n\t\n\t\tafterDatasetsUpdate: function(chart, options) {\n\t\t\tvar count = (chart.data.datasets || []).length;\n\t\t\tvar propagate = options.propagate;\n\t\t\tvar sources = [];\n\t\t\tvar meta, i, el, source;\n\t\n\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tel = meta.dataset;\n\t\t\t\tsource = null;\n\t\n\t\t\t\tif (el && el._model && el instanceof elements.Line) {\n\t\t\t\t\tsource = {\n\t\t\t\t\t\tvisible: chart.isDatasetVisible(i),\n\t\t\t\t\t\tfill: decodeFill(el, i, count),\n\t\t\t\t\t\tchart: chart,\n\t\t\t\t\t\tel: el\n\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\tmeta.$filler = source;\n\t\t\t\tsources.push(source);\n\t\t\t}\n\t\n\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\tsource = sources[i];\n\t\t\t\tif (!source) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\n\t\t\t\tsource.fill = resolveTarget(sources, i, propagate);\n\t\t\t\tsource.boundary = computeBoundary(source);\n\t\t\t\tsource.mapper = createMapper(source);\n\t\t\t}\n\t\t},\n\t\n\t\tbeforeDatasetDraw: function(chart, args) {\n\t\t\tvar meta = args.meta.$filler;\n\t\t\tif (!meta) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar ctx = chart.ctx;\n\t\t\tvar el = meta.el;\n\t\t\tvar view = el._view;\n\t\t\tvar points = el._children || [];\n\t\t\tvar mapper = meta.mapper;\n\t\t\tvar color = view.backgroundColor || core_defaults.global.defaultColor;\n\t\n\t\t\tif (mapper && color && points.length) {\n\t\t\t\thelpers$1.canvas.clipArea(ctx, chart.chartArea);\n\t\t\t\tdoFill(ctx, points, mapper, view, color, el._loop);\n\t\t\t\thelpers$1.canvas.unclipArea(ctx);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tvar noop$1 = helpers$1.noop;\n\tvar valueOrDefault$d = helpers$1.valueOrDefault;\n\t\n\tcore_defaults._set('global', {\n\t\tlegend: {\n\t\t\tdisplay: true,\n\t\t\tposition: 'top',\n\t\t\tfullWidth: true,\n\t\t\treverse: false,\n\t\t\tweight: 1000,\n\t\n\t\t\t// a callback that will handle\n\t\t\tonClick: function(e, legendItem) {\n\t\t\t\tvar index = legendItem.datasetIndex;\n\t\t\t\tvar ci = this.chart;\n\t\t\t\tvar meta = ci.getDatasetMeta(index);\n\t\n\t\t\t\t// See controller.isDatasetVisible comment\n\t\t\t\tmeta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;\n\t\n\t\t\t\t// We hid a dataset ... rerender the chart\n\t\t\t\tci.update();\n\t\t\t},\n\t\n\t\t\tonHover: null,\n\t\t\tonLeave: null,\n\t\n\t\t\tlabels: {\n\t\t\t\tboxWidth: 40,\n\t\t\t\tpadding: 10,\n\t\t\t\t// Generates labels shown in the legend\n\t\t\t\t// Valid properties to return:\n\t\t\t\t// text : text to display\n\t\t\t\t// fillStyle : fill of coloured box\n\t\t\t\t// strokeStyle: stroke of coloured box\n\t\t\t\t// hidden : if this legend item refers to a hidden item\n\t\t\t\t// lineCap : cap style for line\n\t\t\t\t// lineDash\n\t\t\t\t// lineDashOffset :\n\t\t\t\t// lineJoin :\n\t\t\t\t// lineWidth :\n\t\t\t\tgenerateLabels: function(chart) {\n\t\t\t\t\tvar data = chart.data;\n\t\t\t\t\treturn helpers$1.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttext: dataset.label,\n\t\t\t\t\t\t\tfillStyle: (!helpers$1.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\n\t\t\t\t\t\t\thidden: !chart.isDatasetVisible(i),\n\t\t\t\t\t\t\tlineCap: dataset.borderCapStyle,\n\t\t\t\t\t\t\tlineDash: dataset.borderDash,\n\t\t\t\t\t\t\tlineDashOffset: dataset.borderDashOffset,\n\t\t\t\t\t\t\tlineJoin: dataset.borderJoinStyle,\n\t\t\t\t\t\t\tlineWidth: dataset.borderWidth,\n\t\t\t\t\t\t\tstrokeStyle: dataset.borderColor,\n\t\t\t\t\t\t\tpointStyle: dataset.pointStyle,\n\t\n\t\t\t\t\t\t\t// Below is extra data used for toggling the datasets\n\t\t\t\t\t\t\tdatasetIndex: i\n\t\t\t\t\t\t};\n\t\t\t\t\t}, this) : [];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\n\t\tlegendCallback: function(chart) {\n\t\t\tvar text = [];\n\t\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\t\tfor (var i = 0; i < chart.data.datasets.length; i++) {\n\t\t\t\ttext.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n\t\t\t\tif (chart.data.datasets[i].label) {\n\t\t\t\t\ttext.push(chart.data.datasets[i].label);\n\t\t\t\t}\n\t\t\t\ttext.push('</li>');\n\t\t\t}\n\t\t\ttext.push('</ul>');\n\t\t\treturn text.join('');\n\t\t}\n\t});\n\t\n\t/**\n\t * Helper function to get the box width based on the usePointStyle option\n\t * @param {object} labelopts - the label options on the legend\n\t * @param {number} fontSize - the label font size\n\t * @return {number} width of the color box area\n\t */\n\tfunction getBoxWidth(labelOpts, fontSize) {\n\t\treturn labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ?\n\t\t\tfontSize :\n\t\t\tlabelOpts.boxWidth;\n\t}\n\t\n\t/**\n\t * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\n\t */\n\tvar Legend = core_element.extend({\n\t\n\t\tinitialize: function(config) {\n\t\t\thelpers$1.extend(this, config);\n\t\n\t\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\t\tthis.legendHitBoxes = [];\n\t\n\t\t\t/**\n\t \t\t * @private\n\t \t\t */\n\t\t\tthis._hoveredItem = null;\n\t\n\t\t\t// Are we in doughnut mode which has a different data type\n\t\t\tthis.doughnutMode = false;\n\t\t},\n\t\n\t\t// These methods are ordered by lifecycle. Utilities then follow.\n\t\t// Any function defined here is inherited by all legend types.\n\t\t// Any function can be extended by the legend type\n\t\n\t\tbeforeUpdate: noop$1,\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\t\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\t\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = margins;\n\t\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\t\t\t// Labels\n\t\t\tme.beforeBuildLabels();\n\t\t\tme.buildLabels();\n\t\t\tme.afterBuildLabels();\n\t\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\t\n\t\t\treturn me.minSize;\n\t\t},\n\t\tafterUpdate: noop$1,\n\t\n\t\t//\n\t\n\t\tbeforeSetDimensions: noop$1,\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\t\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\t\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\t\n\t\t\t// Reset minSize\n\t\t\tme.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\t},\n\t\tafterSetDimensions: noop$1,\n\t\n\t\t//\n\t\n\t\tbeforeBuildLabels: noop$1,\n\t\tbuildLabels: function() {\n\t\t\tvar me = this;\n\t\t\tvar labelOpts = me.options.labels || {};\n\t\t\tvar legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];\n\t\n\t\t\tif (labelOpts.filter) {\n\t\t\t\tlegendItems = legendItems.filter(function(item) {\n\t\t\t\t\treturn labelOpts.filter(item, me.chart.data);\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tif (me.options.reverse) {\n\t\t\t\tlegendItems.reverse();\n\t\t\t}\n\t\n\t\t\tme.legendItems = legendItems;\n\t\t},\n\t\tafterBuildLabels: noop$1,\n\t\n\t\t//\n\t\n\t\tbeforeFit: noop$1,\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar labelOpts = opts.labels;\n\t\t\tvar display = opts.display;\n\t\n\t\t\tvar ctx = me.ctx;\n\t\n\t\t\tvar labelFont = helpers$1.options._parseFont(labelOpts);\n\t\t\tvar fontSize = labelFont.size;\n\t\n\t\t\t// Reset hit boxes\n\t\t\tvar hitboxes = me.legendHitBoxes = [];\n\t\n\t\t\tvar minSize = me.minSize;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\t\tminSize.height = display ? 10 : 0;\n\t\t\t} else {\n\t\t\t\tminSize.width = display ? 10 : 0;\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\t\n\t\t\t// Increase sizes here\n\t\t\tif (display) {\n\t\t\t\tctx.font = labelFont.string;\n\t\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t// Labels\n\t\n\t\t\t\t\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n\t\t\t\t\tvar lineWidths = me.lineWidths = [0];\n\t\t\t\t\tvar totalHeight = 0;\n\t\n\t\t\t\t\tctx.textAlign = 'left';\n\t\t\t\t\tctx.textBaseline = 'top';\n\t\n\t\t\t\t\thelpers$1.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\t\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\t\n\t\t\t\t\t\tif (i === 0 || lineWidths[lineWidths.length - 1] + width + labelOpts.padding > minSize.width) {\n\t\t\t\t\t\t\ttotalHeight += fontSize + labelOpts.padding;\n\t\t\t\t\t\t\tlineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = labelOpts.padding;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t\t};\n\t\n\t\t\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n\t\t\t\t\t});\n\t\n\t\t\t\t\tminSize.height += totalHeight;\n\t\n\t\t\t\t} else {\n\t\t\t\t\tvar vPadding = labelOpts.padding;\n\t\t\t\t\tvar columnWidths = me.columnWidths = [];\n\t\t\t\t\tvar totalWidth = labelOpts.padding;\n\t\t\t\t\tvar currentColWidth = 0;\n\t\t\t\t\tvar currentColHeight = 0;\n\t\t\t\t\tvar itemHeight = fontSize + vPadding;\n\t\n\t\t\t\t\thelpers$1.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\t\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\t\n\t\t\t\t\t\t// If too tall, go to new column\n\t\t\t\t\t\tif (i > 0 && currentColHeight + itemHeight > minSize.height - vPadding) {\n\t\t\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\n\t\t\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width\n\t\n\t\t\t\t\t\t\tcurrentColWidth = 0;\n\t\t\t\t\t\t\tcurrentColHeight = 0;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Get max width\n\t\t\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\n\t\t\t\t\t\tcurrentColHeight += itemHeight;\n\t\n\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\twidth: itemWidth,\n\t\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\n\t\t\t\t\ttotalWidth += currentColWidth;\n\t\t\t\t\tcolumnWidths.push(currentColWidth);\n\t\t\t\t\tminSize.width += totalWidth;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\t},\n\t\tafterFit: noop$1,\n\t\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t},\n\t\n\t\t// Actually draw the legend on the canvas\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar labelOpts = opts.labels;\n\t\t\tvar globalDefaults = core_defaults.global;\n\t\t\tvar defaultColor = globalDefaults.defaultColor;\n\t\t\tvar lineDefault = globalDefaults.elements.line;\n\t\t\tvar legendWidth = me.width;\n\t\t\tvar lineWidths = me.lineWidths;\n\t\n\t\t\tif (opts.display) {\n\t\t\t\tvar ctx = me.ctx;\n\t\t\t\tvar fontColor = valueOrDefault$d(labelOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\t\tvar labelFont = helpers$1.options._parseFont(labelOpts);\n\t\t\t\tvar fontSize = labelFont.size;\n\t\t\t\tvar cursor;\n\t\n\t\t\t\t// Canvas setup\n\t\t\t\tctx.textAlign = 'left';\n\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\tctx.lineWidth = 0.5;\n\t\t\t\tctx.strokeStyle = fontColor; // for strikethrough effect\n\t\t\t\tctx.fillStyle = fontColor; // render in correct colour\n\t\t\t\tctx.font = labelFont.string;\n\t\n\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\tvar hitboxes = me.legendHitBoxes;\n\t\n\t\t\t\t// current position\n\t\t\t\tvar drawLegendBox = function(x, y, legendItem) {\n\t\t\t\t\tif (isNaN(boxWidth) || boxWidth <= 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Set the ctx for the box\n\t\t\t\t\tctx.save();\n\t\n\t\t\t\t\tvar lineWidth = valueOrDefault$d(legendItem.lineWidth, lineDefault.borderWidth);\n\t\t\t\t\tctx.fillStyle = valueOrDefault$d(legendItem.fillStyle, defaultColor);\n\t\t\t\t\tctx.lineCap = valueOrDefault$d(legendItem.lineCap, lineDefault.borderCapStyle);\n\t\t\t\t\tctx.lineDashOffset = valueOrDefault$d(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n\t\t\t\t\tctx.lineJoin = valueOrDefault$d(legendItem.lineJoin, lineDefault.borderJoinStyle);\n\t\t\t\t\tctx.lineWidth = lineWidth;\n\t\t\t\t\tctx.strokeStyle = valueOrDefault$d(legendItem.strokeStyle, defaultColor);\n\t\n\t\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\t\t// IE 9 and 10 do not support line dash\n\t\t\t\t\t\tctx.setLineDash(valueOrDefault$d(legendItem.lineDash, lineDefault.borderDash));\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (opts.labels && opts.labels.usePointStyle) {\n\t\t\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\n\t\t\t\t\t\t// x and y to be center of figure (instead of top left)\n\t\t\t\t\t\tvar radius = boxWidth * Math.SQRT2 / 2;\n\t\t\t\t\t\tvar centerX = x + boxWidth / 2;\n\t\t\t\t\t\tvar centerY = y + fontSize / 2;\n\t\n\t\t\t\t\t\t// Draw pointStyle as legend symbol\n\t\t\t\t\t\thelpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Draw box as legend symbol\n\t\t\t\t\t\tif (lineWidth !== 0) {\n\t\t\t\t\t\t\tctx.strokeRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx.fillRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tctx.restore();\n\t\t\t\t};\n\t\t\t\tvar fillText = function(x, y, legendItem, textWidth) {\n\t\t\t\t\tvar halfFontSize = fontSize / 2;\n\t\t\t\t\tvar xLeft = boxWidth + halfFontSize + x;\n\t\t\t\t\tvar yMiddle = y + halfFontSize;\n\t\n\t\t\t\t\tctx.fillText(legendItem.text, xLeft, yMiddle);\n\t\n\t\t\t\t\tif (legendItem.hidden) {\n\t\t\t\t\t\t// Strikethrough the text if hidden\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\t\tctx.moveTo(xLeft, yMiddle);\n\t\t\t\t\t\tctx.lineTo(xLeft + textWidth, yMiddle);\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\t// Horizontal\n\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tcursor = {\n\t\t\t\t\t\tx: me.left + ((legendWidth - lineWidths[0]) / 2) + labelOpts.padding,\n\t\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\t\tline: 0\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcursor = {\n\t\t\t\t\t\tx: me.left + labelOpts.padding,\n\t\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\t\tline: 0\n\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\tvar itemHeight = fontSize + labelOpts.padding;\n\t\t\t\thelpers$1.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width;\n\t\t\t\t\tvar width = boxWidth + (fontSize / 2) + textWidth;\n\t\t\t\t\tvar x = cursor.x;\n\t\t\t\t\tvar y = cursor.y;\n\t\n\t\t\t\t\t// Use (me.left + me.minSize.width) and (me.top + me.minSize.height)\n\t\t\t\t\t// instead of me.right and me.bottom because me.width and me.height\n\t\t\t\t\t// may have been changed since me.minSize was calculated\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tif (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {\n\t\t\t\t\t\t\ty = cursor.y += itemHeight;\n\t\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2) + labelOpts.padding;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {\n\t\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n\t\t\t\t\t\ty = cursor.y = me.top + labelOpts.padding;\n\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tdrawLegendBox(x, y, legendItem);\n\t\n\t\t\t\t\thitboxes[i].left = x;\n\t\t\t\t\thitboxes[i].top = y;\n\t\n\t\t\t\t\t// Fill the actual label\n\t\t\t\t\tfillText(x, y, legendItem, textWidth);\n\t\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tcursor.x += width + labelOpts.padding;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcursor.y += itemHeight;\n\t\t\t\t\t}\n\t\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_getLegendItemAt: function(x, y) {\n\t\t\tvar me = this;\n\t\t\tvar i, hitBox, lh;\n\t\n\t\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n\t\t\t\t// See if we are touching one of the dataset boxes\n\t\t\t\tlh = me.legendHitBoxes;\n\t\t\t\tfor (i = 0; i < lh.length; ++i) {\n\t\t\t\t\thitBox = lh[i];\n\t\n\t\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n\t\t\t\t\t\t// Touching an element\n\t\t\t\t\t\treturn me.legendItems[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\t},\n\t\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event - The event to handle\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar type = e.type === 'mouseup' ? 'click' : e.type;\n\t\t\tvar hoveredItem;\n\t\n\t\t\tif (type === 'mousemove') {\n\t\t\t\tif (!opts.onHover && !opts.onLeave) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (type === 'click') {\n\t\t\t\tif (!opts.onClick) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Chart event already has relative position in it\n\t\t\thoveredItem = me._getLegendItemAt(e.x, e.y);\n\t\n\t\t\tif (type === 'click') {\n\t\t\t\tif (hoveredItem && opts.onClick) {\n\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\topts.onClick.call(me, e.native, hoveredItem);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (opts.onLeave && hoveredItem !== me._hoveredItem) {\n\t\t\t\t\tif (me._hoveredItem) {\n\t\t\t\t\t\topts.onLeave.call(me, e.native, me._hoveredItem);\n\t\t\t\t\t}\n\t\t\t\t\tme._hoveredItem = hoveredItem;\n\t\t\t\t}\n\t\n\t\t\t\tif (opts.onHover && hoveredItem) {\n\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\topts.onHover.call(me, e.native, hoveredItem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\t\n\tfunction createNewLegendAndAttach(chart, legendOpts) {\n\t\tvar legend = new Legend({\n\t\t\tctx: chart.ctx,\n\t\t\toptions: legendOpts,\n\t\t\tchart: chart\n\t\t});\n\t\n\t\tcore_layouts.configure(chart, legend, legendOpts);\n\t\tcore_layouts.addBox(chart, legend);\n\t\tchart.legend = legend;\n\t}\n\t\n\tvar plugin_legend = {\n\t\tid: 'legend',\n\t\n\t\t/**\n\t\t * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making\n\t\t * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of\n\t\t * the plugin, which one will be re-exposed in the chart.js file.\n\t\t * https://github.com/chartjs/Chart.js/pull/2640\n\t\t * @private\n\t\t */\n\t\t_element: Legend,\n\t\n\t\tbeforeInit: function(chart) {\n\t\t\tvar legendOpts = chart.options.legend;\n\t\n\t\t\tif (legendOpts) {\n\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t\t}\n\t\t},\n\t\n\t\tbeforeUpdate: function(chart) {\n\t\t\tvar legendOpts = chart.options.legend;\n\t\t\tvar legend = chart.legend;\n\t\n\t\t\tif (legendOpts) {\n\t\t\t\thelpers$1.mergeIf(legendOpts, core_defaults.global.legend);\n\t\n\t\t\t\tif (legend) {\n\t\t\t\t\tcore_layouts.configure(chart, legend, legendOpts);\n\t\t\t\t\tlegend.options = legendOpts;\n\t\t\t\t} else {\n\t\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t\t\t}\n\t\t\t} else if (legend) {\n\t\t\t\tcore_layouts.removeBox(chart, legend);\n\t\t\t\tdelete chart.legend;\n\t\t\t}\n\t\t},\n\t\n\t\tafterEvent: function(chart, e) {\n\t\t\tvar legend = chart.legend;\n\t\t\tif (legend) {\n\t\t\t\tlegend.handleEvent(e);\n\t\t\t}\n\t\t}\n\t};\n\t\n\tvar noop$2 = helpers$1.noop;\n\t\n\tcore_defaults._set('global', {\n\t\ttitle: {\n\t\t\tdisplay: false,\n\t\t\tfontStyle: 'bold',\n\t\t\tfullWidth: true,\n\t\t\tpadding: 10,\n\t\t\tposition: 'top',\n\t\t\ttext: '',\n\t\t\tweight: 2000         // by default greater than legend (1000) to be above\n\t\t}\n\t});\n\t\n\t/**\n\t * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\n\t */\n\tvar Title = core_element.extend({\n\t\tinitialize: function(config) {\n\t\t\tvar me = this;\n\t\t\thelpers$1.extend(me, config);\n\t\n\t\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\t\tme.legendHitBoxes = [];\n\t\t},\n\t\n\t\t// These methods are ordered by lifecycle. Utilities then follow.\n\t\n\t\tbeforeUpdate: noop$2,\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\t\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\t\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = margins;\n\t\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\t\t\t// Labels\n\t\t\tme.beforeBuildLabels();\n\t\t\tme.buildLabels();\n\t\t\tme.afterBuildLabels();\n\t\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\t\n\t\t\treturn me.minSize;\n\t\n\t\t},\n\t\tafterUpdate: noop$2,\n\t\n\t\t//\n\t\n\t\tbeforeSetDimensions: noop$2,\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\t\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\t\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\t\n\t\t\t// Reset minSize\n\t\t\tme.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\t},\n\t\tafterSetDimensions: noop$2,\n\t\n\t\t//\n\t\n\t\tbeforeBuildLabels: noop$2,\n\t\tbuildLabels: noop$2,\n\t\tafterBuildLabels: noop$2,\n\t\n\t\t//\n\t\n\t\tbeforeFit: noop$2,\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar display = opts.display;\n\t\t\tvar minSize = me.minSize;\n\t\t\tvar lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;\n\t\t\tvar fontOpts = helpers$1.options._parseFont(opts);\n\t\t\tvar textSize = display ? (lineCount * fontOpts.lineHeight) + (opts.padding * 2) : 0;\n\t\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\t\tminSize.height = textSize;\n\t\t\t} else {\n\t\t\t\tminSize.width = textSize;\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\t\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\n\t\t},\n\t\tafterFit: noop$2,\n\t\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\tvar pos = this.options.position;\n\t\t\treturn pos === 'top' || pos === 'bottom';\n\t\t},\n\t\n\t\t// Actually draw the title block on the canvas\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar ctx = me.ctx;\n\t\t\tvar opts = me.options;\n\t\n\t\t\tif (opts.display) {\n\t\t\t\tvar fontOpts = helpers$1.options._parseFont(opts);\n\t\t\t\tvar lineHeight = fontOpts.lineHeight;\n\t\t\t\tvar offset = lineHeight / 2 + opts.padding;\n\t\t\t\tvar rotation = 0;\n\t\t\t\tvar top = me.top;\n\t\t\t\tvar left = me.left;\n\t\t\t\tvar bottom = me.bottom;\n\t\t\t\tvar right = me.right;\n\t\t\t\tvar maxWidth, titleX, titleY;\n\t\n\t\t\t\tctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor); // render in correct colour\n\t\t\t\tctx.font = fontOpts.string;\n\t\n\t\t\t\t// Horizontal\n\t\t\t\tif (me.isHorizontal()) {\n\t\t\t\t\ttitleX = left + ((right - left) / 2); // midpoint of the width\n\t\t\t\t\ttitleY = top + offset;\n\t\t\t\t\tmaxWidth = right - left;\n\t\t\t\t} else {\n\t\t\t\t\ttitleX = opts.position === 'left' ? left + offset : right - offset;\n\t\t\t\t\ttitleY = top + ((bottom - top) / 2);\n\t\t\t\t\tmaxWidth = bottom - top;\n\t\t\t\t\trotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\n\t\t\t\t}\n\t\n\t\t\t\tctx.save();\n\t\t\t\tctx.translate(titleX, titleY);\n\t\t\t\tctx.rotate(rotation);\n\t\t\t\tctx.textAlign = 'center';\n\t\t\t\tctx.textBaseline = 'middle';\n\t\n\t\t\t\tvar text = opts.text;\n\t\t\t\tif (helpers$1.isArray(text)) {\n\t\t\t\t\tvar y = 0;\n\t\t\t\t\tfor (var i = 0; i < text.length; ++i) {\n\t\t\t\t\t\tctx.fillText(text[i], 0, y, maxWidth);\n\t\t\t\t\t\ty += lineHeight;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tctx.fillText(text, 0, 0, maxWidth);\n\t\t\t\t}\n\t\n\t\t\t\tctx.restore();\n\t\t\t}\n\t\t}\n\t});\n\t\n\tfunction createNewTitleBlockAndAttach(chart, titleOpts) {\n\t\tvar title = new Title({\n\t\t\tctx: chart.ctx,\n\t\t\toptions: titleOpts,\n\t\t\tchart: chart\n\t\t});\n\t\n\t\tcore_layouts.configure(chart, title, titleOpts);\n\t\tcore_layouts.addBox(chart, title);\n\t\tchart.titleBlock = title;\n\t}\n\t\n\tvar plugin_title = {\n\t\tid: 'title',\n\t\n\t\t/**\n\t\t * Backward compatibility: since 2.1.5, the title is registered as a plugin, making\n\t\t * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of\n\t\t * the plugin, which one will be re-exposed in the chart.js file.\n\t\t * https://github.com/chartjs/Chart.js/pull/2640\n\t\t * @private\n\t\t */\n\t\t_element: Title,\n\t\n\t\tbeforeInit: function(chart) {\n\t\t\tvar titleOpts = chart.options.title;\n\t\n\t\t\tif (titleOpts) {\n\t\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t\t}\n\t\t},\n\t\n\t\tbeforeUpdate: function(chart) {\n\t\t\tvar titleOpts = chart.options.title;\n\t\t\tvar titleBlock = chart.titleBlock;\n\t\n\t\t\tif (titleOpts) {\n\t\t\t\thelpers$1.mergeIf(titleOpts, core_defaults.global.title);\n\t\n\t\t\t\tif (titleBlock) {\n\t\t\t\t\tcore_layouts.configure(chart, titleBlock, titleOpts);\n\t\t\t\t\ttitleBlock.options = titleOpts;\n\t\t\t\t} else {\n\t\t\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t\t\t}\n\t\t\t} else if (titleBlock) {\n\t\t\t\tcore_layouts.removeBox(chart, titleBlock);\n\t\t\t\tdelete chart.titleBlock;\n\t\t\t}\n\t\t}\n\t};\n\t\n\tvar plugins = {};\n\tvar filler = plugin_filler;\n\tvar legend = plugin_legend;\n\tvar title = plugin_title;\n\tplugins.filler = filler;\n\tplugins.legend = legend;\n\tplugins.title = title;\n\t\n\t/**\n\t * @namespace Chart\n\t */\n\t\n\t\n\tcore_controller.helpers = helpers$1;\n\t\n\t// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!\n\tcore_helpers(core_controller);\n\t\n\tcore_controller._adapters = core_adapters;\n\tcore_controller.Animation = core_animation;\n\tcore_controller.animationService = core_animations;\n\tcore_controller.controllers = controllers;\n\tcore_controller.DatasetController = core_datasetController;\n\tcore_controller.defaults = core_defaults;\n\tcore_controller.Element = core_element;\n\tcore_controller.elements = elements;\n\tcore_controller.Interaction = core_interaction;\n\tcore_controller.layouts = core_layouts;\n\tcore_controller.platform = platform;\n\tcore_controller.plugins = core_plugins;\n\tcore_controller.Scale = core_scale;\n\tcore_controller.scaleService = core_scaleService;\n\tcore_controller.Ticks = core_ticks;\n\tcore_controller.Tooltip = core_tooltip;\n\t\n\t// Register built-in scales\n\t\n\tcore_controller.helpers.each(scales, function(scale, type) {\n\t\tcore_controller.scaleService.registerScaleType(type, scale, scale._defaults);\n\t});\n\t\n\t// Load to register built-in adapters (as side effects)\n\t\n\t\n\t// Loading built-in plugins\n\t\n\tfor (var k in plugins) {\n\t\tif (plugins.hasOwnProperty(k)) {\n\t\t\tcore_controller.plugins.register(plugins[k]);\n\t\t}\n\t}\n\t\n\tcore_controller.platform.initialize();\n\t\n\tvar src = core_controller;\n\tif (typeof window !== 'undefined') {\n\t\twindow.Chart = core_controller;\n\t}\n\t\n\t// DEPRECATIONS\n\t\n\t/**\n\t * Provided for backward compatibility, not available anymore\n\t * @namespace Chart.Chart\n\t * @deprecated since version 2.8.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tcore_controller.Chart = core_controller;\n\t\n\t/**\n\t * Provided for backward compatibility, not available anymore\n\t * @namespace Chart.Legend\n\t * @deprecated since version 2.1.5\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tcore_controller.Legend = plugins.legend._element;\n\t\n\t/**\n\t * Provided for backward compatibility, not available anymore\n\t * @namespace Chart.Title\n\t * @deprecated since version 2.1.5\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tcore_controller.Title = plugins.title._element;\n\t\n\t/**\n\t * Provided for backward compatibility, use Chart.plugins instead\n\t * @namespace Chart.pluginService\n\t * @deprecated since version 2.1.5\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tcore_controller.pluginService = core_controller.plugins;\n\t\n\t/**\n\t * Provided for backward compatibility, inheriting from Chart.PlugingBase has no\n\t * effect, instead simply create/register plugins via plain JavaScript objects.\n\t * @interface Chart.PluginBase\n\t * @deprecated since version 2.5.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tcore_controller.PluginBase = core_controller.Element.extend({});\n\t\n\t/**\n\t * Provided for backward compatibility, use Chart.helpers.canvas instead.\n\t * @namespace Chart.canvasHelpers\n\t * @deprecated since version 2.6.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tcore_controller.canvasHelpers = core_controller.helpers.canvas;\n\t\n\t/**\n\t * Provided for backward compatibility, use Chart.layouts instead.\n\t * @namespace Chart.layoutService\n\t * @deprecated since version 2.7.3\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tcore_controller.layoutService = core_controller.layouts;\n\t\n\t/**\n\t * Provided for backward compatibility, not available anymore.\n\t * @namespace Chart.LinearScaleBase\n\t * @deprecated since version 2.8\n\t * @todo remove at version 3\n\t * @private\n\t */\n\tcore_controller.LinearScaleBase = scale_linearbase;\n\t\n\t/**\n\t * Provided for backward compatibility, instead we should create a new Chart\n\t * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).\n\t * @deprecated since version 2.8.0\n\t * @todo remove at version 3\n\t */\n\tcore_controller.helpers.each(\n\t\t[\n\t\t\t'Bar',\n\t\t\t'Bubble',\n\t\t\t'Doughnut',\n\t\t\t'Line',\n\t\t\t'PolarArea',\n\t\t\t'Radar',\n\t\t\t'Scatter'\n\t\t],\n\t\tfunction(klass) {\n\t\t\tcore_controller[klass] = function(ctx, cfg) {\n\t\t\t\treturn new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {\n\t\t\t\t\ttype: klass.charAt(0).toLowerCase() + klass.slice(1)\n\t\t\t\t}));\n\t\t\t};\n\t\t}\n\t);\n\t\n\treturn src;\n\t\n\t})));\n\n\n/***/ }),\n/* 246 */,\n/* 247 */,\n/* 248 */,\n/* 249 */,\n/* 250 */,\n/* 251 */,\n/* 252 */,\n/* 253 */,\n/* 254 */,\n/* 255 */,\n/* 256 */,\n/* 257 */,\n/* 258 */,\n/* 259 */,\n/* 260 */,\n/* 261 */,\n/* 262 */,\n/* 263 */,\n/* 264 */,\n/* 265 */,\n/* 266 */,\n/* 267 */,\n/* 268 */,\n/* 269 */,\n/* 270 */,\n/* 271 */,\n/* 272 */,\n/* 273 */,\n/* 274 */,\n/* 275 */,\n/* 276 */,\n/* 277 */,\n/* 278 */,\n/* 279 */,\n/* 280 */,\n/* 281 */,\n/* 282 */,\n/* 283 */,\n/* 284 */,\n/* 285 */,\n/* 286 */,\n/* 287 */,\n/* 288 */,\n/* 289 */,\n/* 290 */,\n/* 291 */,\n/* 292 */,\n/* 293 */,\n/* 294 */,\n/* 295 */,\n/* 296 */,\n/* 297 */,\n/* 298 */,\n/* 299 */,\n/* 300 */,\n/* 301 */,\n/* 302 */,\n/* 303 */,\n/* 304 */,\n/* 305 */,\n/* 306 */,\n/* 307 */,\n/* 308 */,\n/* 309 */,\n/* 310 */,\n/* 311 */,\n/* 312 */,\n/* 313 */,\n/* 314 */,\n/* 315 */,\n/* 316 */,\n/* 317 */,\n/* 318 */,\n/* 319 */,\n/* 320 */,\n/* 321 */,\n/* 322 */,\n/* 323 */,\n/* 324 */,\n/* 325 */,\n/* 326 */,\n/* 327 */,\n/* 328 */,\n/* 329 */,\n/* 330 */,\n/* 331 */,\n/* 332 */,\n/* 333 */,\n/* 334 */,\n/* 335 */,\n/* 336 */,\n/* 337 */,\n/* 338 */,\n/* 339 */,\n/* 340 */,\n/* 341 */,\n/* 342 */,\n/* 343 */,\n/* 344 */,\n/* 345 */,\n/* 346 */,\n/* 347 */,\n/* 348 */,\n/* 349 */,\n/* 350 */,\n/* 351 */,\n/* 352 */,\n/* 353 */,\n/* 354 */,\n/* 355 */,\n/* 356 */,\n/* 357 */,\n/* 358 */,\n/* 359 */,\n/* 360 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar getNative = __webpack_require__(27),\n\t    root = __webpack_require__(17);\n\t\n\t/* Built-in method references that are verified to be native. */\n\tvar DataView = getNative(root, 'DataView');\n\t\n\tmodule.exports = DataView;\n\n\n/***/ }),\n/* 361 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar hashClear = __webpack_require__(409),\n\t    hashDelete = __webpack_require__(410),\n\t    hashGet = __webpack_require__(411),\n\t    hashHas = __webpack_require__(412),\n\t    hashSet = __webpack_require__(413);\n\t\n\t/**\n\t * Creates a hash object.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */\n\tfunction Hash(entries) {\n\t  var index = -1,\n\t      length = entries == null ? 0 : entries.length;\n\t\n\t  this.clear();\n\t  while (++index < length) {\n\t    var entry = entries[index];\n\t    this.set(entry[0], entry[1]);\n\t  }\n\t}\n\t\n\t// Add methods to `Hash`.\n\tHash.prototype.clear = hashClear;\n\tHash.prototype['delete'] = hashDelete;\n\tHash.prototype.get = hashGet;\n\tHash.prototype.has = hashHas;\n\tHash.prototype.set = hashSet;\n\t\n\tmodule.exports = Hash;\n\n\n/***/ }),\n/* 362 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar getNative = __webpack_require__(27),\n\t    root = __webpack_require__(17);\n\t\n\t/* Built-in method references that are verified to be native. */\n\tvar Promise = getNative(root, 'Promise');\n\t\n\tmodule.exports = Promise;\n\n\n/***/ }),\n/* 363 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar getNative = __webpack_require__(27),\n\t    root = __webpack_require__(17);\n\t\n\t/* Built-in method references that are verified to be native. */\n\tvar Set = getNative(root, 'Set');\n\t\n\tmodule.exports = Set;\n\n\n/***/ }),\n/* 364 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar MapCache = __webpack_require__(116),\n\t    setCacheAdd = __webpack_require__(433),\n\t    setCacheHas = __webpack_require__(434);\n\t\n\t/**\n\t *\n\t * Creates an array cache object to store unique values.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [values] The values to cache.\n\t */\n\tfunction SetCache(values) {\n\t  var index = -1,\n\t      length = values == null ? 0 : values.length;\n\t\n\t  this.__data__ = new MapCache;\n\t  while (++index < length) {\n\t    this.add(values[index]);\n\t  }\n\t}\n\t\n\t// Add methods to `SetCache`.\n\tSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n\tSetCache.prototype.has = setCacheHas;\n\t\n\tmodule.exports = SetCache;\n\n\n/***/ }),\n/* 365 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar root = __webpack_require__(17);\n\t\n\t/** Built-in value references. */\n\tvar Uint8Array = root.Uint8Array;\n\t\n\tmodule.exports = Uint8Array;\n\n\n/***/ }),\n/* 366 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar getNative = __webpack_require__(27),\n\t    root = __webpack_require__(17);\n\t\n\t/* Built-in method references that are verified to be native. */\n\tvar WeakMap = getNative(root, 'WeakMap');\n\t\n\tmodule.exports = WeakMap;\n\n\n/***/ }),\n/* 367 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * A specialized version of `baseAggregator` for arrays.\n\t *\n\t * @private\n\t * @param {Array} [array] The array to iterate over.\n\t * @param {Function} setter The function to set `accumulator` values.\n\t * @param {Function} iteratee The iteratee to transform keys.\n\t * @param {Object} accumulator The initial aggregated object.\n\t * @returns {Function} Returns `accumulator`.\n\t */\n\tfunction arrayAggregator(array, setter, iteratee, accumulator) {\n\t  var index = -1,\n\t      length = array == null ? 0 : array.length;\n\t\n\t  while (++index < length) {\n\t    var value = array[index];\n\t    setter(accumulator, value, iteratee(value), array);\n\t  }\n\t  return accumulator;\n\t}\n\t\n\tmodule.exports = arrayAggregator;\n\n\n/***/ }),\n/* 368 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * A specialized version of `_.filter` for arrays without support for\n\t * iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Array} [array] The array to iterate over.\n\t * @param {Function} predicate The function invoked per iteration.\n\t * @returns {Array} Returns the new filtered array.\n\t */\n\tfunction arrayFilter(array, predicate) {\n\t  var index = -1,\n\t      length = array == null ? 0 : array.length,\n\t      resIndex = 0,\n\t      result = [];\n\t\n\t  while (++index < length) {\n\t    var value = array[index];\n\t    if (predicate(value, index, array)) {\n\t      result[resIndex++] = value;\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = arrayFilter;\n\n\n/***/ }),\n/* 369 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseTimes = __webpack_require__(391),\n\t    isArguments = __webpack_require__(183),\n\t    isArray = __webpack_require__(18),\n\t    isBuffer = __webpack_require__(185),\n\t    isIndex = __webpack_require__(178),\n\t    isTypedArray = __webpack_require__(187);\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/**\n\t * Creates an array of the enumerable property names of the array-like `value`.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @param {boolean} inherited Specify returning inherited property names.\n\t * @returns {Array} Returns the array of property names.\n\t */\n\tfunction arrayLikeKeys(value, inherited) {\n\t  var isArr = isArray(value),\n\t      isArg = !isArr && isArguments(value),\n\t      isBuff = !isArr && !isArg && isBuffer(value),\n\t      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n\t      skipIndexes = isArr || isArg || isBuff || isType,\n\t      result = skipIndexes ? baseTimes(value.length, String) : [],\n\t      length = result.length;\n\t\n\t  for (var key in value) {\n\t    if ((inherited || hasOwnProperty.call(value, key)) &&\n\t        !(skipIndexes && (\n\t           // Safari 9 has enumerable `arguments.length` in strict mode.\n\t           key == 'length' ||\n\t           // Node.js 0.10 has enumerable non-index properties on buffers.\n\t           (isBuff && (key == 'offset' || key == 'parent')) ||\n\t           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n\t           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n\t           // Skip index properties.\n\t           isIndex(key, length)\n\t        ))) {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = arrayLikeKeys;\n\n\n/***/ }),\n/* 370 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * A specialized version of `_.map` for arrays without support for iteratee\n\t * shorthands.\n\t *\n\t * @private\n\t * @param {Array} [array] The array to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Array} Returns the new mapped array.\n\t */\n\tfunction arrayMap(array, iteratee) {\n\t  var index = -1,\n\t      length = array == null ? 0 : array.length,\n\t      result = Array(length);\n\t\n\t  while (++index < length) {\n\t    result[index] = iteratee(array[index], index, array);\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = arrayMap;\n\n\n/***/ }),\n/* 371 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Appends the elements of `values` to `array`.\n\t *\n\t * @private\n\t * @param {Array} array The array to modify.\n\t * @param {Array} values The values to append.\n\t * @returns {Array} Returns `array`.\n\t */\n\tfunction arrayPush(array, values) {\n\t  var index = -1,\n\t      length = values.length,\n\t      offset = array.length;\n\t\n\t  while (++index < length) {\n\t    array[offset + index] = values[index];\n\t  }\n\t  return array;\n\t}\n\t\n\tmodule.exports = arrayPush;\n\n\n/***/ }),\n/* 372 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * A specialized version of `_.some` for arrays without support for iteratee\n\t * shorthands.\n\t *\n\t * @private\n\t * @param {Array} [array] The array to iterate over.\n\t * @param {Function} predicate The function invoked per iteration.\n\t * @returns {boolean} Returns `true` if any element passes the predicate check,\n\t *  else `false`.\n\t */\n\tfunction arraySome(array, predicate) {\n\t  var index = -1,\n\t      length = array == null ? 0 : array.length;\n\t\n\t  while (++index < length) {\n\t    if (predicate(array[index], index, array)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\tmodule.exports = arraySome;\n\n\n/***/ }),\n/* 373 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseEach = __webpack_require__(375);\n\t\n\t/**\n\t * Aggregates elements of `collection` on `accumulator` with keys transformed\n\t * by `iteratee` and values set by `setter`.\n\t *\n\t * @private\n\t * @param {Array|Object} collection The collection to iterate over.\n\t * @param {Function} setter The function to set `accumulator` values.\n\t * @param {Function} iteratee The iteratee to transform keys.\n\t * @param {Object} accumulator The initial aggregated object.\n\t * @returns {Function} Returns `accumulator`.\n\t */\n\tfunction baseAggregator(collection, setter, iteratee, accumulator) {\n\t  baseEach(collection, function(value, key, collection) {\n\t    setter(accumulator, value, iteratee(value), collection);\n\t  });\n\t  return accumulator;\n\t}\n\t\n\tmodule.exports = baseAggregator;\n\n\n/***/ }),\n/* 374 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar defineProperty = __webpack_require__(399);\n\t\n\t/**\n\t * The base implementation of `assignValue` and `assignMergeValue` without\n\t * value checks.\n\t *\n\t * @private\n\t * @param {Object} object The object to modify.\n\t * @param {string} key The key of the property to assign.\n\t * @param {*} value The value to assign.\n\t */\n\tfunction baseAssignValue(object, key, value) {\n\t  if (key == '__proto__' && defineProperty) {\n\t    defineProperty(object, key, {\n\t      'configurable': true,\n\t      'enumerable': true,\n\t      'value': value,\n\t      'writable': true\n\t    });\n\t  } else {\n\t    object[key] = value;\n\t  }\n\t}\n\t\n\tmodule.exports = baseAssignValue;\n\n\n/***/ }),\n/* 375 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseForOwn = __webpack_require__(377),\n\t    createBaseEach = __webpack_require__(397);\n\t\n\t/**\n\t * The base implementation of `_.forEach` without support for iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Array|Object} collection The collection to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Array|Object} Returns `collection`.\n\t */\n\tvar baseEach = createBaseEach(baseForOwn);\n\t\n\tmodule.exports = baseEach;\n\n\n/***/ }),\n/* 376 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar createBaseFor = __webpack_require__(398);\n\t\n\t/**\n\t * The base implementation of `baseForOwn` which iterates over `object`\n\t * properties returned by `keysFunc` and invokes `iteratee` for each property.\n\t * Iteratee functions may exit iteration early by explicitly returning `false`.\n\t *\n\t * @private\n\t * @param {Object} object The object to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @param {Function} keysFunc The function to get the keys of `object`.\n\t * @returns {Object} Returns `object`.\n\t */\n\tvar baseFor = createBaseFor();\n\t\n\tmodule.exports = baseFor;\n\n\n/***/ }),\n/* 377 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseFor = __webpack_require__(376),\n\t    keys = __webpack_require__(122);\n\t\n\t/**\n\t * The base implementation of `_.forOwn` without support for iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Object} object The object to iterate over.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Object} Returns `object`.\n\t */\n\tfunction baseForOwn(object, iteratee) {\n\t  return object && baseFor(object, iteratee, keys);\n\t}\n\t\n\tmodule.exports = baseForOwn;\n\n\n/***/ }),\n/* 378 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar arrayPush = __webpack_require__(371),\n\t    isArray = __webpack_require__(18);\n\t\n\t/**\n\t * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n\t * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n\t * symbols of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {Function} keysFunc The function to get the keys of `object`.\n\t * @param {Function} symbolsFunc The function to get the symbols of `object`.\n\t * @returns {Array} Returns the array of property names and symbols.\n\t */\n\tfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n\t  var result = keysFunc(object);\n\t  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n\t}\n\t\n\tmodule.exports = baseGetAllKeys;\n\n\n/***/ }),\n/* 379 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * The base implementation of `_.hasIn` without support for deep paths.\n\t *\n\t * @private\n\t * @param {Object} [object] The object to query.\n\t * @param {Array|string} key The key to check.\n\t * @returns {boolean} Returns `true` if `key` exists, else `false`.\n\t */\n\tfunction baseHasIn(object, key) {\n\t  return object != null && key in Object(object);\n\t}\n\t\n\tmodule.exports = baseHasIn;\n\n\n/***/ }),\n/* 380 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseGetTag = __webpack_require__(50),\n\t    isObjectLike = __webpack_require__(51);\n\t\n\t/** `Object#toString` result references. */\n\tvar argsTag = '[object Arguments]';\n\t\n\t/**\n\t * The base implementation of `_.isArguments`.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n\t */\n\tfunction baseIsArguments(value) {\n\t  return isObjectLike(value) && baseGetTag(value) == argsTag;\n\t}\n\t\n\tmodule.exports = baseIsArguments;\n\n\n/***/ }),\n/* 381 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Stack = __webpack_require__(173),\n\t    equalArrays = __webpack_require__(176),\n\t    equalByTag = __webpack_require__(400),\n\t    equalObjects = __webpack_require__(401),\n\t    getTag = __webpack_require__(406),\n\t    isArray = __webpack_require__(18),\n\t    isBuffer = __webpack_require__(185),\n\t    isTypedArray = __webpack_require__(187);\n\t\n\t/** Used to compose bitmasks for value comparisons. */\n\tvar COMPARE_PARTIAL_FLAG = 1;\n\t\n\t/** `Object#toString` result references. */\n\tvar argsTag = '[object Arguments]',\n\t    arrayTag = '[object Array]',\n\t    objectTag = '[object Object]';\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/**\n\t * A specialized version of `baseIsEqual` for arrays and objects which performs\n\t * deep comparisons and tracks traversed objects enabling objects with circular\n\t * references to be compared.\n\t *\n\t * @private\n\t * @param {Object} object The object to compare.\n\t * @param {Object} other The other object to compare.\n\t * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n\t * @param {Function} customizer The function to customize comparisons.\n\t * @param {Function} equalFunc The function to determine equivalents of values.\n\t * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n\t * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t */\n\tfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n\t  var objIsArr = isArray(object),\n\t      othIsArr = isArray(other),\n\t      objTag = objIsArr ? arrayTag : getTag(object),\n\t      othTag = othIsArr ? arrayTag : getTag(other);\n\t\n\t  objTag = objTag == argsTag ? objectTag : objTag;\n\t  othTag = othTag == argsTag ? objectTag : othTag;\n\t\n\t  var objIsObj = objTag == objectTag,\n\t      othIsObj = othTag == objectTag,\n\t      isSameTag = objTag == othTag;\n\t\n\t  if (isSameTag && isBuffer(object)) {\n\t    if (!isBuffer(other)) {\n\t      return false;\n\t    }\n\t    objIsArr = true;\n\t    objIsObj = false;\n\t  }\n\t  if (isSameTag && !objIsObj) {\n\t    stack || (stack = new Stack);\n\t    return (objIsArr || isTypedArray(object))\n\t      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n\t      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n\t  }\n\t  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n\t    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n\t        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\t\n\t    if (objIsWrapped || othIsWrapped) {\n\t      var objUnwrapped = objIsWrapped ? object.value() : object,\n\t          othUnwrapped = othIsWrapped ? other.value() : other;\n\t\n\t      stack || (stack = new Stack);\n\t      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n\t    }\n\t  }\n\t  if (!isSameTag) {\n\t    return false;\n\t  }\n\t  stack || (stack = new Stack);\n\t  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n\t}\n\t\n\tmodule.exports = baseIsEqualDeep;\n\n\n/***/ }),\n/* 382 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Stack = __webpack_require__(173),\n\t    baseIsEqual = __webpack_require__(117);\n\t\n\t/** Used to compose bitmasks for value comparisons. */\n\tvar COMPARE_PARTIAL_FLAG = 1,\n\t    COMPARE_UNORDERED_FLAG = 2;\n\t\n\t/**\n\t * The base implementation of `_.isMatch` without support for iteratee shorthands.\n\t *\n\t * @private\n\t * @param {Object} object The object to inspect.\n\t * @param {Object} source The object of property values to match.\n\t * @param {Array} matchData The property names, values, and compare flags to match.\n\t * @param {Function} [customizer] The function to customize comparisons.\n\t * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n\t */\n\tfunction baseIsMatch(object, source, matchData, customizer) {\n\t  var index = matchData.length,\n\t      length = index,\n\t      noCustomizer = !customizer;\n\t\n\t  if (object == null) {\n\t    return !length;\n\t  }\n\t  object = Object(object);\n\t  while (index--) {\n\t    var data = matchData[index];\n\t    if ((noCustomizer && data[2])\n\t          ? data[1] !== object[data[0]]\n\t          : !(data[0] in object)\n\t        ) {\n\t      return false;\n\t    }\n\t  }\n\t  while (++index < length) {\n\t    data = matchData[index];\n\t    var key = data[0],\n\t        objValue = object[key],\n\t        srcValue = data[1];\n\t\n\t    if (noCustomizer && data[2]) {\n\t      if (objValue === undefined && !(key in object)) {\n\t        return false;\n\t      }\n\t    } else {\n\t      var stack = new Stack;\n\t      if (customizer) {\n\t        var result = customizer(objValue, srcValue, key, object, source, stack);\n\t      }\n\t      if (!(result === undefined\n\t            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n\t            : result\n\t          )) {\n\t        return false;\n\t      }\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\tmodule.exports = baseIsMatch;\n\n\n/***/ }),\n/* 383 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar isFunction = __webpack_require__(186),\n\t    isMasked = __webpack_require__(415),\n\t    isObject = __webpack_require__(120),\n\t    toSource = __webpack_require__(181);\n\t\n\t/**\n\t * Used to match `RegExp`\n\t * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n\t */\n\tvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\t\n\t/** Used to detect host constructors (Safari). */\n\tvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\t\n\t/** Used for built-in method references. */\n\tvar funcProto = Function.prototype,\n\t    objectProto = Object.prototype;\n\t\n\t/** Used to resolve the decompiled source of functions. */\n\tvar funcToString = funcProto.toString;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/** Used to detect if a method is native. */\n\tvar reIsNative = RegExp('^' +\n\t  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n\t  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n\t);\n\t\n\t/**\n\t * The base implementation of `_.isNative` without bad shim checks.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a native function,\n\t *  else `false`.\n\t */\n\tfunction baseIsNative(value) {\n\t  if (!isObject(value) || isMasked(value)) {\n\t    return false;\n\t  }\n\t  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n\t  return pattern.test(toSource(value));\n\t}\n\t\n\tmodule.exports = baseIsNative;\n\n\n/***/ }),\n/* 384 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseGetTag = __webpack_require__(50),\n\t    isLength = __webpack_require__(119),\n\t    isObjectLike = __webpack_require__(51);\n\t\n\t/** `Object#toString` result references. */\n\tvar argsTag = '[object Arguments]',\n\t    arrayTag = '[object Array]',\n\t    boolTag = '[object Boolean]',\n\t    dateTag = '[object Date]',\n\t    errorTag = '[object Error]',\n\t    funcTag = '[object Function]',\n\t    mapTag = '[object Map]',\n\t    numberTag = '[object Number]',\n\t    objectTag = '[object Object]',\n\t    regexpTag = '[object RegExp]',\n\t    setTag = '[object Set]',\n\t    stringTag = '[object String]',\n\t    weakMapTag = '[object WeakMap]';\n\t\n\tvar arrayBufferTag = '[object ArrayBuffer]',\n\t    dataViewTag = '[object DataView]',\n\t    float32Tag = '[object Float32Array]',\n\t    float64Tag = '[object Float64Array]',\n\t    int8Tag = '[object Int8Array]',\n\t    int16Tag = '[object Int16Array]',\n\t    int32Tag = '[object Int32Array]',\n\t    uint8Tag = '[object Uint8Array]',\n\t    uint8ClampedTag = '[object Uint8ClampedArray]',\n\t    uint16Tag = '[object Uint16Array]',\n\t    uint32Tag = '[object Uint32Array]';\n\t\n\t/** Used to identify `toStringTag` values of typed arrays. */\n\tvar typedArrayTags = {};\n\ttypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n\ttypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n\ttypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n\ttypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n\ttypedArrayTags[uint32Tag] = true;\n\ttypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n\ttypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n\ttypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n\ttypedArrayTags[errorTag] = typedArrayTags[funcTag] =\n\ttypedArrayTags[mapTag] = typedArrayTags[numberTag] =\n\ttypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n\ttypedArrayTags[setTag] = typedArrayTags[stringTag] =\n\ttypedArrayTags[weakMapTag] = false;\n\t\n\t/**\n\t * The base implementation of `_.isTypedArray` without Node.js optimizations.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n\t */\n\tfunction baseIsTypedArray(value) {\n\t  return isObjectLike(value) &&\n\t    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n\t}\n\t\n\tmodule.exports = baseIsTypedArray;\n\n\n/***/ }),\n/* 385 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseMatches = __webpack_require__(387),\n\t    baseMatchesProperty = __webpack_require__(388),\n\t    identity = __webpack_require__(444),\n\t    isArray = __webpack_require__(18),\n\t    property = __webpack_require__(448);\n\t\n\t/**\n\t * The base implementation of `_.iteratee`.\n\t *\n\t * @private\n\t * @param {*} [value=_.identity] The value to convert to an iteratee.\n\t * @returns {Function} Returns the iteratee.\n\t */\n\tfunction baseIteratee(value) {\n\t  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n\t  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n\t  if (typeof value == 'function') {\n\t    return value;\n\t  }\n\t  if (value == null) {\n\t    return identity;\n\t  }\n\t  if (typeof value == 'object') {\n\t    return isArray(value)\n\t      ? baseMatchesProperty(value[0], value[1])\n\t      : baseMatches(value);\n\t  }\n\t  return property(value);\n\t}\n\t\n\tmodule.exports = baseIteratee;\n\n\n/***/ }),\n/* 386 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar isPrototype = __webpack_require__(416),\n\t    nativeKeys = __webpack_require__(429);\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/**\n\t * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names.\n\t */\n\tfunction baseKeys(object) {\n\t  if (!isPrototype(object)) {\n\t    return nativeKeys(object);\n\t  }\n\t  var result = [];\n\t  for (var key in Object(object)) {\n\t    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n\t      result.push(key);\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = baseKeys;\n\n\n/***/ }),\n/* 387 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseIsMatch = __webpack_require__(382),\n\t    getMatchData = __webpack_require__(403),\n\t    matchesStrictComparable = __webpack_require__(180);\n\t\n\t/**\n\t * The base implementation of `_.matches` which doesn't clone `source`.\n\t *\n\t * @private\n\t * @param {Object} source The object of property values to match.\n\t * @returns {Function} Returns the new spec function.\n\t */\n\tfunction baseMatches(source) {\n\t  var matchData = getMatchData(source);\n\t  if (matchData.length == 1 && matchData[0][2]) {\n\t    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n\t  }\n\t  return function(object) {\n\t    return object === source || baseIsMatch(object, source, matchData);\n\t  };\n\t}\n\t\n\tmodule.exports = baseMatches;\n\n\n/***/ }),\n/* 388 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseIsEqual = __webpack_require__(117),\n\t    get = __webpack_require__(442),\n\t    hasIn = __webpack_require__(443),\n\t    isKey = __webpack_require__(118),\n\t    isStrictComparable = __webpack_require__(179),\n\t    matchesStrictComparable = __webpack_require__(180),\n\t    toKey = __webpack_require__(77);\n\t\n\t/** Used to compose bitmasks for value comparisons. */\n\tvar COMPARE_PARTIAL_FLAG = 1,\n\t    COMPARE_UNORDERED_FLAG = 2;\n\t\n\t/**\n\t * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n\t *\n\t * @private\n\t * @param {string} path The path of the property to get.\n\t * @param {*} srcValue The value to match.\n\t * @returns {Function} Returns the new spec function.\n\t */\n\tfunction baseMatchesProperty(path, srcValue) {\n\t  if (isKey(path) && isStrictComparable(srcValue)) {\n\t    return matchesStrictComparable(toKey(path), srcValue);\n\t  }\n\t  return function(object) {\n\t    var objValue = get(object, path);\n\t    return (objValue === undefined && objValue === srcValue)\n\t      ? hasIn(object, path)\n\t      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n\t  };\n\t}\n\t\n\tmodule.exports = baseMatchesProperty;\n\n\n/***/ }),\n/* 389 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * The base implementation of `_.property` without support for deep paths.\n\t *\n\t * @private\n\t * @param {string} key The key of the property to get.\n\t * @returns {Function} Returns the new accessor function.\n\t */\n\tfunction baseProperty(key) {\n\t  return function(object) {\n\t    return object == null ? undefined : object[key];\n\t  };\n\t}\n\t\n\tmodule.exports = baseProperty;\n\n\n/***/ }),\n/* 390 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseGet = __webpack_require__(174);\n\t\n\t/**\n\t * A specialized version of `baseProperty` which supports deep paths.\n\t *\n\t * @private\n\t * @param {Array|string} path The path of the property to get.\n\t * @returns {Function} Returns the new accessor function.\n\t */\n\tfunction basePropertyDeep(path) {\n\t  return function(object) {\n\t    return baseGet(object, path);\n\t  };\n\t}\n\t\n\tmodule.exports = basePropertyDeep;\n\n\n/***/ }),\n/* 391 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * The base implementation of `_.times` without support for iteratee shorthands\n\t * or max array length checks.\n\t *\n\t * @private\n\t * @param {number} n The number of times to invoke `iteratee`.\n\t * @param {Function} iteratee The function invoked per iteration.\n\t * @returns {Array} Returns the array of results.\n\t */\n\tfunction baseTimes(n, iteratee) {\n\t  var index = -1,\n\t      result = Array(n);\n\t\n\t  while (++index < n) {\n\t    result[index] = iteratee(index);\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = baseTimes;\n\n\n/***/ }),\n/* 392 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(73),\n\t    arrayMap = __webpack_require__(370),\n\t    isArray = __webpack_require__(18),\n\t    isSymbol = __webpack_require__(121);\n\t\n\t/** Used as references for various `Number` constants. */\n\tvar INFINITY = 1 / 0;\n\t\n\t/** Used to convert symbols to primitives and strings. */\n\tvar symbolProto = Symbol ? Symbol.prototype : undefined,\n\t    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\t\n\t/**\n\t * The base implementation of `_.toString` which doesn't convert nullish\n\t * values to empty strings.\n\t *\n\t * @private\n\t * @param {*} value The value to process.\n\t * @returns {string} Returns the string.\n\t */\n\tfunction baseToString(value) {\n\t  // Exit early for strings to avoid a performance hit in some environments.\n\t  if (typeof value == 'string') {\n\t    return value;\n\t  }\n\t  if (isArray(value)) {\n\t    // Recursively convert values (susceptible to call stack limits).\n\t    return arrayMap(value, baseToString) + '';\n\t  }\n\t  if (isSymbol(value)) {\n\t    return symbolToString ? symbolToString.call(value) : '';\n\t  }\n\t  var result = (value + '');\n\t  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n\t}\n\t\n\tmodule.exports = baseToString;\n\n\n/***/ }),\n/* 393 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * The base implementation of `_.unary` without support for storing metadata.\n\t *\n\t * @private\n\t * @param {Function} func The function to cap arguments for.\n\t * @returns {Function} Returns the new capped function.\n\t */\n\tfunction baseUnary(func) {\n\t  return function(value) {\n\t    return func(value);\n\t  };\n\t}\n\t\n\tmodule.exports = baseUnary;\n\n\n/***/ }),\n/* 394 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Checks if a `cache` value for `key` exists.\n\t *\n\t * @private\n\t * @param {Object} cache The cache to query.\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction cacheHas(cache, key) {\n\t  return cache.has(key);\n\t}\n\t\n\tmodule.exports = cacheHas;\n\n\n/***/ }),\n/* 395 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar root = __webpack_require__(17);\n\t\n\t/** Used to detect overreaching core-js shims. */\n\tvar coreJsData = root['__core-js_shared__'];\n\t\n\tmodule.exports = coreJsData;\n\n\n/***/ }),\n/* 396 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar arrayAggregator = __webpack_require__(367),\n\t    baseAggregator = __webpack_require__(373),\n\t    baseIteratee = __webpack_require__(385),\n\t    isArray = __webpack_require__(18);\n\t\n\t/**\n\t * Creates a function like `_.groupBy`.\n\t *\n\t * @private\n\t * @param {Function} setter The function to set accumulator values.\n\t * @param {Function} [initializer] The accumulator object initializer.\n\t * @returns {Function} Returns the new aggregator function.\n\t */\n\tfunction createAggregator(setter, initializer) {\n\t  return function(collection, iteratee) {\n\t    var func = isArray(collection) ? arrayAggregator : baseAggregator,\n\t        accumulator = initializer ? initializer() : {};\n\t\n\t    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n\t  };\n\t}\n\t\n\tmodule.exports = createAggregator;\n\n\n/***/ }),\n/* 397 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar isArrayLike = __webpack_require__(184);\n\t\n\t/**\n\t * Creates a `baseEach` or `baseEachRight` function.\n\t *\n\t * @private\n\t * @param {Function} eachFunc The function to iterate over a collection.\n\t * @param {boolean} [fromRight] Specify iterating from right to left.\n\t * @returns {Function} Returns the new base function.\n\t */\n\tfunction createBaseEach(eachFunc, fromRight) {\n\t  return function(collection, iteratee) {\n\t    if (collection == null) {\n\t      return collection;\n\t    }\n\t    if (!isArrayLike(collection)) {\n\t      return eachFunc(collection, iteratee);\n\t    }\n\t    var length = collection.length,\n\t        index = fromRight ? length : -1,\n\t        iterable = Object(collection);\n\t\n\t    while ((fromRight ? index-- : ++index < length)) {\n\t      if (iteratee(iterable[index], index, iterable) === false) {\n\t        break;\n\t      }\n\t    }\n\t    return collection;\n\t  };\n\t}\n\t\n\tmodule.exports = createBaseEach;\n\n\n/***/ }),\n/* 398 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n\t *\n\t * @private\n\t * @param {boolean} [fromRight] Specify iterating from right to left.\n\t * @returns {Function} Returns the new base function.\n\t */\n\tfunction createBaseFor(fromRight) {\n\t  return function(object, iteratee, keysFunc) {\n\t    var index = -1,\n\t        iterable = Object(object),\n\t        props = keysFunc(object),\n\t        length = props.length;\n\t\n\t    while (length--) {\n\t      var key = props[fromRight ? length : ++index];\n\t      if (iteratee(iterable[key], key, iterable) === false) {\n\t        break;\n\t      }\n\t    }\n\t    return object;\n\t  };\n\t}\n\t\n\tmodule.exports = createBaseFor;\n\n\n/***/ }),\n/* 399 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar getNative = __webpack_require__(27);\n\t\n\tvar defineProperty = (function() {\n\t  try {\n\t    var func = getNative(Object, 'defineProperty');\n\t    func({}, '', {});\n\t    return func;\n\t  } catch (e) {}\n\t}());\n\t\n\tmodule.exports = defineProperty;\n\n\n/***/ }),\n/* 400 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(73),\n\t    Uint8Array = __webpack_require__(365),\n\t    eq = __webpack_require__(182),\n\t    equalArrays = __webpack_require__(176),\n\t    mapToArray = __webpack_require__(427),\n\t    setToArray = __webpack_require__(435);\n\t\n\t/** Used to compose bitmasks for value comparisons. */\n\tvar COMPARE_PARTIAL_FLAG = 1,\n\t    COMPARE_UNORDERED_FLAG = 2;\n\t\n\t/** `Object#toString` result references. */\n\tvar boolTag = '[object Boolean]',\n\t    dateTag = '[object Date]',\n\t    errorTag = '[object Error]',\n\t    mapTag = '[object Map]',\n\t    numberTag = '[object Number]',\n\t    regexpTag = '[object RegExp]',\n\t    setTag = '[object Set]',\n\t    stringTag = '[object String]',\n\t    symbolTag = '[object Symbol]';\n\t\n\tvar arrayBufferTag = '[object ArrayBuffer]',\n\t    dataViewTag = '[object DataView]';\n\t\n\t/** Used to convert symbols to primitives and strings. */\n\tvar symbolProto = Symbol ? Symbol.prototype : undefined,\n\t    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\t\n\t/**\n\t * A specialized version of `baseIsEqualDeep` for comparing objects of\n\t * the same `toStringTag`.\n\t *\n\t * **Note:** This function only supports comparing values with tags of\n\t * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n\t *\n\t * @private\n\t * @param {Object} object The object to compare.\n\t * @param {Object} other The other object to compare.\n\t * @param {string} tag The `toStringTag` of the objects to compare.\n\t * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n\t * @param {Function} customizer The function to customize comparisons.\n\t * @param {Function} equalFunc The function to determine equivalents of values.\n\t * @param {Object} stack Tracks traversed `object` and `other` objects.\n\t * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t */\n\tfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n\t  switch (tag) {\n\t    case dataViewTag:\n\t      if ((object.byteLength != other.byteLength) ||\n\t          (object.byteOffset != other.byteOffset)) {\n\t        return false;\n\t      }\n\t      object = object.buffer;\n\t      other = other.buffer;\n\t\n\t    case arrayBufferTag:\n\t      if ((object.byteLength != other.byteLength) ||\n\t          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n\t        return false;\n\t      }\n\t      return true;\n\t\n\t    case boolTag:\n\t    case dateTag:\n\t    case numberTag:\n\t      // Coerce booleans to `1` or `0` and dates to milliseconds.\n\t      // Invalid dates are coerced to `NaN`.\n\t      return eq(+object, +other);\n\t\n\t    case errorTag:\n\t      return object.name == other.name && object.message == other.message;\n\t\n\t    case regexpTag:\n\t    case stringTag:\n\t      // Coerce regexes to strings and treat strings, primitives and objects,\n\t      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n\t      // for more details.\n\t      return object == (other + '');\n\t\n\t    case mapTag:\n\t      var convert = mapToArray;\n\t\n\t    case setTag:\n\t      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n\t      convert || (convert = setToArray);\n\t\n\t      if (object.size != other.size && !isPartial) {\n\t        return false;\n\t      }\n\t      // Assume cyclic values are equal.\n\t      var stacked = stack.get(object);\n\t      if (stacked) {\n\t        return stacked == other;\n\t      }\n\t      bitmask |= COMPARE_UNORDERED_FLAG;\n\t\n\t      // Recursively compare objects (susceptible to call stack limits).\n\t      stack.set(object, other);\n\t      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n\t      stack['delete'](object);\n\t      return result;\n\t\n\t    case symbolTag:\n\t      if (symbolValueOf) {\n\t        return symbolValueOf.call(object) == symbolValueOf.call(other);\n\t      }\n\t  }\n\t  return false;\n\t}\n\t\n\tmodule.exports = equalByTag;\n\n\n/***/ }),\n/* 401 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar getAllKeys = __webpack_require__(402);\n\t\n\t/** Used to compose bitmasks for value comparisons. */\n\tvar COMPARE_PARTIAL_FLAG = 1;\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/**\n\t * A specialized version of `baseIsEqualDeep` for objects with support for\n\t * partial deep comparisons.\n\t *\n\t * @private\n\t * @param {Object} object The object to compare.\n\t * @param {Object} other The other object to compare.\n\t * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n\t * @param {Function} customizer The function to customize comparisons.\n\t * @param {Function} equalFunc The function to determine equivalents of values.\n\t * @param {Object} stack Tracks traversed `object` and `other` objects.\n\t * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t */\n\tfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n\t  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n\t      objProps = getAllKeys(object),\n\t      objLength = objProps.length,\n\t      othProps = getAllKeys(other),\n\t      othLength = othProps.length;\n\t\n\t  if (objLength != othLength && !isPartial) {\n\t    return false;\n\t  }\n\t  var index = objLength;\n\t  while (index--) {\n\t    var key = objProps[index];\n\t    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n\t      return false;\n\t    }\n\t  }\n\t  // Assume cyclic values are equal.\n\t  var stacked = stack.get(object);\n\t  if (stacked && stack.get(other)) {\n\t    return stacked == other;\n\t  }\n\t  var result = true;\n\t  stack.set(object, other);\n\t  stack.set(other, object);\n\t\n\t  var skipCtor = isPartial;\n\t  while (++index < objLength) {\n\t    key = objProps[index];\n\t    var objValue = object[key],\n\t        othValue = other[key];\n\t\n\t    if (customizer) {\n\t      var compared = isPartial\n\t        ? customizer(othValue, objValue, key, other, object, stack)\n\t        : customizer(objValue, othValue, key, object, other, stack);\n\t    }\n\t    // Recursively compare objects (susceptible to call stack limits).\n\t    if (!(compared === undefined\n\t          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n\t          : compared\n\t        )) {\n\t      result = false;\n\t      break;\n\t    }\n\t    skipCtor || (skipCtor = key == 'constructor');\n\t  }\n\t  if (result && !skipCtor) {\n\t    var objCtor = object.constructor,\n\t        othCtor = other.constructor;\n\t\n\t    // Non `Object` object instances with different constructors are not equal.\n\t    if (objCtor != othCtor &&\n\t        ('constructor' in object && 'constructor' in other) &&\n\t        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n\t          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n\t      result = false;\n\t    }\n\t  }\n\t  stack['delete'](object);\n\t  stack['delete'](other);\n\t  return result;\n\t}\n\t\n\tmodule.exports = equalObjects;\n\n\n/***/ }),\n/* 402 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseGetAllKeys = __webpack_require__(378),\n\t    getSymbols = __webpack_require__(405),\n\t    keys = __webpack_require__(122);\n\t\n\t/**\n\t * Creates an array of own enumerable property names and symbols of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of property names and symbols.\n\t */\n\tfunction getAllKeys(object) {\n\t  return baseGetAllKeys(object, keys, getSymbols);\n\t}\n\t\n\tmodule.exports = getAllKeys;\n\n\n/***/ }),\n/* 403 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar isStrictComparable = __webpack_require__(179),\n\t    keys = __webpack_require__(122);\n\t\n\t/**\n\t * Gets the property names, values, and compare flags of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the match data of `object`.\n\t */\n\tfunction getMatchData(object) {\n\t  var result = keys(object),\n\t      length = result.length;\n\t\n\t  while (length--) {\n\t    var key = result[length],\n\t        value = object[key];\n\t\n\t    result[length] = [key, value, isStrictComparable(value)];\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = getMatchData;\n\n\n/***/ }),\n/* 404 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Symbol = __webpack_require__(73);\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar nativeObjectToString = objectProto.toString;\n\t\n\t/** Built-in value references. */\n\tvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\t\n\t/**\n\t * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the raw `toStringTag`.\n\t */\n\tfunction getRawTag(value) {\n\t  var isOwn = hasOwnProperty.call(value, symToStringTag),\n\t      tag = value[symToStringTag];\n\t\n\t  try {\n\t    value[symToStringTag] = undefined;\n\t    var unmasked = true;\n\t  } catch (e) {}\n\t\n\t  var result = nativeObjectToString.call(value);\n\t  if (unmasked) {\n\t    if (isOwn) {\n\t      value[symToStringTag] = tag;\n\t    } else {\n\t      delete value[symToStringTag];\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tmodule.exports = getRawTag;\n\n\n/***/ }),\n/* 405 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar arrayFilter = __webpack_require__(368),\n\t    stubArray = __webpack_require__(449);\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Built-in value references. */\n\tvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\t\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\t\n\t/**\n\t * Creates an array of the own enumerable symbols of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @returns {Array} Returns the array of symbols.\n\t */\n\tvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n\t  if (object == null) {\n\t    return [];\n\t  }\n\t  object = Object(object);\n\t  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n\t    return propertyIsEnumerable.call(object, symbol);\n\t  });\n\t};\n\t\n\tmodule.exports = getSymbols;\n\n\n/***/ }),\n/* 406 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar DataView = __webpack_require__(360),\n\t    Map = __webpack_require__(115),\n\t    Promise = __webpack_require__(362),\n\t    Set = __webpack_require__(363),\n\t    WeakMap = __webpack_require__(366),\n\t    baseGetTag = __webpack_require__(50),\n\t    toSource = __webpack_require__(181);\n\t\n\t/** `Object#toString` result references. */\n\tvar mapTag = '[object Map]',\n\t    objectTag = '[object Object]',\n\t    promiseTag = '[object Promise]',\n\t    setTag = '[object Set]',\n\t    weakMapTag = '[object WeakMap]';\n\t\n\tvar dataViewTag = '[object DataView]';\n\t\n\t/** Used to detect maps, sets, and weakmaps. */\n\tvar dataViewCtorString = toSource(DataView),\n\t    mapCtorString = toSource(Map),\n\t    promiseCtorString = toSource(Promise),\n\t    setCtorString = toSource(Set),\n\t    weakMapCtorString = toSource(WeakMap);\n\t\n\t/**\n\t * Gets the `toStringTag` of `value`.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the `toStringTag`.\n\t */\n\tvar getTag = baseGetTag;\n\t\n\t// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n\tif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n\t    (Map && getTag(new Map) != mapTag) ||\n\t    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n\t    (Set && getTag(new Set) != setTag) ||\n\t    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n\t  getTag = function(value) {\n\t    var result = baseGetTag(value),\n\t        Ctor = result == objectTag ? value.constructor : undefined,\n\t        ctorString = Ctor ? toSource(Ctor) : '';\n\t\n\t    if (ctorString) {\n\t      switch (ctorString) {\n\t        case dataViewCtorString: return dataViewTag;\n\t        case mapCtorString: return mapTag;\n\t        case promiseCtorString: return promiseTag;\n\t        case setCtorString: return setTag;\n\t        case weakMapCtorString: return weakMapTag;\n\t      }\n\t    }\n\t    return result;\n\t  };\n\t}\n\t\n\tmodule.exports = getTag;\n\n\n/***/ }),\n/* 407 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Gets the value at `key` of `object`.\n\t *\n\t * @private\n\t * @param {Object} [object] The object to query.\n\t * @param {string} key The key of the property to get.\n\t * @returns {*} Returns the property value.\n\t */\n\tfunction getValue(object, key) {\n\t  return object == null ? undefined : object[key];\n\t}\n\t\n\tmodule.exports = getValue;\n\n\n/***/ }),\n/* 408 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar castPath = __webpack_require__(175),\n\t    isArguments = __webpack_require__(183),\n\t    isArray = __webpack_require__(18),\n\t    isIndex = __webpack_require__(178),\n\t    isLength = __webpack_require__(119),\n\t    toKey = __webpack_require__(77);\n\t\n\t/**\n\t * Checks if `path` exists on `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {Array|string} path The path to check.\n\t * @param {Function} hasFunc The function to check properties.\n\t * @returns {boolean} Returns `true` if `path` exists, else `false`.\n\t */\n\tfunction hasPath(object, path, hasFunc) {\n\t  path = castPath(path, object);\n\t\n\t  var index = -1,\n\t      length = path.length,\n\t      result = false;\n\t\n\t  while (++index < length) {\n\t    var key = toKey(path[index]);\n\t    if (!(result = object != null && hasFunc(object, key))) {\n\t      break;\n\t    }\n\t    object = object[key];\n\t  }\n\t  if (result || ++index != length) {\n\t    return result;\n\t  }\n\t  length = object == null ? 0 : object.length;\n\t  return !!length && isLength(length) && isIndex(key, length) &&\n\t    (isArray(object) || isArguments(object));\n\t}\n\t\n\tmodule.exports = hasPath;\n\n\n/***/ }),\n/* 409 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar nativeCreate = __webpack_require__(76);\n\t\n\t/**\n\t * Removes all key-value entries from the hash.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf Hash\n\t */\n\tfunction hashClear() {\n\t  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n\t  this.size = 0;\n\t}\n\t\n\tmodule.exports = hashClear;\n\n\n/***/ }),\n/* 410 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Removes `key` and its value from the hash.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf Hash\n\t * @param {Object} hash The hash to modify.\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */\n\tfunction hashDelete(key) {\n\t  var result = this.has(key) && delete this.__data__[key];\n\t  this.size -= result ? 1 : 0;\n\t  return result;\n\t}\n\t\n\tmodule.exports = hashDelete;\n\n\n/***/ }),\n/* 411 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar nativeCreate = __webpack_require__(76);\n\t\n\t/** Used to stand-in for `undefined` hash values. */\n\tvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/**\n\t * Gets the hash value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf Hash\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */\n\tfunction hashGet(key) {\n\t  var data = this.__data__;\n\t  if (nativeCreate) {\n\t    var result = data[key];\n\t    return result === HASH_UNDEFINED ? undefined : result;\n\t  }\n\t  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n\t}\n\t\n\tmodule.exports = hashGet;\n\n\n/***/ }),\n/* 412 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar nativeCreate = __webpack_require__(76);\n\t\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/** Used to check objects for own properties. */\n\tvar hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t/**\n\t * Checks if a hash value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf Hash\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction hashHas(key) {\n\t  var data = this.__data__;\n\t  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n\t}\n\t\n\tmodule.exports = hashHas;\n\n\n/***/ }),\n/* 413 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar nativeCreate = __webpack_require__(76);\n\t\n\t/** Used to stand-in for `undefined` hash values. */\n\tvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\t\n\t/**\n\t * Sets the hash `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf Hash\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the hash instance.\n\t */\n\tfunction hashSet(key, value) {\n\t  var data = this.__data__;\n\t  this.size += this.has(key) ? 0 : 1;\n\t  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n\t  return this;\n\t}\n\t\n\tmodule.exports = hashSet;\n\n\n/***/ }),\n/* 414 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Checks if `value` is suitable for use as unique object key.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n\t */\n\tfunction isKeyable(value) {\n\t  var type = typeof value;\n\t  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n\t    ? (value !== '__proto__')\n\t    : (value === null);\n\t}\n\t\n\tmodule.exports = isKeyable;\n\n\n/***/ }),\n/* 415 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar coreJsData = __webpack_require__(395);\n\t\n\t/** Used to detect methods masquerading as native. */\n\tvar maskSrcKey = (function() {\n\t  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n\t  return uid ? ('Symbol(src)_1.' + uid) : '';\n\t}());\n\t\n\t/**\n\t * Checks if `func` has its source masked.\n\t *\n\t * @private\n\t * @param {Function} func The function to check.\n\t * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n\t */\n\tfunction isMasked(func) {\n\t  return !!maskSrcKey && (maskSrcKey in func);\n\t}\n\t\n\tmodule.exports = isMasked;\n\n\n/***/ }),\n/* 416 */\n/***/ (function(module, exports) {\n\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/**\n\t * Checks if `value` is likely a prototype object.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n\t */\n\tfunction isPrototype(value) {\n\t  var Ctor = value && value.constructor,\n\t      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\t\n\t  return value === proto;\n\t}\n\t\n\tmodule.exports = isPrototype;\n\n\n/***/ }),\n/* 417 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Removes all key-value entries from the list cache.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf ListCache\n\t */\n\tfunction listCacheClear() {\n\t  this.__data__ = [];\n\t  this.size = 0;\n\t}\n\t\n\tmodule.exports = listCacheClear;\n\n\n/***/ }),\n/* 418 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar assocIndexOf = __webpack_require__(74);\n\t\n\t/** Used for built-in method references. */\n\tvar arrayProto = Array.prototype;\n\t\n\t/** Built-in value references. */\n\tvar splice = arrayProto.splice;\n\t\n\t/**\n\t * Removes `key` and its value from the list cache.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */\n\tfunction listCacheDelete(key) {\n\t  var data = this.__data__,\n\t      index = assocIndexOf(data, key);\n\t\n\t  if (index < 0) {\n\t    return false;\n\t  }\n\t  var lastIndex = data.length - 1;\n\t  if (index == lastIndex) {\n\t    data.pop();\n\t  } else {\n\t    splice.call(data, index, 1);\n\t  }\n\t  --this.size;\n\t  return true;\n\t}\n\t\n\tmodule.exports = listCacheDelete;\n\n\n/***/ }),\n/* 419 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar assocIndexOf = __webpack_require__(74);\n\t\n\t/**\n\t * Gets the list cache value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */\n\tfunction listCacheGet(key) {\n\t  var data = this.__data__,\n\t      index = assocIndexOf(data, key);\n\t\n\t  return index < 0 ? undefined : data[index][1];\n\t}\n\t\n\tmodule.exports = listCacheGet;\n\n\n/***/ }),\n/* 420 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar assocIndexOf = __webpack_require__(74);\n\t\n\t/**\n\t * Checks if a list cache value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf ListCache\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction listCacheHas(key) {\n\t  return assocIndexOf(this.__data__, key) > -1;\n\t}\n\t\n\tmodule.exports = listCacheHas;\n\n\n/***/ }),\n/* 421 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar assocIndexOf = __webpack_require__(74);\n\t\n\t/**\n\t * Sets the list cache `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the list cache instance.\n\t */\n\tfunction listCacheSet(key, value) {\n\t  var data = this.__data__,\n\t      index = assocIndexOf(data, key);\n\t\n\t  if (index < 0) {\n\t    ++this.size;\n\t    data.push([key, value]);\n\t  } else {\n\t    data[index][1] = value;\n\t  }\n\t  return this;\n\t}\n\t\n\tmodule.exports = listCacheSet;\n\n\n/***/ }),\n/* 422 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar Hash = __webpack_require__(361),\n\t    ListCache = __webpack_require__(72),\n\t    Map = __webpack_require__(115);\n\t\n\t/**\n\t * Removes all key-value entries from the map.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf MapCache\n\t */\n\tfunction mapCacheClear() {\n\t  this.size = 0;\n\t  this.__data__ = {\n\t    'hash': new Hash,\n\t    'map': new (Map || ListCache),\n\t    'string': new Hash\n\t  };\n\t}\n\t\n\tmodule.exports = mapCacheClear;\n\n\n/***/ }),\n/* 423 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar getMapData = __webpack_require__(75);\n\t\n\t/**\n\t * Removes `key` and its value from the map.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */\n\tfunction mapCacheDelete(key) {\n\t  var result = getMapData(this, key)['delete'](key);\n\t  this.size -= result ? 1 : 0;\n\t  return result;\n\t}\n\t\n\tmodule.exports = mapCacheDelete;\n\n\n/***/ }),\n/* 424 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar getMapData = __webpack_require__(75);\n\t\n\t/**\n\t * Gets the map value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */\n\tfunction mapCacheGet(key) {\n\t  return getMapData(this, key).get(key);\n\t}\n\t\n\tmodule.exports = mapCacheGet;\n\n\n/***/ }),\n/* 425 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar getMapData = __webpack_require__(75);\n\t\n\t/**\n\t * Checks if a map value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf MapCache\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction mapCacheHas(key) {\n\t  return getMapData(this, key).has(key);\n\t}\n\t\n\tmodule.exports = mapCacheHas;\n\n\n/***/ }),\n/* 426 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar getMapData = __webpack_require__(75);\n\t\n\t/**\n\t * Sets the map `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the map cache instance.\n\t */\n\tfunction mapCacheSet(key, value) {\n\t  var data = getMapData(this, key),\n\t      size = data.size;\n\t\n\t  data.set(key, value);\n\t  this.size += data.size == size ? 0 : 1;\n\t  return this;\n\t}\n\t\n\tmodule.exports = mapCacheSet;\n\n\n/***/ }),\n/* 427 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Converts `map` to its key-value pairs.\n\t *\n\t * @private\n\t * @param {Object} map The map to convert.\n\t * @returns {Array} Returns the key-value pairs.\n\t */\n\tfunction mapToArray(map) {\n\t  var index = -1,\n\t      result = Array(map.size);\n\t\n\t  map.forEach(function(value, key) {\n\t    result[++index] = [key, value];\n\t  });\n\t  return result;\n\t}\n\t\n\tmodule.exports = mapToArray;\n\n\n/***/ }),\n/* 428 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar memoize = __webpack_require__(447);\n\t\n\t/** Used as the maximum memoize cache size. */\n\tvar MAX_MEMOIZE_SIZE = 500;\n\t\n\t/**\n\t * A specialized version of `_.memoize` which clears the memoized function's\n\t * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n\t *\n\t * @private\n\t * @param {Function} func The function to have its output memoized.\n\t * @returns {Function} Returns the new memoized function.\n\t */\n\tfunction memoizeCapped(func) {\n\t  var result = memoize(func, function(key) {\n\t    if (cache.size === MAX_MEMOIZE_SIZE) {\n\t      cache.clear();\n\t    }\n\t    return key;\n\t  });\n\t\n\t  var cache = result.cache;\n\t  return result;\n\t}\n\t\n\tmodule.exports = memoizeCapped;\n\n\n/***/ }),\n/* 429 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar overArg = __webpack_require__(432);\n\t\n\t/* Built-in method references for those with the same name as other `lodash` methods. */\n\tvar nativeKeys = overArg(Object.keys, Object);\n\t\n\tmodule.exports = nativeKeys;\n\n\n/***/ }),\n/* 430 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(177);\n\t\n\t/** Detect free variable `exports`. */\n\tvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\t\n\t/** Detect free variable `module`. */\n\tvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\t\n\t/** Detect the popular CommonJS extension `module.exports`. */\n\tvar moduleExports = freeModule && freeModule.exports === freeExports;\n\t\n\t/** Detect free variable `process` from Node.js. */\n\tvar freeProcess = moduleExports && freeGlobal.process;\n\t\n\t/** Used to access faster Node.js helpers. */\n\tvar nodeUtil = (function() {\n\t  try {\n\t    // Use `util.types` for Node.js 10+.\n\t    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\t\n\t    if (types) {\n\t      return types;\n\t    }\n\t\n\t    // Legacy `process.binding('util')` for Node.js < 10.\n\t    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n\t  } catch (e) {}\n\t}());\n\t\n\tmodule.exports = nodeUtil;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(144)(module)))\n\n/***/ }),\n/* 431 */\n/***/ (function(module, exports) {\n\n\t/** Used for built-in method references. */\n\tvar objectProto = Object.prototype;\n\t\n\t/**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */\n\tvar nativeObjectToString = objectProto.toString;\n\t\n\t/**\n\t * Converts `value` to a string using `Object.prototype.toString`.\n\t *\n\t * @private\n\t * @param {*} value The value to convert.\n\t * @returns {string} Returns the converted string.\n\t */\n\tfunction objectToString(value) {\n\t  return nativeObjectToString.call(value);\n\t}\n\t\n\tmodule.exports = objectToString;\n\n\n/***/ }),\n/* 432 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Creates a unary function that invokes `func` with its argument transformed.\n\t *\n\t * @private\n\t * @param {Function} func The function to wrap.\n\t * @param {Function} transform The argument transform.\n\t * @returns {Function} Returns the new function.\n\t */\n\tfunction overArg(func, transform) {\n\t  return function(arg) {\n\t    return func(transform(arg));\n\t  };\n\t}\n\t\n\tmodule.exports = overArg;\n\n\n/***/ }),\n/* 433 */\n/***/ (function(module, exports) {\n\n\t/** Used to stand-in for `undefined` hash values. */\n\tvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\t\n\t/**\n\t * Adds `value` to the array cache.\n\t *\n\t * @private\n\t * @name add\n\t * @memberOf SetCache\n\t * @alias push\n\t * @param {*} value The value to cache.\n\t * @returns {Object} Returns the cache instance.\n\t */\n\tfunction setCacheAdd(value) {\n\t  this.__data__.set(value, HASH_UNDEFINED);\n\t  return this;\n\t}\n\t\n\tmodule.exports = setCacheAdd;\n\n\n/***/ }),\n/* 434 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Checks if `value` is in the array cache.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf SetCache\n\t * @param {*} value The value to search for.\n\t * @returns {number} Returns `true` if `value` is found, else `false`.\n\t */\n\tfunction setCacheHas(value) {\n\t  return this.__data__.has(value);\n\t}\n\t\n\tmodule.exports = setCacheHas;\n\n\n/***/ }),\n/* 435 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Converts `set` to an array of its values.\n\t *\n\t * @private\n\t * @param {Object} set The set to convert.\n\t * @returns {Array} Returns the values.\n\t */\n\tfunction setToArray(set) {\n\t  var index = -1,\n\t      result = Array(set.size);\n\t\n\t  set.forEach(function(value) {\n\t    result[++index] = value;\n\t  });\n\t  return result;\n\t}\n\t\n\tmodule.exports = setToArray;\n\n\n/***/ }),\n/* 436 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar ListCache = __webpack_require__(72);\n\t\n\t/**\n\t * Removes all key-value entries from the stack.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf Stack\n\t */\n\tfunction stackClear() {\n\t  this.__data__ = new ListCache;\n\t  this.size = 0;\n\t}\n\t\n\tmodule.exports = stackClear;\n\n\n/***/ }),\n/* 437 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Removes `key` and its value from the stack.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf Stack\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */\n\tfunction stackDelete(key) {\n\t  var data = this.__data__,\n\t      result = data['delete'](key);\n\t\n\t  this.size = data.size;\n\t  return result;\n\t}\n\t\n\tmodule.exports = stackDelete;\n\n\n/***/ }),\n/* 438 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Gets the stack value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf Stack\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */\n\tfunction stackGet(key) {\n\t  return this.__data__.get(key);\n\t}\n\t\n\tmodule.exports = stackGet;\n\n\n/***/ }),\n/* 439 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * Checks if a stack value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf Stack\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */\n\tfunction stackHas(key) {\n\t  return this.__data__.has(key);\n\t}\n\t\n\tmodule.exports = stackHas;\n\n\n/***/ }),\n/* 440 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar ListCache = __webpack_require__(72),\n\t    Map = __webpack_require__(115),\n\t    MapCache = __webpack_require__(116);\n\t\n\t/** Used as the size to enable large array optimizations. */\n\tvar LARGE_ARRAY_SIZE = 200;\n\t\n\t/**\n\t * Sets the stack `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf Stack\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the stack cache instance.\n\t */\n\tfunction stackSet(key, value) {\n\t  var data = this.__data__;\n\t  if (data instanceof ListCache) {\n\t    var pairs = data.__data__;\n\t    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n\t      pairs.push([key, value]);\n\t      this.size = ++data.size;\n\t      return this;\n\t    }\n\t    data = this.__data__ = new MapCache(pairs);\n\t  }\n\t  data.set(key, value);\n\t  this.size = data.size;\n\t  return this;\n\t}\n\t\n\tmodule.exports = stackSet;\n\n\n/***/ }),\n/* 441 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar memoizeCapped = __webpack_require__(428);\n\t\n\t/** Used to match property names within property paths. */\n\tvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\t\n\t/** Used to match backslashes in property paths. */\n\tvar reEscapeChar = /\\\\(\\\\)?/g;\n\t\n\t/**\n\t * Converts `string` to a property path array.\n\t *\n\t * @private\n\t * @param {string} string The string to convert.\n\t * @returns {Array} Returns the property path array.\n\t */\n\tvar stringToPath = memoizeCapped(function(string) {\n\t  var result = [];\n\t  if (string.charCodeAt(0) === 46 /* . */) {\n\t    result.push('');\n\t  }\n\t  string.replace(rePropName, function(match, number, quote, subString) {\n\t    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n\t  });\n\t  return result;\n\t});\n\t\n\tmodule.exports = stringToPath;\n\n\n/***/ }),\n/* 442 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseGet = __webpack_require__(174);\n\t\n\t/**\n\t * Gets the value at `path` of `object`. If the resolved value is\n\t * `undefined`, the `defaultValue` is returned in its place.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.7.0\n\t * @category Object\n\t * @param {Object} object The object to query.\n\t * @param {Array|string} path The path of the property to get.\n\t * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n\t * @returns {*} Returns the resolved value.\n\t * @example\n\t *\n\t * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\t *\n\t * _.get(object, 'a[0].b.c');\n\t * // => 3\n\t *\n\t * _.get(object, ['a', '0', 'b', 'c']);\n\t * // => 3\n\t *\n\t * _.get(object, 'a.b.c', 'default');\n\t * // => 'default'\n\t */\n\tfunction get(object, path, defaultValue) {\n\t  var result = object == null ? undefined : baseGet(object, path);\n\t  return result === undefined ? defaultValue : result;\n\t}\n\t\n\tmodule.exports = get;\n\n\n/***/ }),\n/* 443 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseHasIn = __webpack_require__(379),\n\t    hasPath = __webpack_require__(408);\n\t\n\t/**\n\t * Checks if `path` is a direct or inherited property of `object`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Object\n\t * @param {Object} object The object to query.\n\t * @param {Array|string} path The path to check.\n\t * @returns {boolean} Returns `true` if `path` exists, else `false`.\n\t * @example\n\t *\n\t * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n\t *\n\t * _.hasIn(object, 'a');\n\t * // => true\n\t *\n\t * _.hasIn(object, 'a.b');\n\t * // => true\n\t *\n\t * _.hasIn(object, ['a', 'b']);\n\t * // => true\n\t *\n\t * _.hasIn(object, 'b');\n\t * // => false\n\t */\n\tfunction hasIn(object, path) {\n\t  return object != null && hasPath(object, path, baseHasIn);\n\t}\n\t\n\tmodule.exports = hasIn;\n\n\n/***/ }),\n/* 444 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * This method returns the first argument it receives.\n\t *\n\t * @static\n\t * @since 0.1.0\n\t * @memberOf _\n\t * @category Util\n\t * @param {*} value Any value.\n\t * @returns {*} Returns `value`.\n\t * @example\n\t *\n\t * var object = { 'a': 1 };\n\t *\n\t * console.log(_.identity(object) === object);\n\t * // => true\n\t */\n\tfunction identity(value) {\n\t  return value;\n\t}\n\t\n\tmodule.exports = identity;\n\n\n/***/ }),\n/* 445 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseIsEqual = __webpack_require__(117);\n\t\n\t/**\n\t * Performs a deep comparison between two values to determine if they are\n\t * equivalent.\n\t *\n\t * **Note:** This method supports comparing arrays, array buffers, booleans,\n\t * date objects, error objects, maps, numbers, `Object` objects, regexes,\n\t * sets, strings, symbols, and typed arrays. `Object` objects are compared\n\t * by their own, not inherited, enumerable properties. Functions and DOM\n\t * nodes are compared by strict equality, i.e. `===`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to compare.\n\t * @param {*} other The other value to compare.\n\t * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t * @example\n\t *\n\t * var object = { 'a': 1 };\n\t * var other = { 'a': 1 };\n\t *\n\t * _.isEqual(object, other);\n\t * // => true\n\t *\n\t * object === other;\n\t * // => false\n\t */\n\tfunction isEqual(value, other) {\n\t  return baseIsEqual(value, other);\n\t}\n\t\n\tmodule.exports = isEqual;\n\n\n/***/ }),\n/* 446 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseAssignValue = __webpack_require__(374),\n\t    createAggregator = __webpack_require__(396);\n\t\n\t/**\n\t * Creates an object composed of keys generated from the results of running\n\t * each element of `collection` thru `iteratee`. The corresponding value of\n\t * each key is the last element responsible for generating the key. The\n\t * iteratee is invoked with one argument: (value).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Collection\n\t * @param {Array|Object} collection The collection to iterate over.\n\t * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n\t * @returns {Object} Returns the composed aggregate object.\n\t * @example\n\t *\n\t * var array = [\n\t *   { 'dir': 'left', 'code': 97 },\n\t *   { 'dir': 'right', 'code': 100 }\n\t * ];\n\t *\n\t * _.keyBy(array, function(o) {\n\t *   return String.fromCharCode(o.code);\n\t * });\n\t * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n\t *\n\t * _.keyBy(array, 'dir');\n\t * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n\t */\n\tvar keyBy = createAggregator(function(result, value, key) {\n\t  baseAssignValue(result, key, value);\n\t});\n\t\n\tmodule.exports = keyBy;\n\n\n/***/ }),\n/* 447 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar MapCache = __webpack_require__(116);\n\t\n\t/** Error message constants. */\n\tvar FUNC_ERROR_TEXT = 'Expected a function';\n\t\n\t/**\n\t * Creates a function that memoizes the result of `func`. If `resolver` is\n\t * provided, it determines the cache key for storing the result based on the\n\t * arguments provided to the memoized function. By default, the first argument\n\t * provided to the memoized function is used as the map cache key. The `func`\n\t * is invoked with the `this` binding of the memoized function.\n\t *\n\t * **Note:** The cache is exposed as the `cache` property on the memoized\n\t * function. Its creation may be customized by replacing the `_.memoize.Cache`\n\t * constructor with one whose instances implement the\n\t * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n\t * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Function\n\t * @param {Function} func The function to have its output memoized.\n\t * @param {Function} [resolver] The function to resolve the cache key.\n\t * @returns {Function} Returns the new memoized function.\n\t * @example\n\t *\n\t * var object = { 'a': 1, 'b': 2 };\n\t * var other = { 'c': 3, 'd': 4 };\n\t *\n\t * var values = _.memoize(_.values);\n\t * values(object);\n\t * // => [1, 2]\n\t *\n\t * values(other);\n\t * // => [3, 4]\n\t *\n\t * object.a = 2;\n\t * values(object);\n\t * // => [1, 2]\n\t *\n\t * // Modify the result cache.\n\t * values.cache.set(object, ['a', 'b']);\n\t * values(object);\n\t * // => ['a', 'b']\n\t *\n\t * // Replace `_.memoize.Cache`.\n\t * _.memoize.Cache = WeakMap;\n\t */\n\tfunction memoize(func, resolver) {\n\t  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n\t    throw new TypeError(FUNC_ERROR_TEXT);\n\t  }\n\t  var memoized = function() {\n\t    var args = arguments,\n\t        key = resolver ? resolver.apply(this, args) : args[0],\n\t        cache = memoized.cache;\n\t\n\t    if (cache.has(key)) {\n\t      return cache.get(key);\n\t    }\n\t    var result = func.apply(this, args);\n\t    memoized.cache = cache.set(key, result) || cache;\n\t    return result;\n\t  };\n\t  memoized.cache = new (memoize.Cache || MapCache);\n\t  return memoized;\n\t}\n\t\n\t// Expose `MapCache`.\n\tmemoize.Cache = MapCache;\n\t\n\tmodule.exports = memoize;\n\n\n/***/ }),\n/* 448 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseProperty = __webpack_require__(389),\n\t    basePropertyDeep = __webpack_require__(390),\n\t    isKey = __webpack_require__(118),\n\t    toKey = __webpack_require__(77);\n\t\n\t/**\n\t * Creates a function that returns the value at `path` of a given object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 2.4.0\n\t * @category Util\n\t * @param {Array|string} path The path of the property to get.\n\t * @returns {Function} Returns the new accessor function.\n\t * @example\n\t *\n\t * var objects = [\n\t *   { 'a': { 'b': 2 } },\n\t *   { 'a': { 'b': 1 } }\n\t * ];\n\t *\n\t * _.map(objects, _.property('a.b'));\n\t * // => [2, 1]\n\t *\n\t * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n\t * // => [1, 2]\n\t */\n\tfunction property(path) {\n\t  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n\t}\n\t\n\tmodule.exports = property;\n\n\n/***/ }),\n/* 449 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * This method returns a new empty array.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.13.0\n\t * @category Util\n\t * @returns {Array} Returns the new empty array.\n\t * @example\n\t *\n\t * var arrays = _.times(2, _.stubArray);\n\t *\n\t * console.log(arrays);\n\t * // => [[], []]\n\t *\n\t * console.log(arrays[0] === arrays[1]);\n\t * // => false\n\t */\n\tfunction stubArray() {\n\t  return [];\n\t}\n\t\n\tmodule.exports = stubArray;\n\n\n/***/ }),\n/* 450 */\n/***/ (function(module, exports) {\n\n\t/**\n\t * This method returns `false`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.13.0\n\t * @category Util\n\t * @returns {boolean} Returns `false`.\n\t * @example\n\t *\n\t * _.times(2, _.stubFalse);\n\t * // => [false, false]\n\t */\n\tfunction stubFalse() {\n\t  return false;\n\t}\n\t\n\tmodule.exports = stubFalse;\n\n\n/***/ }),\n/* 451 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar baseToString = __webpack_require__(392);\n\t\n\t/**\n\t * Converts `value` to a string. An empty string is returned for `null`\n\t * and `undefined` values. The sign of `-0` is preserved.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to convert.\n\t * @returns {string} Returns the converted string.\n\t * @example\n\t *\n\t * _.toString(null);\n\t * // => ''\n\t *\n\t * _.toString(-0);\n\t * // => '-0'\n\t *\n\t * _.toString([1, 2, 3]);\n\t * // => '1,2,3'\n\t */\n\tfunction toString(value) {\n\t  return value == null ? '' : baseToString(value);\n\t}\n\t\n\tmodule.exports = toString;\n\n\n/***/ }),\n/* 452 */,\n/* 453 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar require;/* WEBPACK VAR INJECTION */(function(module) {//! moment.js\n\t\n\t;(function (global, factory) {\n\t     true ? module.exports = factory() :\n\t    typeof define === 'function' && define.amd ? define(factory) :\n\t    global.moment = factory()\n\t}(this, (function () { 'use strict';\n\t\n\t    var hookCallback;\n\t\n\t    function hooks () {\n\t        return hookCallback.apply(null, arguments);\n\t    }\n\t\n\t    // This is done to register the method called with moment()\n\t    // without creating circular dependencies.\n\t    function setHookCallback (callback) {\n\t        hookCallback = callback;\n\t    }\n\t\n\t    function isArray(input) {\n\t        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n\t    }\n\t\n\t    function isObject(input) {\n\t        // IE8 will treat undefined and null as object if it wasn't for\n\t        // input != null\n\t        return input != null && Object.prototype.toString.call(input) === '[object Object]';\n\t    }\n\t\n\t    function isObjectEmpty(obj) {\n\t        if (Object.getOwnPropertyNames) {\n\t            return (Object.getOwnPropertyNames(obj).length === 0);\n\t        } else {\n\t            var k;\n\t            for (k in obj) {\n\t                if (obj.hasOwnProperty(k)) {\n\t                    return false;\n\t                }\n\t            }\n\t            return true;\n\t        }\n\t    }\n\t\n\t    function isUndefined(input) {\n\t        return input === void 0;\n\t    }\n\t\n\t    function isNumber(input) {\n\t        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n\t    }\n\t\n\t    function isDate(input) {\n\t        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n\t    }\n\t\n\t    function map(arr, fn) {\n\t        var res = [], i;\n\t        for (i = 0; i < arr.length; ++i) {\n\t            res.push(fn(arr[i], i));\n\t        }\n\t        return res;\n\t    }\n\t\n\t    function hasOwnProp(a, b) {\n\t        return Object.prototype.hasOwnProperty.call(a, b);\n\t    }\n\t\n\t    function extend(a, b) {\n\t        for (var i in b) {\n\t            if (hasOwnProp(b, i)) {\n\t                a[i] = b[i];\n\t            }\n\t        }\n\t\n\t        if (hasOwnProp(b, 'toString')) {\n\t            a.toString = b.toString;\n\t        }\n\t\n\t        if (hasOwnProp(b, 'valueOf')) {\n\t            a.valueOf = b.valueOf;\n\t        }\n\t\n\t        return a;\n\t    }\n\t\n\t    function createUTC (input, format, locale, strict) {\n\t        return createLocalOrUTC(input, format, locale, strict, true).utc();\n\t    }\n\t\n\t    function defaultParsingFlags() {\n\t        // We need to deep clone this object.\n\t        return {\n\t            empty           : false,\n\t            unusedTokens    : [],\n\t            unusedInput     : [],\n\t            overflow        : -2,\n\t            charsLeftOver   : 0,\n\t            nullInput       : false,\n\t            invalidMonth    : null,\n\t            invalidFormat   : false,\n\t            userInvalidated : false,\n\t            iso             : false,\n\t            parsedDateParts : [],\n\t            meridiem        : null,\n\t            rfc2822         : false,\n\t            weekdayMismatch : false\n\t        };\n\t    }\n\t\n\t    function getParsingFlags(m) {\n\t        if (m._pf == null) {\n\t            m._pf = defaultParsingFlags();\n\t        }\n\t        return m._pf;\n\t    }\n\t\n\t    var some;\n\t    if (Array.prototype.some) {\n\t        some = Array.prototype.some;\n\t    } else {\n\t        some = function (fun) {\n\t            var t = Object(this);\n\t            var len = t.length >>> 0;\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                if (i in t && fun.call(this, t[i], i, t)) {\n\t                    return true;\n\t                }\n\t            }\n\t\n\t            return false;\n\t        };\n\t    }\n\t\n\t    function isValid(m) {\n\t        if (m._isValid == null) {\n\t            var flags = getParsingFlags(m);\n\t            var parsedParts = some.call(flags.parsedDateParts, function (i) {\n\t                return i != null;\n\t            });\n\t            var isNowValid = !isNaN(m._d.getTime()) &&\n\t                flags.overflow < 0 &&\n\t                !flags.empty &&\n\t                !flags.invalidMonth &&\n\t                !flags.invalidWeekday &&\n\t                !flags.weekdayMismatch &&\n\t                !flags.nullInput &&\n\t                !flags.invalidFormat &&\n\t                !flags.userInvalidated &&\n\t                (!flags.meridiem || (flags.meridiem && parsedParts));\n\t\n\t            if (m._strict) {\n\t                isNowValid = isNowValid &&\n\t                    flags.charsLeftOver === 0 &&\n\t                    flags.unusedTokens.length === 0 &&\n\t                    flags.bigHour === undefined;\n\t            }\n\t\n\t            if (Object.isFrozen == null || !Object.isFrozen(m)) {\n\t                m._isValid = isNowValid;\n\t            }\n\t            else {\n\t                return isNowValid;\n\t            }\n\t        }\n\t        return m._isValid;\n\t    }\n\t\n\t    function createInvalid (flags) {\n\t        var m = createUTC(NaN);\n\t        if (flags != null) {\n\t            extend(getParsingFlags(m), flags);\n\t        }\n\t        else {\n\t            getParsingFlags(m).userInvalidated = true;\n\t        }\n\t\n\t        return m;\n\t    }\n\t\n\t    // Plugins that add properties should also add the key here (null value),\n\t    // so we can properly clone ourselves.\n\t    var momentProperties = hooks.momentProperties = [];\n\t\n\t    function copyConfig(to, from) {\n\t        var i, prop, val;\n\t\n\t        if (!isUndefined(from._isAMomentObject)) {\n\t            to._isAMomentObject = from._isAMomentObject;\n\t        }\n\t        if (!isUndefined(from._i)) {\n\t            to._i = from._i;\n\t        }\n\t        if (!isUndefined(from._f)) {\n\t            to._f = from._f;\n\t        }\n\t        if (!isUndefined(from._l)) {\n\t            to._l = from._l;\n\t        }\n\t        if (!isUndefined(from._strict)) {\n\t            to._strict = from._strict;\n\t        }\n\t        if (!isUndefined(from._tzm)) {\n\t            to._tzm = from._tzm;\n\t        }\n\t        if (!isUndefined(from._isUTC)) {\n\t            to._isUTC = from._isUTC;\n\t        }\n\t        if (!isUndefined(from._offset)) {\n\t            to._offset = from._offset;\n\t        }\n\t        if (!isUndefined(from._pf)) {\n\t            to._pf = getParsingFlags(from);\n\t        }\n\t        if (!isUndefined(from._locale)) {\n\t            to._locale = from._locale;\n\t        }\n\t\n\t        if (momentProperties.length > 0) {\n\t            for (i = 0; i < momentProperties.length; i++) {\n\t                prop = momentProperties[i];\n\t                val = from[prop];\n\t                if (!isUndefined(val)) {\n\t                    to[prop] = val;\n\t                }\n\t            }\n\t        }\n\t\n\t        return to;\n\t    }\n\t\n\t    var updateInProgress = false;\n\t\n\t    // Moment prototype object\n\t    function Moment(config) {\n\t        copyConfig(this, config);\n\t        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n\t        if (!this.isValid()) {\n\t            this._d = new Date(NaN);\n\t        }\n\t        // Prevent infinite loop in case updateOffset creates new moment\n\t        // objects.\n\t        if (updateInProgress === false) {\n\t            updateInProgress = true;\n\t            hooks.updateOffset(this);\n\t            updateInProgress = false;\n\t        }\n\t    }\n\t\n\t    function isMoment (obj) {\n\t        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n\t    }\n\t\n\t    function absFloor (number) {\n\t        if (number < 0) {\n\t            // -0 -> 0\n\t            return Math.ceil(number) || 0;\n\t        } else {\n\t            return Math.floor(number);\n\t        }\n\t    }\n\t\n\t    function toInt(argumentForCoercion) {\n\t        var coercedNumber = +argumentForCoercion,\n\t            value = 0;\n\t\n\t        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n\t            value = absFloor(coercedNumber);\n\t        }\n\t\n\t        return value;\n\t    }\n\t\n\t    // compare two arrays, return the number of differences\n\t    function compareArrays(array1, array2, dontConvert) {\n\t        var len = Math.min(array1.length, array2.length),\n\t            lengthDiff = Math.abs(array1.length - array2.length),\n\t            diffs = 0,\n\t            i;\n\t        for (i = 0; i < len; i++) {\n\t            if ((dontConvert && array1[i] !== array2[i]) ||\n\t                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n\t                diffs++;\n\t            }\n\t        }\n\t        return diffs + lengthDiff;\n\t    }\n\t\n\t    function warn(msg) {\n\t        if (hooks.suppressDeprecationWarnings === false &&\n\t                (typeof console !==  'undefined') && console.warn) {\n\t            console.warn('Deprecation warning: ' + msg);\n\t        }\n\t    }\n\t\n\t    function deprecate(msg, fn) {\n\t        var firstTime = true;\n\t\n\t        return extend(function () {\n\t            if (hooks.deprecationHandler != null) {\n\t                hooks.deprecationHandler(null, msg);\n\t            }\n\t            if (firstTime) {\n\t                var args = [];\n\t                var arg;\n\t                for (var i = 0; i < arguments.length; i++) {\n\t                    arg = '';\n\t                    if (typeof arguments[i] === 'object') {\n\t                        arg += '\\n[' + i + '] ';\n\t                        for (var key in arguments[0]) {\n\t                            arg += key + ': ' + arguments[0][key] + ', ';\n\t                        }\n\t                        arg = arg.slice(0, -2); // Remove trailing comma and space\n\t                    } else {\n\t                        arg = arguments[i];\n\t                    }\n\t                    args.push(arg);\n\t                }\n\t                warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + (new Error()).stack);\n\t                firstTime = false;\n\t            }\n\t            return fn.apply(this, arguments);\n\t        }, fn);\n\t    }\n\t\n\t    var deprecations = {};\n\t\n\t    function deprecateSimple(name, msg) {\n\t        if (hooks.deprecationHandler != null) {\n\t            hooks.deprecationHandler(name, msg);\n\t        }\n\t        if (!deprecations[name]) {\n\t            warn(msg);\n\t            deprecations[name] = true;\n\t        }\n\t    }\n\t\n\t    hooks.suppressDeprecationWarnings = false;\n\t    hooks.deprecationHandler = null;\n\t\n\t    function isFunction(input) {\n\t        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n\t    }\n\t\n\t    function set (config) {\n\t        var prop, i;\n\t        for (i in config) {\n\t            prop = config[i];\n\t            if (isFunction(prop)) {\n\t                this[i] = prop;\n\t            } else {\n\t                this['_' + i] = prop;\n\t            }\n\t        }\n\t        this._config = config;\n\t        // Lenient ordinal parsing accepts just a number in addition to\n\t        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n\t        // TODO: Remove \"ordinalParse\" fallback in next major release.\n\t        this._dayOfMonthOrdinalParseLenient = new RegExp(\n\t            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\n\t                '|' + (/\\d{1,2}/).source);\n\t    }\n\t\n\t    function mergeConfigs(parentConfig, childConfig) {\n\t        var res = extend({}, parentConfig), prop;\n\t        for (prop in childConfig) {\n\t            if (hasOwnProp(childConfig, prop)) {\n\t                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n\t                    res[prop] = {};\n\t                    extend(res[prop], parentConfig[prop]);\n\t                    extend(res[prop], childConfig[prop]);\n\t                } else if (childConfig[prop] != null) {\n\t                    res[prop] = childConfig[prop];\n\t                } else {\n\t                    delete res[prop];\n\t                }\n\t            }\n\t        }\n\t        for (prop in parentConfig) {\n\t            if (hasOwnProp(parentConfig, prop) &&\n\t                    !hasOwnProp(childConfig, prop) &&\n\t                    isObject(parentConfig[prop])) {\n\t                // make sure changes to properties don't modify parent config\n\t                res[prop] = extend({}, res[prop]);\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t\n\t    function Locale(config) {\n\t        if (config != null) {\n\t            this.set(config);\n\t        }\n\t    }\n\t\n\t    var keys;\n\t\n\t    if (Object.keys) {\n\t        keys = Object.keys;\n\t    } else {\n\t        keys = function (obj) {\n\t            var i, res = [];\n\t            for (i in obj) {\n\t                if (hasOwnProp(obj, i)) {\n\t                    res.push(i);\n\t                }\n\t            }\n\t            return res;\n\t        };\n\t    }\n\t\n\t    var defaultCalendar = {\n\t        sameDay : '[Today at] LT',\n\t        nextDay : '[Tomorrow at] LT',\n\t        nextWeek : 'dddd [at] LT',\n\t        lastDay : '[Yesterday at] LT',\n\t        lastWeek : '[Last] dddd [at] LT',\n\t        sameElse : 'L'\n\t    };\n\t\n\t    function calendar (key, mom, now) {\n\t        var output = this._calendar[key] || this._calendar['sameElse'];\n\t        return isFunction(output) ? output.call(mom, now) : output;\n\t    }\n\t\n\t    var defaultLongDateFormat = {\n\t        LTS  : 'h:mm:ss A',\n\t        LT   : 'h:mm A',\n\t        L    : 'MM/DD/YYYY',\n\t        LL   : 'MMMM D, YYYY',\n\t        LLL  : 'MMMM D, YYYY h:mm A',\n\t        LLLL : 'dddd, MMMM D, YYYY h:mm A'\n\t    };\n\t\n\t    function longDateFormat (key) {\n\t        var format = this._longDateFormat[key],\n\t            formatUpper = this._longDateFormat[key.toUpperCase()];\n\t\n\t        if (format || !formatUpper) {\n\t            return format;\n\t        }\n\t\n\t        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n\t            return val.slice(1);\n\t        });\n\t\n\t        return this._longDateFormat[key];\n\t    }\n\t\n\t    var defaultInvalidDate = 'Invalid date';\n\t\n\t    function invalidDate () {\n\t        return this._invalidDate;\n\t    }\n\t\n\t    var defaultOrdinal = '%d';\n\t    var defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\t\n\t    function ordinal (number) {\n\t        return this._ordinal.replace('%d', number);\n\t    }\n\t\n\t    var defaultRelativeTime = {\n\t        future : 'in %s',\n\t        past   : '%s ago',\n\t        s  : 'a few seconds',\n\t        ss : '%d seconds',\n\t        m  : 'a minute',\n\t        mm : '%d minutes',\n\t        h  : 'an hour',\n\t        hh : '%d hours',\n\t        d  : 'a day',\n\t        dd : '%d days',\n\t        M  : 'a month',\n\t        MM : '%d months',\n\t        y  : 'a year',\n\t        yy : '%d years'\n\t    };\n\t\n\t    function relativeTime (number, withoutSuffix, string, isFuture) {\n\t        var output = this._relativeTime[string];\n\t        return (isFunction(output)) ?\n\t            output(number, withoutSuffix, string, isFuture) :\n\t            output.replace(/%d/i, number);\n\t    }\n\t\n\t    function pastFuture (diff, output) {\n\t        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n\t        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n\t    }\n\t\n\t    var aliases = {};\n\t\n\t    function addUnitAlias (unit, shorthand) {\n\t        var lowerCase = unit.toLowerCase();\n\t        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n\t    }\n\t\n\t    function normalizeUnits(units) {\n\t        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n\t    }\n\t\n\t    function normalizeObjectUnits(inputObject) {\n\t        var normalizedInput = {},\n\t            normalizedProp,\n\t            prop;\n\t\n\t        for (prop in inputObject) {\n\t            if (hasOwnProp(inputObject, prop)) {\n\t                normalizedProp = normalizeUnits(prop);\n\t                if (normalizedProp) {\n\t                    normalizedInput[normalizedProp] = inputObject[prop];\n\t                }\n\t            }\n\t        }\n\t\n\t        return normalizedInput;\n\t    }\n\t\n\t    var priorities = {};\n\t\n\t    function addUnitPriority(unit, priority) {\n\t        priorities[unit] = priority;\n\t    }\n\t\n\t    function getPrioritizedUnits(unitsObj) {\n\t        var units = [];\n\t        for (var u in unitsObj) {\n\t            units.push({unit: u, priority: priorities[u]});\n\t        }\n\t        units.sort(function (a, b) {\n\t            return a.priority - b.priority;\n\t        });\n\t        return units;\n\t    }\n\t\n\t    function zeroFill(number, targetLength, forceSign) {\n\t        var absNumber = '' + Math.abs(number),\n\t            zerosToFill = targetLength - absNumber.length,\n\t            sign = number >= 0;\n\t        return (sign ? (forceSign ? '+' : '') : '-') +\n\t            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n\t    }\n\t\n\t    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\t\n\t    var localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\t\n\t    var formatFunctions = {};\n\t\n\t    var formatTokenFunctions = {};\n\t\n\t    // token:    'M'\n\t    // padded:   ['MM', 2]\n\t    // ordinal:  'Mo'\n\t    // callback: function () { this.month() + 1 }\n\t    function addFormatToken (token, padded, ordinal, callback) {\n\t        var func = callback;\n\t        if (typeof callback === 'string') {\n\t            func = function () {\n\t                return this[callback]();\n\t            };\n\t        }\n\t        if (token) {\n\t            formatTokenFunctions[token] = func;\n\t        }\n\t        if (padded) {\n\t            formatTokenFunctions[padded[0]] = function () {\n\t                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n\t            };\n\t        }\n\t        if (ordinal) {\n\t            formatTokenFunctions[ordinal] = function () {\n\t                return this.localeData().ordinal(func.apply(this, arguments), token);\n\t            };\n\t        }\n\t    }\n\t\n\t    function removeFormattingTokens(input) {\n\t        if (input.match(/\\[[\\s\\S]/)) {\n\t            return input.replace(/^\\[|\\]$/g, '');\n\t        }\n\t        return input.replace(/\\\\/g, '');\n\t    }\n\t\n\t    function makeFormatFunction(format) {\n\t        var array = format.match(formattingTokens), i, length;\n\t\n\t        for (i = 0, length = array.length; i < length; i++) {\n\t            if (formatTokenFunctions[array[i]]) {\n\t                array[i] = formatTokenFunctions[array[i]];\n\t            } else {\n\t                array[i] = removeFormattingTokens(array[i]);\n\t            }\n\t        }\n\t\n\t        return function (mom) {\n\t            var output = '', i;\n\t            for (i = 0; i < length; i++) {\n\t                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n\t            }\n\t            return output;\n\t        };\n\t    }\n\t\n\t    // format date using native date object\n\t    function formatMoment(m, format) {\n\t        if (!m.isValid()) {\n\t            return m.localeData().invalidDate();\n\t        }\n\t\n\t        format = expandFormat(format, m.localeData());\n\t        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\t\n\t        return formatFunctions[format](m);\n\t    }\n\t\n\t    function expandFormat(format, locale) {\n\t        var i = 5;\n\t\n\t        function replaceLongDateFormatTokens(input) {\n\t            return locale.longDateFormat(input) || input;\n\t        }\n\t\n\t        localFormattingTokens.lastIndex = 0;\n\t        while (i >= 0 && localFormattingTokens.test(format)) {\n\t            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n\t            localFormattingTokens.lastIndex = 0;\n\t            i -= 1;\n\t        }\n\t\n\t        return format;\n\t    }\n\t\n\t    var match1         = /\\d/;            //       0 - 9\n\t    var match2         = /\\d\\d/;          //      00 - 99\n\t    var match3         = /\\d{3}/;         //     000 - 999\n\t    var match4         = /\\d{4}/;         //    0000 - 9999\n\t    var match6         = /[+-]?\\d{6}/;    // -999999 - 999999\n\t    var match1to2      = /\\d\\d?/;         //       0 - 99\n\t    var match3to4      = /\\d\\d\\d\\d?/;     //     999 - 9999\n\t    var match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999\n\t    var match1to3      = /\\d{1,3}/;       //       0 - 999\n\t    var match1to4      = /\\d{1,4}/;       //       0 - 9999\n\t    var match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\t\n\t    var matchUnsigned  = /\\d+/;           //       0 - inf\n\t    var matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\t\n\t    var matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\n\t    var matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n\t\n\t    var matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\t\n\t    // any word (or two) characters or numbers including two/three word month in arabic.\n\t    // includes scottish gaelic two word and hyphenated months\n\t    var matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i;\n\t\n\t    var regexes = {};\n\t\n\t    function addRegexToken (token, regex, strictRegex) {\n\t        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n\t            return (isStrict && strictRegex) ? strictRegex : regex;\n\t        };\n\t    }\n\t\n\t    function getParseRegexForToken (token, config) {\n\t        if (!hasOwnProp(regexes, token)) {\n\t            return new RegExp(unescapeFormat(token));\n\t        }\n\t\n\t        return regexes[token](config._strict, config._locale);\n\t    }\n\t\n\t    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n\t    function unescapeFormat(s) {\n\t        return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n\t            return p1 || p2 || p3 || p4;\n\t        }));\n\t    }\n\t\n\t    function regexEscape(s) {\n\t        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\t    }\n\t\n\t    var tokens = {};\n\t\n\t    function addParseToken (token, callback) {\n\t        var i, func = callback;\n\t        if (typeof token === 'string') {\n\t            token = [token];\n\t        }\n\t        if (isNumber(callback)) {\n\t            func = function (input, array) {\n\t                array[callback] = toInt(input);\n\t            };\n\t        }\n\t        for (i = 0; i < token.length; i++) {\n\t            tokens[token[i]] = func;\n\t        }\n\t    }\n\t\n\t    function addWeekParseToken (token, callback) {\n\t        addParseToken(token, function (input, array, config, token) {\n\t            config._w = config._w || {};\n\t            callback(input, config._w, config, token);\n\t        });\n\t    }\n\t\n\t    function addTimeToArrayFromToken(token, input, config) {\n\t        if (input != null && hasOwnProp(tokens, token)) {\n\t            tokens[token](input, config._a, config, token);\n\t        }\n\t    }\n\t\n\t    var YEAR = 0;\n\t    var MONTH = 1;\n\t    var DATE = 2;\n\t    var HOUR = 3;\n\t    var MINUTE = 4;\n\t    var SECOND = 5;\n\t    var MILLISECOND = 6;\n\t    var WEEK = 7;\n\t    var WEEKDAY = 8;\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('Y', 0, 0, function () {\n\t        var y = this.year();\n\t        return y <= 9999 ? '' + y : '+' + y;\n\t    });\n\t\n\t    addFormatToken(0, ['YY', 2], 0, function () {\n\t        return this.year() % 100;\n\t    });\n\t\n\t    addFormatToken(0, ['YYYY',   4],       0, 'year');\n\t    addFormatToken(0, ['YYYYY',  5],       0, 'year');\n\t    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('year', 'y');\n\t\n\t    // PRIORITIES\n\t\n\t    addUnitPriority('year', 1);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('Y',      matchSigned);\n\t    addRegexToken('YY',     match1to2, match2);\n\t    addRegexToken('YYYY',   match1to4, match4);\n\t    addRegexToken('YYYYY',  match1to6, match6);\n\t    addRegexToken('YYYYYY', match1to6, match6);\n\t\n\t    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n\t    addParseToken('YYYY', function (input, array) {\n\t        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n\t    });\n\t    addParseToken('YY', function (input, array) {\n\t        array[YEAR] = hooks.parseTwoDigitYear(input);\n\t    });\n\t    addParseToken('Y', function (input, array) {\n\t        array[YEAR] = parseInt(input, 10);\n\t    });\n\t\n\t    // HELPERS\n\t\n\t    function daysInYear(year) {\n\t        return isLeapYear(year) ? 366 : 365;\n\t    }\n\t\n\t    function isLeapYear(year) {\n\t        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n\t    }\n\t\n\t    // HOOKS\n\t\n\t    hooks.parseTwoDigitYear = function (input) {\n\t        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n\t    };\n\t\n\t    // MOMENTS\n\t\n\t    var getSetYear = makeGetSet('FullYear', true);\n\t\n\t    function getIsLeapYear () {\n\t        return isLeapYear(this.year());\n\t    }\n\t\n\t    function makeGetSet (unit, keepTime) {\n\t        return function (value) {\n\t            if (value != null) {\n\t                set$1(this, unit, value);\n\t                hooks.updateOffset(this, keepTime);\n\t                return this;\n\t            } else {\n\t                return get(this, unit);\n\t            }\n\t        };\n\t    }\n\t\n\t    function get (mom, unit) {\n\t        return mom.isValid() ?\n\t            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n\t    }\n\t\n\t    function set$1 (mom, unit, value) {\n\t        if (mom.isValid() && !isNaN(value)) {\n\t            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\n\t                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));\n\t            }\n\t            else {\n\t                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n\t            }\n\t        }\n\t    }\n\t\n\t    // MOMENTS\n\t\n\t    function stringGet (units) {\n\t        units = normalizeUnits(units);\n\t        if (isFunction(this[units])) {\n\t            return this[units]();\n\t        }\n\t        return this;\n\t    }\n\t\n\t\n\t    function stringSet (units, value) {\n\t        if (typeof units === 'object') {\n\t            units = normalizeObjectUnits(units);\n\t            var prioritized = getPrioritizedUnits(units);\n\t            for (var i = 0; i < prioritized.length; i++) {\n\t                this[prioritized[i].unit](units[prioritized[i].unit]);\n\t            }\n\t        } else {\n\t            units = normalizeUnits(units);\n\t            if (isFunction(this[units])) {\n\t                return this[units](value);\n\t            }\n\t        }\n\t        return this;\n\t    }\n\t\n\t    function mod(n, x) {\n\t        return ((n % x) + x) % x;\n\t    }\n\t\n\t    var indexOf;\n\t\n\t    if (Array.prototype.indexOf) {\n\t        indexOf = Array.prototype.indexOf;\n\t    } else {\n\t        indexOf = function (o) {\n\t            // I know\n\t            var i;\n\t            for (i = 0; i < this.length; ++i) {\n\t                if (this[i] === o) {\n\t                    return i;\n\t                }\n\t            }\n\t            return -1;\n\t        };\n\t    }\n\t\n\t    function daysInMonth(year, month) {\n\t        if (isNaN(year) || isNaN(month)) {\n\t            return NaN;\n\t        }\n\t        var modMonth = mod(month, 12);\n\t        year += (month - modMonth) / 12;\n\t        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('M', ['MM', 2], 'Mo', function () {\n\t        return this.month() + 1;\n\t    });\n\t\n\t    addFormatToken('MMM', 0, 0, function (format) {\n\t        return this.localeData().monthsShort(this, format);\n\t    });\n\t\n\t    addFormatToken('MMMM', 0, 0, function (format) {\n\t        return this.localeData().months(this, format);\n\t    });\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('month', 'M');\n\t\n\t    // PRIORITY\n\t\n\t    addUnitPriority('month', 8);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('M',    match1to2);\n\t    addRegexToken('MM',   match1to2, match2);\n\t    addRegexToken('MMM',  function (isStrict, locale) {\n\t        return locale.monthsShortRegex(isStrict);\n\t    });\n\t    addRegexToken('MMMM', function (isStrict, locale) {\n\t        return locale.monthsRegex(isStrict);\n\t    });\n\t\n\t    addParseToken(['M', 'MM'], function (input, array) {\n\t        array[MONTH] = toInt(input) - 1;\n\t    });\n\t\n\t    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n\t        var month = config._locale.monthsParse(input, token, config._strict);\n\t        // if we didn't find a month name, mark the date as invalid.\n\t        if (month != null) {\n\t            array[MONTH] = month;\n\t        } else {\n\t            getParsingFlags(config).invalidMonth = input;\n\t        }\n\t    });\n\t\n\t    // LOCALES\n\t\n\t    var MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/;\n\t    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\n\t    function localeMonths (m, format) {\n\t        if (!m) {\n\t            return isArray(this._months) ? this._months :\n\t                this._months['standalone'];\n\t        }\n\t        return isArray(this._months) ? this._months[m.month()] :\n\t            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n\t    }\n\t\n\t    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\n\t    function localeMonthsShort (m, format) {\n\t        if (!m) {\n\t            return isArray(this._monthsShort) ? this._monthsShort :\n\t                this._monthsShort['standalone'];\n\t        }\n\t        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\n\t            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n\t    }\n\t\n\t    function handleStrictParse(monthName, format, strict) {\n\t        var i, ii, mom, llc = monthName.toLocaleLowerCase();\n\t        if (!this._monthsParse) {\n\t            // this is not used\n\t            this._monthsParse = [];\n\t            this._longMonthsParse = [];\n\t            this._shortMonthsParse = [];\n\t            for (i = 0; i < 12; ++i) {\n\t                mom = createUTC([2000, i]);\n\t                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n\t                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n\t            }\n\t        }\n\t\n\t        if (strict) {\n\t            if (format === 'MMM') {\n\t                ii = indexOf.call(this._shortMonthsParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            } else {\n\t                ii = indexOf.call(this._longMonthsParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            }\n\t        } else {\n\t            if (format === 'MMM') {\n\t                ii = indexOf.call(this._shortMonthsParse, llc);\n\t                if (ii !== -1) {\n\t                    return ii;\n\t                }\n\t                ii = indexOf.call(this._longMonthsParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            } else {\n\t                ii = indexOf.call(this._longMonthsParse, llc);\n\t                if (ii !== -1) {\n\t                    return ii;\n\t                }\n\t                ii = indexOf.call(this._shortMonthsParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            }\n\t        }\n\t    }\n\t\n\t    function localeMonthsParse (monthName, format, strict) {\n\t        var i, mom, regex;\n\t\n\t        if (this._monthsParseExact) {\n\t            return handleStrictParse.call(this, monthName, format, strict);\n\t        }\n\t\n\t        if (!this._monthsParse) {\n\t            this._monthsParse = [];\n\t            this._longMonthsParse = [];\n\t            this._shortMonthsParse = [];\n\t        }\n\t\n\t        // TODO: add sorting\n\t        // Sorting makes sure if one month (or abbr) is a prefix of another\n\t        // see sorting in computeMonthsParse\n\t        for (i = 0; i < 12; i++) {\n\t            // make the regex if we don't have it already\n\t            mom = createUTC([2000, i]);\n\t            if (strict && !this._longMonthsParse[i]) {\n\t                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n\t                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n\t            }\n\t            if (!strict && !this._monthsParse[i]) {\n\t                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n\t                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n\t            }\n\t            // test the regex\n\t            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n\t                return i;\n\t            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n\t                return i;\n\t            } else if (!strict && this._monthsParse[i].test(monthName)) {\n\t                return i;\n\t            }\n\t        }\n\t    }\n\t\n\t    // MOMENTS\n\t\n\t    function setMonth (mom, value) {\n\t        var dayOfMonth;\n\t\n\t        if (!mom.isValid()) {\n\t            // No op\n\t            return mom;\n\t        }\n\t\n\t        if (typeof value === 'string') {\n\t            if (/^\\d+$/.test(value)) {\n\t                value = toInt(value);\n\t            } else {\n\t                value = mom.localeData().monthsParse(value);\n\t                // TODO: Another silent failure?\n\t                if (!isNumber(value)) {\n\t                    return mom;\n\t                }\n\t            }\n\t        }\n\t\n\t        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n\t        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n\t        return mom;\n\t    }\n\t\n\t    function getSetMonth (value) {\n\t        if (value != null) {\n\t            setMonth(this, value);\n\t            hooks.updateOffset(this, true);\n\t            return this;\n\t        } else {\n\t            return get(this, 'Month');\n\t        }\n\t    }\n\t\n\t    function getDaysInMonth () {\n\t        return daysInMonth(this.year(), this.month());\n\t    }\n\t\n\t    var defaultMonthsShortRegex = matchWord;\n\t    function monthsShortRegex (isStrict) {\n\t        if (this._monthsParseExact) {\n\t            if (!hasOwnProp(this, '_monthsRegex')) {\n\t                computeMonthsParse.call(this);\n\t            }\n\t            if (isStrict) {\n\t                return this._monthsShortStrictRegex;\n\t            } else {\n\t                return this._monthsShortRegex;\n\t            }\n\t        } else {\n\t            if (!hasOwnProp(this, '_monthsShortRegex')) {\n\t                this._monthsShortRegex = defaultMonthsShortRegex;\n\t            }\n\t            return this._monthsShortStrictRegex && isStrict ?\n\t                this._monthsShortStrictRegex : this._monthsShortRegex;\n\t        }\n\t    }\n\t\n\t    var defaultMonthsRegex = matchWord;\n\t    function monthsRegex (isStrict) {\n\t        if (this._monthsParseExact) {\n\t            if (!hasOwnProp(this, '_monthsRegex')) {\n\t                computeMonthsParse.call(this);\n\t            }\n\t            if (isStrict) {\n\t                return this._monthsStrictRegex;\n\t            } else {\n\t                return this._monthsRegex;\n\t            }\n\t        } else {\n\t            if (!hasOwnProp(this, '_monthsRegex')) {\n\t                this._monthsRegex = defaultMonthsRegex;\n\t            }\n\t            return this._monthsStrictRegex && isStrict ?\n\t                this._monthsStrictRegex : this._monthsRegex;\n\t        }\n\t    }\n\t\n\t    function computeMonthsParse () {\n\t        function cmpLenRev(a, b) {\n\t            return b.length - a.length;\n\t        }\n\t\n\t        var shortPieces = [], longPieces = [], mixedPieces = [],\n\t            i, mom;\n\t        for (i = 0; i < 12; i++) {\n\t            // make the regex if we don't have it already\n\t            mom = createUTC([2000, i]);\n\t            shortPieces.push(this.monthsShort(mom, ''));\n\t            longPieces.push(this.months(mom, ''));\n\t            mixedPieces.push(this.months(mom, ''));\n\t            mixedPieces.push(this.monthsShort(mom, ''));\n\t        }\n\t        // Sorting makes sure if one month (or abbr) is a prefix of another it\n\t        // will match the longer piece.\n\t        shortPieces.sort(cmpLenRev);\n\t        longPieces.sort(cmpLenRev);\n\t        mixedPieces.sort(cmpLenRev);\n\t        for (i = 0; i < 12; i++) {\n\t            shortPieces[i] = regexEscape(shortPieces[i]);\n\t            longPieces[i] = regexEscape(longPieces[i]);\n\t        }\n\t        for (i = 0; i < 24; i++) {\n\t            mixedPieces[i] = regexEscape(mixedPieces[i]);\n\t        }\n\t\n\t        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n\t        this._monthsShortRegex = this._monthsRegex;\n\t        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n\t        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n\t    }\n\t\n\t    function createDate (y, m, d, h, M, s, ms) {\n\t        // can't just apply() to create a date:\n\t        // https://stackoverflow.com/q/181348\n\t        var date;\n\t        // the date constructor remaps years 0-99 to 1900-1999\n\t        if (y < 100 && y >= 0) {\n\t            // preserve leap years using a full 400 year cycle, then reset\n\t            date = new Date(y + 400, m, d, h, M, s, ms);\n\t            if (isFinite(date.getFullYear())) {\n\t                date.setFullYear(y);\n\t            }\n\t        } else {\n\t            date = new Date(y, m, d, h, M, s, ms);\n\t        }\n\t\n\t        return date;\n\t    }\n\t\n\t    function createUTCDate (y) {\n\t        var date;\n\t        // the Date.UTC function remaps years 0-99 to 1900-1999\n\t        if (y < 100 && y >= 0) {\n\t            var args = Array.prototype.slice.call(arguments);\n\t            // preserve leap years using a full 400 year cycle, then reset\n\t            args[0] = y + 400;\n\t            date = new Date(Date.UTC.apply(null, args));\n\t            if (isFinite(date.getUTCFullYear())) {\n\t                date.setUTCFullYear(y);\n\t            }\n\t        } else {\n\t            date = new Date(Date.UTC.apply(null, arguments));\n\t        }\n\t\n\t        return date;\n\t    }\n\t\n\t    // start-of-first-week - start-of-year\n\t    function firstWeekOffset(year, dow, doy) {\n\t        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n\t            fwd = 7 + dow - doy,\n\t            // first-week day local weekday -- which local weekday is fwd\n\t            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\t\n\t        return -fwdlw + fwd - 1;\n\t    }\n\t\n\t    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n\t    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n\t        var localWeekday = (7 + weekday - dow) % 7,\n\t            weekOffset = firstWeekOffset(year, dow, doy),\n\t            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n\t            resYear, resDayOfYear;\n\t\n\t        if (dayOfYear <= 0) {\n\t            resYear = year - 1;\n\t            resDayOfYear = daysInYear(resYear) + dayOfYear;\n\t        } else if (dayOfYear > daysInYear(year)) {\n\t            resYear = year + 1;\n\t            resDayOfYear = dayOfYear - daysInYear(year);\n\t        } else {\n\t            resYear = year;\n\t            resDayOfYear = dayOfYear;\n\t        }\n\t\n\t        return {\n\t            year: resYear,\n\t            dayOfYear: resDayOfYear\n\t        };\n\t    }\n\t\n\t    function weekOfYear(mom, dow, doy) {\n\t        var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n\t            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n\t            resWeek, resYear;\n\t\n\t        if (week < 1) {\n\t            resYear = mom.year() - 1;\n\t            resWeek = week + weeksInYear(resYear, dow, doy);\n\t        } else if (week > weeksInYear(mom.year(), dow, doy)) {\n\t            resWeek = week - weeksInYear(mom.year(), dow, doy);\n\t            resYear = mom.year() + 1;\n\t        } else {\n\t            resYear = mom.year();\n\t            resWeek = week;\n\t        }\n\t\n\t        return {\n\t            week: resWeek,\n\t            year: resYear\n\t        };\n\t    }\n\t\n\t    function weeksInYear(year, dow, doy) {\n\t        var weekOffset = firstWeekOffset(year, dow, doy),\n\t            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n\t        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('w', ['ww', 2], 'wo', 'week');\n\t    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('week', 'w');\n\t    addUnitAlias('isoWeek', 'W');\n\t\n\t    // PRIORITIES\n\t\n\t    addUnitPriority('week', 5);\n\t    addUnitPriority('isoWeek', 5);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('w',  match1to2);\n\t    addRegexToken('ww', match1to2, match2);\n\t    addRegexToken('W',  match1to2);\n\t    addRegexToken('WW', match1to2, match2);\n\t\n\t    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n\t        week[token.substr(0, 1)] = toInt(input);\n\t    });\n\t\n\t    // HELPERS\n\t\n\t    // LOCALES\n\t\n\t    function localeWeek (mom) {\n\t        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n\t    }\n\t\n\t    var defaultLocaleWeek = {\n\t        dow : 0, // Sunday is the first day of the week.\n\t        doy : 6  // The week that contains Jan 6th is the first week of the year.\n\t    };\n\t\n\t    function localeFirstDayOfWeek () {\n\t        return this._week.dow;\n\t    }\n\t\n\t    function localeFirstDayOfYear () {\n\t        return this._week.doy;\n\t    }\n\t\n\t    // MOMENTS\n\t\n\t    function getSetWeek (input) {\n\t        var week = this.localeData().week(this);\n\t        return input == null ? week : this.add((input - week) * 7, 'd');\n\t    }\n\t\n\t    function getSetISOWeek (input) {\n\t        var week = weekOfYear(this, 1, 4).week;\n\t        return input == null ? week : this.add((input - week) * 7, 'd');\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('d', 0, 'do', 'day');\n\t\n\t    addFormatToken('dd', 0, 0, function (format) {\n\t        return this.localeData().weekdaysMin(this, format);\n\t    });\n\t\n\t    addFormatToken('ddd', 0, 0, function (format) {\n\t        return this.localeData().weekdaysShort(this, format);\n\t    });\n\t\n\t    addFormatToken('dddd', 0, 0, function (format) {\n\t        return this.localeData().weekdays(this, format);\n\t    });\n\t\n\t    addFormatToken('e', 0, 0, 'weekday');\n\t    addFormatToken('E', 0, 0, 'isoWeekday');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('day', 'd');\n\t    addUnitAlias('weekday', 'e');\n\t    addUnitAlias('isoWeekday', 'E');\n\t\n\t    // PRIORITY\n\t    addUnitPriority('day', 11);\n\t    addUnitPriority('weekday', 11);\n\t    addUnitPriority('isoWeekday', 11);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('d',    match1to2);\n\t    addRegexToken('e',    match1to2);\n\t    addRegexToken('E',    match1to2);\n\t    addRegexToken('dd',   function (isStrict, locale) {\n\t        return locale.weekdaysMinRegex(isStrict);\n\t    });\n\t    addRegexToken('ddd',   function (isStrict, locale) {\n\t        return locale.weekdaysShortRegex(isStrict);\n\t    });\n\t    addRegexToken('dddd',   function (isStrict, locale) {\n\t        return locale.weekdaysRegex(isStrict);\n\t    });\n\t\n\t    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n\t        var weekday = config._locale.weekdaysParse(input, token, config._strict);\n\t        // if we didn't get a weekday name, mark the date as invalid\n\t        if (weekday != null) {\n\t            week.d = weekday;\n\t        } else {\n\t            getParsingFlags(config).invalidWeekday = input;\n\t        }\n\t    });\n\t\n\t    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n\t        week[token] = toInt(input);\n\t    });\n\t\n\t    // HELPERS\n\t\n\t    function parseWeekday(input, locale) {\n\t        if (typeof input !== 'string') {\n\t            return input;\n\t        }\n\t\n\t        if (!isNaN(input)) {\n\t            return parseInt(input, 10);\n\t        }\n\t\n\t        input = locale.weekdaysParse(input);\n\t        if (typeof input === 'number') {\n\t            return input;\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    function parseIsoWeekday(input, locale) {\n\t        if (typeof input === 'string') {\n\t            return locale.weekdaysParse(input) % 7 || 7;\n\t        }\n\t        return isNaN(input) ? null : input;\n\t    }\n\t\n\t    // LOCALES\n\t    function shiftWeekdays (ws, n) {\n\t        return ws.slice(n, 7).concat(ws.slice(0, n));\n\t    }\n\t\n\t    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\n\t    function localeWeekdays (m, format) {\n\t        var weekdays = isArray(this._weekdays) ? this._weekdays :\n\t            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];\n\t        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)\n\t            : (m) ? weekdays[m.day()] : weekdays;\n\t    }\n\t\n\t    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\n\t    function localeWeekdaysShort (m) {\n\t        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)\n\t            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n\t    }\n\t\n\t    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\n\t    function localeWeekdaysMin (m) {\n\t        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)\n\t            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n\t    }\n\t\n\t    function handleStrictParse$1(weekdayName, format, strict) {\n\t        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n\t        if (!this._weekdaysParse) {\n\t            this._weekdaysParse = [];\n\t            this._shortWeekdaysParse = [];\n\t            this._minWeekdaysParse = [];\n\t\n\t            for (i = 0; i < 7; ++i) {\n\t                mom = createUTC([2000, 1]).day(i);\n\t                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n\t                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n\t                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n\t            }\n\t        }\n\t\n\t        if (strict) {\n\t            if (format === 'dddd') {\n\t                ii = indexOf.call(this._weekdaysParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            } else if (format === 'ddd') {\n\t                ii = indexOf.call(this._shortWeekdaysParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            } else {\n\t                ii = indexOf.call(this._minWeekdaysParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            }\n\t        } else {\n\t            if (format === 'dddd') {\n\t                ii = indexOf.call(this._weekdaysParse, llc);\n\t                if (ii !== -1) {\n\t                    return ii;\n\t                }\n\t                ii = indexOf.call(this._shortWeekdaysParse, llc);\n\t                if (ii !== -1) {\n\t                    return ii;\n\t                }\n\t                ii = indexOf.call(this._minWeekdaysParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            } else if (format === 'ddd') {\n\t                ii = indexOf.call(this._shortWeekdaysParse, llc);\n\t                if (ii !== -1) {\n\t                    return ii;\n\t                }\n\t                ii = indexOf.call(this._weekdaysParse, llc);\n\t                if (ii !== -1) {\n\t                    return ii;\n\t                }\n\t                ii = indexOf.call(this._minWeekdaysParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            } else {\n\t                ii = indexOf.call(this._minWeekdaysParse, llc);\n\t                if (ii !== -1) {\n\t                    return ii;\n\t                }\n\t                ii = indexOf.call(this._weekdaysParse, llc);\n\t                if (ii !== -1) {\n\t                    return ii;\n\t                }\n\t                ii = indexOf.call(this._shortWeekdaysParse, llc);\n\t                return ii !== -1 ? ii : null;\n\t            }\n\t        }\n\t    }\n\t\n\t    function localeWeekdaysParse (weekdayName, format, strict) {\n\t        var i, mom, regex;\n\t\n\t        if (this._weekdaysParseExact) {\n\t            return handleStrictParse$1.call(this, weekdayName, format, strict);\n\t        }\n\t\n\t        if (!this._weekdaysParse) {\n\t            this._weekdaysParse = [];\n\t            this._minWeekdaysParse = [];\n\t            this._shortWeekdaysParse = [];\n\t            this._fullWeekdaysParse = [];\n\t        }\n\t\n\t        for (i = 0; i < 7; i++) {\n\t            // make the regex if we don't have it already\n\t\n\t            mom = createUTC([2000, 1]).day(i);\n\t            if (strict && !this._fullWeekdaysParse[i]) {\n\t                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\\\.?') + '$', 'i');\n\t                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\\\.?') + '$', 'i');\n\t                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\\\.?') + '$', 'i');\n\t            }\n\t            if (!this._weekdaysParse[i]) {\n\t                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n\t                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n\t            }\n\t            // test the regex\n\t            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n\t                return i;\n\t            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n\t                return i;\n\t            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n\t                return i;\n\t            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n\t                return i;\n\t            }\n\t        }\n\t    }\n\t\n\t    // MOMENTS\n\t\n\t    function getSetDayOfWeek (input) {\n\t        if (!this.isValid()) {\n\t            return input != null ? this : NaN;\n\t        }\n\t        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n\t        if (input != null) {\n\t            input = parseWeekday(input, this.localeData());\n\t            return this.add(input - day, 'd');\n\t        } else {\n\t            return day;\n\t        }\n\t    }\n\t\n\t    function getSetLocaleDayOfWeek (input) {\n\t        if (!this.isValid()) {\n\t            return input != null ? this : NaN;\n\t        }\n\t        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n\t        return input == null ? weekday : this.add(input - weekday, 'd');\n\t    }\n\t\n\t    function getSetISODayOfWeek (input) {\n\t        if (!this.isValid()) {\n\t            return input != null ? this : NaN;\n\t        }\n\t\n\t        // behaves the same as moment#day except\n\t        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n\t        // as a setter, sunday should belong to the previous week.\n\t\n\t        if (input != null) {\n\t            var weekday = parseIsoWeekday(input, this.localeData());\n\t            return this.day(this.day() % 7 ? weekday : weekday - 7);\n\t        } else {\n\t            return this.day() || 7;\n\t        }\n\t    }\n\t\n\t    var defaultWeekdaysRegex = matchWord;\n\t    function weekdaysRegex (isStrict) {\n\t        if (this._weekdaysParseExact) {\n\t            if (!hasOwnProp(this, '_weekdaysRegex')) {\n\t                computeWeekdaysParse.call(this);\n\t            }\n\t            if (isStrict) {\n\t                return this._weekdaysStrictRegex;\n\t            } else {\n\t                return this._weekdaysRegex;\n\t            }\n\t        } else {\n\t            if (!hasOwnProp(this, '_weekdaysRegex')) {\n\t                this._weekdaysRegex = defaultWeekdaysRegex;\n\t            }\n\t            return this._weekdaysStrictRegex && isStrict ?\n\t                this._weekdaysStrictRegex : this._weekdaysRegex;\n\t        }\n\t    }\n\t\n\t    var defaultWeekdaysShortRegex = matchWord;\n\t    function weekdaysShortRegex (isStrict) {\n\t        if (this._weekdaysParseExact) {\n\t            if (!hasOwnProp(this, '_weekdaysRegex')) {\n\t                computeWeekdaysParse.call(this);\n\t            }\n\t            if (isStrict) {\n\t                return this._weekdaysShortStrictRegex;\n\t            } else {\n\t                return this._weekdaysShortRegex;\n\t            }\n\t        } else {\n\t            if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n\t                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n\t            }\n\t            return this._weekdaysShortStrictRegex && isStrict ?\n\t                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n\t        }\n\t    }\n\t\n\t    var defaultWeekdaysMinRegex = matchWord;\n\t    function weekdaysMinRegex (isStrict) {\n\t        if (this._weekdaysParseExact) {\n\t            if (!hasOwnProp(this, '_weekdaysRegex')) {\n\t                computeWeekdaysParse.call(this);\n\t            }\n\t            if (isStrict) {\n\t                return this._weekdaysMinStrictRegex;\n\t            } else {\n\t                return this._weekdaysMinRegex;\n\t            }\n\t        } else {\n\t            if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n\t                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n\t            }\n\t            return this._weekdaysMinStrictRegex && isStrict ?\n\t                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n\t        }\n\t    }\n\t\n\t\n\t    function computeWeekdaysParse () {\n\t        function cmpLenRev(a, b) {\n\t            return b.length - a.length;\n\t        }\n\t\n\t        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\n\t            i, mom, minp, shortp, longp;\n\t        for (i = 0; i < 7; i++) {\n\t            // make the regex if we don't have it already\n\t            mom = createUTC([2000, 1]).day(i);\n\t            minp = this.weekdaysMin(mom, '');\n\t            shortp = this.weekdaysShort(mom, '');\n\t            longp = this.weekdays(mom, '');\n\t            minPieces.push(minp);\n\t            shortPieces.push(shortp);\n\t            longPieces.push(longp);\n\t            mixedPieces.push(minp);\n\t            mixedPieces.push(shortp);\n\t            mixedPieces.push(longp);\n\t        }\n\t        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n\t        // will match the longer piece.\n\t        minPieces.sort(cmpLenRev);\n\t        shortPieces.sort(cmpLenRev);\n\t        longPieces.sort(cmpLenRev);\n\t        mixedPieces.sort(cmpLenRev);\n\t        for (i = 0; i < 7; i++) {\n\t            shortPieces[i] = regexEscape(shortPieces[i]);\n\t            longPieces[i] = regexEscape(longPieces[i]);\n\t            mixedPieces[i] = regexEscape(mixedPieces[i]);\n\t        }\n\t\n\t        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n\t        this._weekdaysShortRegex = this._weekdaysRegex;\n\t        this._weekdaysMinRegex = this._weekdaysRegex;\n\t\n\t        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n\t        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n\t        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    function hFormat() {\n\t        return this.hours() % 12 || 12;\n\t    }\n\t\n\t    function kFormat() {\n\t        return this.hours() || 24;\n\t    }\n\t\n\t    addFormatToken('H', ['HH', 2], 0, 'hour');\n\t    addFormatToken('h', ['hh', 2], 0, hFormat);\n\t    addFormatToken('k', ['kk', 2], 0, kFormat);\n\t\n\t    addFormatToken('hmm', 0, 0, function () {\n\t        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n\t    });\n\t\n\t    addFormatToken('hmmss', 0, 0, function () {\n\t        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\n\t            zeroFill(this.seconds(), 2);\n\t    });\n\t\n\t    addFormatToken('Hmm', 0, 0, function () {\n\t        return '' + this.hours() + zeroFill(this.minutes(), 2);\n\t    });\n\t\n\t    addFormatToken('Hmmss', 0, 0, function () {\n\t        return '' + this.hours() + zeroFill(this.minutes(), 2) +\n\t            zeroFill(this.seconds(), 2);\n\t    });\n\t\n\t    function meridiem (token, lowercase) {\n\t        addFormatToken(token, 0, 0, function () {\n\t            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n\t        });\n\t    }\n\t\n\t    meridiem('a', true);\n\t    meridiem('A', false);\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('hour', 'h');\n\t\n\t    // PRIORITY\n\t    addUnitPriority('hour', 13);\n\t\n\t    // PARSING\n\t\n\t    function matchMeridiem (isStrict, locale) {\n\t        return locale._meridiemParse;\n\t    }\n\t\n\t    addRegexToken('a',  matchMeridiem);\n\t    addRegexToken('A',  matchMeridiem);\n\t    addRegexToken('H',  match1to2);\n\t    addRegexToken('h',  match1to2);\n\t    addRegexToken('k',  match1to2);\n\t    addRegexToken('HH', match1to2, match2);\n\t    addRegexToken('hh', match1to2, match2);\n\t    addRegexToken('kk', match1to2, match2);\n\t\n\t    addRegexToken('hmm', match3to4);\n\t    addRegexToken('hmmss', match5to6);\n\t    addRegexToken('Hmm', match3to4);\n\t    addRegexToken('Hmmss', match5to6);\n\t\n\t    addParseToken(['H', 'HH'], HOUR);\n\t    addParseToken(['k', 'kk'], function (input, array, config) {\n\t        var kInput = toInt(input);\n\t        array[HOUR] = kInput === 24 ? 0 : kInput;\n\t    });\n\t    addParseToken(['a', 'A'], function (input, array, config) {\n\t        config._isPm = config._locale.isPM(input);\n\t        config._meridiem = input;\n\t    });\n\t    addParseToken(['h', 'hh'], function (input, array, config) {\n\t        array[HOUR] = toInt(input);\n\t        getParsingFlags(config).bigHour = true;\n\t    });\n\t    addParseToken('hmm', function (input, array, config) {\n\t        var pos = input.length - 2;\n\t        array[HOUR] = toInt(input.substr(0, pos));\n\t        array[MINUTE] = toInt(input.substr(pos));\n\t        getParsingFlags(config).bigHour = true;\n\t    });\n\t    addParseToken('hmmss', function (input, array, config) {\n\t        var pos1 = input.length - 4;\n\t        var pos2 = input.length - 2;\n\t        array[HOUR] = toInt(input.substr(0, pos1));\n\t        array[MINUTE] = toInt(input.substr(pos1, 2));\n\t        array[SECOND] = toInt(input.substr(pos2));\n\t        getParsingFlags(config).bigHour = true;\n\t    });\n\t    addParseToken('Hmm', function (input, array, config) {\n\t        var pos = input.length - 2;\n\t        array[HOUR] = toInt(input.substr(0, pos));\n\t        array[MINUTE] = toInt(input.substr(pos));\n\t    });\n\t    addParseToken('Hmmss', function (input, array, config) {\n\t        var pos1 = input.length - 4;\n\t        var pos2 = input.length - 2;\n\t        array[HOUR] = toInt(input.substr(0, pos1));\n\t        array[MINUTE] = toInt(input.substr(pos1, 2));\n\t        array[SECOND] = toInt(input.substr(pos2));\n\t    });\n\t\n\t    // LOCALES\n\t\n\t    function localeIsPM (input) {\n\t        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n\t        // Using charAt should be more compatible.\n\t        return ((input + '').toLowerCase().charAt(0) === 'p');\n\t    }\n\t\n\t    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\n\t    function localeMeridiem (hours, minutes, isLower) {\n\t        if (hours > 11) {\n\t            return isLower ? 'pm' : 'PM';\n\t        } else {\n\t            return isLower ? 'am' : 'AM';\n\t        }\n\t    }\n\t\n\t\n\t    // MOMENTS\n\t\n\t    // Setting the hour should keep the time, because the user explicitly\n\t    // specified which hour they want. So trying to maintain the same hour (in\n\t    // a new timezone) makes sense. Adding/subtracting hours does not follow\n\t    // this rule.\n\t    var getSetHour = makeGetSet('Hours', true);\n\t\n\t    var baseConfig = {\n\t        calendar: defaultCalendar,\n\t        longDateFormat: defaultLongDateFormat,\n\t        invalidDate: defaultInvalidDate,\n\t        ordinal: defaultOrdinal,\n\t        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n\t        relativeTime: defaultRelativeTime,\n\t\n\t        months: defaultLocaleMonths,\n\t        monthsShort: defaultLocaleMonthsShort,\n\t\n\t        week: defaultLocaleWeek,\n\t\n\t        weekdays: defaultLocaleWeekdays,\n\t        weekdaysMin: defaultLocaleWeekdaysMin,\n\t        weekdaysShort: defaultLocaleWeekdaysShort,\n\t\n\t        meridiemParse: defaultLocaleMeridiemParse\n\t    };\n\t\n\t    // internal storage for locale config files\n\t    var locales = {};\n\t    var localeFamilies = {};\n\t    var globalLocale;\n\t\n\t    function normalizeLocale(key) {\n\t        return key ? key.toLowerCase().replace('_', '-') : key;\n\t    }\n\t\n\t    // pick the locale from the array\n\t    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n\t    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n\t    function chooseLocale(names) {\n\t        var i = 0, j, next, locale, split;\n\t\n\t        while (i < names.length) {\n\t            split = normalizeLocale(names[i]).split('-');\n\t            j = split.length;\n\t            next = normalizeLocale(names[i + 1]);\n\t            next = next ? next.split('-') : null;\n\t            while (j > 0) {\n\t                locale = loadLocale(split.slice(0, j).join('-'));\n\t                if (locale) {\n\t                    return locale;\n\t                }\n\t                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n\t                    //the next array item is better than a shallower substring of this one\n\t                    break;\n\t                }\n\t                j--;\n\t            }\n\t            i++;\n\t        }\n\t        return globalLocale;\n\t    }\n\t\n\t    function loadLocale(name) {\n\t        var oldLocale = null;\n\t        // TODO: Find a better way to register and load all the locales in Node\n\t        if (!locales[name] && (typeof module !== 'undefined') &&\n\t                module && module.exports) {\n\t            try {\n\t                oldLocale = globalLocale._abbr;\n\t                var aliasedRequire = require;\n\t                !(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"./locale\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n\t                getSetGlobalLocale(oldLocale);\n\t            } catch (e) {}\n\t        }\n\t        return locales[name];\n\t    }\n\t\n\t    // This function will load locale and then set the global locale.  If\n\t    // no arguments are passed in, it will simply return the current global\n\t    // locale key.\n\t    function getSetGlobalLocale (key, values) {\n\t        var data;\n\t        if (key) {\n\t            if (isUndefined(values)) {\n\t                data = getLocale(key);\n\t            }\n\t            else {\n\t                data = defineLocale(key, values);\n\t            }\n\t\n\t            if (data) {\n\t                // moment.duration._locale = moment._locale = data;\n\t                globalLocale = data;\n\t            }\n\t            else {\n\t                if ((typeof console !==  'undefined') && console.warn) {\n\t                    //warn user if arguments are passed but the locale could not be set\n\t                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');\n\t                }\n\t            }\n\t        }\n\t\n\t        return globalLocale._abbr;\n\t    }\n\t\n\t    function defineLocale (name, config) {\n\t        if (config !== null) {\n\t            var locale, parentConfig = baseConfig;\n\t            config.abbr = name;\n\t            if (locales[name] != null) {\n\t                deprecateSimple('defineLocaleOverride',\n\t                        'use moment.updateLocale(localeName, config) to change ' +\n\t                        'an existing locale. moment.defineLocale(localeName, ' +\n\t                        'config) should only be used for creating a new locale ' +\n\t                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n\t                parentConfig = locales[name]._config;\n\t            } else if (config.parentLocale != null) {\n\t                if (locales[config.parentLocale] != null) {\n\t                    parentConfig = locales[config.parentLocale]._config;\n\t                } else {\n\t                    locale = loadLocale(config.parentLocale);\n\t                    if (locale != null) {\n\t                        parentConfig = locale._config;\n\t                    } else {\n\t                        if (!localeFamilies[config.parentLocale]) {\n\t                            localeFamilies[config.parentLocale] = [];\n\t                        }\n\t                        localeFamilies[config.parentLocale].push({\n\t                            name: name,\n\t                            config: config\n\t                        });\n\t                        return null;\n\t                    }\n\t                }\n\t            }\n\t            locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\t\n\t            if (localeFamilies[name]) {\n\t                localeFamilies[name].forEach(function (x) {\n\t                    defineLocale(x.name, x.config);\n\t                });\n\t            }\n\t\n\t            // backwards compat for now: also set the locale\n\t            // make sure we set the locale AFTER all child locales have been\n\t            // created, so we won't end up with the child locale set.\n\t            getSetGlobalLocale(name);\n\t\n\t\n\t            return locales[name];\n\t        } else {\n\t            // useful for testing\n\t            delete locales[name];\n\t            return null;\n\t        }\n\t    }\n\t\n\t    function updateLocale(name, config) {\n\t        if (config != null) {\n\t            var locale, tmpLocale, parentConfig = baseConfig;\n\t            // MERGE\n\t            tmpLocale = loadLocale(name);\n\t            if (tmpLocale != null) {\n\t                parentConfig = tmpLocale._config;\n\t            }\n\t            config = mergeConfigs(parentConfig, config);\n\t            locale = new Locale(config);\n\t            locale.parentLocale = locales[name];\n\t            locales[name] = locale;\n\t\n\t            // backwards compat for now: also set the locale\n\t            getSetGlobalLocale(name);\n\t        } else {\n\t            // pass null for config to unupdate, useful for tests\n\t            if (locales[name] != null) {\n\t                if (locales[name].parentLocale != null) {\n\t                    locales[name] = locales[name].parentLocale;\n\t                } else if (locales[name] != null) {\n\t                    delete locales[name];\n\t                }\n\t            }\n\t        }\n\t        return locales[name];\n\t    }\n\t\n\t    // returns locale data\n\t    function getLocale (key) {\n\t        var locale;\n\t\n\t        if (key && key._locale && key._locale._abbr) {\n\t            key = key._locale._abbr;\n\t        }\n\t\n\t        if (!key) {\n\t            return globalLocale;\n\t        }\n\t\n\t        if (!isArray(key)) {\n\t            //short-circuit everything else\n\t            locale = loadLocale(key);\n\t            if (locale) {\n\t                return locale;\n\t            }\n\t            key = [key];\n\t        }\n\t\n\t        return chooseLocale(key);\n\t    }\n\t\n\t    function listLocales() {\n\t        return keys(locales);\n\t    }\n\t\n\t    function checkOverflow (m) {\n\t        var overflow;\n\t        var a = m._a;\n\t\n\t        if (a && getParsingFlags(m).overflow === -2) {\n\t            overflow =\n\t                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n\t                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n\t                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n\t                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n\t                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n\t                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n\t                -1;\n\t\n\t            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n\t                overflow = DATE;\n\t            }\n\t            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n\t                overflow = WEEK;\n\t            }\n\t            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n\t                overflow = WEEKDAY;\n\t            }\n\t\n\t            getParsingFlags(m).overflow = overflow;\n\t        }\n\t\n\t        return m;\n\t    }\n\t\n\t    // Pick the first defined of two or three arguments.\n\t    function defaults(a, b, c) {\n\t        if (a != null) {\n\t            return a;\n\t        }\n\t        if (b != null) {\n\t            return b;\n\t        }\n\t        return c;\n\t    }\n\t\n\t    function currentDateArray(config) {\n\t        // hooks is actually the exported moment object\n\t        var nowValue = new Date(hooks.now());\n\t        if (config._useUTC) {\n\t            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n\t        }\n\t        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n\t    }\n\t\n\t    // convert an array to a date.\n\t    // the array should mirror the parameters below\n\t    // note: all values past the year are optional and will default to the lowest possible value.\n\t    // [year, month, day , hour, minute, second, millisecond]\n\t    function configFromArray (config) {\n\t        var i, date, input = [], currentDate, expectedWeekday, yearToUse;\n\t\n\t        if (config._d) {\n\t            return;\n\t        }\n\t\n\t        currentDate = currentDateArray(config);\n\t\n\t        //compute day of the year from weeks and weekdays\n\t        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n\t            dayOfYearFromWeekInfo(config);\n\t        }\n\t\n\t        //if the day of the year is set, figure out what it is\n\t        if (config._dayOfYear != null) {\n\t            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\t\n\t            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n\t                getParsingFlags(config)._overflowDayOfYear = true;\n\t            }\n\t\n\t            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n\t            config._a[MONTH] = date.getUTCMonth();\n\t            config._a[DATE] = date.getUTCDate();\n\t        }\n\t\n\t        // Default to current date.\n\t        // * if no year, month, day of month are given, default to today\n\t        // * if day of month is given, default month and year\n\t        // * if month is given, default only year\n\t        // * if year is given, don't default anything\n\t        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n\t            config._a[i] = input[i] = currentDate[i];\n\t        }\n\t\n\t        // Zero out whatever was not defaulted, including time\n\t        for (; i < 7; i++) {\n\t            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n\t        }\n\t\n\t        // Check for 24:00:00.000\n\t        if (config._a[HOUR] === 24 &&\n\t                config._a[MINUTE] === 0 &&\n\t                config._a[SECOND] === 0 &&\n\t                config._a[MILLISECOND] === 0) {\n\t            config._nextDay = true;\n\t            config._a[HOUR] = 0;\n\t        }\n\t\n\t        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n\t        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\n\t\n\t        // Apply timezone offset from input. The actual utcOffset can be changed\n\t        // with parseZone.\n\t        if (config._tzm != null) {\n\t            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\t        }\n\t\n\t        if (config._nextDay) {\n\t            config._a[HOUR] = 24;\n\t        }\n\t\n\t        // check for mismatching day of week\n\t        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {\n\t            getParsingFlags(config).weekdayMismatch = true;\n\t        }\n\t    }\n\t\n\t    function dayOfYearFromWeekInfo(config) {\n\t        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\n\t\n\t        w = config._w;\n\t        if (w.GG != null || w.W != null || w.E != null) {\n\t            dow = 1;\n\t            doy = 4;\n\t\n\t            // TODO: We need to take the current isoWeekYear, but that depends on\n\t            // how we interpret now (local, utc, fixed offset). So create\n\t            // a now version of current config (take local/utc/offset flags, and\n\t            // create now).\n\t            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n\t            week = defaults(w.W, 1);\n\t            weekday = defaults(w.E, 1);\n\t            if (weekday < 1 || weekday > 7) {\n\t                weekdayOverflow = true;\n\t            }\n\t        } else {\n\t            dow = config._locale._week.dow;\n\t            doy = config._locale._week.doy;\n\t\n\t            var curWeek = weekOfYear(createLocal(), dow, doy);\n\t\n\t            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\t\n\t            // Default to current week.\n\t            week = defaults(w.w, curWeek.week);\n\t\n\t            if (w.d != null) {\n\t                // weekday -- low day numbers are considered next week\n\t                weekday = w.d;\n\t                if (weekday < 0 || weekday > 6) {\n\t                    weekdayOverflow = true;\n\t                }\n\t            } else if (w.e != null) {\n\t                // local weekday -- counting starts from beginning of week\n\t                weekday = w.e + dow;\n\t                if (w.e < 0 || w.e > 6) {\n\t                    weekdayOverflow = true;\n\t                }\n\t            } else {\n\t                // default to beginning of week\n\t                weekday = dow;\n\t            }\n\t        }\n\t        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n\t            getParsingFlags(config)._overflowWeeks = true;\n\t        } else if (weekdayOverflow != null) {\n\t            getParsingFlags(config)._overflowWeekday = true;\n\t        } else {\n\t            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n\t            config._a[YEAR] = temp.year;\n\t            config._dayOfYear = temp.dayOfYear;\n\t        }\n\t    }\n\t\n\t    // iso 8601 regex\n\t    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n\t    var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\t    var basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\t\n\t    var tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\n\t\n\t    var isoDates = [\n\t        ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n\t        ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n\t        ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n\t        ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n\t        ['YYYY-DDD', /\\d{4}-\\d{3}/],\n\t        ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n\t        ['YYYYYYMMDD', /[+-]\\d{10}/],\n\t        ['YYYYMMDD', /\\d{8}/],\n\t        // YYYYMM is NOT allowed by the standard\n\t        ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n\t        ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n\t        ['YYYYDDD', /\\d{7}/]\n\t    ];\n\t\n\t    // iso time formats and regexes\n\t    var isoTimes = [\n\t        ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n\t        ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n\t        ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n\t        ['HH:mm', /\\d\\d:\\d\\d/],\n\t        ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n\t        ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n\t        ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n\t        ['HHmm', /\\d\\d\\d\\d/],\n\t        ['HH', /\\d\\d/]\n\t    ];\n\t\n\t    var aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\t\n\t    // date from iso format\n\t    function configFromISO(config) {\n\t        var i, l,\n\t            string = config._i,\n\t            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n\t            allowTime, dateFormat, timeFormat, tzFormat;\n\t\n\t        if (match) {\n\t            getParsingFlags(config).iso = true;\n\t\n\t            for (i = 0, l = isoDates.length; i < l; i++) {\n\t                if (isoDates[i][1].exec(match[1])) {\n\t                    dateFormat = isoDates[i][0];\n\t                    allowTime = isoDates[i][2] !== false;\n\t                    break;\n\t                }\n\t            }\n\t            if (dateFormat == null) {\n\t                config._isValid = false;\n\t                return;\n\t            }\n\t            if (match[3]) {\n\t                for (i = 0, l = isoTimes.length; i < l; i++) {\n\t                    if (isoTimes[i][1].exec(match[3])) {\n\t                        // match[2] should be 'T' or space\n\t                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\n\t                        break;\n\t                    }\n\t                }\n\t                if (timeFormat == null) {\n\t                    config._isValid = false;\n\t                    return;\n\t                }\n\t            }\n\t            if (!allowTime && timeFormat != null) {\n\t                config._isValid = false;\n\t                return;\n\t            }\n\t            if (match[4]) {\n\t                if (tzRegex.exec(match[4])) {\n\t                    tzFormat = 'Z';\n\t                } else {\n\t                    config._isValid = false;\n\t                    return;\n\t                }\n\t            }\n\t            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n\t            configFromStringAndFormat(config);\n\t        } else {\n\t            config._isValid = false;\n\t        }\n\t    }\n\t\n\t    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n\t    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/;\n\t\n\t    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n\t        var result = [\n\t            untruncateYear(yearStr),\n\t            defaultLocaleMonthsShort.indexOf(monthStr),\n\t            parseInt(dayStr, 10),\n\t            parseInt(hourStr, 10),\n\t            parseInt(minuteStr, 10)\n\t        ];\n\t\n\t        if (secondStr) {\n\t            result.push(parseInt(secondStr, 10));\n\t        }\n\t\n\t        return result;\n\t    }\n\t\n\t    function untruncateYear(yearStr) {\n\t        var year = parseInt(yearStr, 10);\n\t        if (year <= 49) {\n\t            return 2000 + year;\n\t        } else if (year <= 999) {\n\t            return 1900 + year;\n\t        }\n\t        return year;\n\t    }\n\t\n\t    function preprocessRFC2822(s) {\n\t        // Remove comments and folding whitespace and replace multiple-spaces with a single space\n\t        return s.replace(/\\([^)]*\\)|[\\n\\t]/g, ' ').replace(/(\\s\\s+)/g, ' ').replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n\t    }\n\t\n\t    function checkWeekday(weekdayStr, parsedInput, config) {\n\t        if (weekdayStr) {\n\t            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.\n\t            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n\t                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\n\t            if (weekdayProvided !== weekdayActual) {\n\t                getParsingFlags(config).weekdayMismatch = true;\n\t                config._isValid = false;\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    var obsOffsets = {\n\t        UT: 0,\n\t        GMT: 0,\n\t        EDT: -4 * 60,\n\t        EST: -5 * 60,\n\t        CDT: -5 * 60,\n\t        CST: -6 * 60,\n\t        MDT: -6 * 60,\n\t        MST: -7 * 60,\n\t        PDT: -7 * 60,\n\t        PST: -8 * 60\n\t    };\n\t\n\t    function calculateOffset(obsOffset, militaryOffset, numOffset) {\n\t        if (obsOffset) {\n\t            return obsOffsets[obsOffset];\n\t        } else if (militaryOffset) {\n\t            // the only allowed military tz is Z\n\t            return 0;\n\t        } else {\n\t            var hm = parseInt(numOffset, 10);\n\t            var m = hm % 100, h = (hm - m) / 100;\n\t            return h * 60 + m;\n\t        }\n\t    }\n\t\n\t    // date and time from ref 2822 format\n\t    function configFromRFC2822(config) {\n\t        var match = rfc2822.exec(preprocessRFC2822(config._i));\n\t        if (match) {\n\t            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\n\t            if (!checkWeekday(match[1], parsedArray, config)) {\n\t                return;\n\t            }\n\t\n\t            config._a = parsedArray;\n\t            config._tzm = calculateOffset(match[8], match[9], match[10]);\n\t\n\t            config._d = createUTCDate.apply(null, config._a);\n\t            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\t\n\t            getParsingFlags(config).rfc2822 = true;\n\t        } else {\n\t            config._isValid = false;\n\t        }\n\t    }\n\t\n\t    // date from iso format or fallback\n\t    function configFromString(config) {\n\t        var matched = aspNetJsonRegex.exec(config._i);\n\t\n\t        if (matched !== null) {\n\t            config._d = new Date(+matched[1]);\n\t            return;\n\t        }\n\t\n\t        configFromISO(config);\n\t        if (config._isValid === false) {\n\t            delete config._isValid;\n\t        } else {\n\t            return;\n\t        }\n\t\n\t        configFromRFC2822(config);\n\t        if (config._isValid === false) {\n\t            delete config._isValid;\n\t        } else {\n\t            return;\n\t        }\n\t\n\t        // Final attempt, use Input Fallback\n\t        hooks.createFromInputFallback(config);\n\t    }\n\t\n\t    hooks.createFromInputFallback = deprecate(\n\t        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n\t        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n\t        'discouraged and will be removed in an upcoming major release. Please refer to ' +\n\t        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n\t        function (config) {\n\t            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n\t        }\n\t    );\n\t\n\t    // constant that refers to the ISO standard\n\t    hooks.ISO_8601 = function () {};\n\t\n\t    // constant that refers to the RFC 2822 form\n\t    hooks.RFC_2822 = function () {};\n\t\n\t    // date from string and format string\n\t    function configFromStringAndFormat(config) {\n\t        // TODO: Move this to another part of the creation flow to prevent circular deps\n\t        if (config._f === hooks.ISO_8601) {\n\t            configFromISO(config);\n\t            return;\n\t        }\n\t        if (config._f === hooks.RFC_2822) {\n\t            configFromRFC2822(config);\n\t            return;\n\t        }\n\t        config._a = [];\n\t        getParsingFlags(config).empty = true;\n\t\n\t        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n\t        var string = '' + config._i,\n\t            i, parsedInput, tokens, token, skipped,\n\t            stringLength = string.length,\n\t            totalParsedInputLength = 0;\n\t\n\t        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\t\n\t        for (i = 0; i < tokens.length; i++) {\n\t            token = tokens[i];\n\t            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n\t            // console.log('token', token, 'parsedInput', parsedInput,\n\t            //         'regex', getParseRegexForToken(token, config));\n\t            if (parsedInput) {\n\t                skipped = string.substr(0, string.indexOf(parsedInput));\n\t                if (skipped.length > 0) {\n\t                    getParsingFlags(config).unusedInput.push(skipped);\n\t                }\n\t                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n\t                totalParsedInputLength += parsedInput.length;\n\t            }\n\t            // don't parse if it's not a known token\n\t            if (formatTokenFunctions[token]) {\n\t                if (parsedInput) {\n\t                    getParsingFlags(config).empty = false;\n\t                }\n\t                else {\n\t                    getParsingFlags(config).unusedTokens.push(token);\n\t                }\n\t                addTimeToArrayFromToken(token, parsedInput, config);\n\t            }\n\t            else if (config._strict && !parsedInput) {\n\t                getParsingFlags(config).unusedTokens.push(token);\n\t            }\n\t        }\n\t\n\t        // add remaining unparsed input length to the string\n\t        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n\t        if (string.length > 0) {\n\t            getParsingFlags(config).unusedInput.push(string);\n\t        }\n\t\n\t        // clear _12h flag if hour is <= 12\n\t        if (config._a[HOUR] <= 12 &&\n\t            getParsingFlags(config).bigHour === true &&\n\t            config._a[HOUR] > 0) {\n\t            getParsingFlags(config).bigHour = undefined;\n\t        }\n\t\n\t        getParsingFlags(config).parsedDateParts = config._a.slice(0);\n\t        getParsingFlags(config).meridiem = config._meridiem;\n\t        // handle meridiem\n\t        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\t\n\t        configFromArray(config);\n\t        checkOverflow(config);\n\t    }\n\t\n\t\n\t    function meridiemFixWrap (locale, hour, meridiem) {\n\t        var isPm;\n\t\n\t        if (meridiem == null) {\n\t            // nothing to do\n\t            return hour;\n\t        }\n\t        if (locale.meridiemHour != null) {\n\t            return locale.meridiemHour(hour, meridiem);\n\t        } else if (locale.isPM != null) {\n\t            // Fallback\n\t            isPm = locale.isPM(meridiem);\n\t            if (isPm && hour < 12) {\n\t                hour += 12;\n\t            }\n\t            if (!isPm && hour === 12) {\n\t                hour = 0;\n\t            }\n\t            return hour;\n\t        } else {\n\t            // this is not supposed to happen\n\t            return hour;\n\t        }\n\t    }\n\t\n\t    // date from string and array of format strings\n\t    function configFromStringAndArray(config) {\n\t        var tempConfig,\n\t            bestMoment,\n\t\n\t            scoreToBeat,\n\t            i,\n\t            currentScore;\n\t\n\t        if (config._f.length === 0) {\n\t            getParsingFlags(config).invalidFormat = true;\n\t            config._d = new Date(NaN);\n\t            return;\n\t        }\n\t\n\t        for (i = 0; i < config._f.length; i++) {\n\t            currentScore = 0;\n\t            tempConfig = copyConfig({}, config);\n\t            if (config._useUTC != null) {\n\t                tempConfig._useUTC = config._useUTC;\n\t            }\n\t            tempConfig._f = config._f[i];\n\t            configFromStringAndFormat(tempConfig);\n\t\n\t            if (!isValid(tempConfig)) {\n\t                continue;\n\t            }\n\t\n\t            // if there is any input that was not parsed add a penalty for that format\n\t            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\t\n\t            //or tokens\n\t            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\t\n\t            getParsingFlags(tempConfig).score = currentScore;\n\t\n\t            if (scoreToBeat == null || currentScore < scoreToBeat) {\n\t                scoreToBeat = currentScore;\n\t                bestMoment = tempConfig;\n\t            }\n\t        }\n\t\n\t        extend(config, bestMoment || tempConfig);\n\t    }\n\t\n\t    function configFromObject(config) {\n\t        if (config._d) {\n\t            return;\n\t        }\n\t\n\t        var i = normalizeObjectUnits(config._i);\n\t        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n\t            return obj && parseInt(obj, 10);\n\t        });\n\t\n\t        configFromArray(config);\n\t    }\n\t\n\t    function createFromConfig (config) {\n\t        var res = new Moment(checkOverflow(prepareConfig(config)));\n\t        if (res._nextDay) {\n\t            // Adding is smart enough around DST\n\t            res.add(1, 'd');\n\t            res._nextDay = undefined;\n\t        }\n\t\n\t        return res;\n\t    }\n\t\n\t    function prepareConfig (config) {\n\t        var input = config._i,\n\t            format = config._f;\n\t\n\t        config._locale = config._locale || getLocale(config._l);\n\t\n\t        if (input === null || (format === undefined && input === '')) {\n\t            return createInvalid({nullInput: true});\n\t        }\n\t\n\t        if (typeof input === 'string') {\n\t            config._i = input = config._locale.preparse(input);\n\t        }\n\t\n\t        if (isMoment(input)) {\n\t            return new Moment(checkOverflow(input));\n\t        } else if (isDate(input)) {\n\t            config._d = input;\n\t        } else if (isArray(format)) {\n\t            configFromStringAndArray(config);\n\t        } else if (format) {\n\t            configFromStringAndFormat(config);\n\t        }  else {\n\t            configFromInput(config);\n\t        }\n\t\n\t        if (!isValid(config)) {\n\t            config._d = null;\n\t        }\n\t\n\t        return config;\n\t    }\n\t\n\t    function configFromInput(config) {\n\t        var input = config._i;\n\t        if (isUndefined(input)) {\n\t            config._d = new Date(hooks.now());\n\t        } else if (isDate(input)) {\n\t            config._d = new Date(input.valueOf());\n\t        } else if (typeof input === 'string') {\n\t            configFromString(config);\n\t        } else if (isArray(input)) {\n\t            config._a = map(input.slice(0), function (obj) {\n\t                return parseInt(obj, 10);\n\t            });\n\t            configFromArray(config);\n\t        } else if (isObject(input)) {\n\t            configFromObject(config);\n\t        } else if (isNumber(input)) {\n\t            // from milliseconds\n\t            config._d = new Date(input);\n\t        } else {\n\t            hooks.createFromInputFallback(config);\n\t        }\n\t    }\n\t\n\t    function createLocalOrUTC (input, format, locale, strict, isUTC) {\n\t        var c = {};\n\t\n\t        if (locale === true || locale === false) {\n\t            strict = locale;\n\t            locale = undefined;\n\t        }\n\t\n\t        if ((isObject(input) && isObjectEmpty(input)) ||\n\t                (isArray(input) && input.length === 0)) {\n\t            input = undefined;\n\t        }\n\t        // object construction must be done this way.\n\t        // https://github.com/moment/moment/issues/1423\n\t        c._isAMomentObject = true;\n\t        c._useUTC = c._isUTC = isUTC;\n\t        c._l = locale;\n\t        c._i = input;\n\t        c._f = format;\n\t        c._strict = strict;\n\t\n\t        return createFromConfig(c);\n\t    }\n\t\n\t    function createLocal (input, format, locale, strict) {\n\t        return createLocalOrUTC(input, format, locale, strict, false);\n\t    }\n\t\n\t    var prototypeMin = deprecate(\n\t        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n\t        function () {\n\t            var other = createLocal.apply(null, arguments);\n\t            if (this.isValid() && other.isValid()) {\n\t                return other < this ? this : other;\n\t            } else {\n\t                return createInvalid();\n\t            }\n\t        }\n\t    );\n\t\n\t    var prototypeMax = deprecate(\n\t        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n\t        function () {\n\t            var other = createLocal.apply(null, arguments);\n\t            if (this.isValid() && other.isValid()) {\n\t                return other > this ? this : other;\n\t            } else {\n\t                return createInvalid();\n\t            }\n\t        }\n\t    );\n\t\n\t    // Pick a moment m from moments so that m[fn](other) is true for all\n\t    // other. This relies on the function fn to be transitive.\n\t    //\n\t    // moments should either be an array of moment objects or an array, whose\n\t    // first element is an array of moment objects.\n\t    function pickBy(fn, moments) {\n\t        var res, i;\n\t        if (moments.length === 1 && isArray(moments[0])) {\n\t            moments = moments[0];\n\t        }\n\t        if (!moments.length) {\n\t            return createLocal();\n\t        }\n\t        res = moments[0];\n\t        for (i = 1; i < moments.length; ++i) {\n\t            if (!moments[i].isValid() || moments[i][fn](res)) {\n\t                res = moments[i];\n\t            }\n\t        }\n\t        return res;\n\t    }\n\t\n\t    // TODO: Use [].sort instead?\n\t    function min () {\n\t        var args = [].slice.call(arguments, 0);\n\t\n\t        return pickBy('isBefore', args);\n\t    }\n\t\n\t    function max () {\n\t        var args = [].slice.call(arguments, 0);\n\t\n\t        return pickBy('isAfter', args);\n\t    }\n\t\n\t    var now = function () {\n\t        return Date.now ? Date.now() : +(new Date());\n\t    };\n\t\n\t    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\n\t\n\t    function isDurationValid(m) {\n\t        for (var key in m) {\n\t            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n\t                return false;\n\t            }\n\t        }\n\t\n\t        var unitHasDecimal = false;\n\t        for (var i = 0; i < ordering.length; ++i) {\n\t            if (m[ordering[i]]) {\n\t                if (unitHasDecimal) {\n\t                    return false; // only allow non-integers for smallest unit\n\t                }\n\t                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n\t                    unitHasDecimal = true;\n\t                }\n\t            }\n\t        }\n\t\n\t        return true;\n\t    }\n\t\n\t    function isValid$1() {\n\t        return this._isValid;\n\t    }\n\t\n\t    function createInvalid$1() {\n\t        return createDuration(NaN);\n\t    }\n\t\n\t    function Duration (duration) {\n\t        var normalizedInput = normalizeObjectUnits(duration),\n\t            years = normalizedInput.year || 0,\n\t            quarters = normalizedInput.quarter || 0,\n\t            months = normalizedInput.month || 0,\n\t            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,\n\t            days = normalizedInput.day || 0,\n\t            hours = normalizedInput.hour || 0,\n\t            minutes = normalizedInput.minute || 0,\n\t            seconds = normalizedInput.second || 0,\n\t            milliseconds = normalizedInput.millisecond || 0;\n\t\n\t        this._isValid = isDurationValid(normalizedInput);\n\t\n\t        // representation for dateAddRemove\n\t        this._milliseconds = +milliseconds +\n\t            seconds * 1e3 + // 1000\n\t            minutes * 6e4 + // 1000 * 60\n\t            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n\t        // Because of dateAddRemove treats 24 hours as different from a\n\t        // day when working around DST, we need to store them separately\n\t        this._days = +days +\n\t            weeks * 7;\n\t        // It is impossible to translate months into days without knowing\n\t        // which months you are are talking about, so we have to store\n\t        // it separately.\n\t        this._months = +months +\n\t            quarters * 3 +\n\t            years * 12;\n\t\n\t        this._data = {};\n\t\n\t        this._locale = getLocale();\n\t\n\t        this._bubble();\n\t    }\n\t\n\t    function isDuration (obj) {\n\t        return obj instanceof Duration;\n\t    }\n\t\n\t    function absRound (number) {\n\t        if (number < 0) {\n\t            return Math.round(-1 * number) * -1;\n\t        } else {\n\t            return Math.round(number);\n\t        }\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    function offset (token, separator) {\n\t        addFormatToken(token, 0, 0, function () {\n\t            var offset = this.utcOffset();\n\t            var sign = '+';\n\t            if (offset < 0) {\n\t                offset = -offset;\n\t                sign = '-';\n\t            }\n\t            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n\t        });\n\t    }\n\t\n\t    offset('Z', ':');\n\t    offset('ZZ', '');\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('Z',  matchShortOffset);\n\t    addRegexToken('ZZ', matchShortOffset);\n\t    addParseToken(['Z', 'ZZ'], function (input, array, config) {\n\t        config._useUTC = true;\n\t        config._tzm = offsetFromString(matchShortOffset, input);\n\t    });\n\t\n\t    // HELPERS\n\t\n\t    // timezone chunker\n\t    // '+10:00' > ['10',  '00']\n\t    // '-1530'  > ['-15', '30']\n\t    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\t\n\t    function offsetFromString(matcher, string) {\n\t        var matches = (string || '').match(matcher);\n\t\n\t        if (matches === null) {\n\t            return null;\n\t        }\n\t\n\t        var chunk   = matches[matches.length - 1] || [];\n\t        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n\t        var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\t\n\t        return minutes === 0 ?\n\t          0 :\n\t          parts[0] === '+' ? minutes : -minutes;\n\t    }\n\t\n\t    // Return a moment from input, that is local/utc/zone equivalent to model.\n\t    function cloneWithOffset(input, model) {\n\t        var res, diff;\n\t        if (model._isUTC) {\n\t            res = model.clone();\n\t            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n\t            // Use low-level api, because this fn is low-level api.\n\t            res._d.setTime(res._d.valueOf() + diff);\n\t            hooks.updateOffset(res, false);\n\t            return res;\n\t        } else {\n\t            return createLocal(input).local();\n\t        }\n\t    }\n\t\n\t    function getDateOffset (m) {\n\t        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n\t        // https://github.com/moment/moment/pull/1871\n\t        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n\t    }\n\t\n\t    // HOOKS\n\t\n\t    // This function will be called whenever a moment is mutated.\n\t    // It is intended to keep the offset in sync with the timezone.\n\t    hooks.updateOffset = function () {};\n\t\n\t    // MOMENTS\n\t\n\t    // keepLocalTime = true means only change the timezone, without\n\t    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n\t    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n\t    // +0200, so we adjust the time as needed, to be valid.\n\t    //\n\t    // Keeping the time actually adds/subtracts (one hour)\n\t    // from the actual represented time. That is why we call updateOffset\n\t    // a second time. In case it wants us to change the offset again\n\t    // _changeInProgress == true case, then we have to adjust, because\n\t    // there is no such time in the given timezone.\n\t    function getSetOffset (input, keepLocalTime, keepMinutes) {\n\t        var offset = this._offset || 0,\n\t            localAdjust;\n\t        if (!this.isValid()) {\n\t            return input != null ? this : NaN;\n\t        }\n\t        if (input != null) {\n\t            if (typeof input === 'string') {\n\t                input = offsetFromString(matchShortOffset, input);\n\t                if (input === null) {\n\t                    return this;\n\t                }\n\t            } else if (Math.abs(input) < 16 && !keepMinutes) {\n\t                input = input * 60;\n\t            }\n\t            if (!this._isUTC && keepLocalTime) {\n\t                localAdjust = getDateOffset(this);\n\t            }\n\t            this._offset = input;\n\t            this._isUTC = true;\n\t            if (localAdjust != null) {\n\t                this.add(localAdjust, 'm');\n\t            }\n\t            if (offset !== input) {\n\t                if (!keepLocalTime || this._changeInProgress) {\n\t                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n\t                } else if (!this._changeInProgress) {\n\t                    this._changeInProgress = true;\n\t                    hooks.updateOffset(this, true);\n\t                    this._changeInProgress = null;\n\t                }\n\t            }\n\t            return this;\n\t        } else {\n\t            return this._isUTC ? offset : getDateOffset(this);\n\t        }\n\t    }\n\t\n\t    function getSetZone (input, keepLocalTime) {\n\t        if (input != null) {\n\t            if (typeof input !== 'string') {\n\t                input = -input;\n\t            }\n\t\n\t            this.utcOffset(input, keepLocalTime);\n\t\n\t            return this;\n\t        } else {\n\t            return -this.utcOffset();\n\t        }\n\t    }\n\t\n\t    function setOffsetToUTC (keepLocalTime) {\n\t        return this.utcOffset(0, keepLocalTime);\n\t    }\n\t\n\t    function setOffsetToLocal (keepLocalTime) {\n\t        if (this._isUTC) {\n\t            this.utcOffset(0, keepLocalTime);\n\t            this._isUTC = false;\n\t\n\t            if (keepLocalTime) {\n\t                this.subtract(getDateOffset(this), 'm');\n\t            }\n\t        }\n\t        return this;\n\t    }\n\t\n\t    function setOffsetToParsedOffset () {\n\t        if (this._tzm != null) {\n\t            this.utcOffset(this._tzm, false, true);\n\t        } else if (typeof this._i === 'string') {\n\t            var tZone = offsetFromString(matchOffset, this._i);\n\t            if (tZone != null) {\n\t                this.utcOffset(tZone);\n\t            }\n\t            else {\n\t                this.utcOffset(0, true);\n\t            }\n\t        }\n\t        return this;\n\t    }\n\t\n\t    function hasAlignedHourOffset (input) {\n\t        if (!this.isValid()) {\n\t            return false;\n\t        }\n\t        input = input ? createLocal(input).utcOffset() : 0;\n\t\n\t        return (this.utcOffset() - input) % 60 === 0;\n\t    }\n\t\n\t    function isDaylightSavingTime () {\n\t        return (\n\t            this.utcOffset() > this.clone().month(0).utcOffset() ||\n\t            this.utcOffset() > this.clone().month(5).utcOffset()\n\t        );\n\t    }\n\t\n\t    function isDaylightSavingTimeShifted () {\n\t        if (!isUndefined(this._isDSTShifted)) {\n\t            return this._isDSTShifted;\n\t        }\n\t\n\t        var c = {};\n\t\n\t        copyConfig(c, this);\n\t        c = prepareConfig(c);\n\t\n\t        if (c._a) {\n\t            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n\t            this._isDSTShifted = this.isValid() &&\n\t                compareArrays(c._a, other.toArray()) > 0;\n\t        } else {\n\t            this._isDSTShifted = false;\n\t        }\n\t\n\t        return this._isDSTShifted;\n\t    }\n\t\n\t    function isLocal () {\n\t        return this.isValid() ? !this._isUTC : false;\n\t    }\n\t\n\t    function isUtcOffset () {\n\t        return this.isValid() ? this._isUTC : false;\n\t    }\n\t\n\t    function isUtc () {\n\t        return this.isValid() ? this._isUTC && this._offset === 0 : false;\n\t    }\n\t\n\t    // ASP.NET json date format regex\n\t    var aspNetRegex = /^(\\-|\\+)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)(\\.\\d*)?)?$/;\n\t\n\t    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n\t    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n\t    // and further modified to allow for strings containing both week and day\n\t    var isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\t\n\t    function createDuration (input, key) {\n\t        var duration = input,\n\t            // matching against regexp is expensive, do it on demand\n\t            match = null,\n\t            sign,\n\t            ret,\n\t            diffRes;\n\t\n\t        if (isDuration(input)) {\n\t            duration = {\n\t                ms : input._milliseconds,\n\t                d  : input._days,\n\t                M  : input._months\n\t            };\n\t        } else if (isNumber(input)) {\n\t            duration = {};\n\t            if (key) {\n\t                duration[key] = input;\n\t            } else {\n\t                duration.milliseconds = input;\n\t            }\n\t        } else if (!!(match = aspNetRegex.exec(input))) {\n\t            sign = (match[1] === '-') ? -1 : 1;\n\t            duration = {\n\t                y  : 0,\n\t                d  : toInt(match[DATE])                         * sign,\n\t                h  : toInt(match[HOUR])                         * sign,\n\t                m  : toInt(match[MINUTE])                       * sign,\n\t                s  : toInt(match[SECOND])                       * sign,\n\t                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\n\t            };\n\t        } else if (!!(match = isoRegex.exec(input))) {\n\t            sign = (match[1] === '-') ? -1 : 1;\n\t            duration = {\n\t                y : parseIso(match[2], sign),\n\t                M : parseIso(match[3], sign),\n\t                w : parseIso(match[4], sign),\n\t                d : parseIso(match[5], sign),\n\t                h : parseIso(match[6], sign),\n\t                m : parseIso(match[7], sign),\n\t                s : parseIso(match[8], sign)\n\t            };\n\t        } else if (duration == null) {// checks for null or undefined\n\t            duration = {};\n\t        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n\t            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n\t\n\t            duration = {};\n\t            duration.ms = diffRes.milliseconds;\n\t            duration.M = diffRes.months;\n\t        }\n\t\n\t        ret = new Duration(duration);\n\t\n\t        if (isDuration(input) && hasOwnProp(input, '_locale')) {\n\t            ret._locale = input._locale;\n\t        }\n\t\n\t        return ret;\n\t    }\n\t\n\t    createDuration.fn = Duration.prototype;\n\t    createDuration.invalid = createInvalid$1;\n\t\n\t    function parseIso (inp, sign) {\n\t        // We'd normally use ~~inp for this, but unfortunately it also\n\t        // converts floats to ints.\n\t        // inp may be undefined, so careful calling replace on it.\n\t        var res = inp && parseFloat(inp.replace(',', '.'));\n\t        // apply sign while we're at it\n\t        return (isNaN(res) ? 0 : res) * sign;\n\t    }\n\t\n\t    function positiveMomentsDifference(base, other) {\n\t        var res = {};\n\t\n\t        res.months = other.month() - base.month() +\n\t            (other.year() - base.year()) * 12;\n\t        if (base.clone().add(res.months, 'M').isAfter(other)) {\n\t            --res.months;\n\t        }\n\t\n\t        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\t\n\t        return res;\n\t    }\n\t\n\t    function momentsDifference(base, other) {\n\t        var res;\n\t        if (!(base.isValid() && other.isValid())) {\n\t            return {milliseconds: 0, months: 0};\n\t        }\n\t\n\t        other = cloneWithOffset(other, base);\n\t        if (base.isBefore(other)) {\n\t            res = positiveMomentsDifference(base, other);\n\t        } else {\n\t            res = positiveMomentsDifference(other, base);\n\t            res.milliseconds = -res.milliseconds;\n\t            res.months = -res.months;\n\t        }\n\t\n\t        return res;\n\t    }\n\t\n\t    // TODO: remove 'name' arg after deprecation is removed\n\t    function createAdder(direction, name) {\n\t        return function (val, period) {\n\t            var dur, tmp;\n\t            //invert the arguments, but complain about it\n\t            if (period !== null && !isNaN(+period)) {\n\t                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +\n\t                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n\t                tmp = val; val = period; period = tmp;\n\t            }\n\t\n\t            val = typeof val === 'string' ? +val : val;\n\t            dur = createDuration(val, period);\n\t            addSubtract(this, dur, direction);\n\t            return this;\n\t        };\n\t    }\n\t\n\t    function addSubtract (mom, duration, isAdding, updateOffset) {\n\t        var milliseconds = duration._milliseconds,\n\t            days = absRound(duration._days),\n\t            months = absRound(duration._months);\n\t\n\t        if (!mom.isValid()) {\n\t            // No op\n\t            return;\n\t        }\n\t\n\t        updateOffset = updateOffset == null ? true : updateOffset;\n\t\n\t        if (months) {\n\t            setMonth(mom, get(mom, 'Month') + months * isAdding);\n\t        }\n\t        if (days) {\n\t            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n\t        }\n\t        if (milliseconds) {\n\t            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n\t        }\n\t        if (updateOffset) {\n\t            hooks.updateOffset(mom, days || months);\n\t        }\n\t    }\n\t\n\t    var add      = createAdder(1, 'add');\n\t    var subtract = createAdder(-1, 'subtract');\n\t\n\t    function getCalendarFormat(myMoment, now) {\n\t        var diff = myMoment.diff(now, 'days', true);\n\t        return diff < -6 ? 'sameElse' :\n\t                diff < -1 ? 'lastWeek' :\n\t                diff < 0 ? 'lastDay' :\n\t                diff < 1 ? 'sameDay' :\n\t                diff < 2 ? 'nextDay' :\n\t                diff < 7 ? 'nextWeek' : 'sameElse';\n\t    }\n\t\n\t    function calendar$1 (time, formats) {\n\t        // We want to compare the start of today, vs this.\n\t        // Getting start-of-today depends on whether we're local/utc/offset or not.\n\t        var now = time || createLocal(),\n\t            sod = cloneWithOffset(now, this).startOf('day'),\n\t            format = hooks.calendarFormat(this, sod) || 'sameElse';\n\t\n\t        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n\t\n\t        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n\t    }\n\t\n\t    function clone () {\n\t        return new Moment(this);\n\t    }\n\t\n\t    function isAfter (input, units) {\n\t        var localInput = isMoment(input) ? input : createLocal(input);\n\t        if (!(this.isValid() && localInput.isValid())) {\n\t            return false;\n\t        }\n\t        units = normalizeUnits(units) || 'millisecond';\n\t        if (units === 'millisecond') {\n\t            return this.valueOf() > localInput.valueOf();\n\t        } else {\n\t            return localInput.valueOf() < this.clone().startOf(units).valueOf();\n\t        }\n\t    }\n\t\n\t    function isBefore (input, units) {\n\t        var localInput = isMoment(input) ? input : createLocal(input);\n\t        if (!(this.isValid() && localInput.isValid())) {\n\t            return false;\n\t        }\n\t        units = normalizeUnits(units) || 'millisecond';\n\t        if (units === 'millisecond') {\n\t            return this.valueOf() < localInput.valueOf();\n\t        } else {\n\t            return this.clone().endOf(units).valueOf() < localInput.valueOf();\n\t        }\n\t    }\n\t\n\t    function isBetween (from, to, units, inclusivity) {\n\t        var localFrom = isMoment(from) ? from : createLocal(from),\n\t            localTo = isMoment(to) ? to : createLocal(to);\n\t        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {\n\t            return false;\n\t        }\n\t        inclusivity = inclusivity || '()';\n\t        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&\n\t            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));\n\t    }\n\t\n\t    function isSame (input, units) {\n\t        var localInput = isMoment(input) ? input : createLocal(input),\n\t            inputMs;\n\t        if (!(this.isValid() && localInput.isValid())) {\n\t            return false;\n\t        }\n\t        units = normalizeUnits(units) || 'millisecond';\n\t        if (units === 'millisecond') {\n\t            return this.valueOf() === localInput.valueOf();\n\t        } else {\n\t            inputMs = localInput.valueOf();\n\t            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n\t        }\n\t    }\n\t\n\t    function isSameOrAfter (input, units) {\n\t        return this.isSame(input, units) || this.isAfter(input, units);\n\t    }\n\t\n\t    function isSameOrBefore (input, units) {\n\t        return this.isSame(input, units) || this.isBefore(input, units);\n\t    }\n\t\n\t    function diff (input, units, asFloat) {\n\t        var that,\n\t            zoneDelta,\n\t            output;\n\t\n\t        if (!this.isValid()) {\n\t            return NaN;\n\t        }\n\t\n\t        that = cloneWithOffset(input, this);\n\t\n\t        if (!that.isValid()) {\n\t            return NaN;\n\t        }\n\t\n\t        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\t\n\t        units = normalizeUnits(units);\n\t\n\t        switch (units) {\n\t            case 'year': output = monthDiff(this, that) / 12; break;\n\t            case 'month': output = monthDiff(this, that); break;\n\t            case 'quarter': output = monthDiff(this, that) / 3; break;\n\t            case 'second': output = (this - that) / 1e3; break; // 1000\n\t            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60\n\t            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60\n\t            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst\n\t            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst\n\t            default: output = this - that;\n\t        }\n\t\n\t        return asFloat ? output : absFloor(output);\n\t    }\n\t\n\t    function monthDiff (a, b) {\n\t        // difference in months\n\t        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n\t            // b is in (anchor - 1 month, anchor + 1 month)\n\t            anchor = a.clone().add(wholeMonthDiff, 'months'),\n\t            anchor2, adjust;\n\t\n\t        if (b - anchor < 0) {\n\t            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n\t            // linear across the month\n\t            adjust = (b - anchor) / (anchor - anchor2);\n\t        } else {\n\t            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n\t            // linear across the month\n\t            adjust = (b - anchor) / (anchor2 - anchor);\n\t        }\n\t\n\t        //check for negative zero, return zero if negative zero\n\t        return -(wholeMonthDiff + adjust) || 0;\n\t    }\n\t\n\t    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n\t    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\t\n\t    function toString () {\n\t        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n\t    }\n\t\n\t    function toISOString(keepOffset) {\n\t        if (!this.isValid()) {\n\t            return null;\n\t        }\n\t        var utc = keepOffset !== true;\n\t        var m = utc ? this.clone().utc() : this;\n\t        if (m.year() < 0 || m.year() > 9999) {\n\t            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');\n\t        }\n\t        if (isFunction(Date.prototype.toISOString)) {\n\t            // native implementation is ~50x faster, use it when we can\n\t            if (utc) {\n\t                return this.toDate().toISOString();\n\t            } else {\n\t                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));\n\t            }\n\t        }\n\t        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');\n\t    }\n\t\n\t    /**\n\t     * Return a human readable representation of a moment that can\n\t     * also be evaluated to get a new moment which is the same\n\t     *\n\t     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n\t     */\n\t    function inspect () {\n\t        if (!this.isValid()) {\n\t            return 'moment.invalid(/* ' + this._i + ' */)';\n\t        }\n\t        var func = 'moment';\n\t        var zone = '';\n\t        if (!this.isLocal()) {\n\t            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n\t            zone = 'Z';\n\t        }\n\t        var prefix = '[' + func + '(\"]';\n\t        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\n\t        var datetime = '-MM-DD[T]HH:mm:ss.SSS';\n\t        var suffix = zone + '[\")]';\n\t\n\t        return this.format(prefix + year + datetime + suffix);\n\t    }\n\t\n\t    function format (inputString) {\n\t        if (!inputString) {\n\t            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n\t        }\n\t        var output = formatMoment(this, inputString);\n\t        return this.localeData().postformat(output);\n\t    }\n\t\n\t    function from (time, withoutSuffix) {\n\t        if (this.isValid() &&\n\t                ((isMoment(time) && time.isValid()) ||\n\t                 createLocal(time).isValid())) {\n\t            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n\t        } else {\n\t            return this.localeData().invalidDate();\n\t        }\n\t    }\n\t\n\t    function fromNow (withoutSuffix) {\n\t        return this.from(createLocal(), withoutSuffix);\n\t    }\n\t\n\t    function to (time, withoutSuffix) {\n\t        if (this.isValid() &&\n\t                ((isMoment(time) && time.isValid()) ||\n\t                 createLocal(time).isValid())) {\n\t            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n\t        } else {\n\t            return this.localeData().invalidDate();\n\t        }\n\t    }\n\t\n\t    function toNow (withoutSuffix) {\n\t        return this.to(createLocal(), withoutSuffix);\n\t    }\n\t\n\t    // If passed a locale key, it will set the locale for this\n\t    // instance.  Otherwise, it will return the locale configuration\n\t    // variables for this instance.\n\t    function locale (key) {\n\t        var newLocaleData;\n\t\n\t        if (key === undefined) {\n\t            return this._locale._abbr;\n\t        } else {\n\t            newLocaleData = getLocale(key);\n\t            if (newLocaleData != null) {\n\t                this._locale = newLocaleData;\n\t            }\n\t            return this;\n\t        }\n\t    }\n\t\n\t    var lang = deprecate(\n\t        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n\t        function (key) {\n\t            if (key === undefined) {\n\t                return this.localeData();\n\t            } else {\n\t                return this.locale(key);\n\t            }\n\t        }\n\t    );\n\t\n\t    function localeData () {\n\t        return this._locale;\n\t    }\n\t\n\t    var MS_PER_SECOND = 1000;\n\t    var MS_PER_MINUTE = 60 * MS_PER_SECOND;\n\t    var MS_PER_HOUR = 60 * MS_PER_MINUTE;\n\t    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;\n\t\n\t    // actual modulo - handles negative numbers (for dates before 1970):\n\t    function mod$1(dividend, divisor) {\n\t        return (dividend % divisor + divisor) % divisor;\n\t    }\n\t\n\t    function localStartOfDate(y, m, d) {\n\t        // the date constructor remaps years 0-99 to 1900-1999\n\t        if (y < 100 && y >= 0) {\n\t            // preserve leap years using a full 400 year cycle, then reset\n\t            return new Date(y + 400, m, d) - MS_PER_400_YEARS;\n\t        } else {\n\t            return new Date(y, m, d).valueOf();\n\t        }\n\t    }\n\t\n\t    function utcStartOfDate(y, m, d) {\n\t        // Date.UTC remaps years 0-99 to 1900-1999\n\t        if (y < 100 && y >= 0) {\n\t            // preserve leap years using a full 400 year cycle, then reset\n\t            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;\n\t        } else {\n\t            return Date.UTC(y, m, d);\n\t        }\n\t    }\n\t\n\t    function startOf (units) {\n\t        var time;\n\t        units = normalizeUnits(units);\n\t        if (units === undefined || units === 'millisecond' || !this.isValid()) {\n\t            return this;\n\t        }\n\t\n\t        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n\t\n\t        switch (units) {\n\t            case 'year':\n\t                time = startOfDate(this.year(), 0, 1);\n\t                break;\n\t            case 'quarter':\n\t                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);\n\t                break;\n\t            case 'month':\n\t                time = startOfDate(this.year(), this.month(), 1);\n\t                break;\n\t            case 'week':\n\t                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());\n\t                break;\n\t            case 'isoWeek':\n\t                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));\n\t                break;\n\t            case 'day':\n\t            case 'date':\n\t                time = startOfDate(this.year(), this.month(), this.date());\n\t                break;\n\t            case 'hour':\n\t                time = this._d.valueOf();\n\t                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);\n\t                break;\n\t            case 'minute':\n\t                time = this._d.valueOf();\n\t                time -= mod$1(time, MS_PER_MINUTE);\n\t                break;\n\t            case 'second':\n\t                time = this._d.valueOf();\n\t                time -= mod$1(time, MS_PER_SECOND);\n\t                break;\n\t        }\n\t\n\t        this._d.setTime(time);\n\t        hooks.updateOffset(this, true);\n\t        return this;\n\t    }\n\t\n\t    function endOf (units) {\n\t        var time;\n\t        units = normalizeUnits(units);\n\t        if (units === undefined || units === 'millisecond' || !this.isValid()) {\n\t            return this;\n\t        }\n\t\n\t        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n\t\n\t        switch (units) {\n\t            case 'year':\n\t                time = startOfDate(this.year() + 1, 0, 1) - 1;\n\t                break;\n\t            case 'quarter':\n\t                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;\n\t                break;\n\t            case 'month':\n\t                time = startOfDate(this.year(), this.month() + 1, 1) - 1;\n\t                break;\n\t            case 'week':\n\t                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;\n\t                break;\n\t            case 'isoWeek':\n\t                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;\n\t                break;\n\t            case 'day':\n\t            case 'date':\n\t                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;\n\t                break;\n\t            case 'hour':\n\t                time = this._d.valueOf();\n\t                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;\n\t                break;\n\t            case 'minute':\n\t                time = this._d.valueOf();\n\t                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;\n\t                break;\n\t            case 'second':\n\t                time = this._d.valueOf();\n\t                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;\n\t                break;\n\t        }\n\t\n\t        this._d.setTime(time);\n\t        hooks.updateOffset(this, true);\n\t        return this;\n\t    }\n\t\n\t    function valueOf () {\n\t        return this._d.valueOf() - ((this._offset || 0) * 60000);\n\t    }\n\t\n\t    function unix () {\n\t        return Math.floor(this.valueOf() / 1000);\n\t    }\n\t\n\t    function toDate () {\n\t        return new Date(this.valueOf());\n\t    }\n\t\n\t    function toArray () {\n\t        var m = this;\n\t        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n\t    }\n\t\n\t    function toObject () {\n\t        var m = this;\n\t        return {\n\t            years: m.year(),\n\t            months: m.month(),\n\t            date: m.date(),\n\t            hours: m.hours(),\n\t            minutes: m.minutes(),\n\t            seconds: m.seconds(),\n\t            milliseconds: m.milliseconds()\n\t        };\n\t    }\n\t\n\t    function toJSON () {\n\t        // new Date(NaN).toJSON() === null\n\t        return this.isValid() ? this.toISOString() : null;\n\t    }\n\t\n\t    function isValid$2 () {\n\t        return isValid(this);\n\t    }\n\t\n\t    function parsingFlags () {\n\t        return extend({}, getParsingFlags(this));\n\t    }\n\t\n\t    function invalidAt () {\n\t        return getParsingFlags(this).overflow;\n\t    }\n\t\n\t    function creationData() {\n\t        return {\n\t            input: this._i,\n\t            format: this._f,\n\t            locale: this._locale,\n\t            isUTC: this._isUTC,\n\t            strict: this._strict\n\t        };\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken(0, ['gg', 2], 0, function () {\n\t        return this.weekYear() % 100;\n\t    });\n\t\n\t    addFormatToken(0, ['GG', 2], 0, function () {\n\t        return this.isoWeekYear() % 100;\n\t    });\n\t\n\t    function addWeekYearFormatToken (token, getter) {\n\t        addFormatToken(0, [token, token.length], 0, getter);\n\t    }\n\t\n\t    addWeekYearFormatToken('gggg',     'weekYear');\n\t    addWeekYearFormatToken('ggggg',    'weekYear');\n\t    addWeekYearFormatToken('GGGG',  'isoWeekYear');\n\t    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('weekYear', 'gg');\n\t    addUnitAlias('isoWeekYear', 'GG');\n\t\n\t    // PRIORITY\n\t\n\t    addUnitPriority('weekYear', 1);\n\t    addUnitPriority('isoWeekYear', 1);\n\t\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('G',      matchSigned);\n\t    addRegexToken('g',      matchSigned);\n\t    addRegexToken('GG',     match1to2, match2);\n\t    addRegexToken('gg',     match1to2, match2);\n\t    addRegexToken('GGGG',   match1to4, match4);\n\t    addRegexToken('gggg',   match1to4, match4);\n\t    addRegexToken('GGGGG',  match1to6, match6);\n\t    addRegexToken('ggggg',  match1to6, match6);\n\t\n\t    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n\t        week[token.substr(0, 2)] = toInt(input);\n\t    });\n\t\n\t    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n\t        week[token] = hooks.parseTwoDigitYear(input);\n\t    });\n\t\n\t    // MOMENTS\n\t\n\t    function getSetWeekYear (input) {\n\t        return getSetWeekYearHelper.call(this,\n\t                input,\n\t                this.week(),\n\t                this.weekday(),\n\t                this.localeData()._week.dow,\n\t                this.localeData()._week.doy);\n\t    }\n\t\n\t    function getSetISOWeekYear (input) {\n\t        return getSetWeekYearHelper.call(this,\n\t                input, this.isoWeek(), this.isoWeekday(), 1, 4);\n\t    }\n\t\n\t    function getISOWeeksInYear () {\n\t        return weeksInYear(this.year(), 1, 4);\n\t    }\n\t\n\t    function getWeeksInYear () {\n\t        var weekInfo = this.localeData()._week;\n\t        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n\t    }\n\t\n\t    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n\t        var weeksTarget;\n\t        if (input == null) {\n\t            return weekOfYear(this, dow, doy).year;\n\t        } else {\n\t            weeksTarget = weeksInYear(input, dow, doy);\n\t            if (week > weeksTarget) {\n\t                week = weeksTarget;\n\t            }\n\t            return setWeekAll.call(this, input, week, weekday, dow, doy);\n\t        }\n\t    }\n\t\n\t    function setWeekAll(weekYear, week, weekday, dow, doy) {\n\t        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n\t            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\t\n\t        this.year(date.getUTCFullYear());\n\t        this.month(date.getUTCMonth());\n\t        this.date(date.getUTCDate());\n\t        return this;\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('Q', 0, 'Qo', 'quarter');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('quarter', 'Q');\n\t\n\t    // PRIORITY\n\t\n\t    addUnitPriority('quarter', 7);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('Q', match1);\n\t    addParseToken('Q', function (input, array) {\n\t        array[MONTH] = (toInt(input) - 1) * 3;\n\t    });\n\t\n\t    // MOMENTS\n\t\n\t    function getSetQuarter (input) {\n\t        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('D', ['DD', 2], 'Do', 'date');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('date', 'D');\n\t\n\t    // PRIORITY\n\t    addUnitPriority('date', 9);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('D',  match1to2);\n\t    addRegexToken('DD', match1to2, match2);\n\t    addRegexToken('Do', function (isStrict, locale) {\n\t        // TODO: Remove \"ordinalParse\" fallback in next major release.\n\t        return isStrict ?\n\t          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\n\t          locale._dayOfMonthOrdinalParseLenient;\n\t    });\n\t\n\t    addParseToken(['D', 'DD'], DATE);\n\t    addParseToken('Do', function (input, array) {\n\t        array[DATE] = toInt(input.match(match1to2)[0]);\n\t    });\n\t\n\t    // MOMENTS\n\t\n\t    var getSetDayOfMonth = makeGetSet('Date', true);\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('dayOfYear', 'DDD');\n\t\n\t    // PRIORITY\n\t    addUnitPriority('dayOfYear', 4);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('DDD',  match1to3);\n\t    addRegexToken('DDDD', match3);\n\t    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n\t        config._dayOfYear = toInt(input);\n\t    });\n\t\n\t    // HELPERS\n\t\n\t    // MOMENTS\n\t\n\t    function getSetDayOfYear (input) {\n\t        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n\t        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n\t    }\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('m', ['mm', 2], 0, 'minute');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('minute', 'm');\n\t\n\t    // PRIORITY\n\t\n\t    addUnitPriority('minute', 14);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('m',  match1to2);\n\t    addRegexToken('mm', match1to2, match2);\n\t    addParseToken(['m', 'mm'], MINUTE);\n\t\n\t    // MOMENTS\n\t\n\t    var getSetMinute = makeGetSet('Minutes', false);\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('s', ['ss', 2], 0, 'second');\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('second', 's');\n\t\n\t    // PRIORITY\n\t\n\t    addUnitPriority('second', 15);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('s',  match1to2);\n\t    addRegexToken('ss', match1to2, match2);\n\t    addParseToken(['s', 'ss'], SECOND);\n\t\n\t    // MOMENTS\n\t\n\t    var getSetSecond = makeGetSet('Seconds', false);\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('S', 0, 0, function () {\n\t        return ~~(this.millisecond() / 100);\n\t    });\n\t\n\t    addFormatToken(0, ['SS', 2], 0, function () {\n\t        return ~~(this.millisecond() / 10);\n\t    });\n\t\n\t    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n\t    addFormatToken(0, ['SSSS', 4], 0, function () {\n\t        return this.millisecond() * 10;\n\t    });\n\t    addFormatToken(0, ['SSSSS', 5], 0, function () {\n\t        return this.millisecond() * 100;\n\t    });\n\t    addFormatToken(0, ['SSSSSS', 6], 0, function () {\n\t        return this.millisecond() * 1000;\n\t    });\n\t    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n\t        return this.millisecond() * 10000;\n\t    });\n\t    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n\t        return this.millisecond() * 100000;\n\t    });\n\t    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n\t        return this.millisecond() * 1000000;\n\t    });\n\t\n\t\n\t    // ALIASES\n\t\n\t    addUnitAlias('millisecond', 'ms');\n\t\n\t    // PRIORITY\n\t\n\t    addUnitPriority('millisecond', 16);\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('S',    match1to3, match1);\n\t    addRegexToken('SS',   match1to3, match2);\n\t    addRegexToken('SSS',  match1to3, match3);\n\t\n\t    var token;\n\t    for (token = 'SSSS'; token.length <= 9; token += 'S') {\n\t        addRegexToken(token, matchUnsigned);\n\t    }\n\t\n\t    function parseMs(input, array) {\n\t        array[MILLISECOND] = toInt(('0.' + input) * 1000);\n\t    }\n\t\n\t    for (token = 'S'; token.length <= 9; token += 'S') {\n\t        addParseToken(token, parseMs);\n\t    }\n\t    // MOMENTS\n\t\n\t    var getSetMillisecond = makeGetSet('Milliseconds', false);\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('z',  0, 0, 'zoneAbbr');\n\t    addFormatToken('zz', 0, 0, 'zoneName');\n\t\n\t    // MOMENTS\n\t\n\t    function getZoneAbbr () {\n\t        return this._isUTC ? 'UTC' : '';\n\t    }\n\t\n\t    function getZoneName () {\n\t        return this._isUTC ? 'Coordinated Universal Time' : '';\n\t    }\n\t\n\t    var proto = Moment.prototype;\n\t\n\t    proto.add               = add;\n\t    proto.calendar          = calendar$1;\n\t    proto.clone             = clone;\n\t    proto.diff              = diff;\n\t    proto.endOf             = endOf;\n\t    proto.format            = format;\n\t    proto.from              = from;\n\t    proto.fromNow           = fromNow;\n\t    proto.to                = to;\n\t    proto.toNow             = toNow;\n\t    proto.get               = stringGet;\n\t    proto.invalidAt         = invalidAt;\n\t    proto.isAfter           = isAfter;\n\t    proto.isBefore          = isBefore;\n\t    proto.isBetween         = isBetween;\n\t    proto.isSame            = isSame;\n\t    proto.isSameOrAfter     = isSameOrAfter;\n\t    proto.isSameOrBefore    = isSameOrBefore;\n\t    proto.isValid           = isValid$2;\n\t    proto.lang              = lang;\n\t    proto.locale            = locale;\n\t    proto.localeData        = localeData;\n\t    proto.max               = prototypeMax;\n\t    proto.min               = prototypeMin;\n\t    proto.parsingFlags      = parsingFlags;\n\t    proto.set               = stringSet;\n\t    proto.startOf           = startOf;\n\t    proto.subtract          = subtract;\n\t    proto.toArray           = toArray;\n\t    proto.toObject          = toObject;\n\t    proto.toDate            = toDate;\n\t    proto.toISOString       = toISOString;\n\t    proto.inspect           = inspect;\n\t    proto.toJSON            = toJSON;\n\t    proto.toString          = toString;\n\t    proto.unix              = unix;\n\t    proto.valueOf           = valueOf;\n\t    proto.creationData      = creationData;\n\t    proto.year       = getSetYear;\n\t    proto.isLeapYear = getIsLeapYear;\n\t    proto.weekYear    = getSetWeekYear;\n\t    proto.isoWeekYear = getSetISOWeekYear;\n\t    proto.quarter = proto.quarters = getSetQuarter;\n\t    proto.month       = getSetMonth;\n\t    proto.daysInMonth = getDaysInMonth;\n\t    proto.week           = proto.weeks        = getSetWeek;\n\t    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\n\t    proto.weeksInYear    = getWeeksInYear;\n\t    proto.isoWeeksInYear = getISOWeeksInYear;\n\t    proto.date       = getSetDayOfMonth;\n\t    proto.day        = proto.days             = getSetDayOfWeek;\n\t    proto.weekday    = getSetLocaleDayOfWeek;\n\t    proto.isoWeekday = getSetISODayOfWeek;\n\t    proto.dayOfYear  = getSetDayOfYear;\n\t    proto.hour = proto.hours = getSetHour;\n\t    proto.minute = proto.minutes = getSetMinute;\n\t    proto.second = proto.seconds = getSetSecond;\n\t    proto.millisecond = proto.milliseconds = getSetMillisecond;\n\t    proto.utcOffset            = getSetOffset;\n\t    proto.utc                  = setOffsetToUTC;\n\t    proto.local                = setOffsetToLocal;\n\t    proto.parseZone            = setOffsetToParsedOffset;\n\t    proto.hasAlignedHourOffset = hasAlignedHourOffset;\n\t    proto.isDST                = isDaylightSavingTime;\n\t    proto.isLocal              = isLocal;\n\t    proto.isUtcOffset          = isUtcOffset;\n\t    proto.isUtc                = isUtc;\n\t    proto.isUTC                = isUtc;\n\t    proto.zoneAbbr = getZoneAbbr;\n\t    proto.zoneName = getZoneName;\n\t    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\n\t    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\n\t    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\n\t    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\n\t    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n\t\n\t    function createUnix (input) {\n\t        return createLocal(input * 1000);\n\t    }\n\t\n\t    function createInZone () {\n\t        return createLocal.apply(null, arguments).parseZone();\n\t    }\n\t\n\t    function preParsePostFormat (string) {\n\t        return string;\n\t    }\n\t\n\t    var proto$1 = Locale.prototype;\n\t\n\t    proto$1.calendar        = calendar;\n\t    proto$1.longDateFormat  = longDateFormat;\n\t    proto$1.invalidDate     = invalidDate;\n\t    proto$1.ordinal         = ordinal;\n\t    proto$1.preparse        = preParsePostFormat;\n\t    proto$1.postformat      = preParsePostFormat;\n\t    proto$1.relativeTime    = relativeTime;\n\t    proto$1.pastFuture      = pastFuture;\n\t    proto$1.set             = set;\n\t\n\t    proto$1.months            =        localeMonths;\n\t    proto$1.monthsShort       =        localeMonthsShort;\n\t    proto$1.monthsParse       =        localeMonthsParse;\n\t    proto$1.monthsRegex       = monthsRegex;\n\t    proto$1.monthsShortRegex  = monthsShortRegex;\n\t    proto$1.week = localeWeek;\n\t    proto$1.firstDayOfYear = localeFirstDayOfYear;\n\t    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n\t\n\t    proto$1.weekdays       =        localeWeekdays;\n\t    proto$1.weekdaysMin    =        localeWeekdaysMin;\n\t    proto$1.weekdaysShort  =        localeWeekdaysShort;\n\t    proto$1.weekdaysParse  =        localeWeekdaysParse;\n\t\n\t    proto$1.weekdaysRegex       =        weekdaysRegex;\n\t    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;\n\t    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;\n\t\n\t    proto$1.isPM = localeIsPM;\n\t    proto$1.meridiem = localeMeridiem;\n\t\n\t    function get$1 (format, index, field, setter) {\n\t        var locale = getLocale();\n\t        var utc = createUTC().set(setter, index);\n\t        return locale[field](utc, format);\n\t    }\n\t\n\t    function listMonthsImpl (format, index, field) {\n\t        if (isNumber(format)) {\n\t            index = format;\n\t            format = undefined;\n\t        }\n\t\n\t        format = format || '';\n\t\n\t        if (index != null) {\n\t            return get$1(format, index, field, 'month');\n\t        }\n\t\n\t        var i;\n\t        var out = [];\n\t        for (i = 0; i < 12; i++) {\n\t            out[i] = get$1(format, i, field, 'month');\n\t        }\n\t        return out;\n\t    }\n\t\n\t    // ()\n\t    // (5)\n\t    // (fmt, 5)\n\t    // (fmt)\n\t    // (true)\n\t    // (true, 5)\n\t    // (true, fmt, 5)\n\t    // (true, fmt)\n\t    function listWeekdaysImpl (localeSorted, format, index, field) {\n\t        if (typeof localeSorted === 'boolean') {\n\t            if (isNumber(format)) {\n\t                index = format;\n\t                format = undefined;\n\t            }\n\t\n\t            format = format || '';\n\t        } else {\n\t            format = localeSorted;\n\t            index = format;\n\t            localeSorted = false;\n\t\n\t            if (isNumber(format)) {\n\t                index = format;\n\t                format = undefined;\n\t            }\n\t\n\t            format = format || '';\n\t        }\n\t\n\t        var locale = getLocale(),\n\t            shift = localeSorted ? locale._week.dow : 0;\n\t\n\t        if (index != null) {\n\t            return get$1(format, (index + shift) % 7, field, 'day');\n\t        }\n\t\n\t        var i;\n\t        var out = [];\n\t        for (i = 0; i < 7; i++) {\n\t            out[i] = get$1(format, (i + shift) % 7, field, 'day');\n\t        }\n\t        return out;\n\t    }\n\t\n\t    function listMonths (format, index) {\n\t        return listMonthsImpl(format, index, 'months');\n\t    }\n\t\n\t    function listMonthsShort (format, index) {\n\t        return listMonthsImpl(format, index, 'monthsShort');\n\t    }\n\t\n\t    function listWeekdays (localeSorted, format, index) {\n\t        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n\t    }\n\t\n\t    function listWeekdaysShort (localeSorted, format, index) {\n\t        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n\t    }\n\t\n\t    function listWeekdaysMin (localeSorted, format, index) {\n\t        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n\t    }\n\t\n\t    getSetGlobalLocale('en', {\n\t        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n\t        ordinal : function (number) {\n\t            var b = number % 10,\n\t                output = (toInt(number % 100 / 10) === 1) ? 'th' :\n\t                (b === 1) ? 'st' :\n\t                (b === 2) ? 'nd' :\n\t                (b === 3) ? 'rd' : 'th';\n\t            return number + output;\n\t        }\n\t    });\n\t\n\t    // Side effect imports\n\t\n\t    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\n\t    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n\t\n\t    var mathAbs = Math.abs;\n\t\n\t    function abs () {\n\t        var data           = this._data;\n\t\n\t        this._milliseconds = mathAbs(this._milliseconds);\n\t        this._days         = mathAbs(this._days);\n\t        this._months       = mathAbs(this._months);\n\t\n\t        data.milliseconds  = mathAbs(data.milliseconds);\n\t        data.seconds       = mathAbs(data.seconds);\n\t        data.minutes       = mathAbs(data.minutes);\n\t        data.hours         = mathAbs(data.hours);\n\t        data.months        = mathAbs(data.months);\n\t        data.years         = mathAbs(data.years);\n\t\n\t        return this;\n\t    }\n\t\n\t    function addSubtract$1 (duration, input, value, direction) {\n\t        var other = createDuration(input, value);\n\t\n\t        duration._milliseconds += direction * other._milliseconds;\n\t        duration._days         += direction * other._days;\n\t        duration._months       += direction * other._months;\n\t\n\t        return duration._bubble();\n\t    }\n\t\n\t    // supports only 2.0-style add(1, 's') or add(duration)\n\t    function add$1 (input, value) {\n\t        return addSubtract$1(this, input, value, 1);\n\t    }\n\t\n\t    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n\t    function subtract$1 (input, value) {\n\t        return addSubtract$1(this, input, value, -1);\n\t    }\n\t\n\t    function absCeil (number) {\n\t        if (number < 0) {\n\t            return Math.floor(number);\n\t        } else {\n\t            return Math.ceil(number);\n\t        }\n\t    }\n\t\n\t    function bubble () {\n\t        var milliseconds = this._milliseconds;\n\t        var days         = this._days;\n\t        var months       = this._months;\n\t        var data         = this._data;\n\t        var seconds, minutes, hours, years, monthsFromDays;\n\t\n\t        // if we have a mix of positive and negative values, bubble down first\n\t        // check: https://github.com/moment/moment/issues/2166\n\t        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n\t                (milliseconds <= 0 && days <= 0 && months <= 0))) {\n\t            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n\t            days = 0;\n\t            months = 0;\n\t        }\n\t\n\t        // The following code bubbles up values, see the tests for\n\t        // examples of what that means.\n\t        data.milliseconds = milliseconds % 1000;\n\t\n\t        seconds           = absFloor(milliseconds / 1000);\n\t        data.seconds      = seconds % 60;\n\t\n\t        minutes           = absFloor(seconds / 60);\n\t        data.minutes      = minutes % 60;\n\t\n\t        hours             = absFloor(minutes / 60);\n\t        data.hours        = hours % 24;\n\t\n\t        days += absFloor(hours / 24);\n\t\n\t        // convert days to months\n\t        monthsFromDays = absFloor(daysToMonths(days));\n\t        months += monthsFromDays;\n\t        days -= absCeil(monthsToDays(monthsFromDays));\n\t\n\t        // 12 months -> 1 year\n\t        years = absFloor(months / 12);\n\t        months %= 12;\n\t\n\t        data.days   = days;\n\t        data.months = months;\n\t        data.years  = years;\n\t\n\t        return this;\n\t    }\n\t\n\t    function daysToMonths (days) {\n\t        // 400 years have 146097 days (taking into account leap year rules)\n\t        // 400 years have 12 months === 4800\n\t        return days * 4800 / 146097;\n\t    }\n\t\n\t    function monthsToDays (months) {\n\t        // the reverse of daysToMonths\n\t        return months * 146097 / 4800;\n\t    }\n\t\n\t    function as (units) {\n\t        if (!this.isValid()) {\n\t            return NaN;\n\t        }\n\t        var days;\n\t        var months;\n\t        var milliseconds = this._milliseconds;\n\t\n\t        units = normalizeUnits(units);\n\t\n\t        if (units === 'month' || units === 'quarter' || units === 'year') {\n\t            days = this._days + milliseconds / 864e5;\n\t            months = this._months + daysToMonths(days);\n\t            switch (units) {\n\t                case 'month':   return months;\n\t                case 'quarter': return months / 3;\n\t                case 'year':    return months / 12;\n\t            }\n\t        } else {\n\t            // handle milliseconds separately because of floating point math errors (issue #1867)\n\t            days = this._days + Math.round(monthsToDays(this._months));\n\t            switch (units) {\n\t                case 'week'   : return days / 7     + milliseconds / 6048e5;\n\t                case 'day'    : return days         + milliseconds / 864e5;\n\t                case 'hour'   : return days * 24    + milliseconds / 36e5;\n\t                case 'minute' : return days * 1440  + milliseconds / 6e4;\n\t                case 'second' : return days * 86400 + milliseconds / 1000;\n\t                // Math.floor prevents floating point math errors here\n\t                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n\t                default: throw new Error('Unknown unit ' + units);\n\t            }\n\t        }\n\t    }\n\t\n\t    // TODO: Use this.as('ms')?\n\t    function valueOf$1 () {\n\t        if (!this.isValid()) {\n\t            return NaN;\n\t        }\n\t        return (\n\t            this._milliseconds +\n\t            this._days * 864e5 +\n\t            (this._months % 12) * 2592e6 +\n\t            toInt(this._months / 12) * 31536e6\n\t        );\n\t    }\n\t\n\t    function makeAs (alias) {\n\t        return function () {\n\t            return this.as(alias);\n\t        };\n\t    }\n\t\n\t    var asMilliseconds = makeAs('ms');\n\t    var asSeconds      = makeAs('s');\n\t    var asMinutes      = makeAs('m');\n\t    var asHours        = makeAs('h');\n\t    var asDays         = makeAs('d');\n\t    var asWeeks        = makeAs('w');\n\t    var asMonths       = makeAs('M');\n\t    var asQuarters     = makeAs('Q');\n\t    var asYears        = makeAs('y');\n\t\n\t    function clone$1 () {\n\t        return createDuration(this);\n\t    }\n\t\n\t    function get$2 (units) {\n\t        units = normalizeUnits(units);\n\t        return this.isValid() ? this[units + 's']() : NaN;\n\t    }\n\t\n\t    function makeGetter(name) {\n\t        return function () {\n\t            return this.isValid() ? this._data[name] : NaN;\n\t        };\n\t    }\n\t\n\t    var milliseconds = makeGetter('milliseconds');\n\t    var seconds      = makeGetter('seconds');\n\t    var minutes      = makeGetter('minutes');\n\t    var hours        = makeGetter('hours');\n\t    var days         = makeGetter('days');\n\t    var months       = makeGetter('months');\n\t    var years        = makeGetter('years');\n\t\n\t    function weeks () {\n\t        return absFloor(this.days() / 7);\n\t    }\n\t\n\t    var round = Math.round;\n\t    var thresholds = {\n\t        ss: 44,         // a few seconds to seconds\n\t        s : 45,         // seconds to minute\n\t        m : 45,         // minutes to hour\n\t        h : 22,         // hours to day\n\t        d : 26,         // days to month\n\t        M : 11          // months to year\n\t    };\n\t\n\t    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n\t    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n\t        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n\t    }\n\t\n\t    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {\n\t        var duration = createDuration(posNegDuration).abs();\n\t        var seconds  = round(duration.as('s'));\n\t        var minutes  = round(duration.as('m'));\n\t        var hours    = round(duration.as('h'));\n\t        var days     = round(duration.as('d'));\n\t        var months   = round(duration.as('M'));\n\t        var years    = round(duration.as('y'));\n\t\n\t        var a = seconds <= thresholds.ss && ['s', seconds]  ||\n\t                seconds < thresholds.s   && ['ss', seconds] ||\n\t                minutes <= 1             && ['m']           ||\n\t                minutes < thresholds.m   && ['mm', minutes] ||\n\t                hours   <= 1             && ['h']           ||\n\t                hours   < thresholds.h   && ['hh', hours]   ||\n\t                days    <= 1             && ['d']           ||\n\t                days    < thresholds.d   && ['dd', days]    ||\n\t                months  <= 1             && ['M']           ||\n\t                months  < thresholds.M   && ['MM', months]  ||\n\t                years   <= 1             && ['y']           || ['yy', years];\n\t\n\t        a[2] = withoutSuffix;\n\t        a[3] = +posNegDuration > 0;\n\t        a[4] = locale;\n\t        return substituteTimeAgo.apply(null, a);\n\t    }\n\t\n\t    // This function allows you to set the rounding function for relative time strings\n\t    function getSetRelativeTimeRounding (roundingFunction) {\n\t        if (roundingFunction === undefined) {\n\t            return round;\n\t        }\n\t        if (typeof(roundingFunction) === 'function') {\n\t            round = roundingFunction;\n\t            return true;\n\t        }\n\t        return false;\n\t    }\n\t\n\t    // This function allows you to set a threshold for relative time strings\n\t    function getSetRelativeTimeThreshold (threshold, limit) {\n\t        if (thresholds[threshold] === undefined) {\n\t            return false;\n\t        }\n\t        if (limit === undefined) {\n\t            return thresholds[threshold];\n\t        }\n\t        thresholds[threshold] = limit;\n\t        if (threshold === 's') {\n\t            thresholds.ss = limit - 1;\n\t        }\n\t        return true;\n\t    }\n\t\n\t    function humanize (withSuffix) {\n\t        if (!this.isValid()) {\n\t            return this.localeData().invalidDate();\n\t        }\n\t\n\t        var locale = this.localeData();\n\t        var output = relativeTime$1(this, !withSuffix, locale);\n\t\n\t        if (withSuffix) {\n\t            output = locale.pastFuture(+this, output);\n\t        }\n\t\n\t        return locale.postformat(output);\n\t    }\n\t\n\t    var abs$1 = Math.abs;\n\t\n\t    function sign(x) {\n\t        return ((x > 0) - (x < 0)) || +x;\n\t    }\n\t\n\t    function toISOString$1() {\n\t        // for ISO strings we do not use the normal bubbling rules:\n\t        //  * milliseconds bubble up until they become hours\n\t        //  * days do not bubble at all\n\t        //  * months bubble up until they become years\n\t        // This is because there is no context-free conversion between hours and days\n\t        // (think of clock changes)\n\t        // and also not between days and months (28-31 days per month)\n\t        if (!this.isValid()) {\n\t            return this.localeData().invalidDate();\n\t        }\n\t\n\t        var seconds = abs$1(this._milliseconds) / 1000;\n\t        var days         = abs$1(this._days);\n\t        var months       = abs$1(this._months);\n\t        var minutes, hours, years;\n\t\n\t        // 3600 seconds -> 60 minutes -> 1 hour\n\t        minutes           = absFloor(seconds / 60);\n\t        hours             = absFloor(minutes / 60);\n\t        seconds %= 60;\n\t        minutes %= 60;\n\t\n\t        // 12 months -> 1 year\n\t        years  = absFloor(months / 12);\n\t        months %= 12;\n\t\n\t\n\t        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n\t        var Y = years;\n\t        var M = months;\n\t        var D = days;\n\t        var h = hours;\n\t        var m = minutes;\n\t        var s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\n\t        var total = this.asSeconds();\n\t\n\t        if (!total) {\n\t            // this is the same as C#'s (Noda) and python (isodate)...\n\t            // but not other JS (goog.date)\n\t            return 'P0D';\n\t        }\n\t\n\t        var totalSign = total < 0 ? '-' : '';\n\t        var ymSign = sign(this._months) !== sign(total) ? '-' : '';\n\t        var daysSign = sign(this._days) !== sign(total) ? '-' : '';\n\t        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\n\t\n\t        return totalSign + 'P' +\n\t            (Y ? ymSign + Y + 'Y' : '') +\n\t            (M ? ymSign + M + 'M' : '') +\n\t            (D ? daysSign + D + 'D' : '') +\n\t            ((h || m || s) ? 'T' : '') +\n\t            (h ? hmsSign + h + 'H' : '') +\n\t            (m ? hmsSign + m + 'M' : '') +\n\t            (s ? hmsSign + s + 'S' : '');\n\t    }\n\t\n\t    var proto$2 = Duration.prototype;\n\t\n\t    proto$2.isValid        = isValid$1;\n\t    proto$2.abs            = abs;\n\t    proto$2.add            = add$1;\n\t    proto$2.subtract       = subtract$1;\n\t    proto$2.as             = as;\n\t    proto$2.asMilliseconds = asMilliseconds;\n\t    proto$2.asSeconds      = asSeconds;\n\t    proto$2.asMinutes      = asMinutes;\n\t    proto$2.asHours        = asHours;\n\t    proto$2.asDays         = asDays;\n\t    proto$2.asWeeks        = asWeeks;\n\t    proto$2.asMonths       = asMonths;\n\t    proto$2.asQuarters     = asQuarters;\n\t    proto$2.asYears        = asYears;\n\t    proto$2.valueOf        = valueOf$1;\n\t    proto$2._bubble        = bubble;\n\t    proto$2.clone          = clone$1;\n\t    proto$2.get            = get$2;\n\t    proto$2.milliseconds   = milliseconds;\n\t    proto$2.seconds        = seconds;\n\t    proto$2.minutes        = minutes;\n\t    proto$2.hours          = hours;\n\t    proto$2.days           = days;\n\t    proto$2.weeks          = weeks;\n\t    proto$2.months         = months;\n\t    proto$2.years          = years;\n\t    proto$2.humanize       = humanize;\n\t    proto$2.toISOString    = toISOString$1;\n\t    proto$2.toString       = toISOString$1;\n\t    proto$2.toJSON         = toISOString$1;\n\t    proto$2.locale         = locale;\n\t    proto$2.localeData     = localeData;\n\t\n\t    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\n\t    proto$2.lang = lang;\n\t\n\t    // Side effect imports\n\t\n\t    // FORMATTING\n\t\n\t    addFormatToken('X', 0, 0, 'unix');\n\t    addFormatToken('x', 0, 0, 'valueOf');\n\t\n\t    // PARSING\n\t\n\t    addRegexToken('x', matchSigned);\n\t    addRegexToken('X', matchTimestamp);\n\t    addParseToken('X', function (input, array, config) {\n\t        config._d = new Date(parseFloat(input, 10) * 1000);\n\t    });\n\t    addParseToken('x', function (input, array, config) {\n\t        config._d = new Date(toInt(input));\n\t    });\n\t\n\t    // Side effect imports\n\t\n\t\n\t    hooks.version = '2.24.0';\n\t\n\t    setHookCallback(createLocal);\n\t\n\t    hooks.fn                    = proto;\n\t    hooks.min                   = min;\n\t    hooks.max                   = max;\n\t    hooks.now                   = now;\n\t    hooks.utc                   = createUTC;\n\t    hooks.unix                  = createUnix;\n\t    hooks.months                = listMonths;\n\t    hooks.isDate                = isDate;\n\t    hooks.locale                = getSetGlobalLocale;\n\t    hooks.invalid               = createInvalid;\n\t    hooks.duration              = createDuration;\n\t    hooks.isMoment              = isMoment;\n\t    hooks.weekdays              = listWeekdays;\n\t    hooks.parseZone             = createInZone;\n\t    hooks.localeData            = getLocale;\n\t    hooks.isDuration            = isDuration;\n\t    hooks.monthsShort           = listMonthsShort;\n\t    hooks.weekdaysMin           = listWeekdaysMin;\n\t    hooks.defineLocale          = defineLocale;\n\t    hooks.updateLocale          = updateLocale;\n\t    hooks.locales               = listLocales;\n\t    hooks.weekdaysShort         = listWeekdaysShort;\n\t    hooks.normalizeUnits        = normalizeUnits;\n\t    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;\n\t    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n\t    hooks.calendarFormat        = getCalendarFormat;\n\t    hooks.prototype             = proto;\n\t\n\t    // currently HTML5 input type only supports 24-hour formats\n\t    hooks.HTML5_FMT = {\n\t        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type=\"datetime-local\" />\n\t        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type=\"datetime-local\" step=\"1\" />\n\t        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type=\"datetime-local\" step=\"0.001\" />\n\t        DATE: 'YYYY-MM-DD',                             // <input type=\"date\" />\n\t        TIME: 'HH:mm',                                  // <input type=\"time\" />\n\t        TIME_SECONDS: 'HH:mm:ss',                       // <input type=\"time\" step=\"1\" />\n\t        TIME_MS: 'HH:mm:ss.SSS',                        // <input type=\"time\" step=\"0.001\" />\n\t        WEEK: 'GGGG-[W]WW',                             // <input type=\"week\" />\n\t        MONTH: 'YYYY-MM'                                // <input type=\"month\" />\n\t    };\n\t\n\t    return hooks;\n\t\n\t})));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(144)(module)))\n\n/***/ }),\n/* 454 */,\n/* 455 */,\n/* 456 */,\n/* 457 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\texports.__esModule = true;\n\texports.Chart = exports.defaults = exports.Scatter = exports.Bubble = exports.Polar = exports.Radar = exports.HorizontalBar = exports.Bar = exports.Line = exports.Pie = exports.Doughnut = undefined;\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _react = __webpack_require__(4);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _propTypes = __webpack_require__(7);\n\t\n\tvar _propTypes2 = _interopRequireDefault(_propTypes);\n\t\n\tvar _chart = __webpack_require__(245);\n\t\n\tvar _chart2 = _interopRequireDefault(_chart);\n\t\n\tvar _isEqual = __webpack_require__(445);\n\t\n\tvar _isEqual2 = _interopRequireDefault(_isEqual);\n\t\n\tvar _keyBy = __webpack_require__(446);\n\t\n\tvar _keyBy2 = _interopRequireDefault(_keyBy);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar NODE_ENV = typeof process !== 'undefined' && ({\"NODE_ENV\":\"production\",\"PUBLIC_DIR\":\"/Users/dalepalmer/Development/cancount.github.io/public\"}) && (\"production\");\n\t\n\tvar ChartComponent = function (_React$Component) {\n\t  _inherits(ChartComponent, _React$Component);\n\t\n\t  function ChartComponent() {\n\t    var _temp, _this, _ret;\n\t\n\t    _classCallCheck(this, ChartComponent);\n\t\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleOnClick = function (event) {\n\t      var instance = _this.chartInstance;\n\t\n\t      var _this$props = _this.props,\n\t          getDatasetAtEvent = _this$props.getDatasetAtEvent,\n\t          getElementAtEvent = _this$props.getElementAtEvent,\n\t          getElementsAtEvent = _this$props.getElementsAtEvent,\n\t          onElementsClick = _this$props.onElementsClick;\n\t\n\t\n\t      getDatasetAtEvent && getDatasetAtEvent(instance.getDatasetAtEvent(event), event);\n\t      getElementAtEvent && getElementAtEvent(instance.getElementAtEvent(event), event);\n\t      getElementsAtEvent && getElementsAtEvent(instance.getElementsAtEvent(event), event);\n\t      onElementsClick && onElementsClick(instance.getElementsAtEvent(event), event); // Backward compatibility\n\t    }, _this.ref = function (element) {\n\t      _this.element = element;\n\t    }, _temp), _possibleConstructorReturn(_this, _ret);\n\t  }\n\t\n\t  ChartComponent.prototype.componentWillMount = function componentWillMount() {\n\t    this.chartInstance = undefined;\n\t  };\n\t\n\t  ChartComponent.prototype.componentDidMount = function componentDidMount() {\n\t    this.renderChart();\n\t  };\n\t\n\t  ChartComponent.prototype.componentDidUpdate = function componentDidUpdate() {\n\t    if (this.props.redraw) {\n\t      this.destroyChart();\n\t      this.renderChart();\n\t      return;\n\t    }\n\t\n\t    this.updateChart();\n\t  };\n\t\n\t  ChartComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n\t    var _props = this.props,\n\t        redraw = _props.redraw,\n\t        type = _props.type,\n\t        options = _props.options,\n\t        plugins = _props.plugins,\n\t        legend = _props.legend,\n\t        height = _props.height,\n\t        width = _props.width;\n\t\n\t\n\t    if (nextProps.redraw === true) {\n\t      return true;\n\t    }\n\t\n\t    if (height !== nextProps.height || width !== nextProps.width) {\n\t      return true;\n\t    }\n\t\n\t    if (type !== nextProps.type) {\n\t      return true;\n\t    }\n\t\n\t    if (!(0, _isEqual2.default)(legend, nextProps.legend)) {\n\t      return true;\n\t    }\n\t\n\t    if (!(0, _isEqual2.default)(options, nextProps.options)) {\n\t      return true;\n\t    }\n\t\n\t    var nextData = this.transformDataProp(nextProps);\n\t\n\t    if (!(0, _isEqual2.default)(this.shadowDataProp, nextData)) {\n\t      return true;\n\t    }\n\t\n\t    return !(0, _isEqual2.default)(plugins, nextProps.plugins);\n\t  };\n\t\n\t  ChartComponent.prototype.componentWillUnmount = function componentWillUnmount() {\n\t    this.destroyChart();\n\t  };\n\t\n\t  ChartComponent.prototype.transformDataProp = function transformDataProp(props) {\n\t    var data = props.data;\n\t\n\t    if (typeof data == 'function') {\n\t      var node = this.element;\n\t      return data(node);\n\t    } else {\n\t      return data;\n\t    }\n\t  };\n\t\n\t  // Chart.js directly mutates the data.dataset objects by adding _meta proprerty\n\t  // this makes impossible to compare the current and next data changes\n\t  // therefore we memoize the data prop while sending a fake to Chart.js for mutation.\n\t  // see https://github.com/chartjs/Chart.js/blob/master/src/core/core.controller.js#L615-L617\n\t\n\t\n\t  ChartComponent.prototype.memoizeDataProps = function memoizeDataProps() {\n\t    if (!this.props.data) {\n\t      return;\n\t    }\n\t\n\t    var data = this.transformDataProp(this.props);\n\t\n\t    this.shadowDataProp = _extends({}, data, {\n\t      datasets: data.datasets && data.datasets.map(function (set) {\n\t        return _extends({}, set);\n\t      })\n\t    });\n\t\n\t    this.saveCurrentDatasets(); // to remove the dataset metadata from this chart when the chart is destroyed\n\t\n\t    return data;\n\t  };\n\t\n\t  ChartComponent.prototype.checkDatasets = function checkDatasets(datasets) {\n\t    var isDev = NODE_ENV !== 'production' && NODE_ENV !== 'prod';\n\t    var usingCustomKeyProvider = this.props.datasetKeyProvider !== ChartComponent.getLabelAsKey;\n\t    var multipleDatasets = datasets.length > 1;\n\t\n\t    if (isDev && multipleDatasets && !usingCustomKeyProvider) {\n\t      var shouldWarn = false;\n\t      datasets.forEach(function (dataset) {\n\t        if (!dataset.label) {\n\t          shouldWarn = true;\n\t        }\n\t      });\n\t\n\t      if (shouldWarn) {\n\t        console.error('[react-chartjs-2] Warning: Each dataset needs a unique key. By default, the \"label\" property on each dataset is used. Alternatively, you may provide a \"datasetKeyProvider\" as a prop that returns a unique key.');\n\t      }\n\t    }\n\t  };\n\t\n\t  ChartComponent.prototype.getCurrentDatasets = function getCurrentDatasets() {\n\t    return this.chartInstance && this.chartInstance.config.data && this.chartInstance.config.data.datasets || [];\n\t  };\n\t\n\t  ChartComponent.prototype.saveCurrentDatasets = function saveCurrentDatasets() {\n\t    var _this2 = this;\n\t\n\t    this.datasets = this.datasets || {};\n\t    var currentDatasets = this.getCurrentDatasets();\n\t    currentDatasets.forEach(function (d) {\n\t      _this2.datasets[_this2.props.datasetKeyProvider(d)] = d;\n\t    });\n\t  };\n\t\n\t  ChartComponent.prototype.updateChart = function updateChart() {\n\t    var _this3 = this;\n\t\n\t    var options = this.props.options;\n\t\n\t\n\t    var data = this.memoizeDataProps(this.props);\n\t\n\t    if (!this.chartInstance) return;\n\t\n\t    if (options) {\n\t      this.chartInstance.options = _chart2.default.helpers.configMerge(this.chartInstance.options, options);\n\t    }\n\t\n\t    // Pipe datasets to chart instance datasets enabling\n\t    // seamless transitions\n\t    var currentDatasets = this.getCurrentDatasets();\n\t    var nextDatasets = data.datasets || [];\n\t    this.checkDatasets(currentDatasets);\n\t\n\t    var currentDatasetsIndexed = (0, _keyBy2.default)(currentDatasets, this.props.datasetKeyProvider);\n\t\n\t    // We can safely replace the dataset array, as long as we retain the _meta property\n\t    // on each dataset.\n\t    this.chartInstance.config.data.datasets = nextDatasets.map(function (next) {\n\t      var current = currentDatasetsIndexed[_this3.props.datasetKeyProvider(next)];\n\t\n\t      if (current && current.type === next.type) {\n\t        // The data array must be edited in place. As chart.js adds listeners to it.\n\t        current.data.splice(next.data.length);\n\t        next.data.forEach(function (point, pid) {\n\t          current.data[pid] = next.data[pid];\n\t        });\n\t\n\t        var _data = next.data,\n\t            otherProps = _objectWithoutProperties(next, ['data']);\n\t        // Merge properties. Notice a weakness here. If a property is removed\n\t        // from next, it will be retained by current and never disappears.\n\t        // Workaround is to set value to null or undefined in next.\n\t\n\t\n\t        return _extends({}, current, otherProps);\n\t      } else {\n\t        return next;\n\t      }\n\t    });\n\t\n\t    var datasets = data.datasets,\n\t        rest = _objectWithoutProperties(data, ['datasets']);\n\t\n\t    this.chartInstance.config.data = _extends({}, this.chartInstance.config.data, rest);\n\t\n\t    this.chartInstance.update();\n\t  };\n\t\n\t  ChartComponent.prototype.renderChart = function renderChart() {\n\t    var _props2 = this.props,\n\t        options = _props2.options,\n\t        legend = _props2.legend,\n\t        type = _props2.type,\n\t        plugins = _props2.plugins;\n\t\n\t    var node = this.element;\n\t    var data = this.memoizeDataProps();\n\t\n\t    if (typeof legend !== 'undefined' && !(0, _isEqual2.default)(ChartComponent.defaultProps.legend, legend)) {\n\t      options.legend = legend;\n\t    }\n\t\n\t    this.chartInstance = new _chart2.default(node, {\n\t      type: type,\n\t      data: data,\n\t      options: options,\n\t      plugins: plugins\n\t    });\n\t  };\n\t\n\t  ChartComponent.prototype.destroyChart = function destroyChart() {\n\t    // Put all of the datasets that have existed in the chart back on the chart\n\t    // so that the metadata associated with this chart get destroyed.\n\t    // This allows the datasets to be used in another chart. This can happen,\n\t    // for example, in a tabbed UI where the chart gets created each time the\n\t    // tab gets switched to the chart and uses the same data).\n\t    this.saveCurrentDatasets();\n\t    var datasets = Object.values(this.datasets);\n\t    this.chartInstance.config.data.datasets = datasets;\n\t\n\t    this.chartInstance.destroy();\n\t  };\n\t\n\t  ChartComponent.prototype.render = function render() {\n\t    var _props3 = this.props,\n\t        height = _props3.height,\n\t        width = _props3.width,\n\t        id = _props3.id;\n\t\n\t\n\t    return _react2.default.createElement('canvas', {\n\t      ref: this.ref,\n\t      height: height,\n\t      width: width,\n\t      id: id,\n\t      onClick: this.handleOnClick\n\t    });\n\t  };\n\t\n\t  return ChartComponent;\n\t}(_react2.default.Component);\n\t\n\tChartComponent.getLabelAsKey = function (d) {\n\t  return d.label;\n\t};\n\t\n\tChartComponent.propTypes = {\n\t  data: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]).isRequired,\n\t  getDatasetAtEvent: _propTypes2.default.func,\n\t  getElementAtEvent: _propTypes2.default.func,\n\t  getElementsAtEvent: _propTypes2.default.func,\n\t  height: _propTypes2.default.number,\n\t  legend: _propTypes2.default.object,\n\t  onElementsClick: _propTypes2.default.func,\n\t  options: _propTypes2.default.object,\n\t  plugins: _propTypes2.default.arrayOf(_propTypes2.default.object),\n\t  redraw: _propTypes2.default.bool,\n\t  type: function type(props, propName, componentName) {\n\t    if (!_chart2.default.controllers[props[propName]]) {\n\t      return new Error('Invalid chart type `' + props[propName] + '` supplied to' + ' `' + componentName + '`.');\n\t    }\n\t  },\n\t  width: _propTypes2.default.number,\n\t  datasetKeyProvider: _propTypes2.default.func\n\t};\n\tChartComponent.defaultProps = {\n\t  legend: {\n\t    display: true,\n\t    position: 'bottom'\n\t  },\n\t  type: 'doughnut',\n\t  height: 150,\n\t  width: 300,\n\t  redraw: false,\n\t  options: {},\n\t  datasetKeyProvider: ChartComponent.getLabelAsKey\n\t};\n\texports.default = ChartComponent;\n\t\n\tvar Doughnut = exports.Doughnut = function (_React$Component2) {\n\t  _inherits(Doughnut, _React$Component2);\n\t\n\t  function Doughnut() {\n\t    _classCallCheck(this, Doughnut);\n\t\n\t    return _possibleConstructorReturn(this, _React$Component2.apply(this, arguments));\n\t  }\n\t\n\t  Doughnut.prototype.render = function render() {\n\t    var _this5 = this;\n\t\n\t    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n\t      ref: function ref(_ref) {\n\t        return _this5.chartInstance = _ref && _ref.chartInstance;\n\t      },\n\t      type: 'doughnut'\n\t    }));\n\t  };\n\t\n\t  return Doughnut;\n\t}(_react2.default.Component);\n\t\n\tvar Pie = exports.Pie = function (_React$Component3) {\n\t  _inherits(Pie, _React$Component3);\n\t\n\t  function Pie() {\n\t    _classCallCheck(this, Pie);\n\t\n\t    return _possibleConstructorReturn(this, _React$Component3.apply(this, arguments));\n\t  }\n\t\n\t  Pie.prototype.render = function render() {\n\t    var _this7 = this;\n\t\n\t    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n\t      ref: function ref(_ref2) {\n\t        return _this7.chartInstance = _ref2 && _ref2.chartInstance;\n\t      },\n\t      type: 'pie'\n\t    }));\n\t  };\n\t\n\t  return Pie;\n\t}(_react2.default.Component);\n\t\n\tvar Line = exports.Line = function (_React$Component4) {\n\t  _inherits(Line, _React$Component4);\n\t\n\t  function Line() {\n\t    _classCallCheck(this, Line);\n\t\n\t    return _possibleConstructorReturn(this, _React$Component4.apply(this, arguments));\n\t  }\n\t\n\t  Line.prototype.render = function render() {\n\t    var _this9 = this;\n\t\n\t    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n\t      ref: function ref(_ref3) {\n\t        return _this9.chartInstance = _ref3 && _ref3.chartInstance;\n\t      },\n\t      type: 'line'\n\t    }));\n\t  };\n\t\n\t  return Line;\n\t}(_react2.default.Component);\n\t\n\tvar Bar = exports.Bar = function (_React$Component5) {\n\t  _inherits(Bar, _React$Component5);\n\t\n\t  function Bar() {\n\t    _classCallCheck(this, Bar);\n\t\n\t    return _possibleConstructorReturn(this, _React$Component5.apply(this, arguments));\n\t  }\n\t\n\t  Bar.prototype.render = function render() {\n\t    var _this11 = this;\n\t\n\t    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n\t      ref: function ref(_ref4) {\n\t        return _this11.chartInstance = _ref4 && _ref4.chartInstance;\n\t      },\n\t      type: 'bar'\n\t    }));\n\t  };\n\t\n\t  return Bar;\n\t}(_react2.default.Component);\n\t\n\tvar HorizontalBar = exports.HorizontalBar = function (_React$Component6) {\n\t  _inherits(HorizontalBar, _React$Component6);\n\t\n\t  function HorizontalBar() {\n\t    _classCallCheck(this, HorizontalBar);\n\t\n\t    return _possibleConstructorReturn(this, _React$Component6.apply(this, arguments));\n\t  }\n\t\n\t  HorizontalBar.prototype.render = function render() {\n\t    var _this13 = this;\n\t\n\t    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n\t      ref: function ref(_ref5) {\n\t        return _this13.chartInstance = _ref5 && _ref5.chartInstance;\n\t      },\n\t      type: 'horizontalBar'\n\t    }));\n\t  };\n\t\n\t  return HorizontalBar;\n\t}(_react2.default.Component);\n\t\n\tvar Radar = exports.Radar = function (_React$Component7) {\n\t  _inherits(Radar, _React$Component7);\n\t\n\t  function Radar() {\n\t    _classCallCheck(this, Radar);\n\t\n\t    return _possibleConstructorReturn(this, _React$Component7.apply(this, arguments));\n\t  }\n\t\n\t  Radar.prototype.render = function render() {\n\t    var _this15 = this;\n\t\n\t    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n\t      ref: function ref(_ref6) {\n\t        return _this15.chartInstance = _ref6 && _ref6.chartInstance;\n\t      },\n\t      type: 'radar'\n\t    }));\n\t  };\n\t\n\t  return Radar;\n\t}(_react2.default.Component);\n\t\n\tvar Polar = exports.Polar = function (_React$Component8) {\n\t  _inherits(Polar, _React$Component8);\n\t\n\t  function Polar() {\n\t    _classCallCheck(this, Polar);\n\t\n\t    return _possibleConstructorReturn(this, _React$Component8.apply(this, arguments));\n\t  }\n\t\n\t  Polar.prototype.render = function render() {\n\t    var _this17 = this;\n\t\n\t    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n\t      ref: function ref(_ref7) {\n\t        return _this17.chartInstance = _ref7 && _ref7.chartInstance;\n\t      },\n\t      type: 'polarArea'\n\t    }));\n\t  };\n\t\n\t  return Polar;\n\t}(_react2.default.Component);\n\t\n\tvar Bubble = exports.Bubble = function (_React$Component9) {\n\t  _inherits(Bubble, _React$Component9);\n\t\n\t  function Bubble() {\n\t    _classCallCheck(this, Bubble);\n\t\n\t    return _possibleConstructorReturn(this, _React$Component9.apply(this, arguments));\n\t  }\n\t\n\t  Bubble.prototype.render = function render() {\n\t    var _this19 = this;\n\t\n\t    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n\t      ref: function ref(_ref8) {\n\t        return _this19.chartInstance = _ref8 && _ref8.chartInstance;\n\t      },\n\t      type: 'bubble'\n\t    }));\n\t  };\n\t\n\t  return Bubble;\n\t}(_react2.default.Component);\n\t\n\tvar Scatter = exports.Scatter = function (_React$Component10) {\n\t  _inherits(Scatter, _React$Component10);\n\t\n\t  function Scatter() {\n\t    _classCallCheck(this, Scatter);\n\t\n\t    return _possibleConstructorReturn(this, _React$Component10.apply(this, arguments));\n\t  }\n\t\n\t  Scatter.prototype.render = function render() {\n\t    var _this21 = this;\n\t\n\t    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n\t      ref: function ref(_ref9) {\n\t        return _this21.chartInstance = _ref9 && _ref9.chartInstance;\n\t      },\n\t      type: 'scatter'\n\t    }));\n\t  };\n\t\n\t  return Scatter;\n\t}(_react2.default.Component);\n\t\n\tvar defaults = exports.defaults = _chart2.default.defaults;\n\texports.Chart = _chart2.default;\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(52)))\n\n/***/ })\n]);\n\n\n// WEBPACK FOOTER //\n// component---src-pages-index-js-eb2681cacb891241f817.js","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_root.js\n// module id = 17\n// module chunks = 35783957827783","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/isArray.js\n// module id = 18\n// module chunks = 35783957827783","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_getNative.js\n// module id = 27\n// module chunks = 35783957827783","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseGetTag.js\n// module id = 50\n// module chunks = 35783957827783","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/isObjectLike.js\n// module id = 51\n// module chunks = 35783957827783","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 52\n// module chunks = 35783957827783 231608221292675","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_ListCache.js\n// module id = 72\n// module chunks = 35783957827783","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_Symbol.js\n// module id = 73\n// module chunks = 35783957827783","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_assocIndexOf.js\n// module id = 74\n// module chunks = 35783957827783","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_getMapData.js\n// module id = 75\n// module chunks = 35783957827783","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_nativeCreate.js\n// module id = 76\n// module chunks = 35783957827783","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_toKey.js\n// module id = 77\n// module chunks = 35783957827783","'use strict';\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    getDerivedStateFromProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\n\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    callee: true,\n    arguments: true,\n    arity: true\n};\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = getPrototypeOf && getPrototypeOf(Object);\n\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n\n        if (objectPrototype) {\n            var inheritedComponent = getPrototypeOf(sourceComponent);\n            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n            }\n        }\n\n        var keys = getOwnPropertyNames(sourceComponent);\n\n        if (getOwnPropertySymbols) {\n            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n        }\n\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {\n                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                try { // Avoid failures from read-only properties\n                    defineProperty(targetComponent, key, descriptor);\n                } catch (e) {}\n            }\n        }\n\n        return targetComponent;\n    }\n\n    return targetComponent;\n}\n\nmodule.exports = hoistNonReactStatics;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js\n// module id = 113\n// module chunks = 35783957827783 218538773642512 231608221292675","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_Map.js\n// module id = 115\n// module chunks = 35783957827783","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_MapCache.js\n// module id = 116\n// module chunks = 35783957827783","var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseIsEqual.js\n// module id = 117\n// module chunks = 35783957827783","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_isKey.js\n// module id = 118\n// module chunks = 35783957827783","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/isLength.js\n// module id = 119\n// module chunks = 35783957827783","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/isObject.js\n// module id = 120\n// module chunks = 35783957827783","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/isSymbol.js\n// module id = 121\n// module chunks = 35783957827783","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/keys.js\n// module id = 122\n// module chunks = 35783957827783","'use strict';\n\nvar isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction) {\n    throw new Error(prefix);\n  } else {\n    throw new Error(prefix + \": \" + (message || ''));\n  }\n}\n\nmodule.exports = invariant;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/tiny-invariant/dist/tiny-invariant.cjs.js\n// module id = 142\n// module chunks = 35783957827783 218538773642512 231608221292675","'use strict';\n\nvar isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nmodule.exports = warning;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/tiny-warning/dist/tiny-warning.cjs.js\n// module id = 143\n// module chunks = 35783957827783 218538773642512 231608221292675","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 144\n// module chunks = 35783957827783","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_Stack.js\n// module id = 173\n// module chunks = 35783957827783","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseGet.js\n// module id = 174\n// module chunks = 35783957827783","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_castPath.js\n// module id = 175\n// module chunks = 35783957827783","var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_equalArrays.js\n// module id = 176\n// module chunks = 35783957827783","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_freeGlobal.js\n// module id = 177\n// module chunks = 35783957827783","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_isIndex.js\n// module id = 178\n// module chunks = 35783957827783","var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_isStrictComparable.js\n// module id = 179\n// module chunks = 35783957827783","/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_matchesStrictComparable.js\n// module id = 180\n// module chunks = 35783957827783","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_toSource.js\n// module id = 181\n// module chunks = 35783957827783","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/eq.js\n// module id = 182\n// module chunks = 35783957827783","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/isArguments.js\n// module id = 183\n// module chunks = 35783957827783","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/isArrayLike.js\n// module id = 184\n// module chunks = 35783957827783","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/isBuffer.js\n// module id = 185\n// module chunks = 35783957827783","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/isFunction.js\n// module id = 186\n// module chunks = 35783957827783","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/isTypedArray.js\n// module id = 187\n// module chunks = 35783957827783","import React from 'react'\nimport Link from 'gatsby-link'\nimport Doughnut from 'react-chartjs-2'\nconst chartOptions = {\n          responsive: true,\n          legend: {\n            display: true\n          },\n          animation: {\n            duration: 1200,\n            easing: 'easeOutBack'\n          },\n          labels: {\n            display: true\n          },\n          layout: {\n            padding: {\n                top: 20,\n                bottom: 30\n            },\n          },\n          tooltips: {\n              callbacks: {\n                label: function(tooltipItem, data) {\n                    var total = (data.datasets[0].data).reduce((a, b) => a + b, 0)\n                    var label = data.labels[tooltipItem.index] || '';\n                    label += ' : $' +  data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index]\n                    label += ' : ' + Math.abs(Math.round(data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index] / total * 100))\n                    label += '%'\n                    label += '\\n'\n                    label += 'Number of cans : ' + Math.round(data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index] * 10)\n                    return label;\n                },\n             }\n          },\n          pieceLabel: {\n             render: function (args) {\n              // args will be something like:\n              // { label: 'Label', value: 123, percentage: 50, index: 0, dataset: {...} }\n              return args.label + '\\n';\n\n              // return object if it is image\n              // return { src: 'image.png', width: 16, height: 16 };\n            },\n            fontFamily: 'Helvetica Neue',\n            fontSize: 14,\n            position: 'outside',\n            textMargin: 10\n          },\n      }\nconst chartData = {\n    labels: [\"Team Matt\", \"Radon Canyon\", \"Total\", \"Goal\"],\n    datasets: [\n\n    {\n      data: [114.40, 185.60, 300.00, 50.00],\n      backgroundColor: [\"#0ad1bf\", \"#ff7e22\", \"green\", \"#b0bec5\"],\n     \n    }\n    ]}\n\nconst IndexPage = () => (\n  <div>\n    <p>Welcome to our can collection counter.</p>\n    <p>A group of friends and I are collecting cans for whimsical things to make our lives more vibrant. Here I will document our process:</p>\n    <div>\n\n    </div>\n\n    <Doughnut data={chartData} options={chartOptions}  />\n  </div>\n)\n\nexport default IndexPage\n\n\n\n// WEBPACK FOOTER //\n// ./src/pages/index.js","/*!\n * Chart.js v2.8.0\n * https://www.chartjs.org\n * (c) 2019 Chart.js Contributors\n * Released under the MIT License\n */\n(function (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(function() { try { return require('moment'); } catch(e) { } }()) :\ntypeof define === 'function' && define.amd ? define(['require'], function(require) { return factory(function() { try { return require('moment'); } catch(e) { } }()); }) :\n(global.Chart = factory(global.moment));\n}(this, (function (moment) { 'use strict';\n\nmoment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;\n\n/* MIT license */\n\nvar conversions = {\n  rgb2hsl: rgb2hsl,\n  rgb2hsv: rgb2hsv,\n  rgb2hwb: rgb2hwb,\n  rgb2cmyk: rgb2cmyk,\n  rgb2keyword: rgb2keyword,\n  rgb2xyz: rgb2xyz,\n  rgb2lab: rgb2lab,\n  rgb2lch: rgb2lch,\n\n  hsl2rgb: hsl2rgb,\n  hsl2hsv: hsl2hsv,\n  hsl2hwb: hsl2hwb,\n  hsl2cmyk: hsl2cmyk,\n  hsl2keyword: hsl2keyword,\n\n  hsv2rgb: hsv2rgb,\n  hsv2hsl: hsv2hsl,\n  hsv2hwb: hsv2hwb,\n  hsv2cmyk: hsv2cmyk,\n  hsv2keyword: hsv2keyword,\n\n  hwb2rgb: hwb2rgb,\n  hwb2hsl: hwb2hsl,\n  hwb2hsv: hwb2hsv,\n  hwb2cmyk: hwb2cmyk,\n  hwb2keyword: hwb2keyword,\n\n  cmyk2rgb: cmyk2rgb,\n  cmyk2hsl: cmyk2hsl,\n  cmyk2hsv: cmyk2hsv,\n  cmyk2hwb: cmyk2hwb,\n  cmyk2keyword: cmyk2keyword,\n\n  keyword2rgb: keyword2rgb,\n  keyword2hsl: keyword2hsl,\n  keyword2hsv: keyword2hsv,\n  keyword2hwb: keyword2hwb,\n  keyword2cmyk: keyword2cmyk,\n  keyword2lab: keyword2lab,\n  keyword2xyz: keyword2xyz,\n\n  xyz2rgb: xyz2rgb,\n  xyz2lab: xyz2lab,\n  xyz2lch: xyz2lch,\n\n  lab2xyz: lab2xyz,\n  lab2rgb: lab2rgb,\n  lab2lch: lab2lch,\n\n  lch2lab: lch2lab,\n  lch2xyz: lch2xyz,\n  lch2rgb: lch2rgb\n};\n\n\nfunction rgb2hsl(rgb) {\n  var r = rgb[0]/255,\n      g = rgb[1]/255,\n      b = rgb[2]/255,\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, l;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g)/ delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  l = (min + max) / 2;\n\n  if (max == min)\n    s = 0;\n  else if (l <= 0.5)\n    s = delta / (max + min);\n  else\n    s = delta / (2 - max - min);\n\n  return [h, s * 100, l * 100];\n}\n\nfunction rgb2hsv(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      delta = max - min,\n      h, s, v;\n\n  if (max == 0)\n    s = 0;\n  else\n    s = (delta/max * 1000)/10;\n\n  if (max == min)\n    h = 0;\n  else if (r == max)\n    h = (g - b) / delta;\n  else if (g == max)\n    h = 2 + (b - r) / delta;\n  else if (b == max)\n    h = 4 + (r - g) / delta;\n\n  h = Math.min(h * 60, 360);\n\n  if (h < 0)\n    h += 360;\n\n  v = ((max / 255) * 1000) / 10;\n\n  return [h, s, v];\n}\n\nfunction rgb2hwb(rgb) {\n  var r = rgb[0],\n      g = rgb[1],\n      b = rgb[2],\n      h = rgb2hsl(rgb)[0],\n      w = 1/255 * Math.min(r, Math.min(g, b)),\n      b = 1 - 1/255 * Math.max(r, Math.max(g, b));\n\n  return [h, w * 100, b * 100];\n}\n\nfunction rgb2cmyk(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255,\n      c, m, y, k;\n\n  k = Math.min(1 - r, 1 - g, 1 - b);\n  c = (1 - r - k) / (1 - k) || 0;\n  m = (1 - g - k) / (1 - k) || 0;\n  y = (1 - b - k) / (1 - k) || 0;\n  return [c * 100, m * 100, y * 100, k * 100];\n}\n\nfunction rgb2keyword(rgb) {\n  return reverseKeywords[JSON.stringify(rgb)];\n}\n\nfunction rgb2xyz(rgb) {\n  var r = rgb[0] / 255,\n      g = rgb[1] / 255,\n      b = rgb[2] / 255;\n\n  // assume sRGB\n  r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n  g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n  b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n  var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n  var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n  var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n  return [x * 100, y *100, z * 100];\n}\n\nfunction rgb2lab(rgb) {\n  var xyz = rgb2xyz(rgb),\n        x = xyz[0],\n        y = xyz[1],\n        z = xyz[2],\n        l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction rgb2lch(args) {\n  return lab2lch(rgb2lab(args));\n}\n\nfunction hsl2rgb(hsl) {\n  var h = hsl[0] / 360,\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      t1, t2, t3, rgb, val;\n\n  if (s == 0) {\n    val = l * 255;\n    return [val, val, val];\n  }\n\n  if (l < 0.5)\n    t2 = l * (1 + s);\n  else\n    t2 = l + s - l * s;\n  t1 = 2 * l - t2;\n\n  rgb = [0, 0, 0];\n  for (var i = 0; i < 3; i++) {\n    t3 = h + 1 / 3 * - (i - 1);\n    t3 < 0 && t3++;\n    t3 > 1 && t3--;\n\n    if (6 * t3 < 1)\n      val = t1 + (t2 - t1) * 6 * t3;\n    else if (2 * t3 < 1)\n      val = t2;\n    else if (3 * t3 < 2)\n      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n    else\n      val = t1;\n\n    rgb[i] = val * 255;\n  }\n\n  return rgb;\n}\n\nfunction hsl2hsv(hsl) {\n  var h = hsl[0],\n      s = hsl[1] / 100,\n      l = hsl[2] / 100,\n      sv, v;\n\n  if(l === 0) {\n      // no need to do calc on black\n      // also avoids divide by 0 error\n      return [0, 0, 0];\n  }\n\n  l *= 2;\n  s *= (l <= 1) ? l : 2 - l;\n  v = (l + s) / 2;\n  sv = (2 * s) / (l + s);\n  return [h, sv * 100, v * 100];\n}\n\nfunction hsl2hwb(args) {\n  return rgb2hwb(hsl2rgb(args));\n}\n\nfunction hsl2cmyk(args) {\n  return rgb2cmyk(hsl2rgb(args));\n}\n\nfunction hsl2keyword(args) {\n  return rgb2keyword(hsl2rgb(args));\n}\n\n\nfunction hsv2rgb(hsv) {\n  var h = hsv[0] / 60,\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      hi = Math.floor(h) % 6;\n\n  var f = h - Math.floor(h),\n      p = 255 * v * (1 - s),\n      q = 255 * v * (1 - (s * f)),\n      t = 255 * v * (1 - (s * (1 - f))),\n      v = 255 * v;\n\n  switch(hi) {\n    case 0:\n      return [v, t, p];\n    case 1:\n      return [q, v, p];\n    case 2:\n      return [p, v, t];\n    case 3:\n      return [p, q, v];\n    case 4:\n      return [t, p, v];\n    case 5:\n      return [v, p, q];\n  }\n}\n\nfunction hsv2hsl(hsv) {\n  var h = hsv[0],\n      s = hsv[1] / 100,\n      v = hsv[2] / 100,\n      sl, l;\n\n  l = (2 - s) * v;\n  sl = s * v;\n  sl /= (l <= 1) ? l : 2 - l;\n  sl = sl || 0;\n  l /= 2;\n  return [h, sl * 100, l * 100];\n}\n\nfunction hsv2hwb(args) {\n  return rgb2hwb(hsv2rgb(args))\n}\n\nfunction hsv2cmyk(args) {\n  return rgb2cmyk(hsv2rgb(args));\n}\n\nfunction hsv2keyword(args) {\n  return rgb2keyword(hsv2rgb(args));\n}\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nfunction hwb2rgb(hwb) {\n  var h = hwb[0] / 360,\n      wh = hwb[1] / 100,\n      bl = hwb[2] / 100,\n      ratio = wh + bl,\n      i, v, f, n;\n\n  // wh + bl cant be > 1\n  if (ratio > 1) {\n    wh /= ratio;\n    bl /= ratio;\n  }\n\n  i = Math.floor(6 * h);\n  v = 1 - bl;\n  f = 6 * h - i;\n  if ((i & 0x01) != 0) {\n    f = 1 - f;\n  }\n  n = wh + f * (v - wh);  // linear interpolation\n\n  switch (i) {\n    default:\n    case 6:\n    case 0: r = v; g = n; b = wh; break;\n    case 1: r = n; g = v; b = wh; break;\n    case 2: r = wh; g = v; b = n; break;\n    case 3: r = wh; g = n; b = v; break;\n    case 4: r = n; g = wh; b = v; break;\n    case 5: r = v; g = wh; b = n; break;\n  }\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction hwb2hsl(args) {\n  return rgb2hsl(hwb2rgb(args));\n}\n\nfunction hwb2hsv(args) {\n  return rgb2hsv(hwb2rgb(args));\n}\n\nfunction hwb2cmyk(args) {\n  return rgb2cmyk(hwb2rgb(args));\n}\n\nfunction hwb2keyword(args) {\n  return rgb2keyword(hwb2rgb(args));\n}\n\nfunction cmyk2rgb(cmyk) {\n  var c = cmyk[0] / 100,\n      m = cmyk[1] / 100,\n      y = cmyk[2] / 100,\n      k = cmyk[3] / 100,\n      r, g, b;\n\n  r = 1 - Math.min(1, c * (1 - k) + k);\n  g = 1 - Math.min(1, m * (1 - k) + k);\n  b = 1 - Math.min(1, y * (1 - k) + k);\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction cmyk2hsl(args) {\n  return rgb2hsl(cmyk2rgb(args));\n}\n\nfunction cmyk2hsv(args) {\n  return rgb2hsv(cmyk2rgb(args));\n}\n\nfunction cmyk2hwb(args) {\n  return rgb2hwb(cmyk2rgb(args));\n}\n\nfunction cmyk2keyword(args) {\n  return rgb2keyword(cmyk2rgb(args));\n}\n\n\nfunction xyz2rgb(xyz) {\n  var x = xyz[0] / 100,\n      y = xyz[1] / 100,\n      z = xyz[2] / 100,\n      r, g, b;\n\n  r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n  g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n  b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n  // assume sRGB\n  r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)\n    : r = (r * 12.92);\n\n  g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)\n    : g = (g * 12.92);\n\n  b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)\n    : b = (b * 12.92);\n\n  r = Math.min(Math.max(0, r), 1);\n  g = Math.min(Math.max(0, g), 1);\n  b = Math.min(Math.max(0, b), 1);\n\n  return [r * 255, g * 255, b * 255];\n}\n\nfunction xyz2lab(xyz) {\n  var x = xyz[0],\n      y = xyz[1],\n      z = xyz[2],\n      l, a, b;\n\n  x /= 95.047;\n  y /= 100;\n  z /= 108.883;\n\n  x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);\n  y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);\n  z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);\n\n  l = (116 * y) - 16;\n  a = 500 * (x - y);\n  b = 200 * (y - z);\n\n  return [l, a, b];\n}\n\nfunction xyz2lch(args) {\n  return lab2lch(xyz2lab(args));\n}\n\nfunction lab2xyz(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      x, y, z, y2;\n\n  if (l <= 8) {\n    y = (l * 100) / 903.3;\n    y2 = (7.787 * (y / 100)) + (16 / 116);\n  } else {\n    y = 100 * Math.pow((l + 16) / 116, 3);\n    y2 = Math.pow(y / 100, 1/3);\n  }\n\n  x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);\n\n  z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);\n\n  return [x, y, z];\n}\n\nfunction lab2lch(lab) {\n  var l = lab[0],\n      a = lab[1],\n      b = lab[2],\n      hr, h, c;\n\n  hr = Math.atan2(b, a);\n  h = hr * 360 / 2 / Math.PI;\n  if (h < 0) {\n    h += 360;\n  }\n  c = Math.sqrt(a * a + b * b);\n  return [l, c, h];\n}\n\nfunction lab2rgb(args) {\n  return xyz2rgb(lab2xyz(args));\n}\n\nfunction lch2lab(lch) {\n  var l = lch[0],\n      c = lch[1],\n      h = lch[2],\n      a, b, hr;\n\n  hr = h / 360 * 2 * Math.PI;\n  a = c * Math.cos(hr);\n  b = c * Math.sin(hr);\n  return [l, a, b];\n}\n\nfunction lch2xyz(args) {\n  return lab2xyz(lch2lab(args));\n}\n\nfunction lch2rgb(args) {\n  return lab2rgb(lch2lab(args));\n}\n\nfunction keyword2rgb(keyword) {\n  return cssKeywords[keyword];\n}\n\nfunction keyword2hsl(args) {\n  return rgb2hsl(keyword2rgb(args));\n}\n\nfunction keyword2hsv(args) {\n  return rgb2hsv(keyword2rgb(args));\n}\n\nfunction keyword2hwb(args) {\n  return rgb2hwb(keyword2rgb(args));\n}\n\nfunction keyword2cmyk(args) {\n  return rgb2cmyk(keyword2rgb(args));\n}\n\nfunction keyword2lab(args) {\n  return rgb2lab(keyword2rgb(args));\n}\n\nfunction keyword2xyz(args) {\n  return rgb2xyz(keyword2rgb(args));\n}\n\nvar cssKeywords = {\n  aliceblue:  [240,248,255],\n  antiquewhite: [250,235,215],\n  aqua: [0,255,255],\n  aquamarine: [127,255,212],\n  azure:  [240,255,255],\n  beige:  [245,245,220],\n  bisque: [255,228,196],\n  black:  [0,0,0],\n  blanchedalmond: [255,235,205],\n  blue: [0,0,255],\n  blueviolet: [138,43,226],\n  brown:  [165,42,42],\n  burlywood:  [222,184,135],\n  cadetblue:  [95,158,160],\n  chartreuse: [127,255,0],\n  chocolate:  [210,105,30],\n  coral:  [255,127,80],\n  cornflowerblue: [100,149,237],\n  cornsilk: [255,248,220],\n  crimson:  [220,20,60],\n  cyan: [0,255,255],\n  darkblue: [0,0,139],\n  darkcyan: [0,139,139],\n  darkgoldenrod:  [184,134,11],\n  darkgray: [169,169,169],\n  darkgreen:  [0,100,0],\n  darkgrey: [169,169,169],\n  darkkhaki:  [189,183,107],\n  darkmagenta:  [139,0,139],\n  darkolivegreen: [85,107,47],\n  darkorange: [255,140,0],\n  darkorchid: [153,50,204],\n  darkred:  [139,0,0],\n  darksalmon: [233,150,122],\n  darkseagreen: [143,188,143],\n  darkslateblue:  [72,61,139],\n  darkslategray:  [47,79,79],\n  darkslategrey:  [47,79,79],\n  darkturquoise:  [0,206,209],\n  darkviolet: [148,0,211],\n  deeppink: [255,20,147],\n  deepskyblue:  [0,191,255],\n  dimgray:  [105,105,105],\n  dimgrey:  [105,105,105],\n  dodgerblue: [30,144,255],\n  firebrick:  [178,34,34],\n  floralwhite:  [255,250,240],\n  forestgreen:  [34,139,34],\n  fuchsia:  [255,0,255],\n  gainsboro:  [220,220,220],\n  ghostwhite: [248,248,255],\n  gold: [255,215,0],\n  goldenrod:  [218,165,32],\n  gray: [128,128,128],\n  green:  [0,128,0],\n  greenyellow:  [173,255,47],\n  grey: [128,128,128],\n  honeydew: [240,255,240],\n  hotpink:  [255,105,180],\n  indianred:  [205,92,92],\n  indigo: [75,0,130],\n  ivory:  [255,255,240],\n  khaki:  [240,230,140],\n  lavender: [230,230,250],\n  lavenderblush:  [255,240,245],\n  lawngreen:  [124,252,0],\n  lemonchiffon: [255,250,205],\n  lightblue:  [173,216,230],\n  lightcoral: [240,128,128],\n  lightcyan:  [224,255,255],\n  lightgoldenrodyellow: [250,250,210],\n  lightgray:  [211,211,211],\n  lightgreen: [144,238,144],\n  lightgrey:  [211,211,211],\n  lightpink:  [255,182,193],\n  lightsalmon:  [255,160,122],\n  lightseagreen:  [32,178,170],\n  lightskyblue: [135,206,250],\n  lightslategray: [119,136,153],\n  lightslategrey: [119,136,153],\n  lightsteelblue: [176,196,222],\n  lightyellow:  [255,255,224],\n  lime: [0,255,0],\n  limegreen:  [50,205,50],\n  linen:  [250,240,230],\n  magenta:  [255,0,255],\n  maroon: [128,0,0],\n  mediumaquamarine: [102,205,170],\n  mediumblue: [0,0,205],\n  mediumorchid: [186,85,211],\n  mediumpurple: [147,112,219],\n  mediumseagreen: [60,179,113],\n  mediumslateblue:  [123,104,238],\n  mediumspringgreen:  [0,250,154],\n  mediumturquoise:  [72,209,204],\n  mediumvioletred:  [199,21,133],\n  midnightblue: [25,25,112],\n  mintcream:  [245,255,250],\n  mistyrose:  [255,228,225],\n  moccasin: [255,228,181],\n  navajowhite:  [255,222,173],\n  navy: [0,0,128],\n  oldlace:  [253,245,230],\n  olive:  [128,128,0],\n  olivedrab:  [107,142,35],\n  orange: [255,165,0],\n  orangered:  [255,69,0],\n  orchid: [218,112,214],\n  palegoldenrod:  [238,232,170],\n  palegreen:  [152,251,152],\n  paleturquoise:  [175,238,238],\n  palevioletred:  [219,112,147],\n  papayawhip: [255,239,213],\n  peachpuff:  [255,218,185],\n  peru: [205,133,63],\n  pink: [255,192,203],\n  plum: [221,160,221],\n  powderblue: [176,224,230],\n  purple: [128,0,128],\n  rebeccapurple: [102, 51, 153],\n  red:  [255,0,0],\n  rosybrown:  [188,143,143],\n  royalblue:  [65,105,225],\n  saddlebrown:  [139,69,19],\n  salmon: [250,128,114],\n  sandybrown: [244,164,96],\n  seagreen: [46,139,87],\n  seashell: [255,245,238],\n  sienna: [160,82,45],\n  silver: [192,192,192],\n  skyblue:  [135,206,235],\n  slateblue:  [106,90,205],\n  slategray:  [112,128,144],\n  slategrey:  [112,128,144],\n  snow: [255,250,250],\n  springgreen:  [0,255,127],\n  steelblue:  [70,130,180],\n  tan:  [210,180,140],\n  teal: [0,128,128],\n  thistle:  [216,191,216],\n  tomato: [255,99,71],\n  turquoise:  [64,224,208],\n  violet: [238,130,238],\n  wheat:  [245,222,179],\n  white:  [255,255,255],\n  whitesmoke: [245,245,245],\n  yellow: [255,255,0],\n  yellowgreen:  [154,205,50]\n};\n\nvar reverseKeywords = {};\nfor (var key in cssKeywords) {\n  reverseKeywords[JSON.stringify(cssKeywords[key])] = key;\n}\n\nvar convert = function() {\n   return new Converter();\n};\n\nfor (var func in conversions) {\n  // export Raw versions\n  convert[func + \"Raw\"] =  (function(func) {\n    // accept array or plain args\n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      return conversions[func](arg);\n    }\n  })(func);\n\n  var pair = /(\\w+)2(\\w+)/.exec(func),\n      from = pair[1],\n      to = pair[2];\n\n  // export rgb2hsl and [\"rgb\"][\"hsl\"]\n  convert[from] = convert[from] || {};\n\n  convert[from][to] = convert[func] = (function(func) { \n    return function(arg) {\n      if (typeof arg == \"number\")\n        arg = Array.prototype.slice.call(arguments);\n      \n      var val = conversions[func](arg);\n      if (typeof val == \"string\" || val === undefined)\n        return val; // keyword\n\n      for (var i = 0; i < val.length; i++)\n        val[i] = Math.round(val[i]);\n      return val;\n    }\n  })(func);\n}\n\n\n/* Converter does lazy conversion and caching */\nvar Converter = function() {\n   this.convs = {};\n};\n\n/* Either get the values for a space or\n  set the values for a space, depending on args */\nConverter.prototype.routeSpace = function(space, args) {\n   var values = args[0];\n   if (values === undefined) {\n      // color.rgb()\n      return this.getValues(space);\n   }\n   // color.rgb(10, 10, 10)\n   if (typeof values == \"number\") {\n      values = Array.prototype.slice.call(args);        \n   }\n\n   return this.setValues(space, values);\n};\n  \n/* Set the values for a space, invalidating cache */\nConverter.prototype.setValues = function(space, values) {\n   this.space = space;\n   this.convs = {};\n   this.convs[space] = values;\n   return this;\n};\n\n/* Get the values for a space. If there's already\n  a conversion for the space, fetch it, otherwise\n  compute it */\nConverter.prototype.getValues = function(space) {\n   var vals = this.convs[space];\n   if (!vals) {\n      var fspace = this.space,\n          from = this.convs[fspace];\n      vals = convert[fspace][space](from);\n\n      this.convs[space] = vals;\n   }\n  return vals;\n};\n\n[\"rgb\", \"hsl\", \"hsv\", \"cmyk\", \"keyword\"].forEach(function(space) {\n   Converter.prototype[space] = function(vals) {\n      return this.routeSpace(space, arguments);\n   };\n});\n\nvar colorConvert = convert;\n\nvar colorName = {\r\n\t\"aliceblue\": [240, 248, 255],\r\n\t\"antiquewhite\": [250, 235, 215],\r\n\t\"aqua\": [0, 255, 255],\r\n\t\"aquamarine\": [127, 255, 212],\r\n\t\"azure\": [240, 255, 255],\r\n\t\"beige\": [245, 245, 220],\r\n\t\"bisque\": [255, 228, 196],\r\n\t\"black\": [0, 0, 0],\r\n\t\"blanchedalmond\": [255, 235, 205],\r\n\t\"blue\": [0, 0, 255],\r\n\t\"blueviolet\": [138, 43, 226],\r\n\t\"brown\": [165, 42, 42],\r\n\t\"burlywood\": [222, 184, 135],\r\n\t\"cadetblue\": [95, 158, 160],\r\n\t\"chartreuse\": [127, 255, 0],\r\n\t\"chocolate\": [210, 105, 30],\r\n\t\"coral\": [255, 127, 80],\r\n\t\"cornflowerblue\": [100, 149, 237],\r\n\t\"cornsilk\": [255, 248, 220],\r\n\t\"crimson\": [220, 20, 60],\r\n\t\"cyan\": [0, 255, 255],\r\n\t\"darkblue\": [0, 0, 139],\r\n\t\"darkcyan\": [0, 139, 139],\r\n\t\"darkgoldenrod\": [184, 134, 11],\r\n\t\"darkgray\": [169, 169, 169],\r\n\t\"darkgreen\": [0, 100, 0],\r\n\t\"darkgrey\": [169, 169, 169],\r\n\t\"darkkhaki\": [189, 183, 107],\r\n\t\"darkmagenta\": [139, 0, 139],\r\n\t\"darkolivegreen\": [85, 107, 47],\r\n\t\"darkorange\": [255, 140, 0],\r\n\t\"darkorchid\": [153, 50, 204],\r\n\t\"darkred\": [139, 0, 0],\r\n\t\"darksalmon\": [233, 150, 122],\r\n\t\"darkseagreen\": [143, 188, 143],\r\n\t\"darkslateblue\": [72, 61, 139],\r\n\t\"darkslategray\": [47, 79, 79],\r\n\t\"darkslategrey\": [47, 79, 79],\r\n\t\"darkturquoise\": [0, 206, 209],\r\n\t\"darkviolet\": [148, 0, 211],\r\n\t\"deeppink\": [255, 20, 147],\r\n\t\"deepskyblue\": [0, 191, 255],\r\n\t\"dimgray\": [105, 105, 105],\r\n\t\"dimgrey\": [105, 105, 105],\r\n\t\"dodgerblue\": [30, 144, 255],\r\n\t\"firebrick\": [178, 34, 34],\r\n\t\"floralwhite\": [255, 250, 240],\r\n\t\"forestgreen\": [34, 139, 34],\r\n\t\"fuchsia\": [255, 0, 255],\r\n\t\"gainsboro\": [220, 220, 220],\r\n\t\"ghostwhite\": [248, 248, 255],\r\n\t\"gold\": [255, 215, 0],\r\n\t\"goldenrod\": [218, 165, 32],\r\n\t\"gray\": [128, 128, 128],\r\n\t\"green\": [0, 128, 0],\r\n\t\"greenyellow\": [173, 255, 47],\r\n\t\"grey\": [128, 128, 128],\r\n\t\"honeydew\": [240, 255, 240],\r\n\t\"hotpink\": [255, 105, 180],\r\n\t\"indianred\": [205, 92, 92],\r\n\t\"indigo\": [75, 0, 130],\r\n\t\"ivory\": [255, 255, 240],\r\n\t\"khaki\": [240, 230, 140],\r\n\t\"lavender\": [230, 230, 250],\r\n\t\"lavenderblush\": [255, 240, 245],\r\n\t\"lawngreen\": [124, 252, 0],\r\n\t\"lemonchiffon\": [255, 250, 205],\r\n\t\"lightblue\": [173, 216, 230],\r\n\t\"lightcoral\": [240, 128, 128],\r\n\t\"lightcyan\": [224, 255, 255],\r\n\t\"lightgoldenrodyellow\": [250, 250, 210],\r\n\t\"lightgray\": [211, 211, 211],\r\n\t\"lightgreen\": [144, 238, 144],\r\n\t\"lightgrey\": [211, 211, 211],\r\n\t\"lightpink\": [255, 182, 193],\r\n\t\"lightsalmon\": [255, 160, 122],\r\n\t\"lightseagreen\": [32, 178, 170],\r\n\t\"lightskyblue\": [135, 206, 250],\r\n\t\"lightslategray\": [119, 136, 153],\r\n\t\"lightslategrey\": [119, 136, 153],\r\n\t\"lightsteelblue\": [176, 196, 222],\r\n\t\"lightyellow\": [255, 255, 224],\r\n\t\"lime\": [0, 255, 0],\r\n\t\"limegreen\": [50, 205, 50],\r\n\t\"linen\": [250, 240, 230],\r\n\t\"magenta\": [255, 0, 255],\r\n\t\"maroon\": [128, 0, 0],\r\n\t\"mediumaquamarine\": [102, 205, 170],\r\n\t\"mediumblue\": [0, 0, 205],\r\n\t\"mediumorchid\": [186, 85, 211],\r\n\t\"mediumpurple\": [147, 112, 219],\r\n\t\"mediumseagreen\": [60, 179, 113],\r\n\t\"mediumslateblue\": [123, 104, 238],\r\n\t\"mediumspringgreen\": [0, 250, 154],\r\n\t\"mediumturquoise\": [72, 209, 204],\r\n\t\"mediumvioletred\": [199, 21, 133],\r\n\t\"midnightblue\": [25, 25, 112],\r\n\t\"mintcream\": [245, 255, 250],\r\n\t\"mistyrose\": [255, 228, 225],\r\n\t\"moccasin\": [255, 228, 181],\r\n\t\"navajowhite\": [255, 222, 173],\r\n\t\"navy\": [0, 0, 128],\r\n\t\"oldlace\": [253, 245, 230],\r\n\t\"olive\": [128, 128, 0],\r\n\t\"olivedrab\": [107, 142, 35],\r\n\t\"orange\": [255, 165, 0],\r\n\t\"orangered\": [255, 69, 0],\r\n\t\"orchid\": [218, 112, 214],\r\n\t\"palegoldenrod\": [238, 232, 170],\r\n\t\"palegreen\": [152, 251, 152],\r\n\t\"paleturquoise\": [175, 238, 238],\r\n\t\"palevioletred\": [219, 112, 147],\r\n\t\"papayawhip\": [255, 239, 213],\r\n\t\"peachpuff\": [255, 218, 185],\r\n\t\"peru\": [205, 133, 63],\r\n\t\"pink\": [255, 192, 203],\r\n\t\"plum\": [221, 160, 221],\r\n\t\"powderblue\": [176, 224, 230],\r\n\t\"purple\": [128, 0, 128],\r\n\t\"rebeccapurple\": [102, 51, 153],\r\n\t\"red\": [255, 0, 0],\r\n\t\"rosybrown\": [188, 143, 143],\r\n\t\"royalblue\": [65, 105, 225],\r\n\t\"saddlebrown\": [139, 69, 19],\r\n\t\"salmon\": [250, 128, 114],\r\n\t\"sandybrown\": [244, 164, 96],\r\n\t\"seagreen\": [46, 139, 87],\r\n\t\"seashell\": [255, 245, 238],\r\n\t\"sienna\": [160, 82, 45],\r\n\t\"silver\": [192, 192, 192],\r\n\t\"skyblue\": [135, 206, 235],\r\n\t\"slateblue\": [106, 90, 205],\r\n\t\"slategray\": [112, 128, 144],\r\n\t\"slategrey\": [112, 128, 144],\r\n\t\"snow\": [255, 250, 250],\r\n\t\"springgreen\": [0, 255, 127],\r\n\t\"steelblue\": [70, 130, 180],\r\n\t\"tan\": [210, 180, 140],\r\n\t\"teal\": [0, 128, 128],\r\n\t\"thistle\": [216, 191, 216],\r\n\t\"tomato\": [255, 99, 71],\r\n\t\"turquoise\": [64, 224, 208],\r\n\t\"violet\": [238, 130, 238],\r\n\t\"wheat\": [245, 222, 179],\r\n\t\"white\": [255, 255, 255],\r\n\t\"whitesmoke\": [245, 245, 245],\r\n\t\"yellow\": [255, 255, 0],\r\n\t\"yellowgreen\": [154, 205, 50]\r\n};\n\n/* MIT license */\n\n\nvar colorString = {\n   getRgba: getRgba,\n   getHsla: getHsla,\n   getRgb: getRgb,\n   getHsl: getHsl,\n   getHwb: getHwb,\n   getAlpha: getAlpha,\n\n   hexString: hexString,\n   rgbString: rgbString,\n   rgbaString: rgbaString,\n   percentString: percentString,\n   percentaString: percentaString,\n   hslString: hslString,\n   hslaString: hslaString,\n   hwbString: hwbString,\n   keyword: keyword\n};\n\nfunction getRgba(string) {\n   if (!string) {\n      return;\n   }\n   var abbr =  /^#([a-fA-F0-9]{3,4})$/i,\n       hex =  /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,\n       rgba = /^rgba?\\(\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*,\\s*([+-]?\\d+)\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n       per = /^rgba?\\(\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*,\\s*([+-]?[\\d\\.]+)\\%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)$/i,\n       keyword = /(\\w+)/;\n\n   var rgb = [0, 0, 0],\n       a = 1,\n       match = string.match(abbr),\n       hexAlpha = \"\";\n   if (match) {\n      match = match[1];\n      hexAlpha = match[3];\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match[i] + match[i], 16);\n      }\n      if (hexAlpha) {\n         a = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;\n      }\n   }\n   else if (match = string.match(hex)) {\n      hexAlpha = match[2];\n      match = match[1];\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);\n      }\n      if (hexAlpha) {\n         a = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;\n      }\n   }\n   else if (match = string.match(rgba)) {\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = parseInt(match[i + 1]);\n      }\n      a = parseFloat(match[4]);\n   }\n   else if (match = string.match(per)) {\n      for (var i = 0; i < rgb.length; i++) {\n         rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);\n      }\n      a = parseFloat(match[4]);\n   }\n   else if (match = string.match(keyword)) {\n      if (match[1] == \"transparent\") {\n         return [0, 0, 0, 0];\n      }\n      rgb = colorName[match[1]];\n      if (!rgb) {\n         return;\n      }\n   }\n\n   for (var i = 0; i < rgb.length; i++) {\n      rgb[i] = scale(rgb[i], 0, 255);\n   }\n   if (!a && a != 0) {\n      a = 1;\n   }\n   else {\n      a = scale(a, 0, 1);\n   }\n   rgb[3] = a;\n   return rgb;\n}\n\nfunction getHsla(string) {\n   if (!string) {\n      return;\n   }\n   var hsl = /^hsla?\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n   var match = string.match(hsl);\n   if (match) {\n      var alpha = parseFloat(match[4]);\n      var h = scale(parseInt(match[1]), 0, 360),\n          s = scale(parseFloat(match[2]), 0, 100),\n          l = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [h, s, l, a];\n   }\n}\n\nfunction getHwb(string) {\n   if (!string) {\n      return;\n   }\n   var hwb = /^hwb\\(\\s*([+-]?\\d+)(?:deg)?\\s*,\\s*([+-]?[\\d\\.]+)%\\s*,\\s*([+-]?[\\d\\.]+)%\\s*(?:,\\s*([+-]?[\\d\\.]+)\\s*)?\\)/;\n   var match = string.match(hwb);\n   if (match) {\n    var alpha = parseFloat(match[4]);\n      var h = scale(parseInt(match[1]), 0, 360),\n          w = scale(parseFloat(match[2]), 0, 100),\n          b = scale(parseFloat(match[3]), 0, 100),\n          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);\n      return [h, w, b, a];\n   }\n}\n\nfunction getRgb(string) {\n   var rgba = getRgba(string);\n   return rgba && rgba.slice(0, 3);\n}\n\nfunction getHsl(string) {\n  var hsla = getHsla(string);\n  return hsla && hsla.slice(0, 3);\n}\n\nfunction getAlpha(string) {\n   var vals = getRgba(string);\n   if (vals) {\n      return vals[3];\n   }\n   else if (vals = getHsla(string)) {\n      return vals[3];\n   }\n   else if (vals = getHwb(string)) {\n      return vals[3];\n   }\n}\n\n// generators\nfunction hexString(rgba, a) {\n   var a = (a !== undefined && rgba.length === 3) ? a : rgba[3];\n   return \"#\" + hexDouble(rgba[0]) \n              + hexDouble(rgba[1])\n              + hexDouble(rgba[2])\n              + (\n                 (a >= 0 && a < 1)\n                 ? hexDouble(Math.round(a * 255))\n                 : \"\"\n              );\n}\n\nfunction rgbString(rgba, alpha) {\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n      return rgbaString(rgba, alpha);\n   }\n   return \"rgb(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2] + \")\";\n}\n\nfunction rgbaString(rgba, alpha) {\n   if (alpha === undefined) {\n      alpha = (rgba[3] !== undefined ? rgba[3] : 1);\n   }\n   return \"rgba(\" + rgba[0] + \", \" + rgba[1] + \", \" + rgba[2]\n           + \", \" + alpha + \")\";\n}\n\nfunction percentString(rgba, alpha) {\n   if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {\n      return percentaString(rgba, alpha);\n   }\n   var r = Math.round(rgba[0]/255 * 100),\n       g = Math.round(rgba[1]/255 * 100),\n       b = Math.round(rgba[2]/255 * 100);\n\n   return \"rgb(\" + r + \"%, \" + g + \"%, \" + b + \"%)\";\n}\n\nfunction percentaString(rgba, alpha) {\n   var r = Math.round(rgba[0]/255 * 100),\n       g = Math.round(rgba[1]/255 * 100),\n       b = Math.round(rgba[2]/255 * 100);\n   return \"rgba(\" + r + \"%, \" + g + \"%, \" + b + \"%, \" + (alpha || rgba[3] || 1) + \")\";\n}\n\nfunction hslString(hsla, alpha) {\n   if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {\n      return hslaString(hsla, alpha);\n   }\n   return \"hsl(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%)\";\n}\n\nfunction hslaString(hsla, alpha) {\n   if (alpha === undefined) {\n      alpha = (hsla[3] !== undefined ? hsla[3] : 1);\n   }\n   return \"hsla(\" + hsla[0] + \", \" + hsla[1] + \"%, \" + hsla[2] + \"%, \"\n           + alpha + \")\";\n}\n\n// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax\n// (hwb have alpha optional & 1 is default value)\nfunction hwbString(hwb, alpha) {\n   if (alpha === undefined) {\n      alpha = (hwb[3] !== undefined ? hwb[3] : 1);\n   }\n   return \"hwb(\" + hwb[0] + \", \" + hwb[1] + \"%, \" + hwb[2] + \"%\"\n           + (alpha !== undefined && alpha !== 1 ? \", \" + alpha : \"\") + \")\";\n}\n\nfunction keyword(rgb) {\n  return reverseNames[rgb.slice(0, 3)];\n}\n\n// helpers\nfunction scale(num, min, max) {\n   return Math.min(Math.max(min, num), max);\n}\n\nfunction hexDouble(num) {\n  var str = num.toString(16).toUpperCase();\n  return (str.length < 2) ? \"0\" + str : str;\n}\n\n\n//create a list of reverse color names\nvar reverseNames = {};\nfor (var name in colorName) {\n   reverseNames[colorName[name]] = name;\n}\n\n/* MIT license */\n\n\n\nvar Color = function (obj) {\n\tif (obj instanceof Color) {\n\t\treturn obj;\n\t}\n\tif (!(this instanceof Color)) {\n\t\treturn new Color(obj);\n\t}\n\n\tthis.valid = false;\n\tthis.values = {\n\t\trgb: [0, 0, 0],\n\t\thsl: [0, 0, 0],\n\t\thsv: [0, 0, 0],\n\t\thwb: [0, 0, 0],\n\t\tcmyk: [0, 0, 0, 0],\n\t\talpha: 1\n\t};\n\n\t// parse Color() argument\n\tvar vals;\n\tif (typeof obj === 'string') {\n\t\tvals = colorString.getRgba(obj);\n\t\tif (vals) {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals = colorString.getHsla(obj)) {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals = colorString.getHwb(obj)) {\n\t\t\tthis.setValues('hwb', vals);\n\t\t}\n\t} else if (typeof obj === 'object') {\n\t\tvals = obj;\n\t\tif (vals.r !== undefined || vals.red !== undefined) {\n\t\t\tthis.setValues('rgb', vals);\n\t\t} else if (vals.l !== undefined || vals.lightness !== undefined) {\n\t\t\tthis.setValues('hsl', vals);\n\t\t} else if (vals.v !== undefined || vals.value !== undefined) {\n\t\t\tthis.setValues('hsv', vals);\n\t\t} else if (vals.w !== undefined || vals.whiteness !== undefined) {\n\t\t\tthis.setValues('hwb', vals);\n\t\t} else if (vals.c !== undefined || vals.cyan !== undefined) {\n\t\t\tthis.setValues('cmyk', vals);\n\t\t}\n\t}\n};\n\nColor.prototype = {\n\tisValid: function () {\n\t\treturn this.valid;\n\t},\n\trgb: function () {\n\t\treturn this.setSpace('rgb', arguments);\n\t},\n\thsl: function () {\n\t\treturn this.setSpace('hsl', arguments);\n\t},\n\thsv: function () {\n\t\treturn this.setSpace('hsv', arguments);\n\t},\n\thwb: function () {\n\t\treturn this.setSpace('hwb', arguments);\n\t},\n\tcmyk: function () {\n\t\treturn this.setSpace('cmyk', arguments);\n\t},\n\n\trgbArray: function () {\n\t\treturn this.values.rgb;\n\t},\n\thslArray: function () {\n\t\treturn this.values.hsl;\n\t},\n\thsvArray: function () {\n\t\treturn this.values.hsv;\n\t},\n\thwbArray: function () {\n\t\tvar values = this.values;\n\t\tif (values.alpha !== 1) {\n\t\t\treturn values.hwb.concat([values.alpha]);\n\t\t}\n\t\treturn values.hwb;\n\t},\n\tcmykArray: function () {\n\t\treturn this.values.cmyk;\n\t},\n\trgbaArray: function () {\n\t\tvar values = this.values;\n\t\treturn values.rgb.concat([values.alpha]);\n\t},\n\thslaArray: function () {\n\t\tvar values = this.values;\n\t\treturn values.hsl.concat([values.alpha]);\n\t},\n\talpha: function (val) {\n\t\tif (val === undefined) {\n\t\t\treturn this.values.alpha;\n\t\t}\n\t\tthis.setValues('alpha', val);\n\t\treturn this;\n\t},\n\n\tred: function (val) {\n\t\treturn this.setChannel('rgb', 0, val);\n\t},\n\tgreen: function (val) {\n\t\treturn this.setChannel('rgb', 1, val);\n\t},\n\tblue: function (val) {\n\t\treturn this.setChannel('rgb', 2, val);\n\t},\n\thue: function (val) {\n\t\tif (val) {\n\t\t\tval %= 360;\n\t\t\tval = val < 0 ? 360 + val : val;\n\t\t}\n\t\treturn this.setChannel('hsl', 0, val);\n\t},\n\tsaturation: function (val) {\n\t\treturn this.setChannel('hsl', 1, val);\n\t},\n\tlightness: function (val) {\n\t\treturn this.setChannel('hsl', 2, val);\n\t},\n\tsaturationv: function (val) {\n\t\treturn this.setChannel('hsv', 1, val);\n\t},\n\twhiteness: function (val) {\n\t\treturn this.setChannel('hwb', 1, val);\n\t},\n\tblackness: function (val) {\n\t\treturn this.setChannel('hwb', 2, val);\n\t},\n\tvalue: function (val) {\n\t\treturn this.setChannel('hsv', 2, val);\n\t},\n\tcyan: function (val) {\n\t\treturn this.setChannel('cmyk', 0, val);\n\t},\n\tmagenta: function (val) {\n\t\treturn this.setChannel('cmyk', 1, val);\n\t},\n\tyellow: function (val) {\n\t\treturn this.setChannel('cmyk', 2, val);\n\t},\n\tblack: function (val) {\n\t\treturn this.setChannel('cmyk', 3, val);\n\t},\n\n\thexString: function () {\n\t\treturn colorString.hexString(this.values.rgb);\n\t},\n\trgbString: function () {\n\t\treturn colorString.rgbString(this.values.rgb, this.values.alpha);\n\t},\n\trgbaString: function () {\n\t\treturn colorString.rgbaString(this.values.rgb, this.values.alpha);\n\t},\n\tpercentString: function () {\n\t\treturn colorString.percentString(this.values.rgb, this.values.alpha);\n\t},\n\thslString: function () {\n\t\treturn colorString.hslString(this.values.hsl, this.values.alpha);\n\t},\n\thslaString: function () {\n\t\treturn colorString.hslaString(this.values.hsl, this.values.alpha);\n\t},\n\thwbString: function () {\n\t\treturn colorString.hwbString(this.values.hwb, this.values.alpha);\n\t},\n\tkeyword: function () {\n\t\treturn colorString.keyword(this.values.rgb, this.values.alpha);\n\t},\n\n\trgbNumber: function () {\n\t\tvar rgb = this.values.rgb;\n\t\treturn (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];\n\t},\n\n\tluminosity: function () {\n\t\t// http://www.w3.org/TR/WCAG20/#relativeluminancedef\n\t\tvar rgb = this.values.rgb;\n\t\tvar lum = [];\n\t\tfor (var i = 0; i < rgb.length; i++) {\n\t\t\tvar chan = rgb[i] / 255;\n\t\t\tlum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);\n\t\t}\n\t\treturn 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];\n\t},\n\n\tcontrast: function (color2) {\n\t\t// http://www.w3.org/TR/WCAG20/#contrast-ratiodef\n\t\tvar lum1 = this.luminosity();\n\t\tvar lum2 = color2.luminosity();\n\t\tif (lum1 > lum2) {\n\t\t\treturn (lum1 + 0.05) / (lum2 + 0.05);\n\t\t}\n\t\treturn (lum2 + 0.05) / (lum1 + 0.05);\n\t},\n\n\tlevel: function (color2) {\n\t\tvar contrastRatio = this.contrast(color2);\n\t\tif (contrastRatio >= 7.1) {\n\t\t\treturn 'AAA';\n\t\t}\n\n\t\treturn (contrastRatio >= 4.5) ? 'AA' : '';\n\t},\n\n\tdark: function () {\n\t\t// YIQ equation from http://24ways.org/2010/calculating-color-contrast\n\t\tvar rgb = this.values.rgb;\n\t\tvar yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n\t\treturn yiq < 128;\n\t},\n\n\tlight: function () {\n\t\treturn !this.dark();\n\t},\n\n\tnegate: function () {\n\t\tvar rgb = [];\n\t\tfor (var i = 0; i < 3; i++) {\n\t\t\trgb[i] = 255 - this.values.rgb[i];\n\t\t}\n\t\tthis.setValues('rgb', rgb);\n\t\treturn this;\n\t},\n\n\tlighten: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2] += hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tdarken: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[2] -= hsl[2] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tsaturate: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] += hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\tdesaturate: function (ratio) {\n\t\tvar hsl = this.values.hsl;\n\t\thsl[1] -= hsl[1] * ratio;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\twhiten: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[1] += hwb[1] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tblacken: function (ratio) {\n\t\tvar hwb = this.values.hwb;\n\t\thwb[2] += hwb[2] * ratio;\n\t\tthis.setValues('hwb', hwb);\n\t\treturn this;\n\t},\n\n\tgreyscale: function () {\n\t\tvar rgb = this.values.rgb;\n\t\t// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\t\tvar val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;\n\t\tthis.setValues('rgb', [val, val, val]);\n\t\treturn this;\n\t},\n\n\tclearer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha - (alpha * ratio));\n\t\treturn this;\n\t},\n\n\topaquer: function (ratio) {\n\t\tvar alpha = this.values.alpha;\n\t\tthis.setValues('alpha', alpha + (alpha * ratio));\n\t\treturn this;\n\t},\n\n\trotate: function (degrees) {\n\t\tvar hsl = this.values.hsl;\n\t\tvar hue = (hsl[0] + degrees) % 360;\n\t\thsl[0] = hue < 0 ? 360 + hue : hue;\n\t\tthis.setValues('hsl', hsl);\n\t\treturn this;\n\t},\n\n\t/**\n\t * Ported from sass implementation in C\n\t * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209\n\t */\n\tmix: function (mixinColor, weight) {\n\t\tvar color1 = this;\n\t\tvar color2 = mixinColor;\n\t\tvar p = weight === undefined ? 0.5 : weight;\n\n\t\tvar w = 2 * p - 1;\n\t\tvar a = color1.alpha() - color2.alpha();\n\n\t\tvar w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n\t\tvar w2 = 1 - w1;\n\n\t\treturn this\n\t\t\t.rgb(\n\t\t\t\tw1 * color1.red() + w2 * color2.red(),\n\t\t\t\tw1 * color1.green() + w2 * color2.green(),\n\t\t\t\tw1 * color1.blue() + w2 * color2.blue()\n\t\t\t)\n\t\t\t.alpha(color1.alpha() * p + color2.alpha() * (1 - p));\n\t},\n\n\ttoJSON: function () {\n\t\treturn this.rgb();\n\t},\n\n\tclone: function () {\n\t\t// NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,\n\t\t// making the final build way to big to embed in Chart.js. So let's do it manually,\n\t\t// assuming that values to clone are 1 dimension arrays containing only numbers,\n\t\t// except 'alpha' which is a number.\n\t\tvar result = new Color();\n\t\tvar source = this.values;\n\t\tvar target = result.values;\n\t\tvar value, type;\n\n\t\tfor (var prop in source) {\n\t\t\tif (source.hasOwnProperty(prop)) {\n\t\t\t\tvalue = source[prop];\n\t\t\t\ttype = ({}).toString.call(value);\n\t\t\t\tif (type === '[object Array]') {\n\t\t\t\t\ttarget[prop] = value.slice(0);\n\t\t\t\t} else if (type === '[object Number]') {\n\t\t\t\t\ttarget[prop] = value;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('unexpected color value:', value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\nColor.prototype.spaces = {\n\trgb: ['red', 'green', 'blue'],\n\thsl: ['hue', 'saturation', 'lightness'],\n\thsv: ['hue', 'saturation', 'value'],\n\thwb: ['hue', 'whiteness', 'blackness'],\n\tcmyk: ['cyan', 'magenta', 'yellow', 'black']\n};\n\nColor.prototype.maxes = {\n\trgb: [255, 255, 255],\n\thsl: [360, 100, 100],\n\thsv: [360, 100, 100],\n\thwb: [360, 100, 100],\n\tcmyk: [100, 100, 100, 100]\n};\n\nColor.prototype.getValues = function (space) {\n\tvar values = this.values;\n\tvar vals = {};\n\n\tfor (var i = 0; i < space.length; i++) {\n\t\tvals[space.charAt(i)] = values[space][i];\n\t}\n\n\tif (values.alpha !== 1) {\n\t\tvals.a = values.alpha;\n\t}\n\n\t// {r: 255, g: 255, b: 255, a: 0.4}\n\treturn vals;\n};\n\nColor.prototype.setValues = function (space, vals) {\n\tvar values = this.values;\n\tvar spaces = this.spaces;\n\tvar maxes = this.maxes;\n\tvar alpha = 1;\n\tvar i;\n\n\tthis.valid = true;\n\n\tif (space === 'alpha') {\n\t\talpha = vals;\n\t} else if (vals.length) {\n\t\t// [10, 10, 10]\n\t\tvalues[space] = vals.slice(0, space.length);\n\t\talpha = vals[space.length];\n\t} else if (vals[space.charAt(0)] !== undefined) {\n\t\t// {r: 10, g: 10, b: 10}\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[space.charAt(i)];\n\t\t}\n\n\t\talpha = vals.a;\n\t} else if (vals[spaces[space][0]] !== undefined) {\n\t\t// {red: 10, green: 10, blue: 10}\n\t\tvar chans = spaces[space];\n\n\t\tfor (i = 0; i < space.length; i++) {\n\t\t\tvalues[space][i] = vals[chans[i]];\n\t\t}\n\n\t\talpha = vals.alpha;\n\t}\n\n\tvalues.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));\n\n\tif (space === 'alpha') {\n\t\treturn false;\n\t}\n\n\tvar capped;\n\n\t// cap values of the space prior converting all values\n\tfor (i = 0; i < space.length; i++) {\n\t\tcapped = Math.max(0, Math.min(maxes[space][i], values[space][i]));\n\t\tvalues[space][i] = Math.round(capped);\n\t}\n\n\t// convert to all the other color spaces\n\tfor (var sname in spaces) {\n\t\tif (sname !== space) {\n\t\t\tvalues[sname] = colorConvert[space][sname](values[space]);\n\t\t}\n\t}\n\n\treturn true;\n};\n\nColor.prototype.setSpace = function (space, args) {\n\tvar vals = args[0];\n\n\tif (vals === undefined) {\n\t\t// color.rgb()\n\t\treturn this.getValues(space);\n\t}\n\n\t// color.rgb(10, 10, 10)\n\tif (typeof vals === 'number') {\n\t\tvals = Array.prototype.slice.call(args);\n\t}\n\n\tthis.setValues(space, vals);\n\treturn this;\n};\n\nColor.prototype.setChannel = function (space, index, val) {\n\tvar svalues = this.values[space];\n\tif (val === undefined) {\n\t\t// color.red()\n\t\treturn svalues[index];\n\t} else if (val === svalues[index]) {\n\t\t// color.red(color.red())\n\t\treturn this;\n\t}\n\n\t// color.red(100)\n\tsvalues[index] = val;\n\tthis.setValues(space, svalues);\n\n\treturn this;\n};\n\nif (typeof window !== 'undefined') {\n\twindow.Color = Color;\n}\n\nvar chartjsColor = Color;\n\n/**\n * @namespace Chart.helpers\n */\nvar helpers = {\n\t/**\n\t * An empty function that can be used, for example, for optional callback.\n\t */\n\tnoop: function() {},\n\n\t/**\n\t * Returns a unique id, sequentially generated from a global variable.\n\t * @returns {number}\n\t * @function\n\t */\n\tuid: (function() {\n\t\tvar id = 0;\n\t\treturn function() {\n\t\t\treturn id++;\n\t\t};\n\t}()),\n\n\t/**\n\t * Returns true if `value` is neither null nor undefined, else returns false.\n\t * @param {*} value - The value to test.\n\t * @returns {boolean}\n\t * @since 2.7.0\n\t */\n\tisNullOrUndef: function(value) {\n\t\treturn value === null || typeof value === 'undefined';\n\t},\n\n\t/**\n\t * Returns true if `value` is an array (including typed arrays), else returns false.\n\t * @param {*} value - The value to test.\n\t * @returns {boolean}\n\t * @function\n\t */\n\tisArray: function(value) {\n\t\tif (Array.isArray && Array.isArray(value)) {\n\t\t\treturn true;\n\t\t}\n\t\tvar type = Object.prototype.toString.call(value);\n\t\tif (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\t/**\n\t * Returns true if `value` is an object (excluding null), else returns false.\n\t * @param {*} value - The value to test.\n\t * @returns {boolean}\n\t * @since 2.7.0\n\t */\n\tisObject: function(value) {\n\t\treturn value !== null && Object.prototype.toString.call(value) === '[object Object]';\n\t},\n\n\t/**\n\t * Returns true if `value` is a finite number, else returns false\n\t * @param {*} value  - The value to test.\n\t * @returns {boolean}\n\t */\n\tisFinite: function(value) {\n\t\treturn (typeof value === 'number' || value instanceof Number) && isFinite(value);\n\t},\n\n\t/**\n\t * Returns `value` if defined, else returns `defaultValue`.\n\t * @param {*} value - The value to return if defined.\n\t * @param {*} defaultValue - The value to return if `value` is undefined.\n\t * @returns {*}\n\t */\n\tvalueOrDefault: function(value, defaultValue) {\n\t\treturn typeof value === 'undefined' ? defaultValue : value;\n\t},\n\n\t/**\n\t * Returns value at the given `index` in array if defined, else returns `defaultValue`.\n\t * @param {Array} value - The array to lookup for value at `index`.\n\t * @param {number} index - The index in `value` to lookup for value.\n\t * @param {*} defaultValue - The value to return if `value[index]` is undefined.\n\t * @returns {*}\n\t */\n\tvalueAtIndexOrDefault: function(value, index, defaultValue) {\n\t\treturn helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);\n\t},\n\n\t/**\n\t * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n\t * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n\t * @param {function} fn - The function to call.\n\t * @param {Array|undefined|null} args - The arguments with which `fn` should be called.\n\t * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.\n\t * @returns {*}\n\t */\n\tcallback: function(fn, args, thisArg) {\n\t\tif (fn && typeof fn.call === 'function') {\n\t\t\treturn fn.apply(thisArg, args);\n\t\t}\n\t},\n\n\t/**\n\t * Note(SB) for performance sake, this method should only be used when loopable type\n\t * is unknown or in none intensive code (not called often and small loopable). Else\n\t * it's preferable to use a regular for() loop and save extra function calls.\n\t * @param {object|Array} loopable - The object or array to be iterated.\n\t * @param {function} fn - The function to call for each item.\n\t * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.\n\t * @param {boolean} [reverse] - If true, iterates backward on the loopable.\n\t */\n\teach: function(loopable, fn, thisArg, reverse) {\n\t\tvar i, len, keys;\n\t\tif (helpers.isArray(loopable)) {\n\t\t\tlen = loopable.length;\n\t\t\tif (reverse) {\n\t\t\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\t\t\tfn.call(thisArg, loopable[i], i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tfn.call(thisArg, loopable[i], i);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (helpers.isObject(loopable)) {\n\t\t\tkeys = Object.keys(loopable);\n\t\t\tlen = keys.length;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tfn.call(thisArg, loopable[keys[i]], keys[i]);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n\t * @see https://stackoverflow.com/a/14853974\n\t * @param {Array} a0 - The array to compare\n\t * @param {Array} a1 - The array to compare\n\t * @returns {boolean}\n\t */\n\tarrayEquals: function(a0, a1) {\n\t\tvar i, ilen, v0, v1;\n\n\t\tif (!a0 || !a1 || a0.length !== a1.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (i = 0, ilen = a0.length; i < ilen; ++i) {\n\t\t\tv0 = a0[i];\n\t\t\tv1 = a1[i];\n\n\t\t\tif (v0 instanceof Array && v1 instanceof Array) {\n\t\t\t\tif (!helpers.arrayEquals(v0, v1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (v0 !== v1) {\n\t\t\t\t// NOTE: two different object instances will never be equal: {x:20} != {x:20}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Returns a deep copy of `source` without keeping references on objects and arrays.\n\t * @param {*} source - The value to clone.\n\t * @returns {*}\n\t */\n\tclone: function(source) {\n\t\tif (helpers.isArray(source)) {\n\t\t\treturn source.map(helpers.clone);\n\t\t}\n\n\t\tif (helpers.isObject(source)) {\n\t\t\tvar target = {};\n\t\t\tvar keys = Object.keys(source);\n\t\t\tvar klen = keys.length;\n\t\t\tvar k = 0;\n\n\t\t\tfor (; k < klen; ++k) {\n\t\t\t\ttarget[keys[k]] = helpers.clone(source[keys[k]]);\n\t\t\t}\n\n\t\t\treturn target;\n\t\t}\n\n\t\treturn source;\n\t},\n\n\t/**\n\t * The default merger when Chart.helpers.merge is called without merger option.\n\t * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n\t * @private\n\t */\n\t_merger: function(key, target, source, options) {\n\t\tvar tval = target[key];\n\t\tvar sval = source[key];\n\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\n\t\t\thelpers.merge(tval, sval, options);\n\t\t} else {\n\t\t\ttarget[key] = helpers.clone(sval);\n\t\t}\n\t},\n\n\t/**\n\t * Merges source[key] in target[key] only if target[key] is undefined.\n\t * @private\n\t */\n\t_mergerIf: function(key, target, source) {\n\t\tvar tval = target[key];\n\t\tvar sval = source[key];\n\n\t\tif (helpers.isObject(tval) && helpers.isObject(sval)) {\n\t\t\thelpers.mergeIf(tval, sval);\n\t\t} else if (!target.hasOwnProperty(key)) {\n\t\t\ttarget[key] = helpers.clone(sval);\n\t\t}\n\t},\n\n\t/**\n\t * Recursively deep copies `source` properties into `target` with the given `options`.\n\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n\t * @param {object} target - The target object in which all sources are merged into.\n\t * @param {object|object[]} source - Object(s) to merge into `target`.\n\t * @param {object} [options] - Merging options:\n\t * @param {function} [options.merger] - The merge method (key, target, source, options)\n\t * @returns {object} The `target` object.\n\t */\n\tmerge: function(target, source, options) {\n\t\tvar sources = helpers.isArray(source) ? source : [source];\n\t\tvar ilen = sources.length;\n\t\tvar merge, i, keys, klen, k;\n\n\t\tif (!helpers.isObject(target)) {\n\t\t\treturn target;\n\t\t}\n\n\t\toptions = options || {};\n\t\tmerge = options.merger || helpers._merger;\n\n\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\tsource = sources[i];\n\t\t\tif (!helpers.isObject(source)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tkeys = Object.keys(source);\n\t\t\tfor (k = 0, klen = keys.length; k < klen; ++k) {\n\t\t\t\tmerge(keys[k], target, source, options);\n\t\t\t}\n\t\t}\n\n\t\treturn target;\n\t},\n\n\t/**\n\t * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n\t * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n\t * @param {object} target - The target object in which all sources are merged into.\n\t * @param {object|object[]} source - Object(s) to merge into `target`.\n\t * @returns {object} The `target` object.\n\t */\n\tmergeIf: function(target, source) {\n\t\treturn helpers.merge(target, source, {merger: helpers._mergerIf});\n\t},\n\n\t/**\n\t * Applies the contents of two or more objects together into the first object.\n\t * @param {object} target - The target object in which all objects are merged into.\n\t * @param {object} arg1 - Object containing additional properties to merge in target.\n\t * @param {object} argN - Additional objects containing properties to merge in target.\n\t * @returns {object} The `target` object.\n\t */\n\textend: function(target) {\n\t\tvar setFn = function(value, key) {\n\t\t\ttarget[key] = value;\n\t\t};\n\t\tfor (var i = 1, ilen = arguments.length; i < ilen; ++i) {\n\t\t\thelpers.each(arguments[i], setFn);\n\t\t}\n\t\treturn target;\n\t},\n\n\t/**\n\t * Basic javascript inheritance based on the model created in Backbone.js\n\t */\n\tinherits: function(extensions) {\n\t\tvar me = this;\n\t\tvar ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {\n\t\t\treturn me.apply(this, arguments);\n\t\t};\n\n\t\tvar Surrogate = function() {\n\t\t\tthis.constructor = ChartElement;\n\t\t};\n\n\t\tSurrogate.prototype = me.prototype;\n\t\tChartElement.prototype = new Surrogate();\n\t\tChartElement.extend = helpers.inherits;\n\n\t\tif (extensions) {\n\t\t\thelpers.extend(ChartElement.prototype, extensions);\n\t\t}\n\n\t\tChartElement.__super__ = me.prototype;\n\t\treturn ChartElement;\n\t}\n};\n\nvar helpers_core = helpers;\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart.helpers.callback instead.\n * @function Chart.helpers.callCallback\n * @deprecated since version 2.6.0\n * @todo remove at version 3\n * @private\n */\nhelpers.callCallback = helpers.callback;\n\n/**\n * Provided for backward compatibility, use Array.prototype.indexOf instead.\n * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+\n * @function Chart.helpers.indexOf\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.indexOf = function(array, item, fromIndex) {\n\treturn Array.prototype.indexOf.call(array, item, fromIndex);\n};\n\n/**\n * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.\n * @function Chart.helpers.getValueOrDefault\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.getValueOrDefault = helpers.valueOrDefault;\n\n/**\n * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.\n * @function Chart.helpers.getValueAtIndexOrDefault\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;\n\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easingEffects\n * @see http://www.robertpenner.com/easing/\n */\nvar effects = {\n\tlinear: function(t) {\n\t\treturn t;\n\t},\n\n\teaseInQuad: function(t) {\n\t\treturn t * t;\n\t},\n\n\teaseOutQuad: function(t) {\n\t\treturn -t * (t - 2);\n\t},\n\n\teaseInOutQuad: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t;\n\t\t}\n\t\treturn -0.5 * ((--t) * (t - 2) - 1);\n\t},\n\n\teaseInCubic: function(t) {\n\t\treturn t * t * t;\n\t},\n\n\teaseOutCubic: function(t) {\n\t\treturn (t = t - 1) * t * t + 1;\n\t},\n\n\teaseInOutCubic: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t;\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * t + 2);\n\t},\n\n\teaseInQuart: function(t) {\n\t\treturn t * t * t * t;\n\t},\n\n\teaseOutQuart: function(t) {\n\t\treturn -((t = t - 1) * t * t * t - 1);\n\t},\n\n\teaseInOutQuart: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t * t;\n\t\t}\n\t\treturn -0.5 * ((t -= 2) * t * t * t - 2);\n\t},\n\n\teaseInQuint: function(t) {\n\t\treturn t * t * t * t * t;\n\t},\n\n\teaseOutQuint: function(t) {\n\t\treturn (t = t - 1) * t * t * t * t + 1;\n\t},\n\n\teaseInOutQuint: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * t * t * t * t * t;\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * t * t * t + 2);\n\t},\n\n\teaseInSine: function(t) {\n\t\treturn -Math.cos(t * (Math.PI / 2)) + 1;\n\t},\n\n\teaseOutSine: function(t) {\n\t\treturn Math.sin(t * (Math.PI / 2));\n\t},\n\n\teaseInOutSine: function(t) {\n\t\treturn -0.5 * (Math.cos(Math.PI * t) - 1);\n\t},\n\n\teaseInExpo: function(t) {\n\t\treturn (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));\n\t},\n\n\teaseOutExpo: function(t) {\n\t\treturn (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;\n\t},\n\n\teaseInOutExpo: function(t) {\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * Math.pow(2, 10 * (t - 1));\n\t\t}\n\t\treturn 0.5 * (-Math.pow(2, -10 * --t) + 2);\n\t},\n\n\teaseInCirc: function(t) {\n\t\tif (t >= 1) {\n\t\t\treturn t;\n\t\t}\n\t\treturn -(Math.sqrt(1 - t * t) - 1);\n\t},\n\n\teaseOutCirc: function(t) {\n\t\treturn Math.sqrt(1 - (t = t - 1) * t);\n\t},\n\n\teaseInOutCirc: function(t) {\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn -0.5 * (Math.sqrt(1 - t * t) - 1);\n\t\t}\n\t\treturn 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);\n\t},\n\n\teaseInElastic: function(t) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.3;\n\t\t}\n\t\tif (a < 1) {\n\t\t\ta = 1;\n\t\t\ts = p / 4;\n\t\t} else {\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\treturn -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n\t},\n\n\teaseOutElastic: function(t) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.3;\n\t\t}\n\t\tif (a < 1) {\n\t\t\ta = 1;\n\t\t\ts = p / 4;\n\t\t} else {\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\treturn a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;\n\t},\n\n\teaseInOutElastic: function(t) {\n\t\tvar s = 1.70158;\n\t\tvar p = 0;\n\t\tvar a = 1;\n\t\tif (t === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif ((t /= 0.5) === 2) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tp = 0.45;\n\t\t}\n\t\tif (a < 1) {\n\t\t\ta = 1;\n\t\t\ts = p / 4;\n\t\t} else {\n\t\t\ts = p / (2 * Math.PI) * Math.asin(1 / a);\n\t\t}\n\t\tif (t < 1) {\n\t\t\treturn -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));\n\t\t}\n\t\treturn a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t},\n\teaseInBack: function(t) {\n\t\tvar s = 1.70158;\n\t\treturn t * t * ((s + 1) * t - s);\n\t},\n\n\teaseOutBack: function(t) {\n\t\tvar s = 1.70158;\n\t\treturn (t = t - 1) * t * ((s + 1) * t + s) + 1;\n\t},\n\n\teaseInOutBack: function(t) {\n\t\tvar s = 1.70158;\n\t\tif ((t /= 0.5) < 1) {\n\t\t\treturn 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n\t\t}\n\t\treturn 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n\t},\n\n\teaseInBounce: function(t) {\n\t\treturn 1 - effects.easeOutBounce(1 - t);\n\t},\n\n\teaseOutBounce: function(t) {\n\t\tif (t < (1 / 2.75)) {\n\t\t\treturn 7.5625 * t * t;\n\t\t}\n\t\tif (t < (2 / 2.75)) {\n\t\t\treturn 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;\n\t\t}\n\t\tif (t < (2.5 / 2.75)) {\n\t\t\treturn 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;\n\t\t}\n\t\treturn 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;\n\t},\n\n\teaseInOutBounce: function(t) {\n\t\tif (t < 0.5) {\n\t\t\treturn effects.easeInBounce(t * 2) * 0.5;\n\t\t}\n\t\treturn effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;\n\t}\n};\n\nvar helpers_easing = {\n\teffects: effects\n};\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart.helpers.easing.effects instead.\n * @function Chart.helpers.easingEffects\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers_core.easingEffects = effects;\n\nvar PI = Math.PI;\nvar RAD_PER_DEG = PI / 180;\nvar DOUBLE_PI = PI * 2;\nvar HALF_PI = PI / 2;\nvar QUARTER_PI = PI / 4;\nvar TWO_THIRDS_PI = PI * 2 / 3;\n\n/**\n * @namespace Chart.helpers.canvas\n */\nvar exports$1 = {\n\t/**\n\t * Clears the entire canvas associated to the given `chart`.\n\t * @param {Chart} chart - The chart for which to clear the canvas.\n\t */\n\tclear: function(chart) {\n\t\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\n\t},\n\n\t/**\n\t * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with a\n\t * given size (width, height) and the same `radius` for all corners.\n\t * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\n\t * @param {number} x - The x axis of the coordinate for the rectangle starting point.\n\t * @param {number} y - The y axis of the coordinate for the rectangle starting point.\n\t * @param {number} width - The rectangle's width.\n\t * @param {number} height - The rectangle's height.\n\t * @param {number} radius - The rounded amount (in pixels) for the four corners.\n\t * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?\n\t */\n\troundedRect: function(ctx, x, y, width, height, radius) {\n\t\tif (radius) {\n\t\t\tvar r = Math.min(radius, height / 2, width / 2);\n\t\t\tvar left = x + r;\n\t\t\tvar top = y + r;\n\t\t\tvar right = x + width - r;\n\t\t\tvar bottom = y + height - r;\n\n\t\t\tctx.moveTo(x, top);\n\t\t\tif (left < right && top < bottom) {\n\t\t\t\tctx.arc(left, top, r, -PI, -HALF_PI);\n\t\t\t\tctx.arc(right, top, r, -HALF_PI, 0);\n\t\t\t\tctx.arc(right, bottom, r, 0, HALF_PI);\n\t\t\t\tctx.arc(left, bottom, r, HALF_PI, PI);\n\t\t\t} else if (left < right) {\n\t\t\t\tctx.moveTo(left, y);\n\t\t\t\tctx.arc(right, top, r, -HALF_PI, HALF_PI);\n\t\t\t\tctx.arc(left, top, r, HALF_PI, PI + HALF_PI);\n\t\t\t} else if (top < bottom) {\n\t\t\t\tctx.arc(left, top, r, -PI, 0);\n\t\t\t\tctx.arc(left, bottom, r, 0, PI);\n\t\t\t} else {\n\t\t\t\tctx.arc(left, top, r, -PI, PI);\n\t\t\t}\n\t\t\tctx.closePath();\n\t\t\tctx.moveTo(x, y);\n\t\t} else {\n\t\t\tctx.rect(x, y, width, height);\n\t\t}\n\t},\n\n\tdrawPoint: function(ctx, style, radius, x, y, rotation) {\n\t\tvar type, xOffset, yOffset, size, cornerRadius;\n\t\tvar rad = (rotation || 0) * RAD_PER_DEG;\n\n\t\tif (style && typeof style === 'object') {\n\t\t\ttype = style.toString();\n\t\t\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n\t\t\t\tctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (isNaN(radius) || radius <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tctx.beginPath();\n\n\t\tswitch (style) {\n\t\t// Default includes circle\n\t\tdefault:\n\t\t\tctx.arc(x, y, radius, 0, DOUBLE_PI);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'triangle':\n\t\t\tctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n\t\t\trad += TWO_THIRDS_PI;\n\t\t\tctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n\t\t\trad += TWO_THIRDS_PI;\n\t\t\tctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'rectRounded':\n\t\t\t// NOTE: the rounded rect implementation changed to use `arc` instead of\n\t\t\t// `quadraticCurveTo` since it generates better results when rect is\n\t\t\t// almost a circle. 0.516 (instead of 0.5) produces results with visually\n\t\t\t// closer proportion to the previous impl and it is inscribed in the\n\t\t\t// circle with `radius`. For more details, see the following PRs:\n\t\t\t// https://github.com/chartjs/Chart.js/issues/5597\n\t\t\t// https://github.com/chartjs/Chart.js/issues/5858\n\t\t\tcornerRadius = radius * 0.516;\n\t\t\tsize = radius - cornerRadius;\n\t\t\txOffset = Math.cos(rad + QUARTER_PI) * size;\n\t\t\tyOffset = Math.sin(rad + QUARTER_PI) * size;\n\t\t\tctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n\t\t\tctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n\t\t\tctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n\t\t\tctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'rect':\n\t\t\tif (!rotation) {\n\t\t\t\tsize = Math.SQRT1_2 * radius;\n\t\t\t\tctx.rect(x - size, y - size, 2 * size, 2 * size);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trad += QUARTER_PI;\n\t\t\t/* falls through */\n\t\tcase 'rectRot':\n\t\t\txOffset = Math.cos(rad) * radius;\n\t\t\tyOffset = Math.sin(rad) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + yOffset, y - xOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.lineTo(x - yOffset, y + xOffset);\n\t\t\tctx.closePath();\n\t\t\tbreak;\n\t\tcase 'crossRot':\n\t\t\trad += QUARTER_PI;\n\t\t\t/* falls through */\n\t\tcase 'cross':\n\t\t\txOffset = Math.cos(rad) * radius;\n\t\t\tyOffset = Math.sin(rad) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x + yOffset, y - xOffset);\n\t\t\tctx.lineTo(x - yOffset, y + xOffset);\n\t\t\tbreak;\n\t\tcase 'star':\n\t\t\txOffset = Math.cos(rad) * radius;\n\t\t\tyOffset = Math.sin(rad) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x + yOffset, y - xOffset);\n\t\t\tctx.lineTo(x - yOffset, y + xOffset);\n\t\t\trad += QUARTER_PI;\n\t\t\txOffset = Math.cos(rad) * radius;\n\t\t\tyOffset = Math.sin(rad) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tctx.moveTo(x + yOffset, y - xOffset);\n\t\t\tctx.lineTo(x - yOffset, y + xOffset);\n\t\t\tbreak;\n\t\tcase 'line':\n\t\t\txOffset = Math.cos(rad) * radius;\n\t\t\tyOffset = Math.sin(rad) * radius;\n\t\t\tctx.moveTo(x - xOffset, y - yOffset);\n\t\t\tctx.lineTo(x + xOffset, y + yOffset);\n\t\t\tbreak;\n\t\tcase 'dash':\n\t\t\tctx.moveTo(x, y);\n\t\t\tctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n\t\t\tbreak;\n\t\t}\n\n\t\tctx.fill();\n\t\tctx.stroke();\n\t},\n\n\t/**\n\t * Returns true if the point is inside the rectangle\n\t * @param {object} point - The point to test\n\t * @param {object} area - The rectangle\n\t * @returns {boolean}\n\t * @private\n\t */\n\t_isPointInArea: function(point, area) {\n\t\tvar epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\n\n\t\treturn point.x > area.left - epsilon && point.x < area.right + epsilon &&\n\t\t\tpoint.y > area.top - epsilon && point.y < area.bottom + epsilon;\n\t},\n\n\tclipArea: function(ctx, area) {\n\t\tctx.save();\n\t\tctx.beginPath();\n\t\tctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n\t\tctx.clip();\n\t},\n\n\tunclipArea: function(ctx) {\n\t\tctx.restore();\n\t},\n\n\tlineTo: function(ctx, previous, target, flip) {\n\t\tvar stepped = target.steppedLine;\n\t\tif (stepped) {\n\t\t\tif (stepped === 'middle') {\n\t\t\t\tvar midpoint = (previous.x + target.x) / 2.0;\n\t\t\t\tctx.lineTo(midpoint, flip ? target.y : previous.y);\n\t\t\t\tctx.lineTo(midpoint, flip ? previous.y : target.y);\n\t\t\t} else if ((stepped === 'after' && !flip) || (stepped !== 'after' && flip)) {\n\t\t\t\tctx.lineTo(previous.x, target.y);\n\t\t\t} else {\n\t\t\t\tctx.lineTo(target.x, previous.y);\n\t\t\t}\n\t\t\tctx.lineTo(target.x, target.y);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!target.tension) {\n\t\t\tctx.lineTo(target.x, target.y);\n\t\t\treturn;\n\t\t}\n\n\t\tctx.bezierCurveTo(\n\t\t\tflip ? previous.controlPointPreviousX : previous.controlPointNextX,\n\t\t\tflip ? previous.controlPointPreviousY : previous.controlPointNextY,\n\t\t\tflip ? target.controlPointNextX : target.controlPointPreviousX,\n\t\t\tflip ? target.controlPointNextY : target.controlPointPreviousY,\n\t\t\ttarget.x,\n\t\t\ttarget.y);\n\t}\n};\n\nvar helpers_canvas = exports$1;\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.\n * @namespace Chart.helpers.clear\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers_core.clear = exports$1.clear;\n\n/**\n * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.\n * @namespace Chart.helpers.drawRoundedRectangle\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers_core.drawRoundedRectangle = function(ctx) {\n\tctx.beginPath();\n\texports$1.roundedRect.apply(exports$1, arguments);\n};\n\nvar defaults = {\n\t/**\n\t * @private\n\t */\n\t_set: function(scope, values) {\n\t\treturn helpers_core.merge(this[scope] || (this[scope] = {}), values);\n\t}\n};\n\ndefaults._set('global', {\n\tdefaultColor: 'rgba(0,0,0,0.1)',\n\tdefaultFontColor: '#666',\n\tdefaultFontFamily: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n\tdefaultFontSize: 12,\n\tdefaultFontStyle: 'normal',\n\tdefaultLineHeight: 1.2,\n\tshowLines: true\n});\n\nvar core_defaults = defaults;\n\nvar valueOrDefault = helpers_core.valueOrDefault;\n\n/**\n * Converts the given font object into a CSS font string.\n * @param {object} font - A font object.\n * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */\nfunction toFontString(font) {\n\tif (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {\n\t\treturn null;\n\t}\n\n\treturn (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\n\n/**\n * @alias Chart.helpers.options\n * @namespace\n */\nvar helpers_options = {\n\t/**\n\t * Converts the given line height `value` in pixels for a specific font `size`.\n\t * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n\t * @param {number} size - The font size (in pixels) used to resolve relative `value`.\n\t * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).\n\t * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n\t * @since 2.7.0\n\t */\n\ttoLineHeight: function(value, size) {\n\t\tvar matches = ('' + value).match(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\n\t\tif (!matches || matches[1] === 'normal') {\n\t\t\treturn size * 1.2;\n\t\t}\n\n\t\tvalue = +matches[2];\n\n\t\tswitch (matches[3]) {\n\t\tcase 'px':\n\t\t\treturn value;\n\t\tcase '%':\n\t\t\tvalue /= 100;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\treturn size * value;\n\t},\n\n\t/**\n\t * Converts the given value into a padding object with pre-computed width/height.\n\t * @param {number|object} value - If a number, set the value to all TRBL component,\n\t *  else, if and object, use defined properties and sets undefined ones to 0.\n\t * @returns {object} The padding values (top, right, bottom, left, width, height)\n\t * @since 2.7.0\n\t */\n\ttoPadding: function(value) {\n\t\tvar t, r, b, l;\n\n\t\tif (helpers_core.isObject(value)) {\n\t\t\tt = +value.top || 0;\n\t\t\tr = +value.right || 0;\n\t\t\tb = +value.bottom || 0;\n\t\t\tl = +value.left || 0;\n\t\t} else {\n\t\t\tt = r = b = l = +value || 0;\n\t\t}\n\n\t\treturn {\n\t\t\ttop: t,\n\t\t\tright: r,\n\t\t\tbottom: b,\n\t\t\tleft: l,\n\t\t\theight: t + b,\n\t\t\twidth: l + r\n\t\t};\n\t},\n\n\t/**\n\t * Parses font options and returns the font object.\n\t * @param {object} options - A object that contains font options to be parsed.\n\t * @return {object} The font object.\n\t * @todo Support font.* options and renamed to toFont().\n\t * @private\n\t */\n\t_parseFont: function(options) {\n\t\tvar globalDefaults = core_defaults.global;\n\t\tvar size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n\t\tvar font = {\n\t\t\tfamily: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),\n\t\t\tlineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),\n\t\t\tsize: size,\n\t\t\tstyle: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),\n\t\t\tweight: null,\n\t\t\tstring: ''\n\t\t};\n\n\t\tfont.string = toFontString(font);\n\t\treturn font;\n\t},\n\n\t/**\n\t * Evaluates the given `inputs` sequentially and returns the first defined value.\n\t * @param {Array} inputs - An array of values, falling back to the last value.\n\t * @param {object} [context] - If defined and the current value is a function, the value\n\t * is called with `context` as first argument and the result becomes the new input.\n\t * @param {number} [index] - If defined and the current value is an array, the value\n\t * at `index` become the new input.\n\t * @since 2.7.0\n\t */\n\tresolve: function(inputs, context, index) {\n\t\tvar i, ilen, value;\n\n\t\tfor (i = 0, ilen = inputs.length; i < ilen; ++i) {\n\t\t\tvalue = inputs[i];\n\t\t\tif (value === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (context !== undefined && typeof value === 'function') {\n\t\t\t\tvalue = value(context);\n\t\t\t}\n\t\t\tif (index !== undefined && helpers_core.isArray(value)) {\n\t\t\t\tvalue = value[index];\n\t\t\t}\n\t\t\tif (value !== undefined) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t}\n};\n\nvar helpers$1 = helpers_core;\nvar easing = helpers_easing;\nvar canvas = helpers_canvas;\nvar options = helpers_options;\nhelpers$1.easing = easing;\nhelpers$1.canvas = canvas;\nhelpers$1.options = options;\n\nfunction interpolate(start, view, model, ease) {\n\tvar keys = Object.keys(model);\n\tvar i, ilen, key, actual, origin, target, type, c0, c1;\n\n\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\tkey = keys[i];\n\n\t\ttarget = model[key];\n\n\t\t// if a value is added to the model after pivot() has been called, the view\n\t\t// doesn't contain it, so let's initialize the view to the target value.\n\t\tif (!view.hasOwnProperty(key)) {\n\t\t\tview[key] = target;\n\t\t}\n\n\t\tactual = view[key];\n\n\t\tif (actual === target || key[0] === '_') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!start.hasOwnProperty(key)) {\n\t\t\tstart[key] = actual;\n\t\t}\n\n\t\torigin = start[key];\n\n\t\ttype = typeof target;\n\n\t\tif (type === typeof origin) {\n\t\t\tif (type === 'string') {\n\t\t\t\tc0 = chartjsColor(origin);\n\t\t\t\tif (c0.valid) {\n\t\t\t\t\tc1 = chartjsColor(target);\n\t\t\t\t\tif (c1.valid) {\n\t\t\t\t\t\tview[key] = c1.mix(c0, ease).rgbString();\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {\n\t\t\t\tview[key] = origin + (target - origin) * ease;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tview[key] = target;\n\t}\n}\n\nvar Element = function(configuration) {\n\thelpers$1.extend(this, configuration);\n\tthis.initialize.apply(this, arguments);\n};\n\nhelpers$1.extend(Element.prototype, {\n\n\tinitialize: function() {\n\t\tthis.hidden = false;\n\t},\n\n\tpivot: function() {\n\t\tvar me = this;\n\t\tif (!me._view) {\n\t\t\tme._view = helpers$1.clone(me._model);\n\t\t}\n\t\tme._start = {};\n\t\treturn me;\n\t},\n\n\ttransition: function(ease) {\n\t\tvar me = this;\n\t\tvar model = me._model;\n\t\tvar start = me._start;\n\t\tvar view = me._view;\n\n\t\t// No animation -> No Transition\n\t\tif (!model || ease === 1) {\n\t\t\tme._view = model;\n\t\t\tme._start = null;\n\t\t\treturn me;\n\t\t}\n\n\t\tif (!view) {\n\t\t\tview = me._view = {};\n\t\t}\n\n\t\tif (!start) {\n\t\t\tstart = me._start = {};\n\t\t}\n\n\t\tinterpolate(start, view, model, ease);\n\n\t\treturn me;\n\t},\n\n\ttooltipPosition: function() {\n\t\treturn {\n\t\t\tx: this._model.x,\n\t\t\ty: this._model.y\n\t\t};\n\t},\n\n\thasValue: function() {\n\t\treturn helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);\n\t}\n});\n\nElement.extend = helpers$1.inherits;\n\nvar core_element = Element;\n\nvar exports$2 = core_element.extend({\n\tchart: null, // the animation associated chart instance\n\tcurrentStep: 0, // the current animation step\n\tnumSteps: 60, // default number of steps\n\teasing: '', // the easing to use for this animation\n\trender: null, // render function used by the animation service\n\n\tonAnimationProgress: null, // user specified callback to fire on each step of the animation\n\tonAnimationComplete: null, // user specified callback to fire when the animation finishes\n});\n\nvar core_animation = exports$2;\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart.Animation instead\n * @prop Chart.Animation#animationObject\n * @deprecated since version 2.6.0\n * @todo remove at version 3\n */\nObject.defineProperty(exports$2.prototype, 'animationObject', {\n\tget: function() {\n\t\treturn this;\n\t}\n});\n\n/**\n * Provided for backward compatibility, use Chart.Animation#chart instead\n * @prop Chart.Animation#chartInstance\n * @deprecated since version 2.6.0\n * @todo remove at version 3\n */\nObject.defineProperty(exports$2.prototype, 'chartInstance', {\n\tget: function() {\n\t\treturn this.chart;\n\t},\n\tset: function(value) {\n\t\tthis.chart = value;\n\t}\n});\n\ncore_defaults._set('global', {\n\tanimation: {\n\t\tduration: 1000,\n\t\teasing: 'easeOutQuart',\n\t\tonProgress: helpers$1.noop,\n\t\tonComplete: helpers$1.noop\n\t}\n});\n\nvar core_animations = {\n\tanimations: [],\n\trequest: null,\n\n\t/**\n\t * @param {Chart} chart - The chart to animate.\n\t * @param {Chart.Animation} animation - The animation that we will animate.\n\t * @param {number} duration - The animation duration in ms.\n\t * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions\n\t */\n\taddAnimation: function(chart, animation, duration, lazy) {\n\t\tvar animations = this.animations;\n\t\tvar i, ilen;\n\n\t\tanimation.chart = chart;\n\t\tanimation.startTime = Date.now();\n\t\tanimation.duration = duration;\n\n\t\tif (!lazy) {\n\t\t\tchart.animating = true;\n\t\t}\n\n\t\tfor (i = 0, ilen = animations.length; i < ilen; ++i) {\n\t\t\tif (animations[i].chart === chart) {\n\t\t\t\tanimations[i] = animation;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tanimations.push(animation);\n\n\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\n\t\tif (animations.length === 1) {\n\t\t\tthis.requestAnimationFrame();\n\t\t}\n\t},\n\n\tcancelAnimation: function(chart) {\n\t\tvar index = helpers$1.findIndex(this.animations, function(animation) {\n\t\t\treturn animation.chart === chart;\n\t\t});\n\n\t\tif (index !== -1) {\n\t\t\tthis.animations.splice(index, 1);\n\t\t\tchart.animating = false;\n\t\t}\n\t},\n\n\trequestAnimationFrame: function() {\n\t\tvar me = this;\n\t\tif (me.request === null) {\n\t\t\t// Skip animation frame requests until the active one is executed.\n\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'\n\t\t\t// and 'mouseout' events will trigger multiple renders.\n\t\t\tme.request = helpers$1.requestAnimFrame.call(window, function() {\n\t\t\t\tme.request = null;\n\t\t\t\tme.startDigest();\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * @private\n\t */\n\tstartDigest: function() {\n\t\tvar me = this;\n\n\t\tme.advance();\n\n\t\t// Do we have more stuff to animate?\n\t\tif (me.animations.length > 0) {\n\t\t\tme.requestAnimationFrame();\n\t\t}\n\t},\n\n\t/**\n\t * @private\n\t */\n\tadvance: function() {\n\t\tvar animations = this.animations;\n\t\tvar animation, chart, numSteps, nextStep;\n\t\tvar i = 0;\n\n\t\t// 1 animation per chart, so we are looping charts here\n\t\twhile (i < animations.length) {\n\t\t\tanimation = animations[i];\n\t\t\tchart = animation.chart;\n\t\t\tnumSteps = animation.numSteps;\n\n\t\t\t// Make sure that currentStep starts at 1\n\t\t\t// https://github.com/chartjs/Chart.js/issues/6104\n\t\t\tnextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;\n\t\t\tanimation.currentStep = Math.min(nextStep, numSteps);\n\n\t\t\thelpers$1.callback(animation.render, [chart, animation], chart);\n\t\t\thelpers$1.callback(animation.onAnimationProgress, [animation], chart);\n\n\t\t\tif (animation.currentStep >= numSteps) {\n\t\t\t\thelpers$1.callback(animation.onAnimationComplete, [animation], chart);\n\t\t\t\tchart.animating = false;\n\t\t\t\tanimations.splice(i, 1);\n\t\t\t} else {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n};\n\nvar resolve = helpers$1.options.resolve;\n\nvar arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];\n\n/**\n * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.\n */\nfunction listenArrayEvents(array, listener) {\n\tif (array._chartjs) {\n\t\tarray._chartjs.listeners.push(listener);\n\t\treturn;\n\t}\n\n\tObject.defineProperty(array, '_chartjs', {\n\t\tconfigurable: true,\n\t\tenumerable: false,\n\t\tvalue: {\n\t\t\tlisteners: [listener]\n\t\t}\n\t});\n\n\tarrayEvents.forEach(function(key) {\n\t\tvar method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);\n\t\tvar base = array[key];\n\n\t\tObject.defineProperty(array, key, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: function() {\n\t\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\t\tvar res = base.apply(this, args);\n\n\t\t\t\thelpers$1.each(array._chartjs.listeners, function(object) {\n\t\t\t\t\tif (typeof object[method] === 'function') {\n\t\t\t\t\t\tobject[method].apply(object, args);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Removes the given array event listener and cleanup extra attached properties (such as\n * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n */\nfunction unlistenArrayEvents(array, listener) {\n\tvar stub = array._chartjs;\n\tif (!stub) {\n\t\treturn;\n\t}\n\n\tvar listeners = stub.listeners;\n\tvar index = listeners.indexOf(listener);\n\tif (index !== -1) {\n\t\tlisteners.splice(index, 1);\n\t}\n\n\tif (listeners.length > 0) {\n\t\treturn;\n\t}\n\n\tarrayEvents.forEach(function(key) {\n\t\tdelete array[key];\n\t});\n\n\tdelete array._chartjs;\n}\n\n// Base class for all dataset controllers (line, bar, etc)\nvar DatasetController = function(chart, datasetIndex) {\n\tthis.initialize(chart, datasetIndex);\n};\n\nhelpers$1.extend(DatasetController.prototype, {\n\n\t/**\n\t * Element type used to generate a meta dataset (e.g. Chart.element.Line).\n\t * @type {Chart.core.element}\n\t */\n\tdatasetElementType: null,\n\n\t/**\n\t * Element type used to generate a meta data (e.g. Chart.element.Point).\n\t * @type {Chart.core.element}\n\t */\n\tdataElementType: null,\n\n\tinitialize: function(chart, datasetIndex) {\n\t\tvar me = this;\n\t\tme.chart = chart;\n\t\tme.index = datasetIndex;\n\t\tme.linkScales();\n\t\tme.addElements();\n\t},\n\n\tupdateIndex: function(datasetIndex) {\n\t\tthis.index = datasetIndex;\n\t},\n\n\tlinkScales: function() {\n\t\tvar me = this;\n\t\tvar meta = me.getMeta();\n\t\tvar dataset = me.getDataset();\n\n\t\tif (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {\n\t\t\tmeta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;\n\t\t}\n\t\tif (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {\n\t\t\tmeta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;\n\t\t}\n\t},\n\n\tgetDataset: function() {\n\t\treturn this.chart.data.datasets[this.index];\n\t},\n\n\tgetMeta: function() {\n\t\treturn this.chart.getDatasetMeta(this.index);\n\t},\n\n\tgetScaleForId: function(scaleID) {\n\t\treturn this.chart.scales[scaleID];\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_getValueScaleId: function() {\n\t\treturn this.getMeta().yAxisID;\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_getIndexScaleId: function() {\n\t\treturn this.getMeta().xAxisID;\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_getValueScale: function() {\n\t\treturn this.getScaleForId(this._getValueScaleId());\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_getIndexScale: function() {\n\t\treturn this.getScaleForId(this._getIndexScaleId());\n\t},\n\n\treset: function() {\n\t\tthis.update(true);\n\t},\n\n\t/**\n\t * @private\n\t */\n\tdestroy: function() {\n\t\tif (this._data) {\n\t\t\tunlistenArrayEvents(this._data, this);\n\t\t}\n\t},\n\n\tcreateMetaDataset: function() {\n\t\tvar me = this;\n\t\tvar type = me.datasetElementType;\n\t\treturn type && new type({\n\t\t\t_chart: me.chart,\n\t\t\t_datasetIndex: me.index\n\t\t});\n\t},\n\n\tcreateMetaData: function(index) {\n\t\tvar me = this;\n\t\tvar type = me.dataElementType;\n\t\treturn type && new type({\n\t\t\t_chart: me.chart,\n\t\t\t_datasetIndex: me.index,\n\t\t\t_index: index\n\t\t});\n\t},\n\n\taddElements: function() {\n\t\tvar me = this;\n\t\tvar meta = me.getMeta();\n\t\tvar data = me.getDataset().data || [];\n\t\tvar metaData = meta.data;\n\t\tvar i, ilen;\n\n\t\tfor (i = 0, ilen = data.length; i < ilen; ++i) {\n\t\t\tmetaData[i] = metaData[i] || me.createMetaData(i);\n\t\t}\n\n\t\tmeta.dataset = meta.dataset || me.createMetaDataset();\n\t},\n\n\taddElementAndReset: function(index) {\n\t\tvar element = this.createMetaData(index);\n\t\tthis.getMeta().data.splice(index, 0, element);\n\t\tthis.updateElement(element, index, true);\n\t},\n\n\tbuildOrUpdateElements: function() {\n\t\tvar me = this;\n\t\tvar dataset = me.getDataset();\n\t\tvar data = dataset.data || (dataset.data = []);\n\n\t\t// In order to correctly handle data addition/deletion animation (an thus simulate\n\t\t// real-time charts), we need to monitor these data modifications and synchronize\n\t\t// the internal meta data accordingly.\n\t\tif (me._data !== data) {\n\t\t\tif (me._data) {\n\t\t\t\t// This case happens when the user replaced the data array instance.\n\t\t\t\tunlistenArrayEvents(me._data, me);\n\t\t\t}\n\n\t\t\tif (data && Object.isExtensible(data)) {\n\t\t\t\tlistenArrayEvents(data, me);\n\t\t\t}\n\t\t\tme._data = data;\n\t\t}\n\n\t\t// Re-sync meta data in case the user replaced the data array or if we missed\n\t\t// any updates and so make sure that we handle number of datapoints changing.\n\t\tme.resyncElements();\n\t},\n\n\tupdate: helpers$1.noop,\n\n\ttransition: function(easingValue) {\n\t\tvar meta = this.getMeta();\n\t\tvar elements = meta.data || [];\n\t\tvar ilen = elements.length;\n\t\tvar i = 0;\n\n\t\tfor (; i < ilen; ++i) {\n\t\t\telements[i].transition(easingValue);\n\t\t}\n\n\t\tif (meta.dataset) {\n\t\t\tmeta.dataset.transition(easingValue);\n\t\t}\n\t},\n\n\tdraw: function() {\n\t\tvar meta = this.getMeta();\n\t\tvar elements = meta.data || [];\n\t\tvar ilen = elements.length;\n\t\tvar i = 0;\n\n\t\tif (meta.dataset) {\n\t\t\tmeta.dataset.draw();\n\t\t}\n\n\t\tfor (; i < ilen; ++i) {\n\t\t\telements[i].draw();\n\t\t}\n\t},\n\n\tremoveHoverStyle: function(element) {\n\t\thelpers$1.merge(element._model, element.$previousStyle || {});\n\t\tdelete element.$previousStyle;\n\t},\n\n\tsetHoverStyle: function(element) {\n\t\tvar dataset = this.chart.data.datasets[element._datasetIndex];\n\t\tvar index = element._index;\n\t\tvar custom = element.custom || {};\n\t\tvar model = element._model;\n\t\tvar getHoverColor = helpers$1.getHoverColor;\n\n\t\telement.$previousStyle = {\n\t\t\tbackgroundColor: model.backgroundColor,\n\t\t\tborderColor: model.borderColor,\n\t\t\tborderWidth: model.borderWidth\n\t\t};\n\n\t\tmodel.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);\n\t\tmodel.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);\n\t\tmodel.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);\n\t},\n\n\t/**\n\t * @private\n\t */\n\tresyncElements: function() {\n\t\tvar me = this;\n\t\tvar meta = me.getMeta();\n\t\tvar data = me.getDataset().data;\n\t\tvar numMeta = meta.data.length;\n\t\tvar numData = data.length;\n\n\t\tif (numData < numMeta) {\n\t\t\tmeta.data.splice(numData, numMeta - numData);\n\t\t} else if (numData > numMeta) {\n\t\t\tme.insertElements(numMeta, numData - numMeta);\n\t\t}\n\t},\n\n\t/**\n\t * @private\n\t */\n\tinsertElements: function(start, count) {\n\t\tfor (var i = 0; i < count; ++i) {\n\t\t\tthis.addElementAndReset(start + i);\n\t\t}\n\t},\n\n\t/**\n\t * @private\n\t */\n\tonDataPush: function() {\n\t\tvar count = arguments.length;\n\t\tthis.insertElements(this.getDataset().data.length - count, count);\n\t},\n\n\t/**\n\t * @private\n\t */\n\tonDataPop: function() {\n\t\tthis.getMeta().data.pop();\n\t},\n\n\t/**\n\t * @private\n\t */\n\tonDataShift: function() {\n\t\tthis.getMeta().data.shift();\n\t},\n\n\t/**\n\t * @private\n\t */\n\tonDataSplice: function(start, count) {\n\t\tthis.getMeta().data.splice(start, count);\n\t\tthis.insertElements(start, arguments.length - 2);\n\t},\n\n\t/**\n\t * @private\n\t */\n\tonDataUnshift: function() {\n\t\tthis.insertElements(0, arguments.length);\n\t}\n});\n\nDatasetController.extend = helpers$1.inherits;\n\nvar core_datasetController = DatasetController;\n\ncore_defaults._set('global', {\n\telements: {\n\t\tarc: {\n\t\t\tbackgroundColor: core_defaults.global.defaultColor,\n\t\t\tborderColor: '#fff',\n\t\t\tborderWidth: 2,\n\t\t\tborderAlign: 'center'\n\t\t}\n\t}\n});\n\nvar element_arc = core_element.extend({\n\tinLabelRange: function(mouseX) {\n\t\tvar vm = this._view;\n\n\t\tif (vm) {\n\t\t\treturn (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));\n\t\t}\n\t\treturn false;\n\t},\n\n\tinRange: function(chartX, chartY) {\n\t\tvar vm = this._view;\n\n\t\tif (vm) {\n\t\t\tvar pointRelativePosition = helpers$1.getAngleFromPoint(vm, {x: chartX, y: chartY});\n\t\t\tvar\tangle = pointRelativePosition.angle;\n\t\t\tvar distance = pointRelativePosition.distance;\n\n\t\t\t// Sanitise angle range\n\t\t\tvar startAngle = vm.startAngle;\n\t\t\tvar endAngle = vm.endAngle;\n\t\t\twhile (endAngle < startAngle) {\n\t\t\t\tendAngle += 2.0 * Math.PI;\n\t\t\t}\n\t\t\twhile (angle > endAngle) {\n\t\t\t\tangle -= 2.0 * Math.PI;\n\t\t\t}\n\t\t\twhile (angle < startAngle) {\n\t\t\t\tangle += 2.0 * Math.PI;\n\t\t\t}\n\n\t\t\t// Check if within the range of the open/close angle\n\t\t\tvar betweenAngles = (angle >= startAngle && angle <= endAngle);\n\t\t\tvar withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);\n\n\t\t\treturn (betweenAngles && withinRadius);\n\t\t}\n\t\treturn false;\n\t},\n\n\tgetCenterPoint: function() {\n\t\tvar vm = this._view;\n\t\tvar halfAngle = (vm.startAngle + vm.endAngle) / 2;\n\t\tvar halfRadius = (vm.innerRadius + vm.outerRadius) / 2;\n\t\treturn {\n\t\t\tx: vm.x + Math.cos(halfAngle) * halfRadius,\n\t\t\ty: vm.y + Math.sin(halfAngle) * halfRadius\n\t\t};\n\t},\n\n\tgetArea: function() {\n\t\tvar vm = this._view;\n\t\treturn Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));\n\t},\n\n\ttooltipPosition: function() {\n\t\tvar vm = this._view;\n\t\tvar centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);\n\t\tvar rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;\n\n\t\treturn {\n\t\t\tx: vm.x + (Math.cos(centreAngle) * rangeFromCentre),\n\t\t\ty: vm.y + (Math.sin(centreAngle) * rangeFromCentre)\n\t\t};\n\t},\n\n\tdraw: function() {\n\t\tvar ctx = this._chart.ctx;\n\t\tvar vm = this._view;\n\t\tvar sA = vm.startAngle;\n\t\tvar eA = vm.endAngle;\n\t\tvar pixelMargin = (vm.borderAlign === 'inner') ? 0.33 : 0;\n\t\tvar angleMargin;\n\n\t\tctx.save();\n\n\t\tctx.beginPath();\n\t\tctx.arc(vm.x, vm.y, Math.max(vm.outerRadius - pixelMargin, 0), sA, eA);\n\t\tctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\n\t\tctx.closePath();\n\n\t\tctx.fillStyle = vm.backgroundColor;\n\t\tctx.fill();\n\n\t\tif (vm.borderWidth) {\n\t\t\tif (vm.borderAlign === 'inner') {\n\t\t\t\t// Draw an inner border by cliping the arc and drawing a double-width border\n\t\t\t\t// Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n\t\t\t\tctx.beginPath();\n\t\t\t\tangleMargin = pixelMargin / vm.outerRadius;\n\t\t\t\tctx.arc(vm.x, vm.y, vm.outerRadius, sA - angleMargin, eA + angleMargin);\n\t\t\t\tif (vm.innerRadius > pixelMargin) {\n\t\t\t\t\tangleMargin = pixelMargin / vm.innerRadius;\n\t\t\t\t\tctx.arc(vm.x, vm.y, vm.innerRadius - pixelMargin, eA + angleMargin, sA - angleMargin, true);\n\t\t\t\t} else {\n\t\t\t\t\tctx.arc(vm.x, vm.y, pixelMargin, eA + Math.PI / 2, sA - Math.PI / 2);\n\t\t\t\t}\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.clip();\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);\n\t\t\t\tctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);\n\t\t\t\tctx.closePath();\n\n\t\t\t\tctx.lineWidth = vm.borderWidth * 2;\n\t\t\t\tctx.lineJoin = 'round';\n\t\t\t} else {\n\t\t\t\tctx.lineWidth = vm.borderWidth;\n\t\t\t\tctx.lineJoin = 'bevel';\n\t\t\t}\n\n\t\t\tctx.strokeStyle = vm.borderColor;\n\t\t\tctx.stroke();\n\t\t}\n\n\t\tctx.restore();\n\t}\n});\n\nvar valueOrDefault$1 = helpers$1.valueOrDefault;\n\nvar defaultColor = core_defaults.global.defaultColor;\n\ncore_defaults._set('global', {\n\telements: {\n\t\tline: {\n\t\t\ttension: 0.4,\n\t\t\tbackgroundColor: defaultColor,\n\t\t\tborderWidth: 3,\n\t\t\tborderColor: defaultColor,\n\t\t\tborderCapStyle: 'butt',\n\t\t\tborderDash: [],\n\t\t\tborderDashOffset: 0.0,\n\t\t\tborderJoinStyle: 'miter',\n\t\t\tcapBezierPoints: true,\n\t\t\tfill: true, // do we fill in the area between the line and its base axis\n\t\t}\n\t}\n});\n\nvar element_line = core_element.extend({\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar vm = me._view;\n\t\tvar ctx = me._chart.ctx;\n\t\tvar spanGaps = vm.spanGaps;\n\t\tvar points = me._children.slice(); // clone array\n\t\tvar globalDefaults = core_defaults.global;\n\t\tvar globalOptionLineElements = globalDefaults.elements.line;\n\t\tvar lastDrawnIndex = -1;\n\t\tvar index, current, previous, currentVM;\n\n\t\t// If we are looping, adding the first point again\n\t\tif (me._loop && points.length) {\n\t\t\tpoints.push(points[0]);\n\t\t}\n\n\t\tctx.save();\n\n\t\t// Stroke Line Options\n\t\tctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;\n\n\t\t// IE 9 and 10 do not support line dash\n\t\tif (ctx.setLineDash) {\n\t\t\tctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);\n\t\t}\n\n\t\tctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);\n\t\tctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;\n\t\tctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);\n\t\tctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;\n\n\t\t// Stroke Line\n\t\tctx.beginPath();\n\t\tlastDrawnIndex = -1;\n\n\t\tfor (index = 0; index < points.length; ++index) {\n\t\t\tcurrent = points[index];\n\t\t\tprevious = helpers$1.previousItem(points, index);\n\t\t\tcurrentVM = current._view;\n\n\t\t\t// First point moves to it's starting position no matter what\n\t\t\tif (index === 0) {\n\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprevious = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];\n\n\t\t\t\tif (!currentVM.skip) {\n\t\t\t\t\tif ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {\n\t\t\t\t\t\t// There was a gap and this is the first point after the gap\n\t\t\t\t\t\tctx.moveTo(currentVM.x, currentVM.y);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Line to next point\n\t\t\t\t\t\thelpers$1.canvas.lineTo(ctx, previous._view, current._view);\n\t\t\t\t\t}\n\t\t\t\t\tlastDrawnIndex = index;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tctx.stroke();\n\t\tctx.restore();\n\t}\n});\n\nvar valueOrDefault$2 = helpers$1.valueOrDefault;\n\nvar defaultColor$1 = core_defaults.global.defaultColor;\n\ncore_defaults._set('global', {\n\telements: {\n\t\tpoint: {\n\t\t\tradius: 3,\n\t\t\tpointStyle: 'circle',\n\t\t\tbackgroundColor: defaultColor$1,\n\t\t\tborderColor: defaultColor$1,\n\t\t\tborderWidth: 1,\n\t\t\t// Hover\n\t\t\thitRadius: 1,\n\t\t\thoverRadius: 4,\n\t\t\thoverBorderWidth: 1\n\t\t}\n\t}\n});\n\nfunction xRange(mouseX) {\n\tvar vm = this._view;\n\treturn vm ? (Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius) : false;\n}\n\nfunction yRange(mouseY) {\n\tvar vm = this._view;\n\treturn vm ? (Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius) : false;\n}\n\nvar element_point = core_element.extend({\n\tinRange: function(mouseX, mouseY) {\n\t\tvar vm = this._view;\n\t\treturn vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;\n\t},\n\n\tinLabelRange: xRange,\n\tinXRange: xRange,\n\tinYRange: yRange,\n\n\tgetCenterPoint: function() {\n\t\tvar vm = this._view;\n\t\treturn {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y\n\t\t};\n\t},\n\n\tgetArea: function() {\n\t\treturn Math.PI * Math.pow(this._view.radius, 2);\n\t},\n\n\ttooltipPosition: function() {\n\t\tvar vm = this._view;\n\t\treturn {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y,\n\t\t\tpadding: vm.radius + vm.borderWidth\n\t\t};\n\t},\n\n\tdraw: function(chartArea) {\n\t\tvar vm = this._view;\n\t\tvar ctx = this._chart.ctx;\n\t\tvar pointStyle = vm.pointStyle;\n\t\tvar rotation = vm.rotation;\n\t\tvar radius = vm.radius;\n\t\tvar x = vm.x;\n\t\tvar y = vm.y;\n\t\tvar globalDefaults = core_defaults.global;\n\t\tvar defaultColor = globalDefaults.defaultColor; // eslint-disable-line no-shadow\n\n\t\tif (vm.skip) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Clipping for Points.\n\t\tif (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {\n\t\t\tctx.strokeStyle = vm.borderColor || defaultColor;\n\t\t\tctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);\n\t\t\tctx.fillStyle = vm.backgroundColor || defaultColor;\n\t\t\thelpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);\n\t\t}\n\t}\n});\n\nvar defaultColor$2 = core_defaults.global.defaultColor;\n\ncore_defaults._set('global', {\n\telements: {\n\t\trectangle: {\n\t\t\tbackgroundColor: defaultColor$2,\n\t\t\tborderColor: defaultColor$2,\n\t\t\tborderSkipped: 'bottom',\n\t\t\tborderWidth: 0\n\t\t}\n\t}\n});\n\nfunction isVertical(vm) {\n\treturn vm && vm.width !== undefined;\n}\n\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param bar {Chart.Element.Rectangle} the bar\n * @return {Bounds} bounds of the bar\n * @private\n */\nfunction getBarBounds(vm) {\n\tvar x1, x2, y1, y2, half;\n\n\tif (isVertical(vm)) {\n\t\thalf = vm.width / 2;\n\t\tx1 = vm.x - half;\n\t\tx2 = vm.x + half;\n\t\ty1 = Math.min(vm.y, vm.base);\n\t\ty2 = Math.max(vm.y, vm.base);\n\t} else {\n\t\thalf = vm.height / 2;\n\t\tx1 = Math.min(vm.x, vm.base);\n\t\tx2 = Math.max(vm.x, vm.base);\n\t\ty1 = vm.y - half;\n\t\ty2 = vm.y + half;\n\t}\n\n\treturn {\n\t\tleft: x1,\n\t\ttop: y1,\n\t\tright: x2,\n\t\tbottom: y2\n\t};\n}\n\nfunction swap(orig, v1, v2) {\n\treturn orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\n\nfunction parseBorderSkipped(vm) {\n\tvar edge = vm.borderSkipped;\n\tvar res = {};\n\n\tif (!edge) {\n\t\treturn res;\n\t}\n\n\tif (vm.horizontal) {\n\t\tif (vm.base > vm.x) {\n\t\t\tedge = swap(edge, 'left', 'right');\n\t\t}\n\t} else if (vm.base < vm.y) {\n\t\tedge = swap(edge, 'bottom', 'top');\n\t}\n\n\tres[edge] = true;\n\treturn res;\n}\n\nfunction parseBorderWidth(vm, maxW, maxH) {\n\tvar value = vm.borderWidth;\n\tvar skip = parseBorderSkipped(vm);\n\tvar t, r, b, l;\n\n\tif (helpers$1.isObject(value)) {\n\t\tt = +value.top || 0;\n\t\tr = +value.right || 0;\n\t\tb = +value.bottom || 0;\n\t\tl = +value.left || 0;\n\t} else {\n\t\tt = r = b = l = +value || 0;\n\t}\n\n\treturn {\n\t\tt: skip.top || (t < 0) ? 0 : t > maxH ? maxH : t,\n\t\tr: skip.right || (r < 0) ? 0 : r > maxW ? maxW : r,\n\t\tb: skip.bottom || (b < 0) ? 0 : b > maxH ? maxH : b,\n\t\tl: skip.left || (l < 0) ? 0 : l > maxW ? maxW : l\n\t};\n}\n\nfunction boundingRects(vm) {\n\tvar bounds = getBarBounds(vm);\n\tvar width = bounds.right - bounds.left;\n\tvar height = bounds.bottom - bounds.top;\n\tvar border = parseBorderWidth(vm, width / 2, height / 2);\n\n\treturn {\n\t\touter: {\n\t\t\tx: bounds.left,\n\t\t\ty: bounds.top,\n\t\t\tw: width,\n\t\t\th: height\n\t\t},\n\t\tinner: {\n\t\t\tx: bounds.left + border.l,\n\t\t\ty: bounds.top + border.t,\n\t\t\tw: width - border.l - border.r,\n\t\t\th: height - border.t - border.b\n\t\t}\n\t};\n}\n\nfunction inRange(vm, x, y) {\n\tvar skipX = x === null;\n\tvar skipY = y === null;\n\tvar bounds = !vm || (skipX && skipY) ? false : getBarBounds(vm);\n\n\treturn bounds\n\t\t&& (skipX || x >= bounds.left && x <= bounds.right)\n\t\t&& (skipY || y >= bounds.top && y <= bounds.bottom);\n}\n\nvar element_rectangle = core_element.extend({\n\tdraw: function() {\n\t\tvar ctx = this._chart.ctx;\n\t\tvar vm = this._view;\n\t\tvar rects = boundingRects(vm);\n\t\tvar outer = rects.outer;\n\t\tvar inner = rects.inner;\n\n\t\tctx.fillStyle = vm.backgroundColor;\n\t\tctx.fillRect(outer.x, outer.y, outer.w, outer.h);\n\n\t\tif (outer.w === inner.w && outer.h === inner.h) {\n\t\t\treturn;\n\t\t}\n\n\t\tctx.save();\n\t\tctx.beginPath();\n\t\tctx.rect(outer.x, outer.y, outer.w, outer.h);\n\t\tctx.clip();\n\t\tctx.fillStyle = vm.borderColor;\n\t\tctx.rect(inner.x, inner.y, inner.w, inner.h);\n\t\tctx.fill('evenodd');\n\t\tctx.restore();\n\t},\n\n\theight: function() {\n\t\tvar vm = this._view;\n\t\treturn vm.base - vm.y;\n\t},\n\n\tinRange: function(mouseX, mouseY) {\n\t\treturn inRange(this._view, mouseX, mouseY);\n\t},\n\n\tinLabelRange: function(mouseX, mouseY) {\n\t\tvar vm = this._view;\n\t\treturn isVertical(vm)\n\t\t\t? inRange(vm, mouseX, null)\n\t\t\t: inRange(vm, null, mouseY);\n\t},\n\n\tinXRange: function(mouseX) {\n\t\treturn inRange(this._view, mouseX, null);\n\t},\n\n\tinYRange: function(mouseY) {\n\t\treturn inRange(this._view, null, mouseY);\n\t},\n\n\tgetCenterPoint: function() {\n\t\tvar vm = this._view;\n\t\tvar x, y;\n\t\tif (isVertical(vm)) {\n\t\t\tx = vm.x;\n\t\t\ty = (vm.y + vm.base) / 2;\n\t\t} else {\n\t\t\tx = (vm.x + vm.base) / 2;\n\t\t\ty = vm.y;\n\t\t}\n\n\t\treturn {x: x, y: y};\n\t},\n\n\tgetArea: function() {\n\t\tvar vm = this._view;\n\n\t\treturn isVertical(vm)\n\t\t\t? vm.width * Math.abs(vm.y - vm.base)\n\t\t\t: vm.height * Math.abs(vm.x - vm.base);\n\t},\n\n\ttooltipPosition: function() {\n\t\tvar vm = this._view;\n\t\treturn {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y\n\t\t};\n\t}\n});\n\nvar elements = {};\nvar Arc = element_arc;\nvar Line = element_line;\nvar Point = element_point;\nvar Rectangle = element_rectangle;\nelements.Arc = Arc;\nelements.Line = Line;\nelements.Point = Point;\nelements.Rectangle = Rectangle;\n\nvar resolve$1 = helpers$1.options.resolve;\n\ncore_defaults._set('bar', {\n\thover: {\n\t\tmode: 'label'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'category',\n\t\t\tcategoryPercentage: 0.8,\n\t\t\tbarPercentage: 0.9,\n\t\t\toffset: true,\n\t\t\tgridLines: {\n\t\t\t\toffsetGridLines: true\n\t\t\t}\n\t\t}],\n\n\t\tyAxes: [{\n\t\t\ttype: 'linear'\n\t\t}]\n\t}\n});\n\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\nfunction computeMinSampleSize(scale, pixels) {\n\tvar min = scale.isHorizontal() ? scale.width : scale.height;\n\tvar ticks = scale.getTicks();\n\tvar prev, curr, i, ilen;\n\n\tfor (i = 1, ilen = pixels.length; i < ilen; ++i) {\n\t\tmin = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));\n\t}\n\n\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\tcurr = scale.getPixelForTick(i);\n\t\tmin = i > 0 ? Math.min(min, curr - prev) : min;\n\t\tprev = curr;\n\t}\n\n\treturn min;\n}\n\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\nfunction computeFitCategoryTraits(index, ruler, options) {\n\tvar thickness = options.barThickness;\n\tvar count = ruler.stackCount;\n\tvar curr = ruler.pixels[index];\n\tvar size, ratio;\n\n\tif (helpers$1.isNullOrUndef(thickness)) {\n\t\tsize = ruler.min * options.categoryPercentage;\n\t\tratio = options.barPercentage;\n\t} else {\n\t\t// When bar thickness is enforced, category and bar percentages are ignored.\n\t\t// Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n\t\t// and deprecate barPercentage since this value is ignored when thickness is absolute.\n\t\tsize = thickness * count;\n\t\tratio = 1;\n\t}\n\n\treturn {\n\t\tchunk: size / count,\n\t\tratio: ratio,\n\t\tstart: curr - (size / 2)\n\t};\n}\n\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\nfunction computeFlexCategoryTraits(index, ruler, options) {\n\tvar pixels = ruler.pixels;\n\tvar curr = pixels[index];\n\tvar prev = index > 0 ? pixels[index - 1] : null;\n\tvar next = index < pixels.length - 1 ? pixels[index + 1] : null;\n\tvar percent = options.categoryPercentage;\n\tvar start, size;\n\n\tif (prev === null) {\n\t\t// first data: its size is double based on the next point or,\n\t\t// if it's also the last data, we use the scale size.\n\t\tprev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n\t}\n\n\tif (next === null) {\n\t\t// last data: its size is also double based on the previous point.\n\t\tnext = curr + curr - prev;\n\t}\n\n\tstart = curr - (curr - Math.min(prev, next)) / 2 * percent;\n\tsize = Math.abs(next - prev) / 2 * percent;\n\n\treturn {\n\t\tchunk: size / ruler.stackCount,\n\t\tratio: options.barPercentage,\n\t\tstart: start\n\t};\n}\n\nvar controller_bar = core_datasetController.extend({\n\n\tdataElementType: elements.Rectangle,\n\n\tinitialize: function() {\n\t\tvar me = this;\n\t\tvar meta;\n\n\t\tcore_datasetController.prototype.initialize.apply(me, arguments);\n\n\t\tmeta = me.getMeta();\n\t\tmeta.stack = me.getDataset().stack;\n\t\tmeta.bar = true;\n\t},\n\n\tupdate: function(reset) {\n\t\tvar me = this;\n\t\tvar rects = me.getMeta().data;\n\t\tvar i, ilen;\n\n\t\tme._ruler = me.getRuler();\n\n\t\tfor (i = 0, ilen = rects.length; i < ilen; ++i) {\n\t\t\tme.updateElement(rects[i], i, reset);\n\t\t}\n\t},\n\n\tupdateElement: function(rectangle, index, reset) {\n\t\tvar me = this;\n\t\tvar meta = me.getMeta();\n\t\tvar dataset = me.getDataset();\n\t\tvar options = me._resolveElementOptions(rectangle, index);\n\n\t\trectangle._xScale = me.getScaleForId(meta.xAxisID);\n\t\trectangle._yScale = me.getScaleForId(meta.yAxisID);\n\t\trectangle._datasetIndex = me.index;\n\t\trectangle._index = index;\n\t\trectangle._model = {\n\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\tborderColor: options.borderColor,\n\t\t\tborderSkipped: options.borderSkipped,\n\t\t\tborderWidth: options.borderWidth,\n\t\t\tdatasetLabel: dataset.label,\n\t\t\tlabel: me.chart.data.labels[index]\n\t\t};\n\n\t\tme._updateElementGeometry(rectangle, index, reset);\n\n\t\trectangle.pivot();\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_updateElementGeometry: function(rectangle, index, reset) {\n\t\tvar me = this;\n\t\tvar model = rectangle._model;\n\t\tvar vscale = me._getValueScale();\n\t\tvar base = vscale.getBasePixel();\n\t\tvar horizontal = vscale.isHorizontal();\n\t\tvar ruler = me._ruler || me.getRuler();\n\t\tvar vpixels = me.calculateBarValuePixels(me.index, index);\n\t\tvar ipixels = me.calculateBarIndexPixels(me.index, index, ruler);\n\n\t\tmodel.horizontal = horizontal;\n\t\tmodel.base = reset ? base : vpixels.base;\n\t\tmodel.x = horizontal ? reset ? base : vpixels.head : ipixels.center;\n\t\tmodel.y = horizontal ? ipixels.center : reset ? base : vpixels.head;\n\t\tmodel.height = horizontal ? ipixels.size : undefined;\n\t\tmodel.width = horizontal ? undefined : ipixels.size;\n\t},\n\n\t/**\n\t * Returns the stacks based on groups and bar visibility.\n\t * @param {number} [last] - The dataset index\n\t * @returns {string[]} The list of stack IDs\n\t * @private\n\t */\n\t_getStacks: function(last) {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar scale = me._getIndexScale();\n\t\tvar stacked = scale.options.stacked;\n\t\tvar ilen = last === undefined ? chart.data.datasets.length : last + 1;\n\t\tvar stacks = [];\n\t\tvar i, meta;\n\n\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\tif (meta.bar && chart.isDatasetVisible(i) &&\n\t\t\t\t(stacked === false ||\n\t\t\t\t(stacked === true && stacks.indexOf(meta.stack) === -1) ||\n\t\t\t\t(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {\n\t\t\t\tstacks.push(meta.stack);\n\t\t\t}\n\t\t}\n\n\t\treturn stacks;\n\t},\n\n\t/**\n\t * Returns the effective number of stacks based on groups and bar visibility.\n\t * @private\n\t */\n\tgetStackCount: function() {\n\t\treturn this._getStacks().length;\n\t},\n\n\t/**\n\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t * @param {number} [datasetIndex] - The dataset index\n\t * @param {string} [name] - The stack name to find\n\t * @returns {number} The stack index\n\t * @private\n\t */\n\tgetStackIndex: function(datasetIndex, name) {\n\t\tvar stacks = this._getStacks(datasetIndex);\n\t\tvar index = (name !== undefined)\n\t\t\t? stacks.indexOf(name)\n\t\t\t: -1; // indexOf returns -1 if element is not present\n\n\t\treturn (index === -1)\n\t\t\t? stacks.length - 1\n\t\t\t: index;\n\t},\n\n\t/**\n\t * @private\n\t */\n\tgetRuler: function() {\n\t\tvar me = this;\n\t\tvar scale = me._getIndexScale();\n\t\tvar stackCount = me.getStackCount();\n\t\tvar datasetIndex = me.index;\n\t\tvar isHorizontal = scale.isHorizontal();\n\t\tvar start = isHorizontal ? scale.left : scale.top;\n\t\tvar end = start + (isHorizontal ? scale.width : scale.height);\n\t\tvar pixels = [];\n\t\tvar i, ilen, min;\n\n\t\tfor (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {\n\t\t\tpixels.push(scale.getPixelForValue(null, i, datasetIndex));\n\t\t}\n\n\t\tmin = helpers$1.isNullOrUndef(scale.options.barThickness)\n\t\t\t? computeMinSampleSize(scale, pixels)\n\t\t\t: -1;\n\n\t\treturn {\n\t\t\tmin: min,\n\t\t\tpixels: pixels,\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\t\tstackCount: stackCount,\n\t\t\tscale: scale\n\t\t};\n\t},\n\n\t/**\n\t * Note: pixel values are not clamped to the scale area.\n\t * @private\n\t */\n\tcalculateBarValuePixels: function(datasetIndex, index) {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar meta = me.getMeta();\n\t\tvar scale = me._getValueScale();\n\t\tvar isHorizontal = scale.isHorizontal();\n\t\tvar datasets = chart.data.datasets;\n\t\tvar value = +scale.getRightValue(datasets[datasetIndex].data[index]);\n\t\tvar minBarLength = scale.options.minBarLength;\n\t\tvar stacked = scale.options.stacked;\n\t\tvar stack = meta.stack;\n\t\tvar start = 0;\n\t\tvar i, imeta, ivalue, base, head, size;\n\n\t\tif (stacked || (stacked === undefined && stack !== undefined)) {\n\t\t\tfor (i = 0; i < datasetIndex; ++i) {\n\t\t\t\timeta = chart.getDatasetMeta(i);\n\n\t\t\t\tif (imeta.bar &&\n\t\t\t\t\timeta.stack === stack &&\n\t\t\t\t\timeta.controller._getValueScaleId() === scale.id &&\n\t\t\t\t\tchart.isDatasetVisible(i)) {\n\n\t\t\t\t\tivalue = +scale.getRightValue(datasets[i].data[index]);\n\t\t\t\t\tif ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {\n\t\t\t\t\t\tstart += ivalue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbase = scale.getPixelForValue(start);\n\t\thead = scale.getPixelForValue(start + value);\n\t\tsize = head - base;\n\n\t\tif (minBarLength !== undefined && Math.abs(size) < minBarLength) {\n\t\t\tsize = minBarLength;\n\t\t\tif (value >= 0 && !isHorizontal || value < 0 && isHorizontal) {\n\t\t\t\thead = base - minBarLength;\n\t\t\t} else {\n\t\t\t\thead = base + minBarLength;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsize: size,\n\t\t\tbase: base,\n\t\t\thead: head,\n\t\t\tcenter: head + size / 2\n\t\t};\n\t},\n\n\t/**\n\t * @private\n\t */\n\tcalculateBarIndexPixels: function(datasetIndex, index, ruler) {\n\t\tvar me = this;\n\t\tvar options = ruler.scale.options;\n\t\tvar range = options.barThickness === 'flex'\n\t\t\t? computeFlexCategoryTraits(index, ruler, options)\n\t\t\t: computeFitCategoryTraits(index, ruler, options);\n\n\t\tvar stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);\n\t\tvar center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n\t\tvar size = Math.min(\n\t\t\thelpers$1.valueOrDefault(options.maxBarThickness, Infinity),\n\t\t\trange.chunk * range.ratio);\n\n\t\treturn {\n\t\t\tbase: center - size / 2,\n\t\t\thead: center + size / 2,\n\t\t\tcenter: center,\n\t\t\tsize: size\n\t\t};\n\t},\n\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar scale = me._getValueScale();\n\t\tvar rects = me.getMeta().data;\n\t\tvar dataset = me.getDataset();\n\t\tvar ilen = rects.length;\n\t\tvar i = 0;\n\n\t\thelpers$1.canvas.clipArea(chart.ctx, chart.chartArea);\n\n\t\tfor (; i < ilen; ++i) {\n\t\t\tif (!isNaN(scale.getRightValue(dataset.data[i]))) {\n\t\t\t\trects[i].draw();\n\t\t\t}\n\t\t}\n\n\t\thelpers$1.canvas.unclipArea(chart.ctx);\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_resolveElementOptions: function(rectangle, index) {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar datasets = chart.data.datasets;\n\t\tvar dataset = datasets[me.index];\n\t\tvar custom = rectangle.custom || {};\n\t\tvar options = chart.options.elements.rectangle;\n\t\tvar values = {};\n\t\tvar i, ilen, key;\n\n\t\t// Scriptable options\n\t\tvar context = {\n\t\t\tchart: chart,\n\t\t\tdataIndex: index,\n\t\t\tdataset: dataset,\n\t\t\tdatasetIndex: me.index\n\t\t};\n\n\t\tvar keys = [\n\t\t\t'backgroundColor',\n\t\t\t'borderColor',\n\t\t\t'borderSkipped',\n\t\t\t'borderWidth'\n\t\t];\n\n\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\tkey = keys[i];\n\t\t\tvalues[key] = resolve$1([\n\t\t\t\tcustom[key],\n\t\t\t\tdataset[key],\n\t\t\t\toptions[key]\n\t\t\t], context, index);\n\t\t}\n\n\t\treturn values;\n\t}\n});\n\nvar valueOrDefault$3 = helpers$1.valueOrDefault;\nvar resolve$2 = helpers$1.options.resolve;\n\ncore_defaults._set('bubble', {\n\thover: {\n\t\tmode: 'single'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'linear', // bubble should probably use a linear scale by default\n\t\t\tposition: 'bottom',\n\t\t\tid: 'x-axis-0' // need an ID so datasets can reference the scale\n\t\t}],\n\t\tyAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tposition: 'left',\n\t\t\tid: 'y-axis-0'\n\t\t}]\n\t},\n\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\t// Title doesn't make sense for scatter since we format the data as a point\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel: function(item, data) {\n\t\t\t\tvar datasetLabel = data.datasets[item.datasetIndex].label || '';\n\t\t\t\tvar dataPoint = data.datasets[item.datasetIndex].data[item.index];\n\t\t\t\treturn datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';\n\t\t\t}\n\t\t}\n\t}\n});\n\nvar controller_bubble = core_datasetController.extend({\n\t/**\n\t * @protected\n\t */\n\tdataElementType: elements.Point,\n\n\t/**\n\t * @protected\n\t */\n\tupdate: function(reset) {\n\t\tvar me = this;\n\t\tvar meta = me.getMeta();\n\t\tvar points = meta.data;\n\n\t\t// Update Points\n\t\thelpers$1.each(points, function(point, index) {\n\t\t\tme.updateElement(point, index, reset);\n\t\t});\n\t},\n\n\t/**\n\t * @protected\n\t */\n\tupdateElement: function(point, index, reset) {\n\t\tvar me = this;\n\t\tvar meta = me.getMeta();\n\t\tvar custom = point.custom || {};\n\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\tvar options = me._resolveElementOptions(point, index);\n\t\tvar data = me.getDataset().data[index];\n\t\tvar dsIndex = me.index;\n\n\t\tvar x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);\n\t\tvar y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);\n\n\t\tpoint._xScale = xScale;\n\t\tpoint._yScale = yScale;\n\t\tpoint._options = options;\n\t\tpoint._datasetIndex = dsIndex;\n\t\tpoint._index = index;\n\t\tpoint._model = {\n\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\tborderColor: options.borderColor,\n\t\t\tborderWidth: options.borderWidth,\n\t\t\thitRadius: options.hitRadius,\n\t\t\tpointStyle: options.pointStyle,\n\t\t\trotation: options.rotation,\n\t\t\tradius: reset ? 0 : options.radius,\n\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\tx: x,\n\t\t\ty: y,\n\t\t};\n\n\t\tpoint.pivot();\n\t},\n\n\t/**\n\t * @protected\n\t */\n\tsetHoverStyle: function(point) {\n\t\tvar model = point._model;\n\t\tvar options = point._options;\n\t\tvar getHoverColor = helpers$1.getHoverColor;\n\n\t\tpoint.$previousStyle = {\n\t\t\tbackgroundColor: model.backgroundColor,\n\t\t\tborderColor: model.borderColor,\n\t\t\tborderWidth: model.borderWidth,\n\t\t\tradius: model.radius\n\t\t};\n\n\t\tmodel.backgroundColor = valueOrDefault$3(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n\t\tmodel.borderColor = valueOrDefault$3(options.hoverBorderColor, getHoverColor(options.borderColor));\n\t\tmodel.borderWidth = valueOrDefault$3(options.hoverBorderWidth, options.borderWidth);\n\t\tmodel.radius = options.radius + options.hoverRadius;\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_resolveElementOptions: function(point, index) {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar datasets = chart.data.datasets;\n\t\tvar dataset = datasets[me.index];\n\t\tvar custom = point.custom || {};\n\t\tvar options = chart.options.elements.point;\n\t\tvar data = dataset.data[index];\n\t\tvar values = {};\n\t\tvar i, ilen, key;\n\n\t\t// Scriptable options\n\t\tvar context = {\n\t\t\tchart: chart,\n\t\t\tdataIndex: index,\n\t\t\tdataset: dataset,\n\t\t\tdatasetIndex: me.index\n\t\t};\n\n\t\tvar keys = [\n\t\t\t'backgroundColor',\n\t\t\t'borderColor',\n\t\t\t'borderWidth',\n\t\t\t'hoverBackgroundColor',\n\t\t\t'hoverBorderColor',\n\t\t\t'hoverBorderWidth',\n\t\t\t'hoverRadius',\n\t\t\t'hitRadius',\n\t\t\t'pointStyle',\n\t\t\t'rotation'\n\t\t];\n\n\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\tkey = keys[i];\n\t\t\tvalues[key] = resolve$2([\n\t\t\t\tcustom[key],\n\t\t\t\tdataset[key],\n\t\t\t\toptions[key]\n\t\t\t], context, index);\n\t\t}\n\n\t\t// Custom radius resolution\n\t\tvalues.radius = resolve$2([\n\t\t\tcustom.radius,\n\t\t\tdata ? data.r : undefined,\n\t\t\tdataset.radius,\n\t\t\toptions.radius\n\t\t], context, index);\n\n\t\treturn values;\n\t}\n});\n\nvar resolve$3 = helpers$1.options.resolve;\nvar valueOrDefault$4 = helpers$1.valueOrDefault;\n\ncore_defaults._set('doughnut', {\n\tanimation: {\n\t\t// Boolean - Whether we animate the rotation of the Doughnut\n\t\tanimateRotate: true,\n\t\t// Boolean - Whether we animate scaling the Doughnut from the centre\n\t\tanimateScale: false\n\t},\n\thover: {\n\t\tmode: 'single'\n\t},\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\tvar data = chart.data;\n\t\tvar datasets = data.datasets;\n\t\tvar labels = data.labels;\n\n\t\tif (datasets.length) {\n\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\tif (labels[i]) {\n\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t}\n\t\t\t\ttext.push('</li>');\n\t\t\t}\n\t\t}\n\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t},\n\tlegend: {\n\t\tlabels: {\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\tvar custom = arc && arc.custom || {};\n\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\tvar fill = resolve$3([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);\n\t\t\t\t\t\tvar stroke = resolve$3([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);\n\t\t\t\t\t\tvar bw = resolve$3([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\t\t},\n\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.index;\n\t\t\tvar chart = this.chart;\n\t\t\tvar i, ilen, meta;\n\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t// toggle visibility of index if exists\n\t\t\t\tif (meta.data[index]) {\n\t\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchart.update();\n\t\t}\n\t},\n\n\t// The percentage of the chart that we cut out of the middle.\n\tcutoutPercentage: 50,\n\n\t// The rotation of the chart, where the first data arc begins.\n\trotation: Math.PI * -0.5,\n\n\t// The total circumference of the chart.\n\tcircumference: Math.PI * 2.0,\n\n\t// Need to override these to give a nice default\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\tvar dataLabel = data.labels[tooltipItem.index];\n\t\t\t\tvar value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];\n\n\t\t\t\tif (helpers$1.isArray(dataLabel)) {\n\t\t\t\t\t// show value on first line of multiline label\n\t\t\t\t\t// need to clone because we are changing the value\n\t\t\t\t\tdataLabel = dataLabel.slice();\n\t\t\t\t\tdataLabel[0] += value;\n\t\t\t\t} else {\n\t\t\t\t\tdataLabel += value;\n\t\t\t\t}\n\n\t\t\t\treturn dataLabel;\n\t\t\t}\n\t\t}\n\t}\n});\n\nvar controller_doughnut = core_datasetController.extend({\n\n\tdataElementType: elements.Arc,\n\n\tlinkScales: helpers$1.noop,\n\n\t// Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly\n\tgetRingIndex: function(datasetIndex) {\n\t\tvar ringIndex = 0;\n\n\t\tfor (var j = 0; j < datasetIndex; ++j) {\n\t\t\tif (this.chart.isDatasetVisible(j)) {\n\t\t\t\t++ringIndex;\n\t\t\t}\n\t\t}\n\n\t\treturn ringIndex;\n\t},\n\n\tupdate: function(reset) {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar chartArea = chart.chartArea;\n\t\tvar opts = chart.options;\n\t\tvar availableWidth = chartArea.right - chartArea.left;\n\t\tvar availableHeight = chartArea.bottom - chartArea.top;\n\t\tvar minSize = Math.min(availableWidth, availableHeight);\n\t\tvar offset = {x: 0, y: 0};\n\t\tvar meta = me.getMeta();\n\t\tvar arcs = meta.data;\n\t\tvar cutoutPercentage = opts.cutoutPercentage;\n\t\tvar circumference = opts.circumference;\n\t\tvar chartWeight = me._getRingWeight(me.index);\n\t\tvar i, ilen;\n\n\t\t// If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc\n\t\tif (circumference < Math.PI * 2.0) {\n\t\t\tvar startAngle = opts.rotation % (Math.PI * 2.0);\n\t\t\tstartAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);\n\t\t\tvar endAngle = startAngle + circumference;\n\t\t\tvar start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};\n\t\t\tvar end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};\n\t\t\tvar contains0 = (startAngle <= 0 && endAngle >= 0) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);\n\t\t\tvar contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);\n\t\t\tvar contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);\n\t\t\tvar contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);\n\t\t\tvar cutout = cutoutPercentage / 100.0;\n\t\t\tvar min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};\n\t\t\tvar max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};\n\t\t\tvar size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};\n\t\t\tminSize = Math.min(availableWidth / size.width, availableHeight / size.height);\n\t\t\toffset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};\n\t\t}\n\n\t\tfor (i = 0, ilen = arcs.length; i < ilen; ++i) {\n\t\t\tarcs[i]._options = me._resolveElementOptions(arcs[i], i);\n\t\t}\n\n\t\tchart.borderWidth = me.getMaxBorderWidth();\n\t\tchart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);\n\t\tchart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);\n\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);\n\t\tchart.offsetX = offset.x * chart.outerRadius;\n\t\tchart.offsetY = offset.y * chart.outerRadius;\n\n\t\tmeta.total = me.calculateTotal();\n\n\t\tme.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);\n\t\tme.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);\n\n\t\tfor (i = 0, ilen = arcs.length; i < ilen; ++i) {\n\t\t\tme.updateElement(arcs[i], i, reset);\n\t\t}\n\t},\n\n\tupdateElement: function(arc, index, reset) {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar chartArea = chart.chartArea;\n\t\tvar opts = chart.options;\n\t\tvar animationOpts = opts.animation;\n\t\tvar centerX = (chartArea.left + chartArea.right) / 2;\n\t\tvar centerY = (chartArea.top + chartArea.bottom) / 2;\n\t\tvar startAngle = opts.rotation; // non reset case handled later\n\t\tvar endAngle = opts.rotation; // non reset case handled later\n\t\tvar dataset = me.getDataset();\n\t\tvar circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));\n\t\tvar innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;\n\t\tvar outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;\n\t\tvar options = arc._options || {};\n\n\t\thelpers$1.extend(arc, {\n\t\t\t// Utility\n\t\t\t_datasetIndex: me.index,\n\t\t\t_index: index,\n\n\t\t\t// Desired view properties\n\t\t\t_model: {\n\t\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\t\tborderColor: options.borderColor,\n\t\t\t\tborderWidth: options.borderWidth,\n\t\t\t\tborderAlign: options.borderAlign,\n\t\t\t\tx: centerX + chart.offsetX,\n\t\t\t\ty: centerY + chart.offsetY,\n\t\t\t\tstartAngle: startAngle,\n\t\t\t\tendAngle: endAngle,\n\t\t\t\tcircumference: circumference,\n\t\t\t\touterRadius: outerRadius,\n\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\tlabel: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])\n\t\t\t}\n\t\t});\n\n\t\tvar model = arc._model;\n\n\t\t// Set correct angles if not resetting\n\t\tif (!reset || !animationOpts.animateRotate) {\n\t\t\tif (index === 0) {\n\t\t\t\tmodel.startAngle = opts.rotation;\n\t\t\t} else {\n\t\t\t\tmodel.startAngle = me.getMeta().data[index - 1]._model.endAngle;\n\t\t\t}\n\n\t\t\tmodel.endAngle = model.startAngle + model.circumference;\n\t\t}\n\n\t\tarc.pivot();\n\t},\n\n\tcalculateTotal: function() {\n\t\tvar dataset = this.getDataset();\n\t\tvar meta = this.getMeta();\n\t\tvar total = 0;\n\t\tvar value;\n\n\t\thelpers$1.each(meta.data, function(element, index) {\n\t\t\tvalue = dataset.data[index];\n\t\t\tif (!isNaN(value) && !element.hidden) {\n\t\t\t\ttotal += Math.abs(value);\n\t\t\t}\n\t\t});\n\n\t\t/* if (total === 0) {\n\t\t\ttotal = NaN;\n\t\t}*/\n\n\t\treturn total;\n\t},\n\n\tcalculateCircumference: function(value) {\n\t\tvar total = this.getMeta().total;\n\t\tif (total > 0 && !isNaN(value)) {\n\t\t\treturn (Math.PI * 2.0) * (Math.abs(value) / total);\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// gets the max border or hover width to properly scale pie charts\n\tgetMaxBorderWidth: function(arcs) {\n\t\tvar me = this;\n\t\tvar max = 0;\n\t\tvar chart = me.chart;\n\t\tvar i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;\n\n\t\tif (!arcs) {\n\t\t\t// Find the outmost visible dataset\n\t\t\tfor (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n\t\t\t\tif (chart.isDatasetVisible(i)) {\n\t\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\t\tarcs = meta.data;\n\t\t\t\t\tif (i !== me.index) {\n\t\t\t\t\t\tcontroller = meta.controller;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!arcs) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (i = 0, ilen = arcs.length; i < ilen; ++i) {\n\t\t\tarc = arcs[i];\n\t\t\toptions = controller ? controller._resolveElementOptions(arc, i) : arc._options;\n\t\t\tif (options.borderAlign !== 'inner') {\n\t\t\t\tborderWidth = options.borderWidth;\n\t\t\t\thoverWidth = options.hoverBorderWidth;\n\n\t\t\t\tmax = borderWidth > max ? borderWidth : max;\n\t\t\t\tmax = hoverWidth > max ? hoverWidth : max;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t},\n\n\t/**\n\t * @protected\n\t */\n\tsetHoverStyle: function(arc) {\n\t\tvar model = arc._model;\n\t\tvar options = arc._options;\n\t\tvar getHoverColor = helpers$1.getHoverColor;\n\n\t\tarc.$previousStyle = {\n\t\t\tbackgroundColor: model.backgroundColor,\n\t\t\tborderColor: model.borderColor,\n\t\t\tborderWidth: model.borderWidth,\n\t\t};\n\n\t\tmodel.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n\t\tmodel.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));\n\t\tmodel.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_resolveElementOptions: function(arc, index) {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar dataset = me.getDataset();\n\t\tvar custom = arc.custom || {};\n\t\tvar options = chart.options.elements.arc;\n\t\tvar values = {};\n\t\tvar i, ilen, key;\n\n\t\t// Scriptable options\n\t\tvar context = {\n\t\t\tchart: chart,\n\t\t\tdataIndex: index,\n\t\t\tdataset: dataset,\n\t\t\tdatasetIndex: me.index\n\t\t};\n\n\t\tvar keys = [\n\t\t\t'backgroundColor',\n\t\t\t'borderColor',\n\t\t\t'borderWidth',\n\t\t\t'borderAlign',\n\t\t\t'hoverBackgroundColor',\n\t\t\t'hoverBorderColor',\n\t\t\t'hoverBorderWidth',\n\t\t];\n\n\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\tkey = keys[i];\n\t\t\tvalues[key] = resolve$3([\n\t\t\t\tcustom[key],\n\t\t\t\tdataset[key],\n\t\t\t\toptions[key]\n\t\t\t], context, index);\n\t\t}\n\n\t\treturn values;\n\t},\n\n\t/**\n\t * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly\n\t * @private\n\t */\n\t_getRingWeightOffset: function(datasetIndex) {\n\t\tvar ringWeightOffset = 0;\n\n\t\tfor (var i = 0; i < datasetIndex; ++i) {\n\t\t\tif (this.chart.isDatasetVisible(i)) {\n\t\t\t\tringWeightOffset += this._getRingWeight(i);\n\t\t\t}\n\t\t}\n\n\t\treturn ringWeightOffset;\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_getRingWeight: function(dataSetIndex) {\n\t\treturn Math.max(valueOrDefault$4(this.chart.data.datasets[dataSetIndex].weight, 1), 0);\n\t},\n\n\t/**\n\t * Returns the sum of all visibile data set weights.  This value can be 0.\n\t * @private\n\t */\n\t_getVisibleDatasetWeightTotal: function() {\n\t\treturn this._getRingWeightOffset(this.chart.data.datasets.length);\n\t}\n});\n\ncore_defaults._set('horizontalBar', {\n\thover: {\n\t\tmode: 'index',\n\t\taxis: 'y'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tposition: 'bottom'\n\t\t}],\n\n\t\tyAxes: [{\n\t\t\ttype: 'category',\n\t\t\tposition: 'left',\n\t\t\tcategoryPercentage: 0.8,\n\t\t\tbarPercentage: 0.9,\n\t\t\toffset: true,\n\t\t\tgridLines: {\n\t\t\t\toffsetGridLines: true\n\t\t\t}\n\t\t}]\n\t},\n\n\telements: {\n\t\trectangle: {\n\t\t\tborderSkipped: 'left'\n\t\t}\n\t},\n\n\ttooltips: {\n\t\tmode: 'index',\n\t\taxis: 'y'\n\t}\n});\n\nvar controller_horizontalBar = controller_bar.extend({\n\t/**\n\t * @private\n\t */\n\t_getValueScaleId: function() {\n\t\treturn this.getMeta().xAxisID;\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_getIndexScaleId: function() {\n\t\treturn this.getMeta().yAxisID;\n\t}\n});\n\nvar valueOrDefault$5 = helpers$1.valueOrDefault;\nvar resolve$4 = helpers$1.options.resolve;\nvar isPointInArea = helpers$1.canvas._isPointInArea;\n\ncore_defaults._set('line', {\n\tshowLines: true,\n\tspanGaps: false,\n\n\thover: {\n\t\tmode: 'label'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'category',\n\t\t\tid: 'x-axis-0'\n\t\t}],\n\t\tyAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tid: 'y-axis-0'\n\t\t}]\n\t}\n});\n\nfunction lineEnabled(dataset, options) {\n\treturn valueOrDefault$5(dataset.showLine, options.showLines);\n}\n\nvar controller_line = core_datasetController.extend({\n\n\tdatasetElementType: elements.Line,\n\n\tdataElementType: elements.Point,\n\n\tupdate: function(reset) {\n\t\tvar me = this;\n\t\tvar meta = me.getMeta();\n\t\tvar line = meta.dataset;\n\t\tvar points = meta.data || [];\n\t\tvar scale = me.getScaleForId(meta.yAxisID);\n\t\tvar dataset = me.getDataset();\n\t\tvar showLine = lineEnabled(dataset, me.chart.options);\n\t\tvar i, ilen;\n\n\t\t// Update Line\n\t\tif (showLine) {\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t}\n\n\t\t\t// Utility\n\t\t\tline._scale = scale;\n\t\t\tline._datasetIndex = me.index;\n\t\t\t// Data\n\t\t\tline._children = points;\n\t\t\t// Model\n\t\t\tline._model = me._resolveLineOptions(line);\n\n\t\t\tline.pivot();\n\t\t}\n\n\t\t// Update Points\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\tme.updateElement(points[i], i, reset);\n\t\t}\n\n\t\tif (showLine && line._model.tension !== 0) {\n\t\t\tme.updateBezierControlPoints();\n\t\t}\n\n\t\t// Now pivot the point for animation\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\tpoints[i].pivot();\n\t\t}\n\t},\n\n\tupdateElement: function(point, index, reset) {\n\t\tvar me = this;\n\t\tvar meta = me.getMeta();\n\t\tvar custom = point.custom || {};\n\t\tvar dataset = me.getDataset();\n\t\tvar datasetIndex = me.index;\n\t\tvar value = dataset.data[index];\n\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\tvar lineModel = meta.dataset._model;\n\t\tvar x, y;\n\n\t\tvar options = me._resolvePointOptions(point, index);\n\n\t\tx = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);\n\t\ty = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\n\n\t\t// Utility\n\t\tpoint._xScale = xScale;\n\t\tpoint._yScale = yScale;\n\t\tpoint._options = options;\n\t\tpoint._datasetIndex = datasetIndex;\n\t\tpoint._index = index;\n\n\t\t// Desired view properties\n\t\tpoint._model = {\n\t\t\tx: x,\n\t\t\ty: y,\n\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t// Appearance\n\t\t\tradius: options.radius,\n\t\t\tpointStyle: options.pointStyle,\n\t\t\trotation: options.rotation,\n\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\tborderColor: options.borderColor,\n\t\t\tborderWidth: options.borderWidth,\n\t\t\ttension: valueOrDefault$5(custom.tension, lineModel ? lineModel.tension : 0),\n\t\t\tsteppedLine: lineModel ? lineModel.steppedLine : false,\n\t\t\t// Tooltip\n\t\t\thitRadius: options.hitRadius\n\t\t};\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_resolvePointOptions: function(element, index) {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar dataset = chart.data.datasets[me.index];\n\t\tvar custom = element.custom || {};\n\t\tvar options = chart.options.elements.point;\n\t\tvar values = {};\n\t\tvar i, ilen, key;\n\n\t\t// Scriptable options\n\t\tvar context = {\n\t\t\tchart: chart,\n\t\t\tdataIndex: index,\n\t\t\tdataset: dataset,\n\t\t\tdatasetIndex: me.index\n\t\t};\n\n\t\tvar ELEMENT_OPTIONS = {\n\t\t\tbackgroundColor: 'pointBackgroundColor',\n\t\t\tborderColor: 'pointBorderColor',\n\t\t\tborderWidth: 'pointBorderWidth',\n\t\t\thitRadius: 'pointHitRadius',\n\t\t\thoverBackgroundColor: 'pointHoverBackgroundColor',\n\t\t\thoverBorderColor: 'pointHoverBorderColor',\n\t\t\thoverBorderWidth: 'pointHoverBorderWidth',\n\t\t\thoverRadius: 'pointHoverRadius',\n\t\t\tpointStyle: 'pointStyle',\n\t\t\tradius: 'pointRadius',\n\t\t\trotation: 'pointRotation'\n\t\t};\n\t\tvar keys = Object.keys(ELEMENT_OPTIONS);\n\n\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\tkey = keys[i];\n\t\t\tvalues[key] = resolve$4([\n\t\t\t\tcustom[key],\n\t\t\t\tdataset[ELEMENT_OPTIONS[key]],\n\t\t\t\tdataset[key],\n\t\t\t\toptions[key]\n\t\t\t], context, index);\n\t\t}\n\n\t\treturn values;\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_resolveLineOptions: function(element) {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar dataset = chart.data.datasets[me.index];\n\t\tvar custom = element.custom || {};\n\t\tvar options = chart.options;\n\t\tvar elementOptions = options.elements.line;\n\t\tvar values = {};\n\t\tvar i, ilen, key;\n\n\t\tvar keys = [\n\t\t\t'backgroundColor',\n\t\t\t'borderWidth',\n\t\t\t'borderColor',\n\t\t\t'borderCapStyle',\n\t\t\t'borderDash',\n\t\t\t'borderDashOffset',\n\t\t\t'borderJoinStyle',\n\t\t\t'fill',\n\t\t\t'cubicInterpolationMode'\n\t\t];\n\n\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\tkey = keys[i];\n\t\t\tvalues[key] = resolve$4([\n\t\t\t\tcustom[key],\n\t\t\t\tdataset[key],\n\t\t\t\telementOptions[key]\n\t\t\t]);\n\t\t}\n\n\t\t// The default behavior of lines is to break at null values, according\n\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\n\t\t// This option gives lines the ability to span gaps\n\t\tvalues.spanGaps = valueOrDefault$5(dataset.spanGaps, options.spanGaps);\n\t\tvalues.tension = valueOrDefault$5(dataset.lineTension, elementOptions.tension);\n\t\tvalues.steppedLine = resolve$4([custom.steppedLine, dataset.steppedLine, elementOptions.stepped]);\n\n\t\treturn values;\n\t},\n\n\tcalculatePointY: function(value, index, datasetIndex) {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar meta = me.getMeta();\n\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\tvar sumPos = 0;\n\t\tvar sumNeg = 0;\n\t\tvar i, ds, dsMeta;\n\n\t\tif (yScale.options.stacked) {\n\t\t\tfor (i = 0; i < datasetIndex; i++) {\n\t\t\t\tds = chart.data.datasets[i];\n\t\t\t\tdsMeta = chart.getDatasetMeta(i);\n\t\t\t\tif (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n\t\t\t\t\tvar stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\n\t\t\t\t\tif (stackedRightValue < 0) {\n\t\t\t\t\t\tsumNeg += stackedRightValue || 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsumPos += stackedRightValue || 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar rightValue = Number(yScale.getRightValue(value));\n\t\t\tif (rightValue < 0) {\n\t\t\t\treturn yScale.getPixelForValue(sumNeg + rightValue);\n\t\t\t}\n\t\t\treturn yScale.getPixelForValue(sumPos + rightValue);\n\t\t}\n\n\t\treturn yScale.getPixelForValue(value);\n\t},\n\n\tupdateBezierControlPoints: function() {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar meta = me.getMeta();\n\t\tvar lineModel = meta.dataset._model;\n\t\tvar area = chart.chartArea;\n\t\tvar points = meta.data || [];\n\t\tvar i, ilen, model, controlPoints;\n\n\t\t// Only consider points that are drawn in case the spanGaps option is used\n\t\tif (lineModel.spanGaps) {\n\t\t\tpoints = points.filter(function(pt) {\n\t\t\t\treturn !pt._model.skip;\n\t\t\t});\n\t\t}\n\n\t\tfunction capControlPoint(pt, min, max) {\n\t\t\treturn Math.max(Math.min(pt, max), min);\n\t\t}\n\n\t\tif (lineModel.cubicInterpolationMode === 'monotone') {\n\t\t\thelpers$1.splineCurveMonotone(points);\n\t\t} else {\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tmodel = points[i]._model;\n\t\t\t\tcontrolPoints = helpers$1.splineCurve(\n\t\t\t\t\thelpers$1.previousItem(points, i)._model,\n\t\t\t\t\tmodel,\n\t\t\t\t\thelpers$1.nextItem(points, i)._model,\n\t\t\t\t\tlineModel.tension\n\t\t\t\t);\n\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\n\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\n\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\n\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\n\t\t\t}\n\t\t}\n\n\t\tif (chart.options.elements.line.capBezierPoints) {\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tmodel = points[i]._model;\n\t\t\t\tif (isPointInArea(model, area)) {\n\t\t\t\t\tif (i > 0 && isPointInArea(points[i - 1]._model, area)) {\n\t\t\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n\t\t\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n\t\t\t\t\t}\n\t\t\t\t\tif (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {\n\t\t\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n\t\t\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar meta = me.getMeta();\n\t\tvar points = meta.data || [];\n\t\tvar area = chart.chartArea;\n\t\tvar ilen = points.length;\n\t\tvar halfBorderWidth;\n\t\tvar i = 0;\n\n\t\tif (lineEnabled(me.getDataset(), chart.options)) {\n\t\t\thalfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;\n\n\t\t\thelpers$1.canvas.clipArea(chart.ctx, {\n\t\t\t\tleft: area.left,\n\t\t\t\tright: area.right,\n\t\t\t\ttop: area.top - halfBorderWidth,\n\t\t\t\tbottom: area.bottom + halfBorderWidth\n\t\t\t});\n\n\t\t\tmeta.dataset.draw();\n\n\t\t\thelpers$1.canvas.unclipArea(chart.ctx);\n\t\t}\n\n\t\t// Draw the points\n\t\tfor (; i < ilen; ++i) {\n\t\t\tpoints[i].draw(area);\n\t\t}\n\t},\n\n\t/**\n\t * @protected\n\t */\n\tsetHoverStyle: function(point) {\n\t\tvar model = point._model;\n\t\tvar options = point._options;\n\t\tvar getHoverColor = helpers$1.getHoverColor;\n\n\t\tpoint.$previousStyle = {\n\t\t\tbackgroundColor: model.backgroundColor,\n\t\t\tborderColor: model.borderColor,\n\t\t\tborderWidth: model.borderWidth,\n\t\t\tradius: model.radius\n\t\t};\n\n\t\tmodel.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n\t\tmodel.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));\n\t\tmodel.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);\n\t\tmodel.radius = valueOrDefault$5(options.hoverRadius, options.radius);\n\t},\n});\n\nvar resolve$5 = helpers$1.options.resolve;\n\ncore_defaults._set('polarArea', {\n\tscale: {\n\t\ttype: 'radialLinear',\n\t\tangleLines: {\n\t\t\tdisplay: false\n\t\t},\n\t\tgridLines: {\n\t\t\tcircular: true\n\t\t},\n\t\tpointLabels: {\n\t\t\tdisplay: false\n\t\t},\n\t\tticks: {\n\t\t\tbeginAtZero: true\n\t\t}\n\t},\n\n\t// Boolean - Whether to animate the rotation of the chart\n\tanimation: {\n\t\tanimateRotate: true,\n\t\tanimateScale: true\n\t},\n\n\tstartAngle: -0.5 * Math.PI,\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\n\t\tvar data = chart.data;\n\t\tvar datasets = data.datasets;\n\t\tvar labels = data.labels;\n\n\t\tif (datasets.length) {\n\t\t\tfor (var i = 0; i < datasets[0].data.length; ++i) {\n\t\t\t\ttext.push('<li><span style=\"background-color:' + datasets[0].backgroundColor[i] + '\"></span>');\n\t\t\t\tif (labels[i]) {\n\t\t\t\t\ttext.push(labels[i]);\n\t\t\t\t}\n\t\t\t\ttext.push('</li>');\n\t\t\t}\n\t\t}\n\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t},\n\tlegend: {\n\t\tlabels: {\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\tif (data.labels.length && data.datasets.length) {\n\t\t\t\t\treturn data.labels.map(function(label, i) {\n\t\t\t\t\t\tvar meta = chart.getDatasetMeta(0);\n\t\t\t\t\t\tvar ds = data.datasets[0];\n\t\t\t\t\t\tvar arc = meta.data[i];\n\t\t\t\t\t\tvar custom = arc.custom || {};\n\t\t\t\t\t\tvar arcOpts = chart.options.elements.arc;\n\t\t\t\t\t\tvar fill = resolve$5([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);\n\t\t\t\t\t\tvar stroke = resolve$5([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);\n\t\t\t\t\t\tvar bw = resolve$5([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttext: label,\n\t\t\t\t\t\t\tfillStyle: fill,\n\t\t\t\t\t\t\tstrokeStyle: stroke,\n\t\t\t\t\t\t\tlineWidth: bw,\n\t\t\t\t\t\t\thidden: isNaN(ds.data[i]) || meta.data[i].hidden,\n\n\t\t\t\t\t\t\t// Extra data used for toggling the correct item\n\t\t\t\t\t\t\tindex: i\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\t\t},\n\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.index;\n\t\t\tvar chart = this.chart;\n\t\t\tvar i, ilen, meta;\n\n\t\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tmeta.data[index].hidden = !meta.data[index].hidden;\n\t\t\t}\n\n\t\t\tchart.update();\n\t\t}\n\t},\n\n\t// Need to override these to give a nice default\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\treturn '';\n\t\t\t},\n\t\t\tlabel: function(item, data) {\n\t\t\t\treturn data.labels[item.index] + ': ' + item.yLabel;\n\t\t\t}\n\t\t}\n\t}\n});\n\nvar controller_polarArea = core_datasetController.extend({\n\n\tdataElementType: elements.Arc,\n\n\tlinkScales: helpers$1.noop,\n\n\tupdate: function(reset) {\n\t\tvar me = this;\n\t\tvar dataset = me.getDataset();\n\t\tvar meta = me.getMeta();\n\t\tvar start = me.chart.options.startAngle || 0;\n\t\tvar starts = me._starts = [];\n\t\tvar angles = me._angles = [];\n\t\tvar arcs = meta.data;\n\t\tvar i, ilen, angle;\n\n\t\tme._updateRadius();\n\n\t\tmeta.count = me.countVisibleElements();\n\n\t\tfor (i = 0, ilen = dataset.data.length; i < ilen; i++) {\n\t\t\tstarts[i] = start;\n\t\t\tangle = me._computeAngle(i);\n\t\t\tangles[i] = angle;\n\t\t\tstart += angle;\n\t\t}\n\n\t\tfor (i = 0, ilen = arcs.length; i < ilen; ++i) {\n\t\t\tarcs[i]._options = me._resolveElementOptions(arcs[i], i);\n\t\t\tme.updateElement(arcs[i], i, reset);\n\t\t}\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_updateRadius: function() {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar chartArea = chart.chartArea;\n\t\tvar opts = chart.options;\n\t\tvar minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\n\t\tchart.outerRadius = Math.max(minSize / 2, 0);\n\t\tchart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n\t\tchart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();\n\n\t\tme.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);\n\t\tme.innerRadius = me.outerRadius - chart.radiusLength;\n\t},\n\n\tupdateElement: function(arc, index, reset) {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar dataset = me.getDataset();\n\t\tvar opts = chart.options;\n\t\tvar animationOpts = opts.animation;\n\t\tvar scale = chart.scale;\n\t\tvar labels = chart.data.labels;\n\n\t\tvar centerX = scale.xCenter;\n\t\tvar centerY = scale.yCenter;\n\n\t\t// var negHalfPI = -0.5 * Math.PI;\n\t\tvar datasetStartAngle = opts.startAngle;\n\t\tvar distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\t\tvar startAngle = me._starts[index];\n\t\tvar endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);\n\n\t\tvar resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);\n\t\tvar options = arc._options || {};\n\n\t\thelpers$1.extend(arc, {\n\t\t\t// Utility\n\t\t\t_datasetIndex: me.index,\n\t\t\t_index: index,\n\t\t\t_scale: scale,\n\n\t\t\t// Desired view properties\n\t\t\t_model: {\n\t\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\t\tborderColor: options.borderColor,\n\t\t\t\tborderWidth: options.borderWidth,\n\t\t\t\tborderAlign: options.borderAlign,\n\t\t\t\tx: centerX,\n\t\t\t\ty: centerY,\n\t\t\t\tinnerRadius: 0,\n\t\t\t\touterRadius: reset ? resetRadius : distance,\n\t\t\t\tstartAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,\n\t\t\t\tendAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,\n\t\t\t\tlabel: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])\n\t\t\t}\n\t\t});\n\n\t\tarc.pivot();\n\t},\n\n\tcountVisibleElements: function() {\n\t\tvar dataset = this.getDataset();\n\t\tvar meta = this.getMeta();\n\t\tvar count = 0;\n\n\t\thelpers$1.each(meta.data, function(element, index) {\n\t\t\tif (!isNaN(dataset.data[index]) && !element.hidden) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t});\n\n\t\treturn count;\n\t},\n\n\t/**\n\t * @protected\n\t */\n\tsetHoverStyle: function(arc) {\n\t\tvar model = arc._model;\n\t\tvar options = arc._options;\n\t\tvar getHoverColor = helpers$1.getHoverColor;\n\t\tvar valueOrDefault = helpers$1.valueOrDefault;\n\n\t\tarc.$previousStyle = {\n\t\t\tbackgroundColor: model.backgroundColor,\n\t\t\tborderColor: model.borderColor,\n\t\t\tborderWidth: model.borderWidth,\n\t\t};\n\n\t\tmodel.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n\t\tmodel.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));\n\t\tmodel.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_resolveElementOptions: function(arc, index) {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar dataset = me.getDataset();\n\t\tvar custom = arc.custom || {};\n\t\tvar options = chart.options.elements.arc;\n\t\tvar values = {};\n\t\tvar i, ilen, key;\n\n\t\t// Scriptable options\n\t\tvar context = {\n\t\t\tchart: chart,\n\t\t\tdataIndex: index,\n\t\t\tdataset: dataset,\n\t\t\tdatasetIndex: me.index\n\t\t};\n\n\t\tvar keys = [\n\t\t\t'backgroundColor',\n\t\t\t'borderColor',\n\t\t\t'borderWidth',\n\t\t\t'borderAlign',\n\t\t\t'hoverBackgroundColor',\n\t\t\t'hoverBorderColor',\n\t\t\t'hoverBorderWidth',\n\t\t];\n\n\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\tkey = keys[i];\n\t\t\tvalues[key] = resolve$5([\n\t\t\t\tcustom[key],\n\t\t\t\tdataset[key],\n\t\t\t\toptions[key]\n\t\t\t], context, index);\n\t\t}\n\n\t\treturn values;\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_computeAngle: function(index) {\n\t\tvar me = this;\n\t\tvar count = this.getMeta().count;\n\t\tvar dataset = me.getDataset();\n\t\tvar meta = me.getMeta();\n\n\t\tif (isNaN(dataset.data[index]) || meta.data[index].hidden) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Scriptable options\n\t\tvar context = {\n\t\t\tchart: me.chart,\n\t\t\tdataIndex: index,\n\t\t\tdataset: dataset,\n\t\t\tdatasetIndex: me.index\n\t\t};\n\n\t\treturn resolve$5([\n\t\t\tme.chart.options.elements.arc.angle,\n\t\t\t(2 * Math.PI) / count\n\t\t], context, index);\n\t}\n});\n\ncore_defaults._set('pie', helpers$1.clone(core_defaults.doughnut));\ncore_defaults._set('pie', {\n\tcutoutPercentage: 0\n});\n\n// Pie charts are Doughnut chart with different defaults\nvar controller_pie = controller_doughnut;\n\nvar valueOrDefault$6 = helpers$1.valueOrDefault;\nvar resolve$6 = helpers$1.options.resolve;\n\ncore_defaults._set('radar', {\n\tscale: {\n\t\ttype: 'radialLinear'\n\t},\n\telements: {\n\t\tline: {\n\t\t\ttension: 0 // no bezier in radar\n\t\t}\n\t}\n});\n\nvar controller_radar = core_datasetController.extend({\n\n\tdatasetElementType: elements.Line,\n\n\tdataElementType: elements.Point,\n\n\tlinkScales: helpers$1.noop,\n\n\tupdate: function(reset) {\n\t\tvar me = this;\n\t\tvar meta = me.getMeta();\n\t\tvar line = meta.dataset;\n\t\tvar points = meta.data || [];\n\t\tvar scale = me.chart.scale;\n\t\tvar dataset = me.getDataset();\n\t\tvar i, ilen;\n\n\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\tdataset.lineTension = dataset.tension;\n\t\t}\n\n\t\t// Utility\n\t\tline._scale = scale;\n\t\tline._datasetIndex = me.index;\n\t\t// Data\n\t\tline._children = points;\n\t\tline._loop = true;\n\t\t// Model\n\t\tline._model = me._resolveLineOptions(line);\n\n\t\tline.pivot();\n\n\t\t// Update Points\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\tme.updateElement(points[i], i, reset);\n\t\t}\n\n\t\t// Update bezier control points\n\t\tme.updateBezierControlPoints();\n\n\t\t// Now pivot the point for animation\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\tpoints[i].pivot();\n\t\t}\n\t},\n\n\tupdateElement: function(point, index, reset) {\n\t\tvar me = this;\n\t\tvar custom = point.custom || {};\n\t\tvar dataset = me.getDataset();\n\t\tvar scale = me.chart.scale;\n\t\tvar pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);\n\t\tvar options = me._resolvePointOptions(point, index);\n\t\tvar lineModel = me.getMeta().dataset._model;\n\t\tvar x = reset ? scale.xCenter : pointPosition.x;\n\t\tvar y = reset ? scale.yCenter : pointPosition.y;\n\n\t\t// Utility\n\t\tpoint._scale = scale;\n\t\tpoint._options = options;\n\t\tpoint._datasetIndex = me.index;\n\t\tpoint._index = index;\n\n\t\t// Desired view properties\n\t\tpoint._model = {\n\t\t\tx: x, // value not used in dataset scale, but we want a consistent API between scales\n\t\t\ty: y,\n\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t// Appearance\n\t\t\tradius: options.radius,\n\t\t\tpointStyle: options.pointStyle,\n\t\t\trotation: options.rotation,\n\t\t\tbackgroundColor: options.backgroundColor,\n\t\t\tborderColor: options.borderColor,\n\t\t\tborderWidth: options.borderWidth,\n\t\t\ttension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),\n\n\t\t\t// Tooltip\n\t\t\thitRadius: options.hitRadius\n\t\t};\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_resolvePointOptions: function(element, index) {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar dataset = chart.data.datasets[me.index];\n\t\tvar custom = element.custom || {};\n\t\tvar options = chart.options.elements.point;\n\t\tvar values = {};\n\t\tvar i, ilen, key;\n\n\t\t// Scriptable options\n\t\tvar context = {\n\t\t\tchart: chart,\n\t\t\tdataIndex: index,\n\t\t\tdataset: dataset,\n\t\t\tdatasetIndex: me.index\n\t\t};\n\n\t\tvar ELEMENT_OPTIONS = {\n\t\t\tbackgroundColor: 'pointBackgroundColor',\n\t\t\tborderColor: 'pointBorderColor',\n\t\t\tborderWidth: 'pointBorderWidth',\n\t\t\thitRadius: 'pointHitRadius',\n\t\t\thoverBackgroundColor: 'pointHoverBackgroundColor',\n\t\t\thoverBorderColor: 'pointHoverBorderColor',\n\t\t\thoverBorderWidth: 'pointHoverBorderWidth',\n\t\t\thoverRadius: 'pointHoverRadius',\n\t\t\tpointStyle: 'pointStyle',\n\t\t\tradius: 'pointRadius',\n\t\t\trotation: 'pointRotation'\n\t\t};\n\t\tvar keys = Object.keys(ELEMENT_OPTIONS);\n\n\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\tkey = keys[i];\n\t\t\tvalues[key] = resolve$6([\n\t\t\t\tcustom[key],\n\t\t\t\tdataset[ELEMENT_OPTIONS[key]],\n\t\t\t\tdataset[key],\n\t\t\t\toptions[key]\n\t\t\t], context, index);\n\t\t}\n\n\t\treturn values;\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_resolveLineOptions: function(element) {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar dataset = chart.data.datasets[me.index];\n\t\tvar custom = element.custom || {};\n\t\tvar options = chart.options.elements.line;\n\t\tvar values = {};\n\t\tvar i, ilen, key;\n\n\t\tvar keys = [\n\t\t\t'backgroundColor',\n\t\t\t'borderWidth',\n\t\t\t'borderColor',\n\t\t\t'borderCapStyle',\n\t\t\t'borderDash',\n\t\t\t'borderDashOffset',\n\t\t\t'borderJoinStyle',\n\t\t\t'fill'\n\t\t];\n\n\t\tfor (i = 0, ilen = keys.length; i < ilen; ++i) {\n\t\t\tkey = keys[i];\n\t\t\tvalues[key] = resolve$6([\n\t\t\t\tcustom[key],\n\t\t\t\tdataset[key],\n\t\t\t\toptions[key]\n\t\t\t]);\n\t\t}\n\n\t\tvalues.tension = valueOrDefault$6(dataset.lineTension, options.tension);\n\n\t\treturn values;\n\t},\n\n\tupdateBezierControlPoints: function() {\n\t\tvar me = this;\n\t\tvar meta = me.getMeta();\n\t\tvar area = me.chart.chartArea;\n\t\tvar points = meta.data || [];\n\t\tvar i, ilen, model, controlPoints;\n\n\t\tfunction capControlPoint(pt, min, max) {\n\t\t\treturn Math.max(Math.min(pt, max), min);\n\t\t}\n\n\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\tmodel = points[i]._model;\n\t\t\tcontrolPoints = helpers$1.splineCurve(\n\t\t\t\thelpers$1.previousItem(points, i, true)._model,\n\t\t\t\tmodel,\n\t\t\t\thelpers$1.nextItem(points, i, true)._model,\n\t\t\t\tmodel.tension\n\t\t\t);\n\n\t\t\t// Prevent the bezier going outside of the bounds of the graph\n\t\t\tmodel.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);\n\t\t\tmodel.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);\n\t\t\tmodel.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);\n\t\t\tmodel.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);\n\t\t}\n\t},\n\n\tsetHoverStyle: function(point) {\n\t\tvar model = point._model;\n\t\tvar options = point._options;\n\t\tvar getHoverColor = helpers$1.getHoverColor;\n\n\t\tpoint.$previousStyle = {\n\t\t\tbackgroundColor: model.backgroundColor,\n\t\t\tborderColor: model.borderColor,\n\t\t\tborderWidth: model.borderWidth,\n\t\t\tradius: model.radius\n\t\t};\n\n\t\tmodel.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));\n\t\tmodel.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));\n\t\tmodel.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);\n\t\tmodel.radius = valueOrDefault$6(options.hoverRadius, options.radius);\n\t}\n});\n\ncore_defaults._set('scatter', {\n\thover: {\n\t\tmode: 'single'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\tid: 'x-axis-1',    // need an ID so datasets can reference the scale\n\t\t\ttype: 'linear',    // scatter should not use a category axis\n\t\t\tposition: 'bottom'\n\t\t}],\n\t\tyAxes: [{\n\t\t\tid: 'y-axis-1',\n\t\t\ttype: 'linear',\n\t\t\tposition: 'left'\n\t\t}]\n\t},\n\n\tshowLines: false,\n\n\ttooltips: {\n\t\tcallbacks: {\n\t\t\ttitle: function() {\n\t\t\t\treturn '';     // doesn't make sense for scatter since data are formatted as a point\n\t\t\t},\n\t\t\tlabel: function(item) {\n\t\t\t\treturn '(' + item.xLabel + ', ' + item.yLabel + ')';\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Scatter charts use line controllers\nvar controller_scatter = controller_line;\n\n// NOTE export a map in which the key represents the controller type, not\n// the class, and so must be CamelCase in order to be correctly retrieved\n// by the controller in core.controller.js (`controllers[meta.type]`).\n\nvar controllers = {\n\tbar: controller_bar,\n\tbubble: controller_bubble,\n\tdoughnut: controller_doughnut,\n\thorizontalBar: controller_horizontalBar,\n\tline: controller_line,\n\tpolarArea: controller_polarArea,\n\tpie: controller_pie,\n\tradar: controller_radar,\n\tscatter: controller_scatter\n};\n\n/**\n * Helper function to get relative position for an event\n * @param {Event|IEvent} event - The event to get the position for\n * @param {Chart} chart - The chart\n * @returns {object} the event position\n */\nfunction getRelativePosition(e, chart) {\n\tif (e.native) {\n\t\treturn {\n\t\t\tx: e.x,\n\t\t\ty: e.y\n\t\t};\n\t}\n\n\treturn helpers$1.getRelativePosition(e, chart);\n}\n\n/**\n * Helper function to traverse all of the visible elements in the chart\n * @param {Chart} chart - the chart\n * @param {function} handler - the callback to execute for each visible item\n */\nfunction parseVisibleItems(chart, handler) {\n\tvar datasets = chart.data.datasets;\n\tvar meta, i, j, ilen, jlen;\n\n\tfor (i = 0, ilen = datasets.length; i < ilen; ++i) {\n\t\tif (!chart.isDatasetVisible(i)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tmeta = chart.getDatasetMeta(i);\n\t\tfor (j = 0, jlen = meta.data.length; j < jlen; ++j) {\n\t\t\tvar element = meta.data[j];\n\t\t\tif (!element._view.skip) {\n\t\t\t\thandler(element);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Helper function to get the items that intersect the event position\n * @param {ChartElement[]} items - elements to filter\n * @param {object} position - the point to be nearest to\n * @return {ChartElement[]} the nearest items\n */\nfunction getIntersectItems(chart, position) {\n\tvar elements = [];\n\n\tparseVisibleItems(chart, function(element) {\n\t\tif (element.inRange(position.x, position.y)) {\n\t\t\telements.push(element);\n\t\t}\n\t});\n\n\treturn elements;\n}\n\n/**\n * Helper function to get the items nearest to the event position considering all visible items in teh chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {object} position - the point to be nearest to\n * @param {boolean} intersect - if true, only consider items that intersect the position\n * @param {function} distanceMetric - function to provide the distance between points\n * @return {ChartElement[]} the nearest items\n */\nfunction getNearestItems(chart, position, intersect, distanceMetric) {\n\tvar minDistance = Number.POSITIVE_INFINITY;\n\tvar nearestItems = [];\n\n\tparseVisibleItems(chart, function(element) {\n\t\tif (intersect && !element.inRange(position.x, position.y)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar center = element.getCenterPoint();\n\t\tvar distance = distanceMetric(position, center);\n\t\tif (distance < minDistance) {\n\t\t\tnearestItems = [element];\n\t\t\tminDistance = distance;\n\t\t} else if (distance === minDistance) {\n\t\t\t// Can have multiple items at the same distance in which case we sort by size\n\t\t\tnearestItems.push(element);\n\t\t}\n\t});\n\n\treturn nearestItems;\n}\n\n/**\n * Get a distance metric function for two points based on the\n * axis mode setting\n * @param {string} axis - the axis mode. x|y|xy\n */\nfunction getDistanceMetricForAxis(axis) {\n\tvar useX = axis.indexOf('x') !== -1;\n\tvar useY = axis.indexOf('y') !== -1;\n\n\treturn function(pt1, pt2) {\n\t\tvar deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n\t\tvar deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n\t\treturn Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n\t};\n}\n\nfunction indexMode(chart, e, options) {\n\tvar position = getRelativePosition(e, chart);\n\t// Default axis for index mode is 'x' to match old behaviour\n\toptions.axis = options.axis || 'x';\n\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\tvar elements = [];\n\n\tif (!items.length) {\n\t\treturn [];\n\t}\n\n\tchart.data.datasets.forEach(function(dataset, datasetIndex) {\n\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\tvar element = meta.data[items[0]._index];\n\n\t\t\t// don't count items that are skipped (null data)\n\t\t\tif (element && !element._view.skip) {\n\t\t\t\telements.push(element);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn elements;\n}\n\n/**\n * @interface IInteractionOptions\n */\n/**\n * If true, only consider items that intersect the point\n * @name IInterfaceOptions#boolean\n * @type Boolean\n */\n\n/**\n * Contains interaction related functions\n * @namespace Chart.Interaction\n */\nvar core_interaction = {\n\t// Helper function for different modes\n\tmodes: {\n\t\tsingle: function(chart, e) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar elements = [];\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\telements.push(element);\n\t\t\t\t\treturn elements;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn elements.slice(0, 1);\n\t\t},\n\n\t\t/**\n\t\t * @function Chart.Interaction.modes.label\n\t\t * @deprecated since version 2.4.0\n\t\t * @todo remove at version 3\n\t\t * @private\n\t\t */\n\t\tlabel: indexMode,\n\n\t\t/**\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t * @function Chart.Interaction.modes.index\n\t\t * @since v2.4.0\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {IInteractionOptions} options - options to use during interaction\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tindex: indexMode,\n\n\t\t/**\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t * @function Chart.Interaction.modes.dataset\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {IInteractionOptions} options - options to use during interaction\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tdataset: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\toptions.axis = options.axis || 'xy';\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\t\t\tvar items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);\n\n\t\t\tif (items.length > 0) {\n\t\t\t\titems = chart.getDatasetMeta(items[0]._datasetIndex).data;\n\t\t\t}\n\n\t\t\treturn items;\n\t\t},\n\n\t\t/**\n\t\t * @function Chart.Interaction.modes.x-axis\n\t\t * @deprecated since version 2.4.0. Use index mode and intersect == true\n\t\t * @todo remove at version 3\n\t\t * @private\n\t\t */\n\t\t'x-axis': function(chart, e) {\n\t\t\treturn indexMode(chart, e, {intersect: false});\n\t\t},\n\n\t\t/**\n\t\t * Point mode returns all elements that hit test based on the event position\n\t\t * of the event\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tpoint: function(chart, e) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\treturn getIntersectItems(chart, position);\n\t\t},\n\n\t\t/**\n\t\t * nearest mode returns the element closest to the point\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {IInteractionOptions} options - options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tnearest: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\toptions.axis = options.axis || 'xy';\n\t\t\tvar distanceMetric = getDistanceMetricForAxis(options.axis);\n\t\t\treturn getNearestItems(chart, position, options.intersect, distanceMetric);\n\t\t},\n\n\t\t/**\n\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t * @function Chart.Interaction.modes.x\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {IInteractionOptions} options - options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\tx: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar items = [];\n\t\t\tvar intersectsItem = false;\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inXRange(position.x)) {\n\t\t\t\t\titems.push(element);\n\t\t\t\t}\n\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\tintersectsItem = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t// that intersect the position, return nothing\n\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\titems = [];\n\t\t\t}\n\t\t\treturn items;\n\t\t},\n\n\t\t/**\n\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t * @function Chart.Interaction.modes.y\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {IInteractionOptions} options - options to use\n\t\t * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned\n\t\t */\n\t\ty: function(chart, e, options) {\n\t\t\tvar position = getRelativePosition(e, chart);\n\t\t\tvar items = [];\n\t\t\tvar intersectsItem = false;\n\n\t\t\tparseVisibleItems(chart, function(element) {\n\t\t\t\tif (element.inYRange(position.y)) {\n\t\t\t\t\titems.push(element);\n\t\t\t\t}\n\n\t\t\t\tif (element.inRange(position.x, position.y)) {\n\t\t\t\t\tintersectsItem = true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// If we want to trigger on an intersect and we don't have any items\n\t\t\t// that intersect the position, return nothing\n\t\t\tif (options.intersect && !intersectsItem) {\n\t\t\t\titems = [];\n\t\t\t}\n\t\t\treturn items;\n\t\t}\n\t}\n};\n\nfunction filterByPosition(array, position) {\n\treturn helpers$1.where(array, function(v) {\n\t\treturn v.position === position;\n\t});\n}\n\nfunction sortByWeight(array, reverse) {\n\tarray.forEach(function(v, i) {\n\t\tv._tmpIndex_ = i;\n\t\treturn v;\n\t});\n\tarray.sort(function(a, b) {\n\t\tvar v0 = reverse ? b : a;\n\t\tvar v1 = reverse ? a : b;\n\t\treturn v0.weight === v1.weight ?\n\t\t\tv0._tmpIndex_ - v1._tmpIndex_ :\n\t\t\tv0.weight - v1.weight;\n\t});\n\tarray.forEach(function(v) {\n\t\tdelete v._tmpIndex_;\n\t});\n}\n\nfunction findMaxPadding(boxes) {\n\tvar top = 0;\n\tvar left = 0;\n\tvar bottom = 0;\n\tvar right = 0;\n\thelpers$1.each(boxes, function(box) {\n\t\tif (box.getPadding) {\n\t\t\tvar boxPadding = box.getPadding();\n\t\t\ttop = Math.max(top, boxPadding.top);\n\t\t\tleft = Math.max(left, boxPadding.left);\n\t\t\tbottom = Math.max(bottom, boxPadding.bottom);\n\t\t\tright = Math.max(right, boxPadding.right);\n\t\t}\n\t});\n\treturn {\n\t\ttop: top,\n\t\tleft: left,\n\t\tbottom: bottom,\n\t\tright: right\n\t};\n}\n\nfunction addSizeByPosition(boxes, size) {\n\thelpers$1.each(boxes, function(box) {\n\t\tsize[box.position] += box.isHorizontal() ? box.height : box.width;\n\t});\n}\n\ncore_defaults._set('global', {\n\tlayout: {\n\t\tpadding: {\n\t\t\ttop: 0,\n\t\t\tright: 0,\n\t\t\tbottom: 0,\n\t\t\tleft: 0\n\t\t}\n\t}\n});\n\n/**\n * @interface ILayoutItem\n * @prop {string} position - The position of the item in the chart layout. Possible values are\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\n * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n * @prop {boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down\n * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n * @prop {function} update - Takes two parameters: width and height. Returns size of item\n * @prop {function} getPadding -  Returns an object with padding on the edges\n * @prop {number} width - Width of item. Must be valid after update()\n * @prop {number} height - Height of item. Must be valid after update()\n * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update\n * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update\n * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update\n * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n */\n\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n// It is this service's responsibility of carrying out that layout.\nvar core_layouts = {\n\tdefaults: {},\n\n\t/**\n\t * Register a box to a chart.\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t * @param {Chart} chart - the chart to use\n\t * @param {ILayoutItem} item - the item to add to be layed out\n\t */\n\taddBox: function(chart, item) {\n\t\tif (!chart.boxes) {\n\t\t\tchart.boxes = [];\n\t\t}\n\n\t\t// initialize item with default values\n\t\titem.fullWidth = item.fullWidth || false;\n\t\titem.position = item.position || 'top';\n\t\titem.weight = item.weight || 0;\n\n\t\tchart.boxes.push(item);\n\t},\n\n\t/**\n\t * Remove a layoutItem from a chart\n\t * @param {Chart} chart - the chart to remove the box from\n\t * @param {ILayoutItem} layoutItem - the item to remove from the layout\n\t */\n\tremoveBox: function(chart, layoutItem) {\n\t\tvar index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n\t\tif (index !== -1) {\n\t\t\tchart.boxes.splice(index, 1);\n\t\t}\n\t},\n\n\t/**\n\t * Sets (or updates) options on the given `item`.\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t * @param {ILayoutItem} item - the item to configure with the given options\n\t * @param {object} options - the new item options.\n\t */\n\tconfigure: function(chart, item, options) {\n\t\tvar props = ['fullWidth', 'position', 'weight'];\n\t\tvar ilen = props.length;\n\t\tvar i = 0;\n\t\tvar prop;\n\n\t\tfor (; i < ilen; ++i) {\n\t\t\tprop = props[i];\n\t\t\tif (options.hasOwnProperty(prop)) {\n\t\t\t\titem[prop] = options[prop];\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t * then running a fitting algorithm\n\t * @param {Chart} chart - the chart\n\t * @param {number} width - the width to fit into\n\t * @param {number} height - the height to fit into\n\t */\n\tupdate: function(chart, width, height) {\n\t\tif (!chart) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar layoutOptions = chart.options.layout || {};\n\t\tvar padding = helpers$1.options.toPadding(layoutOptions.padding);\n\t\tvar leftPadding = padding.left;\n\t\tvar rightPadding = padding.right;\n\t\tvar topPadding = padding.top;\n\t\tvar bottomPadding = padding.bottom;\n\n\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\n\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\n\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\n\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\n\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\n\n\t\t// Sort boxes by weight. A higher weight is further away from the chart area\n\t\tsortByWeight(leftBoxes, true);\n\t\tsortByWeight(rightBoxes, false);\n\t\tsortByWeight(topBoxes, true);\n\t\tsortByWeight(bottomBoxes, false);\n\n\t\tvar verticalBoxes = leftBoxes.concat(rightBoxes);\n\t\tvar horizontalBoxes = topBoxes.concat(bottomBoxes);\n\t\tvar outerBoxes = verticalBoxes.concat(horizontalBoxes);\n\n\t\t// Essentially we now have any number of boxes on each of the 4 sides.\n\t\t// Our canvas looks like the following.\n\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n\t\t// B1 is the bottom axis\n\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n\t\t// an error will be thrown.\n\t\t//\n\t\t// |----------------------------------------------------|\n\t\t// |                  T1 (Full Width)                   |\n\t\t// |----------------------------------------------------|\n\t\t// |    |    |                 T2                  |    |\n\t\t// |    |----|-------------------------------------|----|\n\t\t// |    |    | C1 |                           | C2 |    |\n\t\t// |    |    |----|                           |----|    |\n\t\t// |    |    |                                     |    |\n\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\n\t\t// |    |    |                                     |    |\n\t\t// |    |    |----|                           |----|    |\n\t\t// |    |    | C3 |                           | C4 |    |\n\t\t// |    |----|-------------------------------------|----|\n\t\t// |    |    |                 B1                  |    |\n\t\t// |----------------------------------------------------|\n\t\t// |                  B2 (Full Width)                   |\n\t\t// |----------------------------------------------------|\n\t\t//\n\t\t// What we do to find the best sizing, we do the following\n\t\t// 1. Determine the minimum size of the chart area.\n\t\t// 2. Split the remaining width equally between each vertical axis\n\t\t// 3. Split the remaining height equally between each horizontal axis\n\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\n\t\t// 6. Refit each axis\n\t\t// 7. Position each axis in the final location\n\t\t// 8. Tell the chart the final location of the chart area\n\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\n\n\t\t// Step 1\n\t\tvar chartWidth = width - leftPadding - rightPadding;\n\t\tvar chartHeight = height - topPadding - bottomPadding;\n\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\n\n\t\t// Step 2\n\t\tvar verticalBoxWidth = (width - chartAreaWidth) / verticalBoxes.length;\n\n\t\t// Step 3\n\t\t// TODO re-limit horizontal axis height (this limit has affected only padding calculation since PR 1837)\n\t\t// var horizontalBoxHeight = (height - chartAreaHeight) / horizontalBoxes.length;\n\n\t\t// Step 4\n\t\tvar maxChartAreaWidth = chartWidth;\n\t\tvar maxChartAreaHeight = chartHeight;\n\t\tvar outerBoxSizes = {top: topPadding, left: leftPadding, bottom: bottomPadding, right: rightPadding};\n\t\tvar minBoxSizes = [];\n\t\tvar maxPadding;\n\n\t\tfunction getMinimumBoxSize(box) {\n\t\t\tvar minSize;\n\t\t\tvar isHorizontal = box.isHorizontal();\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2);\n\t\t\t\tmaxChartAreaHeight -= minSize.height;\n\t\t\t} else {\n\t\t\t\tminSize = box.update(verticalBoxWidth, maxChartAreaHeight);\n\t\t\t\tmaxChartAreaWidth -= minSize.width;\n\t\t\t}\n\n\t\t\tminBoxSizes.push({\n\t\t\t\thorizontal: isHorizontal,\n\t\t\t\twidth: minSize.width,\n\t\t\t\tbox: box,\n\t\t\t});\n\t\t}\n\n\t\thelpers$1.each(outerBoxes, getMinimumBoxSize);\n\n\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\n\t\tmaxPadding = findMaxPadding(outerBoxes);\n\n\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n\t\t// be if the axes are drawn at their minimum sizes.\n\t\t// Steps 5 & 6\n\n\t\t// Function to fit a box\n\t\tfunction fitBox(box) {\n\t\t\tvar minBoxSize = helpers$1.findNextWhere(minBoxSizes, function(minBox) {\n\t\t\t\treturn minBox.box === box;\n\t\t\t});\n\n\t\t\tif (minBoxSize) {\n\t\t\t\tif (minBoxSize.horizontal) {\n\t\t\t\t\tvar scaleMargin = {\n\t\t\t\t\t\tleft: Math.max(outerBoxSizes.left, maxPadding.left),\n\t\t\t\t\t\tright: Math.max(outerBoxSizes.right, maxPadding.right),\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\tbottom: 0\n\t\t\t\t\t};\n\n\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\n\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n\t\t\t\t} else {\n\t\t\t\t\tbox.update(minBoxSize.width, maxChartAreaHeight);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Update, and calculate the left and right margins for the horizontal boxes\n\t\thelpers$1.each(verticalBoxes, fitBox);\n\t\taddSizeByPosition(verticalBoxes, outerBoxSizes);\n\n\t\t// Set the Left and Right margins for the horizontal boxes\n\t\thelpers$1.each(horizontalBoxes, fitBox);\n\t\taddSizeByPosition(horizontalBoxes, outerBoxSizes);\n\n\t\tfunction finalFitVerticalBox(box) {\n\t\t\tvar minBoxSize = helpers$1.findNextWhere(minBoxSizes, function(minSize) {\n\t\t\t\treturn minSize.box === box;\n\t\t\t});\n\n\t\t\tvar scaleMargin = {\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttop: outerBoxSizes.top,\n\t\t\t\tbottom: outerBoxSizes.bottom\n\t\t\t};\n\n\t\t\tif (minBoxSize) {\n\t\t\t\tbox.update(minBoxSize.width, maxChartAreaHeight, scaleMargin);\n\t\t\t}\n\t\t}\n\n\t\t// Let the left layout know the final margin\n\t\thelpers$1.each(verticalBoxes, finalFitVerticalBox);\n\n\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n\t\touterBoxSizes = {top: topPadding, left: leftPadding, bottom: bottomPadding, right: rightPadding};\n\t\taddSizeByPosition(outerBoxes, outerBoxSizes);\n\n\t\t// We may be adding some padding to account for rotated x axis labels\n\t\tvar leftPaddingAddition = Math.max(maxPadding.left - outerBoxSizes.left, 0);\n\t\touterBoxSizes.left += leftPaddingAddition;\n\t\touterBoxSizes.right += Math.max(maxPadding.right - outerBoxSizes.right, 0);\n\n\t\tvar topPaddingAddition = Math.max(maxPadding.top - outerBoxSizes.top, 0);\n\t\touterBoxSizes.top += topPaddingAddition;\n\t\touterBoxSizes.bottom += Math.max(maxPadding.bottom - outerBoxSizes.bottom, 0);\n\n\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\n\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n\t\t// without calling `fit` again\n\t\tvar newMaxChartAreaHeight = height - outerBoxSizes.top - outerBoxSizes.bottom;\n\t\tvar newMaxChartAreaWidth = width - outerBoxSizes.left - outerBoxSizes.right;\n\n\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n\t\t\thelpers$1.each(verticalBoxes, function(box) {\n\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t});\n\n\t\t\thelpers$1.each(horizontalBoxes, function(box) {\n\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\n\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\n\t\t}\n\n\t\t// Step 7 - Position the boxes\n\t\tvar left = leftPadding + leftPaddingAddition;\n\t\tvar top = topPadding + topPaddingAddition;\n\n\t\tfunction placeBox(box) {\n\t\t\tif (box.isHorizontal()) {\n\t\t\t\tbox.left = box.fullWidth ? leftPadding : outerBoxSizes.left;\n\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : outerBoxSizes.left + maxChartAreaWidth;\n\t\t\t\tbox.top = top;\n\t\t\t\tbox.bottom = top + box.height;\n\n\t\t\t\t// Move to next point\n\t\t\t\ttop = box.bottom;\n\n\t\t\t} else {\n\n\t\t\t\tbox.left = left;\n\t\t\t\tbox.right = left + box.width;\n\t\t\t\tbox.top = outerBoxSizes.top;\n\t\t\t\tbox.bottom = outerBoxSizes.top + maxChartAreaHeight;\n\n\t\t\t\t// Move to next point\n\t\t\t\tleft = box.right;\n\t\t\t}\n\t\t}\n\n\t\thelpers$1.each(leftBoxes.concat(topBoxes), placeBox);\n\n\t\t// Account for chart width and height\n\t\tleft += maxChartAreaWidth;\n\t\ttop += maxChartAreaHeight;\n\n\t\thelpers$1.each(rightBoxes, placeBox);\n\t\thelpers$1.each(bottomBoxes, placeBox);\n\n\t\t// Step 8\n\t\tchart.chartArea = {\n\t\t\tleft: outerBoxSizes.left,\n\t\t\ttop: outerBoxSizes.top,\n\t\t\tright: outerBoxSizes.left + maxChartAreaWidth,\n\t\t\tbottom: outerBoxSizes.top + maxChartAreaHeight\n\t\t};\n\n\t\t// Step 9\n\t\thelpers$1.each(chartAreaBoxes, function(box) {\n\t\t\tbox.left = chart.chartArea.left;\n\t\t\tbox.top = chart.chartArea.top;\n\t\t\tbox.right = chart.chartArea.right;\n\t\t\tbox.bottom = chart.chartArea.bottom;\n\n\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\n\t\t});\n\t}\n};\n\n/**\n * Platform fallback implementation (minimal).\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\n */\n\nvar platform_basic = {\n\tacquireContext: function(item) {\n\t\tif (item && item.canvas) {\n\t\t\t// Support for any object associated to a canvas (including a context2d)\n\t\t\titem = item.canvas;\n\t\t}\n\n\t\treturn item && item.getContext('2d') || null;\n\t}\n};\n\nvar platform_dom = \"/*\\n * DOM element rendering detection\\n * https://davidwalsh.name/detect-node-insertion\\n */\\n@keyframes chartjs-render-animation {\\n\\tfrom { opacity: 0.99; }\\n\\tto { opacity: 1; }\\n}\\n\\n.chartjs-render-monitor {\\n\\tanimation: chartjs-render-animation 0.001s;\\n}\\n\\n/*\\n * DOM element resizing detection\\n * https://github.com/marcj/css-element-queries\\n */\\n.chartjs-size-monitor,\\n.chartjs-size-monitor-expand,\\n.chartjs-size-monitor-shrink {\\n\\tposition: absolute;\\n\\tdirection: ltr;\\n\\tleft: 0;\\n\\ttop: 0;\\n\\tright: 0;\\n\\tbottom: 0;\\n\\toverflow: hidden;\\n\\tpointer-events: none;\\n\\tvisibility: hidden;\\n\\tz-index: -1;\\n}\\n\\n.chartjs-size-monitor-expand > div {\\n\\tposition: absolute;\\n\\twidth: 1000000px;\\n\\theight: 1000000px;\\n\\tleft: 0;\\n\\ttop: 0;\\n}\\n\\n.chartjs-size-monitor-shrink > div {\\n\\tposition: absolute;\\n\\twidth: 200%;\\n\\theight: 200%;\\n\\tleft: 0;\\n\\ttop: 0;\\n}\\n\";\n\nvar platform_dom$1 = /*#__PURE__*/Object.freeze({\ndefault: platform_dom\n});\n\nfunction getCjsExportFromNamespace (n) {\n\treturn n && n.default || n;\n}\n\nvar stylesheet = getCjsExportFromNamespace(platform_dom$1);\n\nvar EXPANDO_KEY = '$chartjs';\nvar CSS_PREFIX = 'chartjs-';\nvar CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';\nvar CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';\nvar CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';\nvar ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];\n\n/**\n * DOM event types -> Chart.js event types.\n * Note: only events with different types are mapped.\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\n */\nvar EVENT_TYPES = {\n\ttouchstart: 'mousedown',\n\ttouchmove: 'mousemove',\n\ttouchend: 'mouseup',\n\tpointerenter: 'mouseenter',\n\tpointerdown: 'mousedown',\n\tpointermove: 'mousemove',\n\tpointerup: 'mouseup',\n\tpointerleave: 'mouseout',\n\tpointerout: 'mouseout'\n};\n\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns {number} Size in pixels or undefined if unknown.\n */\nfunction readUsedSize(element, property) {\n\tvar value = helpers$1.getStyle(element, property);\n\tvar matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n\treturn matches ? Number(matches[1]) : undefined;\n}\n\n/**\n * Initializes the canvas style and render size without modifying the canvas display size,\n * since responsiveness is handled by the controller.resize() method. The config is used\n * to determine the aspect ratio to apply in case no explicit height has been specified.\n */\nfunction initCanvas(canvas, config) {\n\tvar style = canvas.style;\n\n\t// NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n\t// returns null or '' if no explicit value has been set to the canvas attribute.\n\tvar renderHeight = canvas.getAttribute('height');\n\tvar renderWidth = canvas.getAttribute('width');\n\n\t// Chart.js modifies some canvas values that we want to restore on destroy\n\tcanvas[EXPANDO_KEY] = {\n\t\tinitial: {\n\t\t\theight: renderHeight,\n\t\t\twidth: renderWidth,\n\t\t\tstyle: {\n\t\t\t\tdisplay: style.display,\n\t\t\t\theight: style.height,\n\t\t\t\twidth: style.width\n\t\t\t}\n\t\t}\n\t};\n\n\t// Force canvas to display as block to avoid extra space caused by inline\n\t// elements, which would interfere with the responsive resize process.\n\t// https://github.com/chartjs/Chart.js/issues/2538\n\tstyle.display = style.display || 'block';\n\n\tif (renderWidth === null || renderWidth === '') {\n\t\tvar displayWidth = readUsedSize(canvas, 'width');\n\t\tif (displayWidth !== undefined) {\n\t\t\tcanvas.width = displayWidth;\n\t\t}\n\t}\n\n\tif (renderHeight === null || renderHeight === '') {\n\t\tif (canvas.style.height === '') {\n\t\t\t// If no explicit render height and style height, let's apply the aspect ratio,\n\t\t\t// which one can be specified by the user but also by charts as default option\n\t\t\t// (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n\t\t\tcanvas.height = canvas.width / (config.options.aspectRatio || 2);\n\t\t} else {\n\t\t\tvar displayHeight = readUsedSize(canvas, 'height');\n\t\t\tif (displayWidth !== undefined) {\n\t\t\t\tcanvas.height = displayHeight;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn canvas;\n}\n\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nvar supportsEventListenerOptions = (function() {\n\tvar supports = false;\n\ttry {\n\t\tvar options = Object.defineProperty({}, 'passive', {\n\t\t\t// eslint-disable-next-line getter-return\n\t\t\tget: function() {\n\t\t\t\tsupports = true;\n\t\t\t}\n\t\t});\n\t\twindow.addEventListener('e', null, options);\n\t} catch (e) {\n\t\t// continue regardless of error\n\t}\n\treturn supports;\n}());\n\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n// https://github.com/chartjs/Chart.js/issues/4287\nvar eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\n\nfunction addListener(node, type, listener) {\n\tnode.addEventListener(type, listener, eventListenerOptions);\n}\n\nfunction removeListener(node, type, listener) {\n\tnode.removeEventListener(type, listener, eventListenerOptions);\n}\n\nfunction createEvent(type, chart, x, y, nativeEvent) {\n\treturn {\n\t\ttype: type,\n\t\tchart: chart,\n\t\tnative: nativeEvent || null,\n\t\tx: x !== undefined ? x : null,\n\t\ty: y !== undefined ? y : null,\n\t};\n}\n\nfunction fromNativeEvent(event, chart) {\n\tvar type = EVENT_TYPES[event.type] || event.type;\n\tvar pos = helpers$1.getRelativePosition(event, chart);\n\treturn createEvent(type, chart, pos.x, pos.y, event);\n}\n\nfunction throttled(fn, thisArg) {\n\tvar ticking = false;\n\tvar args = [];\n\n\treturn function() {\n\t\targs = Array.prototype.slice.call(arguments);\n\t\tthisArg = thisArg || this;\n\n\t\tif (!ticking) {\n\t\t\tticking = true;\n\t\t\thelpers$1.requestAnimFrame.call(window, function() {\n\t\t\t\tticking = false;\n\t\t\t\tfn.apply(thisArg, args);\n\t\t\t});\n\t\t}\n\t};\n}\n\nfunction createDiv(cls) {\n\tvar el = document.createElement('div');\n\tel.className = cls || '';\n\treturn el;\n}\n\n// Implementation based on https://github.com/marcj/css-element-queries\nfunction createResizer(handler) {\n\tvar maxSize = 1000000;\n\n\t// NOTE(SB) Don't use innerHTML because it could be considered unsafe.\n\t// https://github.com/chartjs/Chart.js/issues/5902\n\tvar resizer = createDiv(CSS_SIZE_MONITOR);\n\tvar expand = createDiv(CSS_SIZE_MONITOR + '-expand');\n\tvar shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');\n\n\texpand.appendChild(createDiv());\n\tshrink.appendChild(createDiv());\n\n\tresizer.appendChild(expand);\n\tresizer.appendChild(shrink);\n\tresizer._reset = function() {\n\t\texpand.scrollLeft = maxSize;\n\t\texpand.scrollTop = maxSize;\n\t\tshrink.scrollLeft = maxSize;\n\t\tshrink.scrollTop = maxSize;\n\t};\n\n\tvar onScroll = function() {\n\t\tresizer._reset();\n\t\thandler();\n\t};\n\n\taddListener(expand, 'scroll', onScroll.bind(expand, 'expand'));\n\taddListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));\n\n\treturn resizer;\n}\n\n// https://davidwalsh.name/detect-node-insertion\nfunction watchForRender(node, handler) {\n\tvar expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\n\tvar proxy = expando.renderProxy = function(e) {\n\t\tif (e.animationName === CSS_RENDER_ANIMATION) {\n\t\t\thandler();\n\t\t}\n\t};\n\n\thelpers$1.each(ANIMATION_START_EVENTS, function(type) {\n\t\taddListener(node, type, proxy);\n\t});\n\n\t// #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class\n\t// is removed then added back immediately (same animation frame?). Accessing the\n\t// `offsetParent` property will force a reflow and re-evaluate the CSS animation.\n\t// https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics\n\t// https://github.com/chartjs/Chart.js/issues/4737\n\texpando.reflow = !!node.offsetParent;\n\n\tnode.classList.add(CSS_RENDER_MONITOR);\n}\n\nfunction unwatchForRender(node) {\n\tvar expando = node[EXPANDO_KEY] || {};\n\tvar proxy = expando.renderProxy;\n\n\tif (proxy) {\n\t\thelpers$1.each(ANIMATION_START_EVENTS, function(type) {\n\t\t\tremoveListener(node, type, proxy);\n\t\t});\n\n\t\tdelete expando.renderProxy;\n\t}\n\n\tnode.classList.remove(CSS_RENDER_MONITOR);\n}\n\nfunction addResizeListener(node, listener, chart) {\n\tvar expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});\n\n\t// Let's keep track of this added resizer and thus avoid DOM query when removing it.\n\tvar resizer = expando.resizer = createResizer(throttled(function() {\n\t\tif (expando.resizer) {\n\t\t\tvar container = chart.options.maintainAspectRatio && node.parentNode;\n\t\t\tvar w = container ? container.clientWidth : 0;\n\t\t\tlistener(createEvent('resize', chart));\n\t\t\tif (container && container.clientWidth < w && chart.canvas) {\n\t\t\t\t// If the container size shrank during chart resize, let's assume\n\t\t\t\t// scrollbar appeared. So we resize again with the scrollbar visible -\n\t\t\t\t// effectively making chart smaller and the scrollbar hidden again.\n\t\t\t\t// Because we are inside `throttled`, and currently `ticking`, scroll\n\t\t\t\t// events are ignored during this whole 2 resize process.\n\t\t\t\t// If we assumed wrong and something else happened, we are resizing\n\t\t\t\t// twice in a frame (potential performance issue)\n\t\t\t\tlistener(createEvent('resize', chart));\n\t\t\t}\n\t\t}\n\t}));\n\n\t// The resizer needs to be attached to the node parent, so we first need to be\n\t// sure that `node` is attached to the DOM before injecting the resizer element.\n\twatchForRender(node, function() {\n\t\tif (expando.resizer) {\n\t\t\tvar container = node.parentNode;\n\t\t\tif (container && container !== resizer.parentNode) {\n\t\t\t\tcontainer.insertBefore(resizer, container.firstChild);\n\t\t\t}\n\n\t\t\t// The container size might have changed, let's reset the resizer state.\n\t\t\tresizer._reset();\n\t\t}\n\t});\n}\n\nfunction removeResizeListener(node) {\n\tvar expando = node[EXPANDO_KEY] || {};\n\tvar resizer = expando.resizer;\n\n\tdelete expando.resizer;\n\tunwatchForRender(node);\n\n\tif (resizer && resizer.parentNode) {\n\t\tresizer.parentNode.removeChild(resizer);\n\t}\n}\n\nfunction injectCSS(platform, css) {\n\t// https://stackoverflow.com/q/3922139\n\tvar style = platform._style || document.createElement('style');\n\tif (!platform._style) {\n\t\tplatform._style = style;\n\t\tcss = '/* Chart.js */\\n' + css;\n\t\tstyle.setAttribute('type', 'text/css');\n\t\tdocument.getElementsByTagName('head')[0].appendChild(style);\n\t}\n\n\tstyle.appendChild(document.createTextNode(css));\n}\n\nvar platform_dom$2 = {\n\t/**\n\t * When `true`, prevents the automatic injection of the stylesheet required to\n\t * correctly detect when the chart is added to the DOM and then resized. This\n\t * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)\n\t * to be manually imported to make this library compatible with any CSP.\n\t * See https://github.com/chartjs/Chart.js/issues/5208\n\t */\n\tdisableCSSInjection: false,\n\n\t/**\n\t * This property holds whether this platform is enabled for the current environment.\n\t * Currently used by platform.js to select the proper implementation.\n\t * @private\n\t */\n\t_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',\n\n\t/**\n\t * @private\n\t */\n\t_ensureLoaded: function() {\n\t\tif (this._loaded) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._loaded = true;\n\n\t\t// https://github.com/chartjs/Chart.js/issues/5208\n\t\tif (!this.disableCSSInjection) {\n\t\t\tinjectCSS(this, stylesheet);\n\t\t}\n\t},\n\n\tacquireContext: function(item, config) {\n\t\tif (typeof item === 'string') {\n\t\t\titem = document.getElementById(item);\n\t\t} else if (item.length) {\n\t\t\t// Support for array based queries (such as jQuery)\n\t\t\titem = item[0];\n\t\t}\n\n\t\tif (item && item.canvas) {\n\t\t\t// Support for any object associated to a canvas (including a context2d)\n\t\t\titem = item.canvas;\n\t\t}\n\n\t\t// To prevent canvas fingerprinting, some add-ons undefine the getContext\n\t\t// method, for example: https://github.com/kkapsner/CanvasBlocker\n\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\tvar context = item && item.getContext && item.getContext('2d');\n\n\t\t// Load platform resources on first chart creation, to make possible to change\n\t\t// platform options after importing the library (e.g. `disableCSSInjection`).\n\t\tthis._ensureLoaded();\n\n\t\t// `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is\n\t\t// inside an iframe or when running in a protected environment. We could guess the\n\t\t// types from their toString() value but let's keep things flexible and assume it's\n\t\t// a sufficient condition if the item has a context2D which has item as `canvas`.\n\t\t// https://github.com/chartjs/Chart.js/issues/3887\n\t\t// https://github.com/chartjs/Chart.js/issues/4102\n\t\t// https://github.com/chartjs/Chart.js/issues/4152\n\t\tif (context && context.canvas === item) {\n\t\t\tinitCanvas(item, config);\n\t\t\treturn context;\n\t\t}\n\n\t\treturn null;\n\t},\n\n\treleaseContext: function(context) {\n\t\tvar canvas = context.canvas;\n\t\tif (!canvas[EXPANDO_KEY]) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar initial = canvas[EXPANDO_KEY].initial;\n\t\t['height', 'width'].forEach(function(prop) {\n\t\t\tvar value = initial[prop];\n\t\t\tif (helpers$1.isNullOrUndef(value)) {\n\t\t\t\tcanvas.removeAttribute(prop);\n\t\t\t} else {\n\t\t\t\tcanvas.setAttribute(prop, value);\n\t\t\t}\n\t\t});\n\n\t\thelpers$1.each(initial.style || {}, function(value, key) {\n\t\t\tcanvas.style[key] = value;\n\t\t});\n\n\t\t// The canvas render size might have been changed (and thus the state stack discarded),\n\t\t// we can't use save() and restore() to restore the initial state. So make sure that at\n\t\t// least the canvas context is reset to the default state by setting the canvas width.\n\t\t// https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n\t\t// eslint-disable-next-line no-self-assign\n\t\tcanvas.width = canvas.width;\n\n\t\tdelete canvas[EXPANDO_KEY];\n\t},\n\n\taddEventListener: function(chart, type, listener) {\n\t\tvar canvas = chart.canvas;\n\t\tif (type === 'resize') {\n\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\taddResizeListener(canvas, listener, chart);\n\t\t\treturn;\n\t\t}\n\n\t\tvar expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});\n\t\tvar proxies = expando.proxies || (expando.proxies = {});\n\t\tvar proxy = proxies[chart.id + '_' + type] = function(event) {\n\t\t\tlistener(fromNativeEvent(event, chart));\n\t\t};\n\n\t\taddListener(canvas, type, proxy);\n\t},\n\n\tremoveEventListener: function(chart, type, listener) {\n\t\tvar canvas = chart.canvas;\n\t\tif (type === 'resize') {\n\t\t\t// Note: the resize event is not supported on all browsers.\n\t\t\tremoveResizeListener(canvas);\n\t\t\treturn;\n\t\t}\n\n\t\tvar expando = listener[EXPANDO_KEY] || {};\n\t\tvar proxies = expando.proxies || {};\n\t\tvar proxy = proxies[chart.id + '_' + type];\n\t\tif (!proxy) {\n\t\t\treturn;\n\t\t}\n\n\t\tremoveListener(canvas, type, proxy);\n\t}\n};\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use EventTarget.addEventListener instead.\n * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n * @function Chart.helpers.addEvent\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers$1.addEvent = addListener;\n\n/**\n * Provided for backward compatibility, use EventTarget.removeEventListener instead.\n * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+\n * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\n * @function Chart.helpers.removeEvent\n * @deprecated since version 2.7.0\n * @todo remove at version 3\n * @private\n */\nhelpers$1.removeEvent = removeListener;\n\n// @TODO Make possible to select another platform at build time.\nvar implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;\n\n/**\n * @namespace Chart.platform\n * @see https://chartjs.gitbooks.io/proposals/content/Platform.html\n * @since 2.4.0\n */\nvar platform = helpers$1.extend({\n\t/**\n\t * @since 2.7.0\n\t */\n\tinitialize: function() {},\n\n\t/**\n\t * Called at chart construction time, returns a context2d instance implementing\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t * @param {*} item - The native item from which to acquire context (platform specific)\n\t * @param {object} options - The chart options\n\t * @returns {CanvasRenderingContext2D} context2d instance\n\t */\n\tacquireContext: function() {},\n\n\t/**\n\t * Called at chart destruction time, releases any resources associated to the context\n\t * previously returned by the acquireContext() method.\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t * @returns {boolean} true if the method succeeded, else false\n\t */\n\treleaseContext: function() {},\n\n\t/**\n\t * Registers the specified listener on the given chart.\n\t * @param {Chart} chart - Chart from which to listen for event\n\t * @param {string} type - The ({@link IEvent}) type to listen for\n\t * @param {function} listener - Receives a notification (an object that implements\n\t * the {@link IEvent} interface) when an event of the specified type occurs.\n\t */\n\taddEventListener: function() {},\n\n\t/**\n\t * Removes the specified listener previously registered with addEventListener.\n\t * @param {Chart} chart - Chart from which to remove the listener\n\t * @param {string} type - The ({@link IEvent}) type to remove\n\t * @param {function} listener - The listener function to remove from the event target.\n\t */\n\tremoveEventListener: function() {}\n\n}, implementation);\n\ncore_defaults._set('global', {\n\tplugins: {}\n});\n\n/**\n * The plugin service singleton\n * @namespace Chart.plugins\n * @since 2.1.0\n */\nvar core_plugins = {\n\t/**\n\t * Globally registered plugins.\n\t * @private\n\t */\n\t_plugins: [],\n\n\t/**\n\t * This identifier is used to invalidate the descriptors cache attached to each chart\n\t * when a global plugin is registered or unregistered. In this case, the cache ID is\n\t * incremented and descriptors are regenerated during following API calls.\n\t * @private\n\t */\n\t_cacheId: 0,\n\n\t/**\n\t * Registers the given plugin(s) if not already registered.\n\t * @param {IPlugin[]|IPlugin} plugins plugin instance(s).\n\t */\n\tregister: function(plugins) {\n\t\tvar p = this._plugins;\n\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\tif (p.indexOf(plugin) === -1) {\n\t\t\t\tp.push(plugin);\n\t\t\t}\n\t\t});\n\n\t\tthis._cacheId++;\n\t},\n\n\t/**\n\t * Unregisters the given plugin(s) only if registered.\n\t * @param {IPlugin[]|IPlugin} plugins plugin instance(s).\n\t */\n\tunregister: function(plugins) {\n\t\tvar p = this._plugins;\n\t\t([]).concat(plugins).forEach(function(plugin) {\n\t\t\tvar idx = p.indexOf(plugin);\n\t\t\tif (idx !== -1) {\n\t\t\t\tp.splice(idx, 1);\n\t\t\t}\n\t\t});\n\n\t\tthis._cacheId++;\n\t},\n\n\t/**\n\t * Remove all registered plugins.\n\t * @since 2.1.5\n\t */\n\tclear: function() {\n\t\tthis._plugins = [];\n\t\tthis._cacheId++;\n\t},\n\n\t/**\n\t * Returns the number of registered plugins?\n\t * @returns {number}\n\t * @since 2.1.5\n\t */\n\tcount: function() {\n\t\treturn this._plugins.length;\n\t},\n\n\t/**\n\t * Returns all registered plugin instances.\n\t * @returns {IPlugin[]} array of plugin objects.\n\t * @since 2.1.5\n\t */\n\tgetAll: function() {\n\t\treturn this._plugins;\n\t},\n\n\t/**\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {Chart} chart - The chart instance for which plugins should be called.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {Array} [args] - Extra arguments to apply to the hook call.\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n\tnotify: function(chart, hook, args) {\n\t\tvar descriptors = this.descriptors(chart);\n\t\tvar ilen = descriptors.length;\n\t\tvar i, descriptor, plugin, params, method;\n\n\t\tfor (i = 0; i < ilen; ++i) {\n\t\t\tdescriptor = descriptors[i];\n\t\t\tplugin = descriptor.plugin;\n\t\t\tmethod = plugin[hook];\n\t\t\tif (typeof method === 'function') {\n\t\t\t\tparams = [chart].concat(args || []);\n\t\t\t\tparams.push(descriptor.options);\n\t\t\t\tif (method.apply(plugin, params) === false) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Returns descriptors of enabled plugins for the given chart.\n\t * @returns {object[]} [{ plugin, options }]\n\t * @private\n\t */\n\tdescriptors: function(chart) {\n\t\tvar cache = chart.$plugins || (chart.$plugins = {});\n\t\tif (cache.id === this._cacheId) {\n\t\t\treturn cache.descriptors;\n\t\t}\n\n\t\tvar plugins = [];\n\t\tvar descriptors = [];\n\t\tvar config = (chart && chart.config) || {};\n\t\tvar options = (config.options && config.options.plugins) || {};\n\n\t\tthis._plugins.concat(config.plugins || []).forEach(function(plugin) {\n\t\t\tvar idx = plugins.indexOf(plugin);\n\t\t\tif (idx !== -1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar id = plugin.id;\n\t\t\tvar opts = options[id];\n\t\t\tif (opts === false) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (opts === true) {\n\t\t\t\topts = helpers$1.clone(core_defaults.global.plugins[id]);\n\t\t\t}\n\n\t\t\tplugins.push(plugin);\n\t\t\tdescriptors.push({\n\t\t\t\tplugin: plugin,\n\t\t\t\toptions: opts || {}\n\t\t\t});\n\t\t});\n\n\t\tcache.descriptors = descriptors;\n\t\tcache.id = this._cacheId;\n\t\treturn descriptors;\n\t},\n\n\t/**\n\t * Invalidates cache for the given chart: descriptors hold a reference on plugin option,\n\t * but in some cases, this reference can be changed by the user when updating options.\n\t * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n\t * @private\n\t */\n\t_invalidate: function(chart) {\n\t\tdelete chart.$plugins;\n\t}\n};\n\nvar core_scaleService = {\n\t// Scale registration object. Extensions can register new scale types (such as log or DB scales) and then\n\t// use the new chart options to grab the correct scale\n\tconstructors: {},\n\t// Use a registration function so that we can move to an ES6 map when we no longer need to support\n\t// old browsers\n\n\t// Scale config defaults\n\tdefaults: {},\n\tregisterScaleType: function(type, scaleConstructor, scaleDefaults) {\n\t\tthis.constructors[type] = scaleConstructor;\n\t\tthis.defaults[type] = helpers$1.clone(scaleDefaults);\n\t},\n\tgetScaleConstructor: function(type) {\n\t\treturn this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;\n\t},\n\tgetScaleDefaults: function(type) {\n\t\t// Return the scale defaults merged with the global settings so that we always use the latest ones\n\t\treturn this.defaults.hasOwnProperty(type) ? helpers$1.merge({}, [core_defaults.scale, this.defaults[type]]) : {};\n\t},\n\tupdateScaleDefaults: function(type, additions) {\n\t\tvar me = this;\n\t\tif (me.defaults.hasOwnProperty(type)) {\n\t\t\tme.defaults[type] = helpers$1.extend(me.defaults[type], additions);\n\t\t}\n\t},\n\taddScalesToLayout: function(chart) {\n\t\t// Adds each scale to the chart.boxes array to be sized accordingly\n\t\thelpers$1.each(chart.scales, function(scale) {\n\t\t\t// Set ILayoutItem parameters for backwards compatibility\n\t\t\tscale.fullWidth = scale.options.fullWidth;\n\t\t\tscale.position = scale.options.position;\n\t\t\tscale.weight = scale.options.weight;\n\t\t\tcore_layouts.addBox(chart, scale);\n\t\t});\n\t}\n};\n\nvar valueOrDefault$7 = helpers$1.valueOrDefault;\n\ncore_defaults._set('global', {\n\ttooltips: {\n\t\tenabled: true,\n\t\tcustom: null,\n\t\tmode: 'nearest',\n\t\tposition: 'average',\n\t\tintersect: true,\n\t\tbackgroundColor: 'rgba(0,0,0,0.8)',\n\t\ttitleFontStyle: 'bold',\n\t\ttitleSpacing: 2,\n\t\ttitleMarginBottom: 6,\n\t\ttitleFontColor: '#fff',\n\t\ttitleAlign: 'left',\n\t\tbodySpacing: 2,\n\t\tbodyFontColor: '#fff',\n\t\tbodyAlign: 'left',\n\t\tfooterFontStyle: 'bold',\n\t\tfooterSpacing: 2,\n\t\tfooterMarginTop: 6,\n\t\tfooterFontColor: '#fff',\n\t\tfooterAlign: 'left',\n\t\tyPadding: 6,\n\t\txPadding: 6,\n\t\tcaretPadding: 2,\n\t\tcaretSize: 5,\n\t\tcornerRadius: 6,\n\t\tmultiKeyBackground: '#fff',\n\t\tdisplayColors: true,\n\t\tborderColor: 'rgba(0,0,0,0)',\n\t\tborderWidth: 0,\n\t\tcallbacks: {\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeTitle: helpers$1.noop,\n\t\t\ttitle: function(tooltipItems, data) {\n\t\t\t\tvar title = '';\n\t\t\t\tvar labels = data.labels;\n\t\t\t\tvar labelCount = labels ? labels.length : 0;\n\n\t\t\t\tif (tooltipItems.length > 0) {\n\t\t\t\t\tvar item = tooltipItems[0];\n\t\t\t\t\tif (item.label) {\n\t\t\t\t\t\ttitle = item.label;\n\t\t\t\t\t} else if (item.xLabel) {\n\t\t\t\t\t\ttitle = item.xLabel;\n\t\t\t\t\t} else if (labelCount > 0 && item.index < labelCount) {\n\t\t\t\t\t\ttitle = labels[item.index];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn title;\n\t\t\t},\n\t\t\tafterTitle: helpers$1.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeBody: helpers$1.noop,\n\n\t\t\t// Args are: (tooltipItem, data)\n\t\t\tbeforeLabel: helpers$1.noop,\n\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\tvar label = data.datasets[tooltipItem.datasetIndex].label || '';\n\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel += ': ';\n\t\t\t\t}\n\t\t\t\tif (!helpers$1.isNullOrUndef(tooltipItem.value)) {\n\t\t\t\t\tlabel += tooltipItem.value;\n\t\t\t\t} else {\n\t\t\t\t\tlabel += tooltipItem.yLabel;\n\t\t\t\t}\n\t\t\t\treturn label;\n\t\t\t},\n\t\t\tlabelColor: function(tooltipItem, chart) {\n\t\t\t\tvar meta = chart.getDatasetMeta(tooltipItem.datasetIndex);\n\t\t\t\tvar activeElement = meta.data[tooltipItem.index];\n\t\t\t\tvar view = activeElement._view;\n\t\t\t\treturn {\n\t\t\t\t\tborderColor: view.borderColor,\n\t\t\t\t\tbackgroundColor: view.backgroundColor\n\t\t\t\t};\n\t\t\t},\n\t\t\tlabelTextColor: function() {\n\t\t\t\treturn this._options.bodyFontColor;\n\t\t\t},\n\t\t\tafterLabel: helpers$1.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tafterBody: helpers$1.noop,\n\n\t\t\t// Args are: (tooltipItems, data)\n\t\t\tbeforeFooter: helpers$1.noop,\n\t\t\tfooter: helpers$1.noop,\n\t\t\tafterFooter: helpers$1.noop\n\t\t}\n\t}\n});\n\nvar positioners = {\n\t/**\n\t * Average mode places the tooltip at the average position of the elements shown\n\t * @function Chart.Tooltip.positioners.average\n\t * @param elements {ChartElement[]} the elements being displayed in the tooltip\n\t * @returns {object} tooltip position\n\t */\n\taverage: function(elements) {\n\t\tif (!elements.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar i, len;\n\t\tvar x = 0;\n\t\tvar y = 0;\n\t\tvar count = 0;\n\n\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\tvar el = elements[i];\n\t\t\tif (el && el.hasValue()) {\n\t\t\t\tvar pos = el.tooltipPosition();\n\t\t\t\tx += pos.x;\n\t\t\t\ty += pos.y;\n\t\t\t\t++count;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tx: x / count,\n\t\t\ty: y / count\n\t\t};\n\t},\n\n\t/**\n\t * Gets the tooltip position nearest of the item nearest to the event position\n\t * @function Chart.Tooltip.positioners.nearest\n\t * @param elements {Chart.Element[]} the tooltip elements\n\t * @param eventPosition {object} the position of the event in canvas coordinates\n\t * @returns {object} the tooltip position\n\t */\n\tnearest: function(elements, eventPosition) {\n\t\tvar x = eventPosition.x;\n\t\tvar y = eventPosition.y;\n\t\tvar minDistance = Number.POSITIVE_INFINITY;\n\t\tvar i, len, nearestElement;\n\n\t\tfor (i = 0, len = elements.length; i < len; ++i) {\n\t\t\tvar el = elements[i];\n\t\t\tif (el && el.hasValue()) {\n\t\t\t\tvar center = el.getCenterPoint();\n\t\t\t\tvar d = helpers$1.distanceBetweenPoints(eventPosition, center);\n\n\t\t\t\tif (d < minDistance) {\n\t\t\t\t\tminDistance = d;\n\t\t\t\t\tnearestElement = el;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (nearestElement) {\n\t\t\tvar tp = nearestElement.tooltipPosition();\n\t\t\tx = tp.x;\n\t\t\ty = tp.y;\n\t\t}\n\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: y\n\t\t};\n\t}\n};\n\n// Helper to push or concat based on if the 2nd parameter is an array or not\nfunction pushOrConcat(base, toPush) {\n\tif (toPush) {\n\t\tif (helpers$1.isArray(toPush)) {\n\t\t\t// base = base.concat(toPush);\n\t\t\tArray.prototype.push.apply(base, toPush);\n\t\t} else {\n\t\t\tbase.push(toPush);\n\t\t}\n\t}\n\n\treturn base;\n}\n\n/**\n * Returns array of strings split by newline\n * @param {string} value - The value to split by newline.\n * @returns {string[]} value if newline present - Returned from String split() method\n * @function\n */\nfunction splitNewlines(str) {\n\tif ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n\t\treturn str.split('\\n');\n\t}\n\treturn str;\n}\n\n\n/**\n * Private helper to create a tooltip item model\n * @param element - the chart element (point, arc, bar) to create the tooltip item for\n * @return new tooltip item\n */\nfunction createTooltipItem(element) {\n\tvar xScale = element._xScale;\n\tvar yScale = element._yScale || element._scale; // handle radar || polarArea charts\n\tvar index = element._index;\n\tvar datasetIndex = element._datasetIndex;\n\tvar controller = element._chart.getDatasetMeta(datasetIndex).controller;\n\tvar indexScale = controller._getIndexScale();\n\tvar valueScale = controller._getValueScale();\n\n\treturn {\n\t\txLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',\n\t\tyLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',\n\t\tlabel: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',\n\t\tvalue: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',\n\t\tindex: index,\n\t\tdatasetIndex: datasetIndex,\n\t\tx: element._model.x,\n\t\ty: element._model.y\n\t};\n}\n\n/**\n * Helper to get the reset model for the tooltip\n * @param tooltipOpts {object} the tooltip options\n */\nfunction getBaseModel(tooltipOpts) {\n\tvar globalDefaults = core_defaults.global;\n\n\treturn {\n\t\t// Positioning\n\t\txPadding: tooltipOpts.xPadding,\n\t\tyPadding: tooltipOpts.yPadding,\n\t\txAlign: tooltipOpts.xAlign,\n\t\tyAlign: tooltipOpts.yAlign,\n\n\t\t// Body\n\t\tbodyFontColor: tooltipOpts.bodyFontColor,\n\t\t_bodyFontFamily: valueOrDefault$7(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),\n\t\t_bodyFontStyle: valueOrDefault$7(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),\n\t\t_bodyAlign: tooltipOpts.bodyAlign,\n\t\tbodyFontSize: valueOrDefault$7(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),\n\t\tbodySpacing: tooltipOpts.bodySpacing,\n\n\t\t// Title\n\t\ttitleFontColor: tooltipOpts.titleFontColor,\n\t\t_titleFontFamily: valueOrDefault$7(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),\n\t\t_titleFontStyle: valueOrDefault$7(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),\n\t\ttitleFontSize: valueOrDefault$7(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),\n\t\t_titleAlign: tooltipOpts.titleAlign,\n\t\ttitleSpacing: tooltipOpts.titleSpacing,\n\t\ttitleMarginBottom: tooltipOpts.titleMarginBottom,\n\n\t\t// Footer\n\t\tfooterFontColor: tooltipOpts.footerFontColor,\n\t\t_footerFontFamily: valueOrDefault$7(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),\n\t\t_footerFontStyle: valueOrDefault$7(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),\n\t\tfooterFontSize: valueOrDefault$7(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),\n\t\t_footerAlign: tooltipOpts.footerAlign,\n\t\tfooterSpacing: tooltipOpts.footerSpacing,\n\t\tfooterMarginTop: tooltipOpts.footerMarginTop,\n\n\t\t// Appearance\n\t\tcaretSize: tooltipOpts.caretSize,\n\t\tcornerRadius: tooltipOpts.cornerRadius,\n\t\tbackgroundColor: tooltipOpts.backgroundColor,\n\t\topacity: 0,\n\t\tlegendColorBackground: tooltipOpts.multiKeyBackground,\n\t\tdisplayColors: tooltipOpts.displayColors,\n\t\tborderColor: tooltipOpts.borderColor,\n\t\tborderWidth: tooltipOpts.borderWidth\n\t};\n}\n\n/**\n * Get the size of the tooltip\n */\nfunction getTooltipSize(tooltip, model) {\n\tvar ctx = tooltip._chart.ctx;\n\n\tvar height = model.yPadding * 2; // Tooltip Padding\n\tvar width = 0;\n\n\t// Count of all lines in the body\n\tvar body = model.body;\n\tvar combinedBodyLength = body.reduce(function(count, bodyItem) {\n\t\treturn count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;\n\t}, 0);\n\tcombinedBodyLength += model.beforeBody.length + model.afterBody.length;\n\n\tvar titleLineCount = model.title.length;\n\tvar footerLineCount = model.footer.length;\n\tvar titleFontSize = model.titleFontSize;\n\tvar bodyFontSize = model.bodyFontSize;\n\tvar footerFontSize = model.footerFontSize;\n\n\theight += titleLineCount * titleFontSize; // Title Lines\n\theight += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing\n\theight += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin\n\theight += combinedBodyLength * bodyFontSize; // Body Lines\n\theight += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing\n\theight += footerLineCount ? model.footerMarginTop : 0; // Footer Margin\n\theight += footerLineCount * (footerFontSize); // Footer Lines\n\theight += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing\n\n\t// Title width\n\tvar widthPadding = 0;\n\tvar maxLineWidth = function(line) {\n\t\twidth = Math.max(width, ctx.measureText(line).width + widthPadding);\n\t};\n\n\tctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);\n\thelpers$1.each(model.title, maxLineWidth);\n\n\t// Body width\n\tctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);\n\thelpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth);\n\n\t// Body lines may include some extra width due to the color box\n\twidthPadding = model.displayColors ? (bodyFontSize + 2) : 0;\n\thelpers$1.each(body, function(bodyItem) {\n\t\thelpers$1.each(bodyItem.before, maxLineWidth);\n\t\thelpers$1.each(bodyItem.lines, maxLineWidth);\n\t\thelpers$1.each(bodyItem.after, maxLineWidth);\n\t});\n\n\t// Reset back to 0\n\twidthPadding = 0;\n\n\t// Footer width\n\tctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);\n\thelpers$1.each(model.footer, maxLineWidth);\n\n\t// Add padding\n\twidth += 2 * model.xPadding;\n\n\treturn {\n\t\twidth: width,\n\t\theight: height\n\t};\n}\n\n/**\n * Helper to get the alignment of a tooltip given the size\n */\nfunction determineAlignment(tooltip, size) {\n\tvar model = tooltip._model;\n\tvar chart = tooltip._chart;\n\tvar chartArea = tooltip._chart.chartArea;\n\tvar xAlign = 'center';\n\tvar yAlign = 'center';\n\n\tif (model.y < size.height) {\n\t\tyAlign = 'top';\n\t} else if (model.y > (chart.height - size.height)) {\n\t\tyAlign = 'bottom';\n\t}\n\n\tvar lf, rf; // functions to determine left, right alignment\n\tvar olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart\n\tvar yf; // function to get the y alignment if the tooltip goes outside of the left or right edges\n\tvar midX = (chartArea.left + chartArea.right) / 2;\n\tvar midY = (chartArea.top + chartArea.bottom) / 2;\n\n\tif (yAlign === 'center') {\n\t\tlf = function(x) {\n\t\t\treturn x <= midX;\n\t\t};\n\t\trf = function(x) {\n\t\t\treturn x > midX;\n\t\t};\n\t} else {\n\t\tlf = function(x) {\n\t\t\treturn x <= (size.width / 2);\n\t\t};\n\t\trf = function(x) {\n\t\t\treturn x >= (chart.width - (size.width / 2));\n\t\t};\n\t}\n\n\tolf = function(x) {\n\t\treturn x + size.width + model.caretSize + model.caretPadding > chart.width;\n\t};\n\torf = function(x) {\n\t\treturn x - size.width - model.caretSize - model.caretPadding < 0;\n\t};\n\tyf = function(y) {\n\t\treturn y <= midY ? 'top' : 'bottom';\n\t};\n\n\tif (lf(model.x)) {\n\t\txAlign = 'left';\n\n\t\t// Is tooltip too wide and goes over the right side of the chart.?\n\t\tif (olf(model.x)) {\n\t\t\txAlign = 'center';\n\t\t\tyAlign = yf(model.y);\n\t\t}\n\t} else if (rf(model.x)) {\n\t\txAlign = 'right';\n\n\t\t// Is tooltip too wide and goes outside left edge of canvas?\n\t\tif (orf(model.x)) {\n\t\t\txAlign = 'center';\n\t\t\tyAlign = yf(model.y);\n\t\t}\n\t}\n\n\tvar opts = tooltip._options;\n\treturn {\n\t\txAlign: opts.xAlign ? opts.xAlign : xAlign,\n\t\tyAlign: opts.yAlign ? opts.yAlign : yAlign\n\t};\n}\n\n/**\n * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n */\nfunction getBackgroundPoint(vm, size, alignment, chart) {\n\t// Background Position\n\tvar x = vm.x;\n\tvar y = vm.y;\n\n\tvar caretSize = vm.caretSize;\n\tvar caretPadding = vm.caretPadding;\n\tvar cornerRadius = vm.cornerRadius;\n\tvar xAlign = alignment.xAlign;\n\tvar yAlign = alignment.yAlign;\n\tvar paddingAndSize = caretSize + caretPadding;\n\tvar radiusAndPadding = cornerRadius + caretPadding;\n\n\tif (xAlign === 'right') {\n\t\tx -= size.width;\n\t} else if (xAlign === 'center') {\n\t\tx -= (size.width / 2);\n\t\tif (x + size.width > chart.width) {\n\t\t\tx = chart.width - size.width;\n\t\t}\n\t\tif (x < 0) {\n\t\t\tx = 0;\n\t\t}\n\t}\n\n\tif (yAlign === 'top') {\n\t\ty += paddingAndSize;\n\t} else if (yAlign === 'bottom') {\n\t\ty -= size.height + paddingAndSize;\n\t} else {\n\t\ty -= (size.height / 2);\n\t}\n\n\tif (yAlign === 'center') {\n\t\tif (xAlign === 'left') {\n\t\t\tx += paddingAndSize;\n\t\t} else if (xAlign === 'right') {\n\t\t\tx -= paddingAndSize;\n\t\t}\n\t} else if (xAlign === 'left') {\n\t\tx -= radiusAndPadding;\n\t} else if (xAlign === 'right') {\n\t\tx += radiusAndPadding;\n\t}\n\n\treturn {\n\t\tx: x,\n\t\ty: y\n\t};\n}\n\nfunction getAlignedX(vm, align) {\n\treturn align === 'center'\n\t\t? vm.x + vm.width / 2\n\t\t: align === 'right'\n\t\t\t? vm.x + vm.width - vm.xPadding\n\t\t\t: vm.x + vm.xPadding;\n}\n\n/**\n * Helper to build before and after body lines\n */\nfunction getBeforeAfterBodyLines(callback) {\n\treturn pushOrConcat([], splitNewlines(callback));\n}\n\nvar exports$3 = core_element.extend({\n\tinitialize: function() {\n\t\tthis._model = getBaseModel(this._options);\n\t\tthis._lastActive = [];\n\t},\n\n\t// Get the title\n\t// Args are: (tooltipItem, data)\n\tgetTitle: function() {\n\t\tvar me = this;\n\t\tvar opts = me._options;\n\t\tvar callbacks = opts.callbacks;\n\n\t\tvar beforeTitle = callbacks.beforeTitle.apply(me, arguments);\n\t\tvar title = callbacks.title.apply(me, arguments);\n\t\tvar afterTitle = callbacks.afterTitle.apply(me, arguments);\n\n\t\tvar lines = [];\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeTitle));\n\t\tlines = pushOrConcat(lines, splitNewlines(title));\n\t\tlines = pushOrConcat(lines, splitNewlines(afterTitle));\n\n\t\treturn lines;\n\t},\n\n\t// Args are: (tooltipItem, data)\n\tgetBeforeBody: function() {\n\t\treturn getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));\n\t},\n\n\t// Args are: (tooltipItem, data)\n\tgetBody: function(tooltipItems, data) {\n\t\tvar me = this;\n\t\tvar callbacks = me._options.callbacks;\n\t\tvar bodyItems = [];\n\n\t\thelpers$1.each(tooltipItems, function(tooltipItem) {\n\t\t\tvar bodyItem = {\n\t\t\t\tbefore: [],\n\t\t\t\tlines: [],\n\t\t\t\tafter: []\n\t\t\t};\n\t\t\tpushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));\n\t\t\tpushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));\n\t\t\tpushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));\n\n\t\t\tbodyItems.push(bodyItem);\n\t\t});\n\n\t\treturn bodyItems;\n\t},\n\n\t// Args are: (tooltipItem, data)\n\tgetAfterBody: function() {\n\t\treturn getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));\n\t},\n\n\t// Get the footer and beforeFooter and afterFooter lines\n\t// Args are: (tooltipItem, data)\n\tgetFooter: function() {\n\t\tvar me = this;\n\t\tvar callbacks = me._options.callbacks;\n\n\t\tvar beforeFooter = callbacks.beforeFooter.apply(me, arguments);\n\t\tvar footer = callbacks.footer.apply(me, arguments);\n\t\tvar afterFooter = callbacks.afterFooter.apply(me, arguments);\n\n\t\tvar lines = [];\n\t\tlines = pushOrConcat(lines, splitNewlines(beforeFooter));\n\t\tlines = pushOrConcat(lines, splitNewlines(footer));\n\t\tlines = pushOrConcat(lines, splitNewlines(afterFooter));\n\n\t\treturn lines;\n\t},\n\n\tupdate: function(changed) {\n\t\tvar me = this;\n\t\tvar opts = me._options;\n\n\t\t// Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition\n\t\t// that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time\n\t\t// which breaks any animations.\n\t\tvar existingModel = me._model;\n\t\tvar model = me._model = getBaseModel(opts);\n\t\tvar active = me._active;\n\n\t\tvar data = me._data;\n\n\t\t// In the case where active.length === 0 we need to keep these at existing values for good animations\n\t\tvar alignment = {\n\t\t\txAlign: existingModel.xAlign,\n\t\t\tyAlign: existingModel.yAlign\n\t\t};\n\t\tvar backgroundPoint = {\n\t\t\tx: existingModel.x,\n\t\t\ty: existingModel.y\n\t\t};\n\t\tvar tooltipSize = {\n\t\t\twidth: existingModel.width,\n\t\t\theight: existingModel.height\n\t\t};\n\t\tvar tooltipPosition = {\n\t\t\tx: existingModel.caretX,\n\t\t\ty: existingModel.caretY\n\t\t};\n\n\t\tvar i, len;\n\n\t\tif (active.length) {\n\t\t\tmodel.opacity = 1;\n\n\t\t\tvar labelColors = [];\n\t\t\tvar labelTextColors = [];\n\t\t\ttooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);\n\n\t\t\tvar tooltipItems = [];\n\t\t\tfor (i = 0, len = active.length; i < len; ++i) {\n\t\t\t\ttooltipItems.push(createTooltipItem(active[i]));\n\t\t\t}\n\n\t\t\t// If the user provided a filter function, use it to modify the tooltip items\n\t\t\tif (opts.filter) {\n\t\t\t\ttooltipItems = tooltipItems.filter(function(a) {\n\t\t\t\t\treturn opts.filter(a, data);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// If the user provided a sorting function, use it to modify the tooltip items\n\t\t\tif (opts.itemSort) {\n\t\t\t\ttooltipItems = tooltipItems.sort(function(a, b) {\n\t\t\t\t\treturn opts.itemSort(a, b, data);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Determine colors for boxes\n\t\t\thelpers$1.each(tooltipItems, function(tooltipItem) {\n\t\t\t\tlabelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));\n\t\t\t\tlabelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));\n\t\t\t});\n\n\n\t\t\t// Build the Text Lines\n\t\t\tmodel.title = me.getTitle(tooltipItems, data);\n\t\t\tmodel.beforeBody = me.getBeforeBody(tooltipItems, data);\n\t\t\tmodel.body = me.getBody(tooltipItems, data);\n\t\t\tmodel.afterBody = me.getAfterBody(tooltipItems, data);\n\t\t\tmodel.footer = me.getFooter(tooltipItems, data);\n\n\t\t\t// Initial positioning and colors\n\t\t\tmodel.x = tooltipPosition.x;\n\t\t\tmodel.y = tooltipPosition.y;\n\t\t\tmodel.caretPadding = opts.caretPadding;\n\t\t\tmodel.labelColors = labelColors;\n\t\t\tmodel.labelTextColors = labelTextColors;\n\n\t\t\t// data points\n\t\t\tmodel.dataPoints = tooltipItems;\n\n\t\t\t// We need to determine alignment of the tooltip\n\t\t\ttooltipSize = getTooltipSize(this, model);\n\t\t\talignment = determineAlignment(this, tooltipSize);\n\t\t\t// Final Size and Position\n\t\t\tbackgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);\n\t\t} else {\n\t\t\tmodel.opacity = 0;\n\t\t}\n\n\t\tmodel.xAlign = alignment.xAlign;\n\t\tmodel.yAlign = alignment.yAlign;\n\t\tmodel.x = backgroundPoint.x;\n\t\tmodel.y = backgroundPoint.y;\n\t\tmodel.width = tooltipSize.width;\n\t\tmodel.height = tooltipSize.height;\n\n\t\t// Point where the caret on the tooltip points to\n\t\tmodel.caretX = tooltipPosition.x;\n\t\tmodel.caretY = tooltipPosition.y;\n\n\t\tme._model = model;\n\n\t\tif (changed && opts.custom) {\n\t\t\topts.custom.call(me, model);\n\t\t}\n\n\t\treturn me;\n\t},\n\n\tdrawCaret: function(tooltipPoint, size) {\n\t\tvar ctx = this._chart.ctx;\n\t\tvar vm = this._view;\n\t\tvar caretPosition = this.getCaretPosition(tooltipPoint, size, vm);\n\n\t\tctx.lineTo(caretPosition.x1, caretPosition.y1);\n\t\tctx.lineTo(caretPosition.x2, caretPosition.y2);\n\t\tctx.lineTo(caretPosition.x3, caretPosition.y3);\n\t},\n\tgetCaretPosition: function(tooltipPoint, size, vm) {\n\t\tvar x1, x2, x3, y1, y2, y3;\n\t\tvar caretSize = vm.caretSize;\n\t\tvar cornerRadius = vm.cornerRadius;\n\t\tvar xAlign = vm.xAlign;\n\t\tvar yAlign = vm.yAlign;\n\t\tvar ptX = tooltipPoint.x;\n\t\tvar ptY = tooltipPoint.y;\n\t\tvar width = size.width;\n\t\tvar height = size.height;\n\n\t\tif (yAlign === 'center') {\n\t\t\ty2 = ptY + (height / 2);\n\n\t\t\tif (xAlign === 'left') {\n\t\t\t\tx1 = ptX;\n\t\t\t\tx2 = x1 - caretSize;\n\t\t\t\tx3 = x1;\n\n\t\t\t\ty1 = y2 + caretSize;\n\t\t\t\ty3 = y2 - caretSize;\n\t\t\t} else {\n\t\t\t\tx1 = ptX + width;\n\t\t\t\tx2 = x1 + caretSize;\n\t\t\t\tx3 = x1;\n\n\t\t\t\ty1 = y2 - caretSize;\n\t\t\t\ty3 = y2 + caretSize;\n\t\t\t}\n\t\t} else {\n\t\t\tif (xAlign === 'left') {\n\t\t\t\tx2 = ptX + cornerRadius + (caretSize);\n\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\tx3 = x2 + caretSize;\n\t\t\t} else if (xAlign === 'right') {\n\t\t\t\tx2 = ptX + width - cornerRadius - caretSize;\n\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\tx3 = x2 + caretSize;\n\t\t\t} else {\n\t\t\t\tx2 = vm.caretX;\n\t\t\t\tx1 = x2 - caretSize;\n\t\t\t\tx3 = x2 + caretSize;\n\t\t\t}\n\t\t\tif (yAlign === 'top') {\n\t\t\t\ty1 = ptY;\n\t\t\t\ty2 = y1 - caretSize;\n\t\t\t\ty3 = y1;\n\t\t\t} else {\n\t\t\t\ty1 = ptY + height;\n\t\t\t\ty2 = y1 + caretSize;\n\t\t\t\ty3 = y1;\n\t\t\t\t// invert drawing order\n\t\t\t\tvar tmp = x3;\n\t\t\t\tx3 = x1;\n\t\t\t\tx1 = tmp;\n\t\t\t}\n\t\t}\n\t\treturn {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};\n\t},\n\n\tdrawTitle: function(pt, vm, ctx) {\n\t\tvar title = vm.title;\n\n\t\tif (title.length) {\n\t\t\tpt.x = getAlignedX(vm, vm._titleAlign);\n\n\t\t\tctx.textAlign = vm._titleAlign;\n\t\t\tctx.textBaseline = 'top';\n\n\t\t\tvar titleFontSize = vm.titleFontSize;\n\t\t\tvar titleSpacing = vm.titleSpacing;\n\n\t\t\tctx.fillStyle = vm.titleFontColor;\n\t\t\tctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);\n\n\t\t\tvar i, len;\n\t\t\tfor (i = 0, len = title.length; i < len; ++i) {\n\t\t\t\tctx.fillText(title[i], pt.x, pt.y);\n\t\t\t\tpt.y += titleFontSize + titleSpacing; // Line Height and spacing\n\n\t\t\t\tif (i + 1 === title.length) {\n\t\t\t\t\tpt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tdrawBody: function(pt, vm, ctx) {\n\t\tvar bodyFontSize = vm.bodyFontSize;\n\t\tvar bodySpacing = vm.bodySpacing;\n\t\tvar bodyAlign = vm._bodyAlign;\n\t\tvar body = vm.body;\n\t\tvar drawColorBoxes = vm.displayColors;\n\t\tvar labelColors = vm.labelColors;\n\t\tvar xLinePadding = 0;\n\t\tvar colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;\n\t\tvar textColor;\n\n\t\tctx.textAlign = bodyAlign;\n\t\tctx.textBaseline = 'top';\n\t\tctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n\n\t\tpt.x = getAlignedX(vm, bodyAlign);\n\n\t\t// Before Body\n\t\tvar fillLineOfText = function(line) {\n\t\t\tctx.fillText(line, pt.x + xLinePadding, pt.y);\n\t\t\tpt.y += bodyFontSize + bodySpacing;\n\t\t};\n\n\t\t// Before body lines\n\t\tctx.fillStyle = vm.bodyFontColor;\n\t\thelpers$1.each(vm.beforeBody, fillLineOfText);\n\n\t\txLinePadding = drawColorBoxes && bodyAlign !== 'right'\n\t\t\t? bodyAlign === 'center' ? (bodyFontSize / 2 + 1) : (bodyFontSize + 2)\n\t\t\t: 0;\n\n\t\t// Draw body lines now\n\t\thelpers$1.each(body, function(bodyItem, i) {\n\t\t\ttextColor = vm.labelTextColors[i];\n\t\t\tctx.fillStyle = textColor;\n\t\t\thelpers$1.each(bodyItem.before, fillLineOfText);\n\n\t\t\thelpers$1.each(bodyItem.lines, function(line) {\n\t\t\t\t// Draw Legend-like boxes if needed\n\t\t\t\tif (drawColorBoxes) {\n\t\t\t\t\t// Fill a white rect so that colours merge nicely if the opacity is < 1\n\t\t\t\t\tctx.fillStyle = vm.legendColorBackground;\n\t\t\t\t\tctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t// Border\n\t\t\t\t\tctx.lineWidth = 1;\n\t\t\t\t\tctx.strokeStyle = labelColors[i].borderColor;\n\t\t\t\t\tctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize);\n\n\t\t\t\t\t// Inner square\n\t\t\t\t\tctx.fillStyle = labelColors[i].backgroundColor;\n\t\t\t\t\tctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n\t\t\t\t\tctx.fillStyle = textColor;\n\t\t\t\t}\n\n\t\t\t\tfillLineOfText(line);\n\t\t\t});\n\n\t\t\thelpers$1.each(bodyItem.after, fillLineOfText);\n\t\t});\n\n\t\t// Reset back to 0 for after body\n\t\txLinePadding = 0;\n\n\t\t// After body lines\n\t\thelpers$1.each(vm.afterBody, fillLineOfText);\n\t\tpt.y -= bodySpacing; // Remove last body spacing\n\t},\n\n\tdrawFooter: function(pt, vm, ctx) {\n\t\tvar footer = vm.footer;\n\n\t\tif (footer.length) {\n\t\t\tpt.x = getAlignedX(vm, vm._footerAlign);\n\t\t\tpt.y += vm.footerMarginTop;\n\n\t\t\tctx.textAlign = vm._footerAlign;\n\t\t\tctx.textBaseline = 'top';\n\n\t\t\tctx.fillStyle = vm.footerFontColor;\n\t\t\tctx.font = helpers$1.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);\n\n\t\t\thelpers$1.each(footer, function(line) {\n\t\t\t\tctx.fillText(line, pt.x, pt.y);\n\t\t\t\tpt.y += vm.footerFontSize + vm.footerSpacing;\n\t\t\t});\n\t\t}\n\t},\n\n\tdrawBackground: function(pt, vm, ctx, tooltipSize) {\n\t\tctx.fillStyle = vm.backgroundColor;\n\t\tctx.strokeStyle = vm.borderColor;\n\t\tctx.lineWidth = vm.borderWidth;\n\t\tvar xAlign = vm.xAlign;\n\t\tvar yAlign = vm.yAlign;\n\t\tvar x = pt.x;\n\t\tvar y = pt.y;\n\t\tvar width = tooltipSize.width;\n\t\tvar height = tooltipSize.height;\n\t\tvar radius = vm.cornerRadius;\n\n\t\tctx.beginPath();\n\t\tctx.moveTo(x + radius, y);\n\t\tif (yAlign === 'top') {\n\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t}\n\t\tctx.lineTo(x + width - radius, y);\n\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\t\tif (yAlign === 'center' && xAlign === 'right') {\n\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t}\n\t\tctx.lineTo(x + width, y + height - radius);\n\t\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\t\tif (yAlign === 'bottom') {\n\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t}\n\t\tctx.lineTo(x + radius, y + height);\n\t\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\t\tif (yAlign === 'center' && xAlign === 'left') {\n\t\t\tthis.drawCaret(pt, tooltipSize);\n\t\t}\n\t\tctx.lineTo(x, y + radius);\n\t\tctx.quadraticCurveTo(x, y, x + radius, y);\n\t\tctx.closePath();\n\n\t\tctx.fill();\n\n\t\tif (vm.borderWidth > 0) {\n\t\t\tctx.stroke();\n\t\t}\n\t},\n\n\tdraw: function() {\n\t\tvar ctx = this._chart.ctx;\n\t\tvar vm = this._view;\n\n\t\tif (vm.opacity === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar tooltipSize = {\n\t\t\twidth: vm.width,\n\t\t\theight: vm.height\n\t\t};\n\t\tvar pt = {\n\t\t\tx: vm.x,\n\t\t\ty: vm.y\n\t\t};\n\n\t\t// IE11/Edge does not like very small opacities, so snap to 0\n\t\tvar opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;\n\n\t\t// Truthy/falsey value for empty tooltip\n\t\tvar hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;\n\n\t\tif (this._options.enabled && hasTooltipContent) {\n\t\t\tctx.save();\n\t\t\tctx.globalAlpha = opacity;\n\n\t\t\t// Draw Background\n\t\t\tthis.drawBackground(pt, vm, ctx, tooltipSize);\n\n\t\t\t// Draw Title, Body, and Footer\n\t\t\tpt.y += vm.yPadding;\n\n\t\t\t// Titles\n\t\t\tthis.drawTitle(pt, vm, ctx);\n\n\t\t\t// Body\n\t\t\tthis.drawBody(pt, vm, ctx);\n\n\t\t\t// Footer\n\t\t\tthis.drawFooter(pt, vm, ctx);\n\n\t\t\tctx.restore();\n\t\t}\n\t},\n\n\t/**\n\t * Handle an event\n\t * @private\n\t * @param {IEvent} event - The event to handle\n\t * @returns {boolean} true if the tooltip changed\n\t */\n\thandleEvent: function(e) {\n\t\tvar me = this;\n\t\tvar options = me._options;\n\t\tvar changed = false;\n\n\t\tme._lastActive = me._lastActive || [];\n\n\t\t// Find Active Elements for tooltips\n\t\tif (e.type === 'mouseout') {\n\t\t\tme._active = [];\n\t\t} else {\n\t\t\tme._active = me._chart.getElementsAtEventForMode(e, options.mode, options);\n\t\t}\n\n\t\t// Remember Last Actives\n\t\tchanged = !helpers$1.arrayEquals(me._active, me._lastActive);\n\n\t\t// Only handle target event on tooltip change\n\t\tif (changed) {\n\t\t\tme._lastActive = me._active;\n\n\t\t\tif (options.enabled || options.custom) {\n\t\t\t\tme._eventPosition = {\n\t\t\t\t\tx: e.x,\n\t\t\t\t\ty: e.y\n\t\t\t\t};\n\n\t\t\t\tme.update(true);\n\t\t\t\tme.pivot();\n\t\t\t}\n\t\t}\n\n\t\treturn changed;\n\t}\n});\n\n/**\n * @namespace Chart.Tooltip.positioners\n */\nvar positioners_1 = positioners;\n\nvar core_tooltip = exports$3;\ncore_tooltip.positioners = positioners_1;\n\nvar valueOrDefault$8 = helpers$1.valueOrDefault;\n\ncore_defaults._set('global', {\n\telements: {},\n\tevents: [\n\t\t'mousemove',\n\t\t'mouseout',\n\t\t'click',\n\t\t'touchstart',\n\t\t'touchmove'\n\t],\n\thover: {\n\t\tonHover: null,\n\t\tmode: 'nearest',\n\t\tintersect: true,\n\t\tanimationDuration: 400\n\t},\n\tonClick: null,\n\tmaintainAspectRatio: true,\n\tresponsive: true,\n\tresponsiveAnimationDuration: 0\n});\n\n/**\n * Recursively merge the given config objects representing the `scales` option\n * by incorporating scale defaults in `xAxes` and `yAxes` array items, then\n * returns a deep copy of the result, thus doesn't alter inputs.\n */\nfunction mergeScaleConfig(/* config objects ... */) {\n\treturn helpers$1.merge({}, [].slice.call(arguments), {\n\t\tmerger: function(key, target, source, options) {\n\t\t\tif (key === 'xAxes' || key === 'yAxes') {\n\t\t\t\tvar slen = source[key].length;\n\t\t\t\tvar i, type, scale;\n\n\t\t\t\tif (!target[key]) {\n\t\t\t\t\ttarget[key] = [];\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < slen; ++i) {\n\t\t\t\t\tscale = source[key][i];\n\t\t\t\t\ttype = valueOrDefault$8(scale.type, key === 'xAxes' ? 'category' : 'linear');\n\n\t\t\t\t\tif (i >= target[key].length) {\n\t\t\t\t\t\ttarget[key].push({});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {\n\t\t\t\t\t\t// new/untyped scale or type changed: let's apply the new defaults\n\t\t\t\t\t\t// then merge source scale to correctly overwrite the defaults.\n\t\t\t\t\t\thelpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// scales type are the same\n\t\t\t\t\t\thelpers$1.merge(target[key][i], scale);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thelpers$1._merger(key, target, source, options);\n\t\t\t}\n\t\t}\n\t});\n}\n\n/**\n * Recursively merge the given config objects as the root options by handling\n * default scale options for the `scales` and `scale` properties, then returns\n * a deep copy of the result, thus doesn't alter inputs.\n */\nfunction mergeConfig(/* config objects ... */) {\n\treturn helpers$1.merge({}, [].slice.call(arguments), {\n\t\tmerger: function(key, target, source, options) {\n\t\t\tvar tval = target[key] || {};\n\t\t\tvar sval = source[key];\n\n\t\t\tif (key === 'scales') {\n\t\t\t\t// scale config merging is complex. Add our own function here for that\n\t\t\t\ttarget[key] = mergeScaleConfig(tval, sval);\n\t\t\t} else if (key === 'scale') {\n\t\t\t\t// used in polar area & radar charts since there is only one scale\n\t\t\t\ttarget[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);\n\t\t\t} else {\n\t\t\t\thelpers$1._merger(key, target, source, options);\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction initConfig(config) {\n\tconfig = config || {};\n\n\t// Do NOT use mergeConfig for the data object because this method merges arrays\n\t// and so would change references to labels and datasets, preventing data updates.\n\tvar data = config.data = config.data || {};\n\tdata.datasets = data.datasets || [];\n\tdata.labels = data.labels || [];\n\n\tconfig.options = mergeConfig(\n\t\tcore_defaults.global,\n\t\tcore_defaults[config.type],\n\t\tconfig.options || {});\n\n\treturn config;\n}\n\nfunction updateConfig(chart) {\n\tvar newOptions = chart.options;\n\n\thelpers$1.each(chart.scales, function(scale) {\n\t\tcore_layouts.removeBox(chart, scale);\n\t});\n\n\tnewOptions = mergeConfig(\n\t\tcore_defaults.global,\n\t\tcore_defaults[chart.config.type],\n\t\tnewOptions);\n\n\tchart.options = chart.config.options = newOptions;\n\tchart.ensureScalesHaveIDs();\n\tchart.buildOrUpdateScales();\n\n\t// Tooltip\n\tchart.tooltip._options = newOptions.tooltips;\n\tchart.tooltip.initialize();\n}\n\nfunction positionIsHorizontal(position) {\n\treturn position === 'top' || position === 'bottom';\n}\n\nvar Chart = function(item, config) {\n\tthis.construct(item, config);\n\treturn this;\n};\n\nhelpers$1.extend(Chart.prototype, /** @lends Chart */ {\n\t/**\n\t * @private\n\t */\n\tconstruct: function(item, config) {\n\t\tvar me = this;\n\n\t\tconfig = initConfig(config);\n\n\t\tvar context = platform.acquireContext(item, config);\n\t\tvar canvas = context && context.canvas;\n\t\tvar height = canvas && canvas.height;\n\t\tvar width = canvas && canvas.width;\n\n\t\tme.id = helpers$1.uid();\n\t\tme.ctx = context;\n\t\tme.canvas = canvas;\n\t\tme.config = config;\n\t\tme.width = width;\n\t\tme.height = height;\n\t\tme.aspectRatio = height ? width / height : null;\n\t\tme.options = config.options;\n\t\tme._bufferedRender = false;\n\n\t\t/**\n\t\t * Provided for backward compatibility, Chart and Chart.Controller have been merged,\n\t\t * the \"instance\" still need to be defined since it might be called from plugins.\n\t\t * @prop Chart#chart\n\t\t * @deprecated since version 2.6.0\n\t\t * @todo remove at version 3\n\t\t * @private\n\t\t */\n\t\tme.chart = me;\n\t\tme.controller = me; // chart.chart.controller #inception\n\n\t\t// Add the chart instance to the global namespace\n\t\tChart.instances[me.id] = me;\n\n\t\t// Define alias to the config data: `chart.data === chart.config.data`\n\t\tObject.defineProperty(me, 'data', {\n\t\t\tget: function() {\n\t\t\t\treturn me.config.data;\n\t\t\t},\n\t\t\tset: function(value) {\n\t\t\t\tme.config.data = value;\n\t\t\t}\n\t\t});\n\n\t\tif (!context || !canvas) {\n\t\t\t// The given item is not a compatible context2d element, let's return before finalizing\n\t\t\t// the chart initialization but after setting basic chart / controller properties that\n\t\t\t// can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n\t\t\t// https://github.com/chartjs/Chart.js/issues/2807\n\t\t\tconsole.error(\"Failed to create chart: can't acquire context from the given item\");\n\t\t\treturn;\n\t\t}\n\n\t\tme.initialize();\n\t\tme.update();\n\t},\n\n\t/**\n\t * @private\n\t */\n\tinitialize: function() {\n\t\tvar me = this;\n\n\t\t// Before init plugin notification\n\t\tcore_plugins.notify(me, 'beforeInit');\n\n\t\thelpers$1.retinaScale(me, me.options.devicePixelRatio);\n\n\t\tme.bindEvents();\n\n\t\tif (me.options.responsive) {\n\t\t\t// Initial resize before chart draws (must be silent to preserve initial animations).\n\t\t\tme.resize(true);\n\t\t}\n\n\t\t// Make sure scales have IDs and are built before we build any controllers.\n\t\tme.ensureScalesHaveIDs();\n\t\tme.buildOrUpdateScales();\n\t\tme.initToolTip();\n\n\t\t// After init plugin notification\n\t\tcore_plugins.notify(me, 'afterInit');\n\n\t\treturn me;\n\t},\n\n\tclear: function() {\n\t\thelpers$1.canvas.clear(this);\n\t\treturn this;\n\t},\n\n\tstop: function() {\n\t\t// Stops any current animation loop occurring\n\t\tcore_animations.cancelAnimation(this);\n\t\treturn this;\n\t},\n\n\tresize: function(silent) {\n\t\tvar me = this;\n\t\tvar options = me.options;\n\t\tvar canvas = me.canvas;\n\t\tvar aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;\n\n\t\t// the canvas render width and height will be casted to integers so make sure that\n\t\t// the canvas display style uses the same integer values to avoid blurring effect.\n\n\t\t// Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed\n\t\tvar newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));\n\t\tvar newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));\n\n\t\tif (me.width === newWidth && me.height === newHeight) {\n\t\t\treturn;\n\t\t}\n\n\t\tcanvas.width = me.width = newWidth;\n\t\tcanvas.height = me.height = newHeight;\n\t\tcanvas.style.width = newWidth + 'px';\n\t\tcanvas.style.height = newHeight + 'px';\n\n\t\thelpers$1.retinaScale(me, options.devicePixelRatio);\n\n\t\tif (!silent) {\n\t\t\t// Notify any plugins about the resize\n\t\t\tvar newSize = {width: newWidth, height: newHeight};\n\t\t\tcore_plugins.notify(me, 'resize', [newSize]);\n\n\t\t\t// Notify of resize\n\t\t\tif (options.onResize) {\n\t\t\t\toptions.onResize(me, newSize);\n\t\t\t}\n\n\t\t\tme.stop();\n\t\t\tme.update({\n\t\t\t\tduration: options.responsiveAnimationDuration\n\t\t\t});\n\t\t}\n\t},\n\n\tensureScalesHaveIDs: function() {\n\t\tvar options = this.options;\n\t\tvar scalesOptions = options.scales || {};\n\t\tvar scaleOptions = options.scale;\n\n\t\thelpers$1.each(scalesOptions.xAxes, function(xAxisOptions, index) {\n\t\t\txAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);\n\t\t});\n\n\t\thelpers$1.each(scalesOptions.yAxes, function(yAxisOptions, index) {\n\t\t\tyAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);\n\t\t});\n\n\t\tif (scaleOptions) {\n\t\t\tscaleOptions.id = scaleOptions.id || 'scale';\n\t\t}\n\t},\n\n\t/**\n\t * Builds a map of scale ID to scale object for future lookup.\n\t */\n\tbuildOrUpdateScales: function() {\n\t\tvar me = this;\n\t\tvar options = me.options;\n\t\tvar scales = me.scales || {};\n\t\tvar items = [];\n\t\tvar updated = Object.keys(scales).reduce(function(obj, id) {\n\t\t\tobj[id] = false;\n\t\t\treturn obj;\n\t\t}, {});\n\n\t\tif (options.scales) {\n\t\t\titems = items.concat(\n\t\t\t\t(options.scales.xAxes || []).map(function(xAxisOptions) {\n\t\t\t\t\treturn {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};\n\t\t\t\t}),\n\t\t\t\t(options.scales.yAxes || []).map(function(yAxisOptions) {\n\t\t\t\t\treturn {options: yAxisOptions, dtype: 'linear', dposition: 'left'};\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\tif (options.scale) {\n\t\t\titems.push({\n\t\t\t\toptions: options.scale,\n\t\t\t\tdtype: 'radialLinear',\n\t\t\t\tisDefault: true,\n\t\t\t\tdposition: 'chartArea'\n\t\t\t});\n\t\t}\n\n\t\thelpers$1.each(items, function(item) {\n\t\t\tvar scaleOptions = item.options;\n\t\t\tvar id = scaleOptions.id;\n\t\t\tvar scaleType = valueOrDefault$8(scaleOptions.type, item.dtype);\n\n\t\t\tif (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {\n\t\t\t\tscaleOptions.position = item.dposition;\n\t\t\t}\n\n\t\t\tupdated[id] = true;\n\t\t\tvar scale = null;\n\t\t\tif (id in scales && scales[id].type === scaleType) {\n\t\t\t\tscale = scales[id];\n\t\t\t\tscale.options = scaleOptions;\n\t\t\t\tscale.ctx = me.ctx;\n\t\t\t\tscale.chart = me;\n\t\t\t} else {\n\t\t\t\tvar scaleClass = core_scaleService.getScaleConstructor(scaleType);\n\t\t\t\tif (!scaleClass) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tscale = new scaleClass({\n\t\t\t\t\tid: id,\n\t\t\t\t\ttype: scaleType,\n\t\t\t\t\toptions: scaleOptions,\n\t\t\t\t\tctx: me.ctx,\n\t\t\t\t\tchart: me\n\t\t\t\t});\n\t\t\t\tscales[scale.id] = scale;\n\t\t\t}\n\n\t\t\tscale.mergeTicksOptions();\n\n\t\t\t// TODO(SB): I think we should be able to remove this custom case (options.scale)\n\t\t\t// and consider it as a regular scale part of the \"scales\"\" map only! This would\n\t\t\t// make the logic easier and remove some useless? custom code.\n\t\t\tif (item.isDefault) {\n\t\t\t\tme.scale = scale;\n\t\t\t}\n\t\t});\n\t\t// clear up discarded scales\n\t\thelpers$1.each(updated, function(hasUpdated, id) {\n\t\t\tif (!hasUpdated) {\n\t\t\t\tdelete scales[id];\n\t\t\t}\n\t\t});\n\n\t\tme.scales = scales;\n\n\t\tcore_scaleService.addScalesToLayout(this);\n\t},\n\n\tbuildOrUpdateControllers: function() {\n\t\tvar me = this;\n\t\tvar newControllers = [];\n\n\t\thelpers$1.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\tvar meta = me.getDatasetMeta(datasetIndex);\n\t\t\tvar type = dataset.type || me.config.type;\n\n\t\t\tif (meta.type && meta.type !== type) {\n\t\t\t\tme.destroyDatasetMeta(datasetIndex);\n\t\t\t\tmeta = me.getDatasetMeta(datasetIndex);\n\t\t\t}\n\t\t\tmeta.type = type;\n\n\t\t\tif (meta.controller) {\n\t\t\t\tmeta.controller.updateIndex(datasetIndex);\n\t\t\t\tmeta.controller.linkScales();\n\t\t\t} else {\n\t\t\t\tvar ControllerClass = controllers[meta.type];\n\t\t\t\tif (ControllerClass === undefined) {\n\t\t\t\t\tthrow new Error('\"' + meta.type + '\" is not a chart type.');\n\t\t\t\t}\n\n\t\t\t\tmeta.controller = new ControllerClass(me, datasetIndex);\n\t\t\t\tnewControllers.push(meta.controller);\n\t\t\t}\n\t\t}, me);\n\n\t\treturn newControllers;\n\t},\n\n\t/**\n\t * Reset the elements of all datasets\n\t * @private\n\t */\n\tresetElements: function() {\n\t\tvar me = this;\n\t\thelpers$1.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\tme.getDatasetMeta(datasetIndex).controller.reset();\n\t\t}, me);\n\t},\n\n\t/**\n\t* Resets the chart back to it's state before the initial animation\n\t*/\n\treset: function() {\n\t\tthis.resetElements();\n\t\tthis.tooltip.initialize();\n\t},\n\n\tupdate: function(config) {\n\t\tvar me = this;\n\n\t\tif (!config || typeof config !== 'object') {\n\t\t\t// backwards compatibility\n\t\t\tconfig = {\n\t\t\t\tduration: config,\n\t\t\t\tlazy: arguments[1]\n\t\t\t};\n\t\t}\n\n\t\tupdateConfig(me);\n\n\t\t// plugins options references might have change, let's invalidate the cache\n\t\t// https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n\t\tcore_plugins._invalidate(me);\n\n\t\tif (core_plugins.notify(me, 'beforeUpdate') === false) {\n\t\t\treturn;\n\t\t}\n\n\t\t// In case the entire data object changed\n\t\tme.tooltip._data = me.data;\n\n\t\t// Make sure dataset controllers are updated and new controllers are reset\n\t\tvar newControllers = me.buildOrUpdateControllers();\n\n\t\t// Make sure all dataset controllers have correct meta data counts\n\t\thelpers$1.each(me.data.datasets, function(dataset, datasetIndex) {\n\t\t\tme.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();\n\t\t}, me);\n\n\t\tme.updateLayout();\n\n\t\t// Can only reset the new controllers after the scales have been updated\n\t\tif (me.options.animation && me.options.animation.duration) {\n\t\t\thelpers$1.each(newControllers, function(controller) {\n\t\t\t\tcontroller.reset();\n\t\t\t});\n\t\t}\n\n\t\tme.updateDatasets();\n\n\t\t// Need to reset tooltip in case it is displayed with elements that are removed\n\t\t// after update.\n\t\tme.tooltip.initialize();\n\n\t\t// Last active contains items that were previously in the tooltip.\n\t\t// When we reset the tooltip, we need to clear it\n\t\tme.lastActive = [];\n\n\t\t// Do this before render so that any plugins that need final scale updates can use it\n\t\tcore_plugins.notify(me, 'afterUpdate');\n\n\t\tif (me._bufferedRender) {\n\t\t\tme._bufferedRequest = {\n\t\t\t\tduration: config.duration,\n\t\t\t\teasing: config.easing,\n\t\t\t\tlazy: config.lazy\n\t\t\t};\n\t\t} else {\n\t\t\tme.render(config);\n\t\t}\n\t},\n\n\t/**\n\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t * @private\n\t */\n\tupdateLayout: function() {\n\t\tvar me = this;\n\n\t\tif (core_plugins.notify(me, 'beforeLayout') === false) {\n\t\t\treturn;\n\t\t}\n\n\t\tcore_layouts.update(this, this.width, this.height);\n\n\t\t/**\n\t\t * Provided for backward compatibility, use `afterLayout` instead.\n\t\t * @method IPlugin#afterScaleUpdate\n\t\t * @deprecated since version 2.5.0\n\t\t * @todo remove at version 3\n\t\t * @private\n\t\t */\n\t\tcore_plugins.notify(me, 'afterScaleUpdate');\n\t\tcore_plugins.notify(me, 'afterLayout');\n\t},\n\n\t/**\n\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t * @private\n\t */\n\tupdateDatasets: function() {\n\t\tvar me = this;\n\n\t\tif (core_plugins.notify(me, 'beforeDatasetsUpdate') === false) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\tme.updateDataset(i);\n\t\t}\n\n\t\tcore_plugins.notify(me, 'afterDatasetsUpdate');\n\t},\n\n\t/**\n\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t * @private\n\t */\n\tupdateDataset: function(index) {\n\t\tvar me = this;\n\t\tvar meta = me.getDatasetMeta(index);\n\t\tvar args = {\n\t\t\tmeta: meta,\n\t\t\tindex: index\n\t\t};\n\n\t\tif (core_plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {\n\t\t\treturn;\n\t\t}\n\n\t\tmeta.controller.update();\n\n\t\tcore_plugins.notify(me, 'afterDatasetUpdate', [args]);\n\t},\n\n\trender: function(config) {\n\t\tvar me = this;\n\n\t\tif (!config || typeof config !== 'object') {\n\t\t\t// backwards compatibility\n\t\t\tconfig = {\n\t\t\t\tduration: config,\n\t\t\t\tlazy: arguments[1]\n\t\t\t};\n\t\t}\n\n\t\tvar animationOptions = me.options.animation;\n\t\tvar duration = valueOrDefault$8(config.duration, animationOptions && animationOptions.duration);\n\t\tvar lazy = config.lazy;\n\n\t\tif (core_plugins.notify(me, 'beforeRender') === false) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar onComplete = function(animation) {\n\t\t\tcore_plugins.notify(me, 'afterRender');\n\t\t\thelpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);\n\t\t};\n\n\t\tif (animationOptions && duration) {\n\t\t\tvar animation = new core_animation({\n\t\t\t\tnumSteps: duration / 16.66, // 60 fps\n\t\t\t\teasing: config.easing || animationOptions.easing,\n\n\t\t\t\trender: function(chart, animationObject) {\n\t\t\t\t\tvar easingFunction = helpers$1.easing.effects[animationObject.easing];\n\t\t\t\t\tvar currentStep = animationObject.currentStep;\n\t\t\t\t\tvar stepDecimal = currentStep / animationObject.numSteps;\n\n\t\t\t\t\tchart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);\n\t\t\t\t},\n\n\t\t\t\tonAnimationProgress: animationOptions.onProgress,\n\t\t\t\tonAnimationComplete: onComplete\n\t\t\t});\n\n\t\t\tcore_animations.addAnimation(me, animation, duration, lazy);\n\t\t} else {\n\t\t\tme.draw();\n\n\t\t\t// See https://github.com/chartjs/Chart.js/issues/3781\n\t\t\tonComplete(new core_animation({numSteps: 0, chart: me}));\n\t\t}\n\n\t\treturn me;\n\t},\n\n\tdraw: function(easingValue) {\n\t\tvar me = this;\n\n\t\tme.clear();\n\n\t\tif (helpers$1.isNullOrUndef(easingValue)) {\n\t\t\teasingValue = 1;\n\t\t}\n\n\t\tme.transition(easingValue);\n\n\t\tif (me.width <= 0 || me.height <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (core_plugins.notify(me, 'beforeDraw', [easingValue]) === false) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Draw all the scales\n\t\thelpers$1.each(me.boxes, function(box) {\n\t\t\tbox.draw(me.chartArea);\n\t\t}, me);\n\n\t\tme.drawDatasets(easingValue);\n\t\tme._drawTooltip(easingValue);\n\n\t\tcore_plugins.notify(me, 'afterDraw', [easingValue]);\n\t},\n\n\t/**\n\t * @private\n\t */\n\ttransition: function(easingValue) {\n\t\tvar me = this;\n\n\t\tfor (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {\n\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\tme.getDatasetMeta(i).controller.transition(easingValue);\n\t\t\t}\n\t\t}\n\n\t\tme.tooltip.transition(easingValue);\n\t},\n\n\t/**\n\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t * @private\n\t */\n\tdrawDatasets: function(easingValue) {\n\t\tvar me = this;\n\n\t\tif (core_plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Draw datasets reversed to support proper line stacking\n\t\tfor (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {\n\t\t\tif (me.isDatasetVisible(i)) {\n\t\t\t\tme.drawDataset(i, easingValue);\n\t\t\t}\n\t\t}\n\n\t\tcore_plugins.notify(me, 'afterDatasetsDraw', [easingValue]);\n\t},\n\n\t/**\n\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t * @private\n\t */\n\tdrawDataset: function(index, easingValue) {\n\t\tvar me = this;\n\t\tvar meta = me.getDatasetMeta(index);\n\t\tvar args = {\n\t\t\tmeta: meta,\n\t\t\tindex: index,\n\t\t\teasingValue: easingValue\n\t\t};\n\n\t\tif (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {\n\t\t\treturn;\n\t\t}\n\n\t\tmeta.controller.draw(easingValue);\n\n\t\tcore_plugins.notify(me, 'afterDatasetDraw', [args]);\n\t},\n\n\t/**\n\t * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`\n\t * hook, in which case, plugins will not be called on `afterTooltipDraw`.\n\t * @private\n\t */\n\t_drawTooltip: function(easingValue) {\n\t\tvar me = this;\n\t\tvar tooltip = me.tooltip;\n\t\tvar args = {\n\t\t\ttooltip: tooltip,\n\t\t\teasingValue: easingValue\n\t\t};\n\n\t\tif (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {\n\t\t\treturn;\n\t\t}\n\n\t\ttooltip.draw();\n\n\t\tcore_plugins.notify(me, 'afterTooltipDraw', [args]);\n\t},\n\n\t/**\n\t * Get the single element that was clicked on\n\t * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw\n\t */\n\tgetElementAtEvent: function(e) {\n\t\treturn core_interaction.modes.single(this, e);\n\t},\n\n\tgetElementsAtEvent: function(e) {\n\t\treturn core_interaction.modes.label(this, e, {intersect: true});\n\t},\n\n\tgetElementsAtXAxis: function(e) {\n\t\treturn core_interaction.modes['x-axis'](this, e, {intersect: true});\n\t},\n\n\tgetElementsAtEventForMode: function(e, mode, options) {\n\t\tvar method = core_interaction.modes[mode];\n\t\tif (typeof method === 'function') {\n\t\t\treturn method(this, e, options);\n\t\t}\n\n\t\treturn [];\n\t},\n\n\tgetDatasetAtEvent: function(e) {\n\t\treturn core_interaction.modes.dataset(this, e, {intersect: true});\n\t},\n\n\tgetDatasetMeta: function(datasetIndex) {\n\t\tvar me = this;\n\t\tvar dataset = me.data.datasets[datasetIndex];\n\t\tif (!dataset._meta) {\n\t\t\tdataset._meta = {};\n\t\t}\n\n\t\tvar meta = dataset._meta[me.id];\n\t\tif (!meta) {\n\t\t\tmeta = dataset._meta[me.id] = {\n\t\t\t\ttype: null,\n\t\t\t\tdata: [],\n\t\t\t\tdataset: null,\n\t\t\t\tcontroller: null,\n\t\t\t\thidden: null,\t\t\t// See isDatasetVisible() comment\n\t\t\t\txAxisID: null,\n\t\t\t\tyAxisID: null\n\t\t\t};\n\t\t}\n\n\t\treturn meta;\n\t},\n\n\tgetVisibleDatasetCount: function() {\n\t\tvar count = 0;\n\t\tfor (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n\t\t\tif (this.isDatasetVisible(i)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t},\n\n\tisDatasetVisible: function(datasetIndex) {\n\t\tvar meta = this.getDatasetMeta(datasetIndex);\n\n\t\t// meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n\t\t// the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n\t\treturn typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;\n\t},\n\n\tgenerateLegend: function() {\n\t\treturn this.options.legendCallback(this);\n\t},\n\n\t/**\n\t * @private\n\t */\n\tdestroyDatasetMeta: function(datasetIndex) {\n\t\tvar id = this.id;\n\t\tvar dataset = this.data.datasets[datasetIndex];\n\t\tvar meta = dataset._meta && dataset._meta[id];\n\n\t\tif (meta) {\n\t\t\tmeta.controller.destroy();\n\t\t\tdelete dataset._meta[id];\n\t\t}\n\t},\n\n\tdestroy: function() {\n\t\tvar me = this;\n\t\tvar canvas = me.canvas;\n\t\tvar i, ilen;\n\n\t\tme.stop();\n\n\t\t// dataset controllers need to cleanup associated data\n\t\tfor (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {\n\t\t\tme.destroyDatasetMeta(i);\n\t\t}\n\n\t\tif (canvas) {\n\t\t\tme.unbindEvents();\n\t\t\thelpers$1.canvas.clear(me);\n\t\t\tplatform.releaseContext(me.ctx);\n\t\t\tme.canvas = null;\n\t\t\tme.ctx = null;\n\t\t}\n\n\t\tcore_plugins.notify(me, 'destroy');\n\n\t\tdelete Chart.instances[me.id];\n\t},\n\n\ttoBase64Image: function() {\n\t\treturn this.canvas.toDataURL.apply(this.canvas, arguments);\n\t},\n\n\tinitToolTip: function() {\n\t\tvar me = this;\n\t\tme.tooltip = new core_tooltip({\n\t\t\t_chart: me,\n\t\t\t_chartInstance: me, // deprecated, backward compatibility\n\t\t\t_data: me.data,\n\t\t\t_options: me.options.tooltips\n\t\t}, me);\n\t},\n\n\t/**\n\t * @private\n\t */\n\tbindEvents: function() {\n\t\tvar me = this;\n\t\tvar listeners = me._listeners = {};\n\t\tvar listener = function() {\n\t\t\tme.eventHandler.apply(me, arguments);\n\t\t};\n\n\t\thelpers$1.each(me.options.events, function(type) {\n\t\t\tplatform.addEventListener(me, type, listener);\n\t\t\tlisteners[type] = listener;\n\t\t});\n\n\t\t// Elements used to detect size change should not be injected for non responsive charts.\n\t\t// See https://github.com/chartjs/Chart.js/issues/2210\n\t\tif (me.options.responsive) {\n\t\t\tlistener = function() {\n\t\t\t\tme.resize();\n\t\t\t};\n\n\t\t\tplatform.addEventListener(me, 'resize', listener);\n\t\t\tlisteners.resize = listener;\n\t\t}\n\t},\n\n\t/**\n\t * @private\n\t */\n\tunbindEvents: function() {\n\t\tvar me = this;\n\t\tvar listeners = me._listeners;\n\t\tif (!listeners) {\n\t\t\treturn;\n\t\t}\n\n\t\tdelete me._listeners;\n\t\thelpers$1.each(listeners, function(listener, type) {\n\t\t\tplatform.removeEventListener(me, type, listener);\n\t\t});\n\t},\n\n\tupdateHoverStyle: function(elements, mode, enabled) {\n\t\tvar method = enabled ? 'setHoverStyle' : 'removeHoverStyle';\n\t\tvar element, i, ilen;\n\n\t\tfor (i = 0, ilen = elements.length; i < ilen; ++i) {\n\t\t\telement = elements[i];\n\t\t\tif (element) {\n\t\t\t\tthis.getDatasetMeta(element._datasetIndex).controller[method](element);\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * @private\n\t */\n\teventHandler: function(e) {\n\t\tvar me = this;\n\t\tvar tooltip = me.tooltip;\n\n\t\tif (core_plugins.notify(me, 'beforeEvent', [e]) === false) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Buffer any update calls so that renders do not occur\n\t\tme._bufferedRender = true;\n\t\tme._bufferedRequest = null;\n\n\t\tvar changed = me.handleEvent(e);\n\t\t// for smooth tooltip animations issue #4989\n\t\t// the tooltip should be the source of change\n\t\t// Animation check workaround:\n\t\t// tooltip._start will be null when tooltip isn't animating\n\t\tif (tooltip) {\n\t\t\tchanged = tooltip._start\n\t\t\t\t? tooltip.handleEvent(e)\n\t\t\t\t: changed | tooltip.handleEvent(e);\n\t\t}\n\n\t\tcore_plugins.notify(me, 'afterEvent', [e]);\n\n\t\tvar bufferedRequest = me._bufferedRequest;\n\t\tif (bufferedRequest) {\n\t\t\t// If we have an update that was triggered, we need to do a normal render\n\t\t\tme.render(bufferedRequest);\n\t\t} else if (changed && !me.animating) {\n\t\t\t// If entering, leaving, or changing elements, animate the change via pivot\n\t\t\tme.stop();\n\n\t\t\t// We only need to render at this point. Updating will cause scales to be\n\t\t\t// recomputed generating flicker & using more memory than necessary.\n\t\t\tme.render({\n\t\t\t\tduration: me.options.hover.animationDuration,\n\t\t\t\tlazy: true\n\t\t\t});\n\t\t}\n\n\t\tme._bufferedRender = false;\n\t\tme._bufferedRequest = null;\n\n\t\treturn me;\n\t},\n\n\t/**\n\t * Handle an event\n\t * @private\n\t * @param {IEvent} event the event to handle\n\t * @return {boolean} true if the chart needs to re-render\n\t */\n\thandleEvent: function(e) {\n\t\tvar me = this;\n\t\tvar options = me.options || {};\n\t\tvar hoverOptions = options.hover;\n\t\tvar changed = false;\n\n\t\tme.lastActive = me.lastActive || [];\n\n\t\t// Find Active Elements for hover and tooltips\n\t\tif (e.type === 'mouseout') {\n\t\t\tme.active = [];\n\t\t} else {\n\t\t\tme.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);\n\t\t}\n\n\t\t// Invoke onHover hook\n\t\t// Need to call with native event here to not break backwards compatibility\n\t\thelpers$1.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);\n\n\t\tif (e.type === 'mouseup' || e.type === 'click') {\n\t\t\tif (options.onClick) {\n\t\t\t\t// Use e.native here for backwards compatibility\n\t\t\t\toptions.onClick.call(me, e.native, me.active);\n\t\t\t}\n\t\t}\n\n\t\t// Remove styling for last active (even if it may still be active)\n\t\tif (me.lastActive.length) {\n\t\t\tme.updateHoverStyle(me.lastActive, hoverOptions.mode, false);\n\t\t}\n\n\t\t// Built in hover styling\n\t\tif (me.active.length && hoverOptions.mode) {\n\t\t\tme.updateHoverStyle(me.active, hoverOptions.mode, true);\n\t\t}\n\n\t\tchanged = !helpers$1.arrayEquals(me.active, me.lastActive);\n\n\t\t// Remember Last Actives\n\t\tme.lastActive = me.active;\n\n\t\treturn changed;\n\t}\n});\n\n/**\n * NOTE(SB) We actually don't use this container anymore but we need to keep it\n * for backward compatibility. Though, it can still be useful for plugins that\n * would need to work on multiple charts?!\n */\nChart.instances = {};\n\nvar core_controller = Chart;\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, use Chart instead.\n * @class Chart.Controller\n * @deprecated since version 2.6\n * @todo remove at version 3\n * @private\n */\nChart.Controller = Chart;\n\n/**\n * Provided for backward compatibility, not available anymore.\n * @namespace Chart\n * @deprecated since version 2.8\n * @todo remove at version 3\n * @private\n */\nChart.types = {};\n\n/**\n * Provided for backward compatibility, not available anymore.\n * @namespace Chart.helpers.configMerge\n * @deprecated since version 2.8.0\n * @todo remove at version 3\n * @private\n */\nhelpers$1.configMerge = mergeConfig;\n\n/**\n * Provided for backward compatibility, not available anymore.\n * @namespace Chart.helpers.scaleMerge\n * @deprecated since version 2.8.0\n * @todo remove at version 3\n * @private\n */\nhelpers$1.scaleMerge = mergeScaleConfig;\n\nvar core_helpers = function() {\n\n\t// -- Basic js utility methods\n\n\thelpers$1.where = function(collection, filterCallback) {\n\t\tif (helpers$1.isArray(collection) && Array.prototype.filter) {\n\t\t\treturn collection.filter(filterCallback);\n\t\t}\n\t\tvar filtered = [];\n\n\t\thelpers$1.each(collection, function(item) {\n\t\t\tif (filterCallback(item)) {\n\t\t\t\tfiltered.push(item);\n\t\t\t}\n\t\t});\n\n\t\treturn filtered;\n\t};\n\thelpers$1.findIndex = Array.prototype.findIndex ?\n\t\tfunction(array, callback, scope) {\n\t\t\treturn array.findIndex(callback, scope);\n\t\t} :\n\t\tfunction(array, callback, scope) {\n\t\t\tscope = scope === undefined ? array : scope;\n\t\t\tfor (var i = 0, ilen = array.length; i < ilen; ++i) {\n\t\t\t\tif (callback.call(scope, array[i], i, array)) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\thelpers$1.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t// Default to start of the array\n\t\tif (helpers$1.isNullOrUndef(startIndex)) {\n\t\t\tstartIndex = -1;\n\t\t}\n\t\tfor (var i = startIndex + 1; i < arrayToSearch.length; i++) {\n\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\treturn currentItem;\n\t\t\t}\n\t\t}\n\t};\n\thelpers$1.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {\n\t\t// Default to end of the array\n\t\tif (helpers$1.isNullOrUndef(startIndex)) {\n\t\t\tstartIndex = arrayToSearch.length;\n\t\t}\n\t\tfor (var i = startIndex - 1; i >= 0; i--) {\n\t\t\tvar currentItem = arrayToSearch[i];\n\t\t\tif (filterCallback(currentItem)) {\n\t\t\t\treturn currentItem;\n\t\t\t}\n\t\t}\n\t};\n\n\t// -- Math methods\n\thelpers$1.isNumber = function(n) {\n\t\treturn !isNaN(parseFloat(n)) && isFinite(n);\n\t};\n\thelpers$1.almostEquals = function(x, y, epsilon) {\n\t\treturn Math.abs(x - y) < epsilon;\n\t};\n\thelpers$1.almostWhole = function(x, epsilon) {\n\t\tvar rounded = Math.round(x);\n\t\treturn (((rounded - epsilon) < x) && ((rounded + epsilon) > x));\n\t};\n\thelpers$1.max = function(array) {\n\t\treturn array.reduce(function(max, value) {\n\t\t\tif (!isNaN(value)) {\n\t\t\t\treturn Math.max(max, value);\n\t\t\t}\n\t\t\treturn max;\n\t\t}, Number.NEGATIVE_INFINITY);\n\t};\n\thelpers$1.min = function(array) {\n\t\treturn array.reduce(function(min, value) {\n\t\t\tif (!isNaN(value)) {\n\t\t\t\treturn Math.min(min, value);\n\t\t\t}\n\t\t\treturn min;\n\t\t}, Number.POSITIVE_INFINITY);\n\t};\n\thelpers$1.sign = Math.sign ?\n\t\tfunction(x) {\n\t\t\treturn Math.sign(x);\n\t\t} :\n\t\tfunction(x) {\n\t\t\tx = +x; // convert to a number\n\t\t\tif (x === 0 || isNaN(x)) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\treturn x > 0 ? 1 : -1;\n\t\t};\n\thelpers$1.log10 = Math.log10 ?\n\t\tfunction(x) {\n\t\t\treturn Math.log10(x);\n\t\t} :\n\t\tfunction(x) {\n\t\t\tvar exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.\n\t\t\t// Check for whole powers of 10,\n\t\t\t// which due to floating point rounding error should be corrected.\n\t\t\tvar powerOf10 = Math.round(exponent);\n\t\t\tvar isPowerOf10 = x === Math.pow(10, powerOf10);\n\n\t\t\treturn isPowerOf10 ? powerOf10 : exponent;\n\t\t};\n\thelpers$1.toRadians = function(degrees) {\n\t\treturn degrees * (Math.PI / 180);\n\t};\n\thelpers$1.toDegrees = function(radians) {\n\t\treturn radians * (180 / Math.PI);\n\t};\n\n\t/**\n\t * Returns the number of decimal places\n\t * i.e. the number of digits after the decimal point, of the value of this Number.\n\t * @param {number} x - A number.\n\t * @returns {number} The number of decimal places.\n\t * @private\n\t */\n\thelpers$1._decimalPlaces = function(x) {\n\t\tif (!helpers$1.isFinite(x)) {\n\t\t\treturn;\n\t\t}\n\t\tvar e = 1;\n\t\tvar p = 0;\n\t\twhile (Math.round(x * e) / e !== x) {\n\t\t\te *= 10;\n\t\t\tp++;\n\t\t}\n\t\treturn p;\n\t};\n\n\t// Gets the angle from vertical upright to the point about a centre.\n\thelpers$1.getAngleFromPoint = function(centrePoint, anglePoint) {\n\t\tvar distanceFromXCenter = anglePoint.x - centrePoint.x;\n\t\tvar distanceFromYCenter = anglePoint.y - centrePoint.y;\n\t\tvar radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n\t\tvar angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n\t\tif (angle < (-0.5 * Math.PI)) {\n\t\t\tangle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n\t\t}\n\n\t\treturn {\n\t\t\tangle: angle,\n\t\t\tdistance: radialDistanceFromCenter\n\t\t};\n\t};\n\thelpers$1.distanceBetweenPoints = function(pt1, pt2) {\n\t\treturn Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n\t};\n\n\t/**\n\t * Provided for backward compatibility, not available anymore\n\t * @function Chart.helpers.aliasPixel\n\t * @deprecated since version 2.8.0\n\t * @todo remove at version 3\n\t */\n\thelpers$1.aliasPixel = function(pixelWidth) {\n\t\treturn (pixelWidth % 2 === 0) ? 0 : 0.5;\n\t};\n\n\t/**\n\t * Returns the aligned pixel value to avoid anti-aliasing blur\n\t * @param {Chart} chart - The chart instance.\n\t * @param {number} pixel - A pixel value.\n\t * @param {number} width - The width of the element.\n\t * @returns {number} The aligned pixel value.\n\t * @private\n\t */\n\thelpers$1._alignPixel = function(chart, pixel, width) {\n\t\tvar devicePixelRatio = chart.currentDevicePixelRatio;\n\t\tvar halfWidth = width / 2;\n\t\treturn Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n\t};\n\n\thelpers$1.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {\n\t\t// Props to Rob Spencer at scaled innovation for his post on splining between points\n\t\t// http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n\t\t// This function must also respect \"skipped\" points\n\n\t\tvar previous = firstPoint.skip ? middlePoint : firstPoint;\n\t\tvar current = middlePoint;\n\t\tvar next = afterPoint.skip ? middlePoint : afterPoint;\n\n\t\tvar d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));\n\t\tvar d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));\n\n\t\tvar s01 = d01 / (d01 + d12);\n\t\tvar s12 = d12 / (d01 + d12);\n\n\t\t// If all points are the same, s01 & s02 will be inf\n\t\ts01 = isNaN(s01) ? 0 : s01;\n\t\ts12 = isNaN(s12) ? 0 : s12;\n\n\t\tvar fa = t * s01; // scaling factor for triangle Ta\n\t\tvar fb = t * s12;\n\n\t\treturn {\n\t\t\tprevious: {\n\t\t\t\tx: current.x - fa * (next.x - previous.x),\n\t\t\t\ty: current.y - fa * (next.y - previous.y)\n\t\t\t},\n\t\t\tnext: {\n\t\t\t\tx: current.x + fb * (next.x - previous.x),\n\t\t\t\ty: current.y + fb * (next.y - previous.y)\n\t\t\t}\n\t\t};\n\t};\n\thelpers$1.EPSILON = Number.EPSILON || 1e-14;\n\thelpers$1.splineCurveMonotone = function(points) {\n\t\t// This function calculates Bzier control points in a similar way than |splineCurve|,\n\t\t// but preserves monotonicity of the provided data and ensures no local extremums are added\n\t\t// between the dataset discrete points due to the interpolation.\n\t\t// See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n\n\t\tvar pointsWithTangents = (points || []).map(function(point) {\n\t\t\treturn {\n\t\t\t\tmodel: point._model,\n\t\t\t\tdeltaK: 0,\n\t\t\t\tmK: 0\n\t\t\t};\n\t\t});\n\n\t\t// Calculate slopes (deltaK) and initialize tangents (mK)\n\t\tvar pointsLen = pointsWithTangents.length;\n\t\tvar i, pointBefore, pointCurrent, pointAfter;\n\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\tvar slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);\n\n\t\t\t\t// In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n\t\t\t\tpointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;\n\t\t\t}\n\n\t\t\tif (!pointBefore || pointBefore.model.skip) {\n\t\t\t\tpointCurrent.mK = pointCurrent.deltaK;\n\t\t\t} else if (!pointAfter || pointAfter.model.skip) {\n\t\t\t\tpointCurrent.mK = pointBefore.deltaK;\n\t\t\t} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {\n\t\t\t\tpointCurrent.mK = 0;\n\t\t\t} else {\n\t\t\t\tpointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;\n\t\t\t}\n\t\t}\n\n\t\t// Adjust tangents to ensure monotonic properties\n\t\tvar alphaK, betaK, tauK, squaredMagnitude;\n\t\tfor (i = 0; i < pointsLen - 1; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tpointAfter = pointsWithTangents[i + 1];\n\t\t\tif (pointCurrent.model.skip || pointAfter.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {\n\t\t\t\tpointCurrent.mK = pointAfter.mK = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\talphaK = pointCurrent.mK / pointCurrent.deltaK;\n\t\t\tbetaK = pointAfter.mK / pointCurrent.deltaK;\n\t\t\tsquaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n\t\t\tif (squaredMagnitude <= 9) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttauK = 3 / Math.sqrt(squaredMagnitude);\n\t\t\tpointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;\n\t\t\tpointAfter.mK = betaK * tauK * pointCurrent.deltaK;\n\t\t}\n\n\t\t// Compute control points\n\t\tvar deltaX;\n\t\tfor (i = 0; i < pointsLen; ++i) {\n\t\t\tpointCurrent = pointsWithTangents[i];\n\t\t\tif (pointCurrent.model.skip) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpointBefore = i > 0 ? pointsWithTangents[i - 1] : null;\n\t\t\tpointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;\n\t\t\tif (pointBefore && !pointBefore.model.skip) {\n\t\t\t\tdeltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;\n\t\t\t\tpointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;\n\t\t\t\tpointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;\n\t\t\t}\n\t\t\tif (pointAfter && !pointAfter.model.skip) {\n\t\t\t\tdeltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;\n\t\t\t\tpointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;\n\t\t\t\tpointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;\n\t\t\t}\n\t\t}\n\t};\n\thelpers$1.nextItem = function(collection, index, loop) {\n\t\tif (loop) {\n\t\t\treturn index >= collection.length - 1 ? collection[0] : collection[index + 1];\n\t\t}\n\t\treturn index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];\n\t};\n\thelpers$1.previousItem = function(collection, index, loop) {\n\t\tif (loop) {\n\t\t\treturn index <= 0 ? collection[collection.length - 1] : collection[index - 1];\n\t\t}\n\t\treturn index <= 0 ? collection[0] : collection[index - 1];\n\t};\n\t// Implementation of the nice number algorithm used in determining where axis labels will go\n\thelpers$1.niceNum = function(range, round) {\n\t\tvar exponent = Math.floor(helpers$1.log10(range));\n\t\tvar fraction = range / Math.pow(10, exponent);\n\t\tvar niceFraction;\n\n\t\tif (round) {\n\t\t\tif (fraction < 1.5) {\n\t\t\t\tniceFraction = 1;\n\t\t\t} else if (fraction < 3) {\n\t\t\t\tniceFraction = 2;\n\t\t\t} else if (fraction < 7) {\n\t\t\t\tniceFraction = 5;\n\t\t\t} else {\n\t\t\t\tniceFraction = 10;\n\t\t\t}\n\t\t} else if (fraction <= 1.0) {\n\t\t\tniceFraction = 1;\n\t\t} else if (fraction <= 2) {\n\t\t\tniceFraction = 2;\n\t\t} else if (fraction <= 5) {\n\t\t\tniceFraction = 5;\n\t\t} else {\n\t\t\tniceFraction = 10;\n\t\t}\n\n\t\treturn niceFraction * Math.pow(10, exponent);\n\t};\n\t// Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/\n\thelpers$1.requestAnimFrame = (function() {\n\t\tif (typeof window === 'undefined') {\n\t\t\treturn function(callback) {\n\t\t\t\tcallback();\n\t\t\t};\n\t\t}\n\t\treturn window.requestAnimationFrame ||\n\t\t\twindow.webkitRequestAnimationFrame ||\n\t\t\twindow.mozRequestAnimationFrame ||\n\t\t\twindow.oRequestAnimationFrame ||\n\t\t\twindow.msRequestAnimationFrame ||\n\t\t\tfunction(callback) {\n\t\t\t\treturn window.setTimeout(callback, 1000 / 60);\n\t\t\t};\n\t}());\n\t// -- DOM methods\n\thelpers$1.getRelativePosition = function(evt, chart) {\n\t\tvar mouseX, mouseY;\n\t\tvar e = evt.originalEvent || evt;\n\t\tvar canvas = evt.target || evt.srcElement;\n\t\tvar boundingRect = canvas.getBoundingClientRect();\n\n\t\tvar touches = e.touches;\n\t\tif (touches && touches.length > 0) {\n\t\t\tmouseX = touches[0].clientX;\n\t\t\tmouseY = touches[0].clientY;\n\n\t\t} else {\n\t\t\tmouseX = e.clientX;\n\t\t\tmouseY = e.clientY;\n\t\t}\n\n\t\t// Scale mouse coordinates into canvas coordinates\n\t\t// by following the pattern laid out by 'jerryj' in the comments of\n\t\t// https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/\n\t\tvar paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));\n\t\tvar paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));\n\t\tvar paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));\n\t\tvar paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));\n\t\tvar width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;\n\t\tvar height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;\n\n\t\t// We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However\n\t\t// the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here\n\t\tmouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);\n\t\tmouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);\n\n\t\treturn {\n\t\t\tx: mouseX,\n\t\t\ty: mouseY\n\t\t};\n\n\t};\n\n\t// Private helper function to convert max-width/max-height values that may be percentages into a number\n\tfunction parseMaxStyle(styleValue, node, parentProperty) {\n\t\tvar valueInPixels;\n\t\tif (typeof styleValue === 'string') {\n\t\t\tvalueInPixels = parseInt(styleValue, 10);\n\n\t\t\tif (styleValue.indexOf('%') !== -1) {\n\t\t\t\t// percentage * size in dimension\n\t\t\t\tvalueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n\t\t\t}\n\t\t} else {\n\t\t\tvalueInPixels = styleValue;\n\t\t}\n\n\t\treturn valueInPixels;\n\t}\n\n\t/**\n\t * Returns if the given value contains an effective constraint.\n\t * @private\n\t */\n\tfunction isConstrainedValue(value) {\n\t\treturn value !== undefined && value !== null && value !== 'none';\n\t}\n\n\t/**\n\t * Returns the max width or height of the given DOM node in a cross-browser compatible fashion\n\t * @param {HTMLElement} domNode - the node to check the constraint on\n\t * @param {string} maxStyle - the style that defines the maximum for the direction we are using ('max-width' / 'max-height')\n\t * @param {string} percentageProperty - property of parent to use when calculating width as a percentage\n\t * @see {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}\n\t */\n\tfunction getConstraintDimension(domNode, maxStyle, percentageProperty) {\n\t\tvar view = document.defaultView;\n\t\tvar parentNode = helpers$1._getParentNode(domNode);\n\t\tvar constrainedNode = view.getComputedStyle(domNode)[maxStyle];\n\t\tvar constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];\n\t\tvar hasCNode = isConstrainedValue(constrainedNode);\n\t\tvar hasCContainer = isConstrainedValue(constrainedContainer);\n\t\tvar infinity = Number.POSITIVE_INFINITY;\n\n\t\tif (hasCNode || hasCContainer) {\n\t\t\treturn Math.min(\n\t\t\t\thasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,\n\t\t\t\thasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);\n\t\t}\n\n\t\treturn 'none';\n\t}\n\t// returns Number or undefined if no constraint\n\thelpers$1.getConstraintWidth = function(domNode) {\n\t\treturn getConstraintDimension(domNode, 'max-width', 'clientWidth');\n\t};\n\t// returns Number or undefined if no constraint\n\thelpers$1.getConstraintHeight = function(domNode) {\n\t\treturn getConstraintDimension(domNode, 'max-height', 'clientHeight');\n\t};\n\t/**\n\t * @private\n \t */\n\thelpers$1._calculatePadding = function(container, padding, parentDimension) {\n\t\tpadding = helpers$1.getStyle(container, padding);\n\n\t\treturn padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);\n\t};\n\t/**\n\t * @private\n\t */\n\thelpers$1._getParentNode = function(domNode) {\n\t\tvar parent = domNode.parentNode;\n\t\tif (parent && parent.toString() === '[object ShadowRoot]') {\n\t\t\tparent = parent.host;\n\t\t}\n\t\treturn parent;\n\t};\n\thelpers$1.getMaximumWidth = function(domNode) {\n\t\tvar container = helpers$1._getParentNode(domNode);\n\t\tif (!container) {\n\t\t\treturn domNode.clientWidth;\n\t\t}\n\n\t\tvar clientWidth = container.clientWidth;\n\t\tvar paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);\n\t\tvar paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);\n\n\t\tvar w = clientWidth - paddingLeft - paddingRight;\n\t\tvar cw = helpers$1.getConstraintWidth(domNode);\n\t\treturn isNaN(cw) ? w : Math.min(w, cw);\n\t};\n\thelpers$1.getMaximumHeight = function(domNode) {\n\t\tvar container = helpers$1._getParentNode(domNode);\n\t\tif (!container) {\n\t\t\treturn domNode.clientHeight;\n\t\t}\n\n\t\tvar clientHeight = container.clientHeight;\n\t\tvar paddingTop = helpers$1._calculatePadding(container, 'padding-top', clientHeight);\n\t\tvar paddingBottom = helpers$1._calculatePadding(container, 'padding-bottom', clientHeight);\n\n\t\tvar h = clientHeight - paddingTop - paddingBottom;\n\t\tvar ch = helpers$1.getConstraintHeight(domNode);\n\t\treturn isNaN(ch) ? h : Math.min(h, ch);\n\t};\n\thelpers$1.getStyle = function(el, property) {\n\t\treturn el.currentStyle ?\n\t\t\tel.currentStyle[property] :\n\t\t\tdocument.defaultView.getComputedStyle(el, null).getPropertyValue(property);\n\t};\n\thelpers$1.retinaScale = function(chart, forceRatio) {\n\t\tvar pixelRatio = chart.currentDevicePixelRatio = forceRatio || (typeof window !== 'undefined' && window.devicePixelRatio) || 1;\n\t\tif (pixelRatio === 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar canvas = chart.canvas;\n\t\tvar height = chart.height;\n\t\tvar width = chart.width;\n\n\t\tcanvas.height = height * pixelRatio;\n\t\tcanvas.width = width * pixelRatio;\n\t\tchart.ctx.scale(pixelRatio, pixelRatio);\n\n\t\t// If no style has been set on the canvas, the render size is used as display size,\n\t\t// making the chart visually bigger, so let's enforce it to the \"correct\" values.\n\t\t// See https://github.com/chartjs/Chart.js/issues/3575\n\t\tif (!canvas.style.height && !canvas.style.width) {\n\t\t\tcanvas.style.height = height + 'px';\n\t\t\tcanvas.style.width = width + 'px';\n\t\t}\n\t};\n\t// -- Canvas methods\n\thelpers$1.fontString = function(pixelSize, fontStyle, fontFamily) {\n\t\treturn fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n\t};\n\thelpers$1.longestText = function(ctx, font, arrayOfThings, cache) {\n\t\tcache = cache || {};\n\t\tvar data = cache.data = cache.data || {};\n\t\tvar gc = cache.garbageCollect = cache.garbageCollect || [];\n\n\t\tif (cache.font !== font) {\n\t\t\tdata = cache.data = {};\n\t\t\tgc = cache.garbageCollect = [];\n\t\t\tcache.font = font;\n\t\t}\n\n\t\tctx.font = font;\n\t\tvar longest = 0;\n\t\thelpers$1.each(arrayOfThings, function(thing) {\n\t\t\t// Undefined strings and arrays should not be measured\n\t\t\tif (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {\n\t\t\t\tlongest = helpers$1.measureText(ctx, data, gc, longest, thing);\n\t\t\t} else if (helpers$1.isArray(thing)) {\n\t\t\t\t// if it is an array lets measure each element\n\t\t\t\t// to do maybe simplify this function a bit so we can do this more recursively?\n\t\t\t\thelpers$1.each(thing, function(nestedThing) {\n\t\t\t\t\t// Undefined strings and arrays should not be measured\n\t\t\t\t\tif (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {\n\t\t\t\t\t\tlongest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tvar gcLen = gc.length / 2;\n\t\tif (gcLen > arrayOfThings.length) {\n\t\t\tfor (var i = 0; i < gcLen; i++) {\n\t\t\t\tdelete data[gc[i]];\n\t\t\t}\n\t\t\tgc.splice(0, gcLen);\n\t\t}\n\t\treturn longest;\n\t};\n\thelpers$1.measureText = function(ctx, data, gc, longest, string) {\n\t\tvar textWidth = data[string];\n\t\tif (!textWidth) {\n\t\t\ttextWidth = data[string] = ctx.measureText(string).width;\n\t\t\tgc.push(string);\n\t\t}\n\t\tif (textWidth > longest) {\n\t\t\tlongest = textWidth;\n\t\t}\n\t\treturn longest;\n\t};\n\thelpers$1.numberOfLabelLines = function(arrayOfThings) {\n\t\tvar numberOfLines = 1;\n\t\thelpers$1.each(arrayOfThings, function(thing) {\n\t\t\tif (helpers$1.isArray(thing)) {\n\t\t\t\tif (thing.length > numberOfLines) {\n\t\t\t\t\tnumberOfLines = thing.length;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn numberOfLines;\n\t};\n\n\thelpers$1.color = !chartjsColor ?\n\t\tfunction(value) {\n\t\t\tconsole.error('Color.js not found!');\n\t\t\treturn value;\n\t\t} :\n\t\tfunction(value) {\n\t\t\t/* global CanvasGradient */\n\t\t\tif (value instanceof CanvasGradient) {\n\t\t\t\tvalue = core_defaults.global.defaultColor;\n\t\t\t}\n\n\t\t\treturn chartjsColor(value);\n\t\t};\n\n\thelpers$1.getHoverColor = function(colorValue) {\n\t\t/* global CanvasPattern */\n\t\treturn (colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient) ?\n\t\t\tcolorValue :\n\t\t\thelpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();\n\t};\n};\n\nfunction abstract() {\n\tthrow new Error(\n\t\t'This method is not implemented: either no adapter can ' +\n\t\t'be found or an incomplete integration was provided.'\n\t);\n}\n\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */\n\n/**\n * Currently supported unit string values.\n * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}\n * @memberof Chart._adapters._date\n * @name Unit\n */\n\n/**\n * @class\n */\nfunction DateAdapter(options) {\n\tthis.options = options || {};\n}\n\nhelpers$1.extend(DateAdapter.prototype, /** @lends DateAdapter */ {\n\t/**\n\t * Returns a map of time formats for the supported formatting units defined\n\t * in Unit as well as 'datetime' representing a detailed date/time string.\n\t * @returns {{string: string}}\n\t */\n\tformats: abstract,\n\n\t/**\n\t * Parses the given `value` and return the associated timestamp.\n\t * @param {any} value - the value to parse (usually comes from the data)\n\t * @param {string} [format] - the expected data format\n\t * @returns {(number|null)}\n\t * @function\n\t */\n\tparse: abstract,\n\n\t/**\n\t * Returns the formatted date in the specified `format` for a given `timestamp`.\n\t * @param {number} timestamp - the timestamp to format\n\t * @param {string} format - the date/time token\n\t * @return {string}\n\t * @function\n\t */\n\tformat: abstract,\n\n\t/**\n\t * Adds the specified `amount` of `unit` to the given `timestamp`.\n\t * @param {number} timestamp - the input timestamp\n\t * @param {number} amount - the amount to add\n\t * @param {Unit} unit - the unit as string\n\t * @return {number}\n\t * @function\n\t */\n\tadd: abstract,\n\n\t/**\n\t * Returns the number of `unit` between the given timestamps.\n\t * @param {number} max - the input timestamp (reference)\n\t * @param {number} min - the timestamp to substract\n\t * @param {Unit} unit - the unit as string\n\t * @return {number}\n\t * @function\n\t */\n\tdiff: abstract,\n\n\t/**\n\t * Returns start of `unit` for the given `timestamp`.\n\t * @param {number} timestamp - the input timestamp\n\t * @param {Unit} unit - the unit as string\n\t * @param {number} [weekday] - the ISO day of the week with 1 being Monday\n\t * and 7 being Sunday (only needed if param *unit* is `isoWeek`).\n\t * @function\n\t */\n\tstartOf: abstract,\n\n\t/**\n\t * Returns end of `unit` for the given `timestamp`.\n\t * @param {number} timestamp - the input timestamp\n\t * @param {Unit} unit - the unit as string\n\t * @function\n\t */\n\tendOf: abstract,\n\n\t// DEPRECATIONS\n\n\t/**\n\t * Provided for backward compatibility for scale.getValueForPixel(),\n\t * this method should be overridden only by the moment adapter.\n\t * @deprecated since version 2.8.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\t_create: function(value) {\n\t\treturn value;\n\t}\n});\n\nDateAdapter.override = function(members) {\n\thelpers$1.extend(DateAdapter.prototype, members);\n};\n\nvar _date = DateAdapter;\n\nvar core_adapters = {\n\t_date: _date\n};\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nvar core_ticks = {\n\t/**\n\t * Namespace to hold formatters for different types of ticks\n\t * @namespace Chart.Ticks.formatters\n\t */\n\tformatters: {\n\t\t/**\n\t\t * Formatter for value labels\n\t\t * @method Chart.Ticks.formatters.values\n\t\t * @param value the value to display\n\t\t * @return {string|string[]} the label to display\n\t\t */\n\t\tvalues: function(value) {\n\t\t\treturn helpers$1.isArray(value) ? value : '' + value;\n\t\t},\n\n\t\t/**\n\t\t * Formatter for linear numeric ticks\n\t\t * @method Chart.Ticks.formatters.linear\n\t\t * @param tickValue {number} the value to be formatted\n\t\t * @param index {number} the position of the tickValue parameter in the ticks array\n\t\t * @param ticks {number[]} the list of ticks being converted\n\t\t * @return {string} string representation of the tickValue parameter\n\t\t */\n\t\tlinear: function(tickValue, index, ticks) {\n\t\t\t// If we have lots of ticks, don't use the ones\n\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n\n\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\t\t\tif (Math.abs(delta) > 1) {\n\t\t\t\tif (tickValue !== Math.floor(tickValue)) {\n\t\t\t\t\t// not an integer\n\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar logDelta = helpers$1.log10(Math.abs(delta));\n\t\t\tvar tickString = '';\n\n\t\t\tif (tickValue !== 0) {\n\t\t\t\tvar maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));\n\t\t\t\tif (maxTick < 1e-4) { // all ticks are small numbers; use scientific notation\n\t\t\t\t\tvar logTick = helpers$1.log10(Math.abs(tickValue));\n\t\t\t\t\ttickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));\n\t\t\t\t} else {\n\t\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\n\t\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\t\t\t\t\ttickString = tickValue.toFixed(numDecimal);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttickString = '0'; // never show decimal places for 0\n\t\t\t}\n\n\t\t\treturn tickString;\n\t\t},\n\n\t\tlogarithmic: function(tickValue, index, ticks) {\n\t\t\tvar remain = tickValue / (Math.pow(10, Math.floor(helpers$1.log10(tickValue))));\n\n\t\t\tif (tickValue === 0) {\n\t\t\t\treturn '0';\n\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n\t\t\t\treturn tickValue.toExponential();\n\t\t\t}\n\t\t\treturn '';\n\t\t}\n\t}\n};\n\nvar valueOrDefault$9 = helpers$1.valueOrDefault;\nvar valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;\n\ncore_defaults._set('scale', {\n\tdisplay: true,\n\tposition: 'left',\n\toffset: false,\n\n\t// grid line settings\n\tgridLines: {\n\t\tdisplay: true,\n\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\tlineWidth: 1,\n\t\tdrawBorder: true,\n\t\tdrawOnChartArea: true,\n\t\tdrawTicks: true,\n\t\ttickMarkLength: 10,\n\t\tzeroLineWidth: 1,\n\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\n\t\tzeroLineBorderDash: [],\n\t\tzeroLineBorderDashOffset: 0.0,\n\t\toffsetGridLines: false,\n\t\tborderDash: [],\n\t\tborderDashOffset: 0.0\n\t},\n\n\t// scale label\n\tscaleLabel: {\n\t\t// display property\n\t\tdisplay: false,\n\n\t\t// actual label\n\t\tlabelString: '',\n\n\t\t// top/bottom padding\n\t\tpadding: {\n\t\t\ttop: 4,\n\t\t\tbottom: 4\n\t\t}\n\t},\n\n\t// label settings\n\tticks: {\n\t\tbeginAtZero: false,\n\t\tminRotation: 0,\n\t\tmaxRotation: 50,\n\t\tmirror: false,\n\t\tpadding: 0,\n\t\treverse: false,\n\t\tdisplay: true,\n\t\tautoSkip: true,\n\t\tautoSkipPadding: 0,\n\t\tlabelOffset: 0,\n\t\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n\t\tcallback: core_ticks.formatters.values,\n\t\tminor: {},\n\t\tmajor: {}\n\t}\n});\n\nfunction labelsFromTicks(ticks) {\n\tvar labels = [];\n\tvar i, ilen;\n\n\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\tlabels.push(ticks[i].label);\n\t}\n\n\treturn labels;\n}\n\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n\tvar lineValue = scale.getPixelForTick(index);\n\n\tif (offsetGridLines) {\n\t\tif (scale.getTicks().length === 1) {\n\t\t\tlineValue -= scale.isHorizontal() ?\n\t\t\t\tMath.max(lineValue - scale.left, scale.right - lineValue) :\n\t\t\t\tMath.max(lineValue - scale.top, scale.bottom - lineValue);\n\t\t} else if (index === 0) {\n\t\t\tlineValue -= (scale.getPixelForTick(1) - lineValue) / 2;\n\t\t} else {\n\t\t\tlineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;\n\t\t}\n\t}\n\treturn lineValue;\n}\n\nfunction computeTextSize(context, tick, font) {\n\treturn helpers$1.isArray(tick) ?\n\t\thelpers$1.longestText(context, font, tick) :\n\t\tcontext.measureText(tick).width;\n}\n\nvar core_scale = core_element.extend({\n\t/**\n\t * Get the padding needed for the scale\n\t * @method getPadding\n\t * @private\n\t * @returns {Padding} the necessary padding\n\t */\n\tgetPadding: function() {\n\t\tvar me = this;\n\t\treturn {\n\t\t\tleft: me.paddingLeft || 0,\n\t\t\ttop: me.paddingTop || 0,\n\t\t\tright: me.paddingRight || 0,\n\t\t\tbottom: me.paddingBottom || 0\n\t\t};\n\t},\n\n\t/**\n\t * Returns the scale tick objects ({label, major})\n\t * @since 2.7\n\t */\n\tgetTicks: function() {\n\t\treturn this._ticks;\n\t},\n\n\t// These methods are ordered by lifecyle. Utilities then follow.\n\t// Any function defined here is inherited by all scale types.\n\t// Any function can be extended by the scale type\n\n\tmergeTicksOptions: function() {\n\t\tvar ticks = this.options.ticks;\n\t\tif (ticks.minor === false) {\n\t\t\tticks.minor = {\n\t\t\t\tdisplay: false\n\t\t\t};\n\t\t}\n\t\tif (ticks.major === false) {\n\t\t\tticks.major = {\n\t\t\t\tdisplay: false\n\t\t\t};\n\t\t}\n\t\tfor (var key in ticks) {\n\t\t\tif (key !== 'major' && key !== 'minor') {\n\t\t\t\tif (typeof ticks.minor[key] === 'undefined') {\n\t\t\t\t\tticks.minor[key] = ticks[key];\n\t\t\t\t}\n\t\t\t\tif (typeof ticks.major[key] === 'undefined') {\n\t\t\t\t\tticks.major[key] = ticks[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\tbeforeUpdate: function() {\n\t\thelpers$1.callback(this.options.beforeUpdate, [this]);\n\t},\n\n\tupdate: function(maxWidth, maxHeight, margins) {\n\t\tvar me = this;\n\t\tvar i, ilen, labels, label, ticks, tick;\n\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\tme.beforeUpdate();\n\n\t\t// Absorb the master measurements\n\t\tme.maxWidth = maxWidth;\n\t\tme.maxHeight = maxHeight;\n\t\tme.margins = helpers$1.extend({\n\t\t\tleft: 0,\n\t\t\tright: 0,\n\t\t\ttop: 0,\n\t\t\tbottom: 0\n\t\t}, margins);\n\n\t\tme._maxLabelLines = 0;\n\t\tme.longestLabelWidth = 0;\n\t\tme.longestTextCache = me.longestTextCache || {};\n\n\t\t// Dimensions\n\t\tme.beforeSetDimensions();\n\t\tme.setDimensions();\n\t\tme.afterSetDimensions();\n\n\t\t// Data min/max\n\t\tme.beforeDataLimits();\n\t\tme.determineDataLimits();\n\t\tme.afterDataLimits();\n\n\t\t// Ticks - `this.ticks` is now DEPRECATED!\n\t\t// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member\n\t\t// and must not be accessed directly from outside this class. `this.ticks` being\n\t\t// around for long time and not marked as private, we can't change its structure\n\t\t// without unexpected breaking changes. If you need to access the scale ticks,\n\t\t// use scale.getTicks() instead.\n\n\t\tme.beforeBuildTicks();\n\n\t\t// New implementations should return an array of objects but for BACKWARD COMPAT,\n\t\t// we still support no return (`this.ticks` internally set by calling this method).\n\t\tticks = me.buildTicks() || [];\n\n\t\t// Allow modification of ticks in callback.\n\t\tticks = me.afterBuildTicks(ticks) || ticks;\n\n\t\tme.beforeTickToLabelConversion();\n\n\t\t// New implementations should return the formatted tick labels but for BACKWARD\n\t\t// COMPAT, we still support no return (`this.ticks` internally changed by calling\n\t\t// this method and supposed to contain only string values).\n\t\tlabels = me.convertTicksToLabels(ticks) || me.ticks;\n\n\t\tme.afterTickToLabelConversion();\n\n\t\tme.ticks = labels;   // BACKWARD COMPATIBILITY\n\n\t\t// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!\n\n\t\t// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)\n\t\tfor (i = 0, ilen = labels.length; i < ilen; ++i) {\n\t\t\tlabel = labels[i];\n\t\t\ttick = ticks[i];\n\t\t\tif (!tick) {\n\t\t\t\tticks.push(tick = {\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tmajor: false\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\ttick.label = label;\n\t\t\t}\n\t\t}\n\n\t\tme._ticks = ticks;\n\n\t\t// Tick Rotation\n\t\tme.beforeCalculateTickRotation();\n\t\tme.calculateTickRotation();\n\t\tme.afterCalculateTickRotation();\n\t\t// Fit\n\t\tme.beforeFit();\n\t\tme.fit();\n\t\tme.afterFit();\n\t\t//\n\t\tme.afterUpdate();\n\n\t\treturn me.minSize;\n\n\t},\n\tafterUpdate: function() {\n\t\thelpers$1.callback(this.options.afterUpdate, [this]);\n\t},\n\n\t//\n\n\tbeforeSetDimensions: function() {\n\t\thelpers$1.callback(this.options.beforeSetDimensions, [this]);\n\t},\n\tsetDimensions: function() {\n\t\tvar me = this;\n\t\t// Set the unconstrained dimension before label rotation\n\t\tif (me.isHorizontal()) {\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.left = 0;\n\t\t\tme.right = me.width;\n\t\t} else {\n\t\t\tme.height = me.maxHeight;\n\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.top = 0;\n\t\t\tme.bottom = me.height;\n\t\t}\n\n\t\t// Reset padding\n\t\tme.paddingLeft = 0;\n\t\tme.paddingTop = 0;\n\t\tme.paddingRight = 0;\n\t\tme.paddingBottom = 0;\n\t},\n\tafterSetDimensions: function() {\n\t\thelpers$1.callback(this.options.afterSetDimensions, [this]);\n\t},\n\n\t// Data limits\n\tbeforeDataLimits: function() {\n\t\thelpers$1.callback(this.options.beforeDataLimits, [this]);\n\t},\n\tdetermineDataLimits: helpers$1.noop,\n\tafterDataLimits: function() {\n\t\thelpers$1.callback(this.options.afterDataLimits, [this]);\n\t},\n\n\t//\n\tbeforeBuildTicks: function() {\n\t\thelpers$1.callback(this.options.beforeBuildTicks, [this]);\n\t},\n\tbuildTicks: helpers$1.noop,\n\tafterBuildTicks: function(ticks) {\n\t\tvar me = this;\n\t\t// ticks is empty for old axis implementations here\n\t\tif (helpers$1.isArray(ticks) && ticks.length) {\n\t\t\treturn helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);\n\t\t}\n\t\t// Support old implementations (that modified `this.ticks` directly in buildTicks)\n\t\tme.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;\n\t\treturn ticks;\n\t},\n\n\tbeforeTickToLabelConversion: function() {\n\t\thelpers$1.callback(this.options.beforeTickToLabelConversion, [this]);\n\t},\n\tconvertTicksToLabels: function() {\n\t\tvar me = this;\n\t\t// Convert ticks to strings\n\t\tvar tickOpts = me.options.ticks;\n\t\tme.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\n\t},\n\tafterTickToLabelConversion: function() {\n\t\thelpers$1.callback(this.options.afterTickToLabelConversion, [this]);\n\t},\n\n\t//\n\n\tbeforeCalculateTickRotation: function() {\n\t\thelpers$1.callback(this.options.beforeCalculateTickRotation, [this]);\n\t},\n\tcalculateTickRotation: function() {\n\t\tvar me = this;\n\t\tvar context = me.ctx;\n\t\tvar tickOpts = me.options.ticks;\n\t\tvar labels = labelsFromTicks(me._ticks);\n\n\t\t// Get the width of each grid by calculating the difference\n\t\t// between x offsets between 0 and 1.\n\t\tvar tickFont = helpers$1.options._parseFont(tickOpts);\n\t\tcontext.font = tickFont.string;\n\n\t\tvar labelRotation = tickOpts.minRotation || 0;\n\n\t\tif (labels.length && me.options.display && me.isHorizontal()) {\n\t\t\tvar originalLabelWidth = helpers$1.longestText(context, tickFont.string, labels, me.longestTextCache);\n\t\t\tvar labelWidth = originalLabelWidth;\n\t\t\tvar cosRotation, sinRotation;\n\n\t\t\t// Allow 3 pixels x2 padding either side for label readability\n\t\t\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n\n\t\t\t// Max label rotation can be set or default to 90 - also act as a loop counter\n\t\t\twhile (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n\t\t\t\tvar angleRadians = helpers$1.toRadians(labelRotation);\n\t\t\t\tcosRotation = Math.cos(angleRadians);\n\t\t\t\tsinRotation = Math.sin(angleRadians);\n\n\t\t\t\tif (sinRotation * originalLabelWidth > me.maxHeight) {\n\t\t\t\t\t// go back one step\n\t\t\t\t\tlabelRotation--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlabelRotation++;\n\t\t\t\tlabelWidth = cosRotation * originalLabelWidth;\n\t\t\t}\n\t\t}\n\n\t\tme.labelRotation = labelRotation;\n\t},\n\tafterCalculateTickRotation: function() {\n\t\thelpers$1.callback(this.options.afterCalculateTickRotation, [this]);\n\t},\n\n\t//\n\n\tbeforeFit: function() {\n\t\thelpers$1.callback(this.options.beforeFit, [this]);\n\t},\n\tfit: function() {\n\t\tvar me = this;\n\t\t// Reset\n\t\tvar minSize = me.minSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\n\t\tvar labels = labelsFromTicks(me._ticks);\n\n\t\tvar opts = me.options;\n\t\tvar tickOpts = opts.ticks;\n\t\tvar scaleLabelOpts = opts.scaleLabel;\n\t\tvar gridLineOpts = opts.gridLines;\n\t\tvar display = me._isVisible();\n\t\tvar position = opts.position;\n\t\tvar isHorizontal = me.isHorizontal();\n\n\t\tvar parseFont = helpers$1.options._parseFont;\n\t\tvar tickFont = parseFont(tickOpts);\n\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\n\n\t\t// Width\n\t\tif (isHorizontal) {\n\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\n\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n\t\t} else {\n\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t}\n\n\t\t// height\n\t\tif (isHorizontal) {\n\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t} else {\n\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t}\n\n\t\t// Are we showing a title for the scale?\n\t\tif (scaleLabelOpts.display && display) {\n\t\t\tvar scaleLabelFont = parseFont(scaleLabelOpts);\n\t\t\tvar scaleLabelPadding = helpers$1.options.toPadding(scaleLabelOpts.padding);\n\t\t\tvar deltaHeight = scaleLabelFont.lineHeight + scaleLabelPadding.height;\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.height += deltaHeight;\n\t\t\t} else {\n\t\t\t\tminSize.width += deltaHeight;\n\t\t\t}\n\t\t}\n\n\t\t// Don't bother fitting the ticks if we are not showing the labels\n\t\tif (tickOpts.display && display) {\n\t\t\tvar largestTextWidth = helpers$1.longestText(me.ctx, tickFont.string, labels, me.longestTextCache);\n\t\t\tvar tallestLabelHeightInLines = helpers$1.numberOfLabelLines(labels);\n\t\t\tvar lineSpace = tickFont.size * 0.5;\n\t\t\tvar tickPadding = me.options.ticks.padding;\n\n\t\t\t// Store max number of lines and widest label for _autoSkip\n\t\t\tme._maxLabelLines = tallestLabelHeightInLines;\n\t\t\tme.longestLabelWidth = largestTextWidth;\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tvar angleRadians = helpers$1.toRadians(me.labelRotation);\n\t\t\t\tvar cosRotation = Math.cos(angleRadians);\n\t\t\t\tvar sinRotation = Math.sin(angleRadians);\n\n\t\t\t\t// TODO - improve this calculation\n\t\t\t\tvar labelHeight = (sinRotation * largestTextWidth)\n\t\t\t\t\t+ (tickFont.lineHeight * tallestLabelHeightInLines)\n\t\t\t\t\t+ lineSpace; // padding\n\n\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n\n\t\t\t\tme.ctx.font = tickFont.string;\n\t\t\t\tvar firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.string);\n\t\t\t\tvar lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.string);\n\t\t\t\tvar offsetLeft = me.getPixelForTick(0) - me.left;\n\t\t\t\tvar offsetRight = me.right - me.getPixelForTick(labels.length - 1);\n\t\t\t\tvar paddingLeft, paddingRight;\n\n\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n\t\t\t\t// which means that the right padding is dominated by the font height\n\t\t\t\tif (me.labelRotation !== 0) {\n\t\t\t\t\tpaddingLeft = position === 'bottom' ? (cosRotation * firstLabelWidth) : (cosRotation * lineSpace);\n\t\t\t\t\tpaddingRight = position === 'bottom' ? (cosRotation * lineSpace) : (cosRotation * lastLabelWidth);\n\t\t\t\t} else {\n\t\t\t\t\tpaddingLeft = firstLabelWidth / 2;\n\t\t\t\t\tpaddingRight = lastLabelWidth / 2;\n\t\t\t\t}\n\t\t\t\tme.paddingLeft = Math.max(paddingLeft - offsetLeft, 0) + 3; // add 3 px to move away from canvas edges\n\t\t\t\tme.paddingRight = Math.max(paddingRight - offsetRight, 0) + 3;\n\t\t\t} else {\n\t\t\t\t// A vertical axis is more constrained by the width. Labels are the\n\t\t\t\t// dominant factor here, so get that length first and account for padding\n\t\t\t\tif (tickOpts.mirror) {\n\t\t\t\t\tlargestTextWidth = 0;\n\t\t\t\t} else {\n\t\t\t\t\t// use lineSpace for consistency with horizontal axis\n\t\t\t\t\t// tickPadding is not implemented for horizontal\n\t\t\t\t\tlargestTextWidth += tickPadding + lineSpace;\n\t\t\t\t}\n\n\t\t\t\tminSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\n\n\t\t\t\tme.paddingTop = tickFont.size / 2;\n\t\t\t\tme.paddingBottom = tickFont.size / 2;\n\t\t\t}\n\t\t}\n\n\t\tme.handleMargins();\n\n\t\tme.width = minSize.width;\n\t\tme.height = minSize.height;\n\t},\n\n\t/**\n\t * Handle margins and padding interactions\n\t * @private\n\t */\n\thandleMargins: function() {\n\t\tvar me = this;\n\t\tif (me.margins) {\n\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n\t\t\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n\t\t\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n\t\t}\n\t},\n\n\tafterFit: function() {\n\t\thelpers$1.callback(this.options.afterFit, [this]);\n\t},\n\n\t// Shared Methods\n\tisHorizontal: function() {\n\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t},\n\tisFullWidth: function() {\n\t\treturn (this.options.fullWidth);\n\t},\n\n\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n\tgetRightValue: function(rawValue) {\n\t\t// Null and undefined values first\n\t\tif (helpers$1.isNullOrUndef(rawValue)) {\n\t\t\treturn NaN;\n\t\t}\n\t\t// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\t\tif ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {\n\t\t\treturn NaN;\n\t\t}\n\t\t// If it is in fact an object, dive in one more level\n\t\tif (rawValue) {\n\t\t\tif (this.isHorizontal()) {\n\t\t\t\tif (rawValue.x !== undefined) {\n\t\t\t\t\treturn this.getRightValue(rawValue.x);\n\t\t\t\t}\n\t\t\t} else if (rawValue.y !== undefined) {\n\t\t\t\treturn this.getRightValue(rawValue.y);\n\t\t\t}\n\t\t}\n\n\t\t// Value is good, return it\n\t\treturn rawValue;\n\t},\n\n\t/**\n\t * Used to get the value to display in the tooltip for the data at the given index\n\t * @param index\n\t * @param datasetIndex\n\t */\n\tgetLabelForIndex: helpers$1.noop,\n\n\t/**\n\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param value\n\t * @param index\n\t * @param datasetIndex\n\t */\n\tgetPixelForValue: helpers$1.noop,\n\n\t/**\n\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param pixel\n\t */\n\tgetValueForPixel: helpers$1.noop,\n\n\t/**\n\t * Returns the location of the tick at the given index\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t */\n\tgetPixelForTick: function(index) {\n\t\tvar me = this;\n\t\tvar offset = me.options.offset;\n\t\tif (me.isHorizontal()) {\n\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\tvar tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n\t\t\tvar pixel = (tickWidth * index) + me.paddingLeft;\n\n\t\t\tif (offset) {\n\t\t\t\tpixel += tickWidth / 2;\n\t\t\t}\n\n\t\t\tvar finalVal = me.left + pixel;\n\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\treturn finalVal;\n\t\t}\n\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\treturn me.top + (index * (innerHeight / (me._ticks.length - 1)));\n\t},\n\n\t/**\n\t * Utility for getting the pixel location of a percentage of scale\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t */\n\tgetPixelForDecimal: function(decimal) {\n\t\tvar me = this;\n\t\tif (me.isHorizontal()) {\n\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;\n\n\t\t\tvar finalVal = me.left + valueOffset;\n\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\treturn finalVal;\n\t\t}\n\t\treturn me.top + (decimal * me.height);\n\t},\n\n\t/**\n\t * Returns the pixel for the minimum chart value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t */\n\tgetBasePixel: function() {\n\t\treturn this.getPixelForValue(this.getBaseValue());\n\t},\n\n\tgetBaseValue: function() {\n\t\tvar me = this;\n\t\tvar min = me.min;\n\t\tvar max = me.max;\n\n\t\treturn me.beginAtZero ? 0 :\n\t\t\tmin < 0 && max < 0 ? max :\n\t\t\tmin > 0 && max > 0 ? min :\n\t\t\t0;\n\t},\n\n\t/**\n\t * Returns a subset of ticks to be plotted to avoid overlapping labels.\n\t * @private\n\t */\n\t_autoSkip: function(ticks) {\n\t\tvar me = this;\n\t\tvar isHorizontal = me.isHorizontal();\n\t\tvar optionTicks = me.options.ticks.minor;\n\t\tvar tickCount = ticks.length;\n\t\tvar skipRatio = false;\n\t\tvar maxTicks = optionTicks.maxTicksLimit;\n\n\t\t// Total space needed to display all ticks. First and last ticks are\n\t\t// drawn as their center at end of axis, so tickCount-1\n\t\tvar ticksLength = me._tickSize() * (tickCount - 1);\n\n\t\t// Axis length\n\t\tvar axisLength = isHorizontal\n\t\t\t? me.width - (me.paddingLeft + me.paddingRight)\n\t\t\t: me.height - (me.paddingTop + me.PaddingBottom);\n\n\t\tvar result = [];\n\t\tvar i, tick;\n\n\t\tif (ticksLength > axisLength) {\n\t\t\tskipRatio = 1 + Math.floor(ticksLength / axisLength);\n\t\t}\n\n\t\t// if they defined a max number of optionTicks,\n\t\t// increase skipRatio until that number is met\n\t\tif (tickCount > maxTicks) {\n\t\t\tskipRatio = Math.max(skipRatio, 1 + Math.floor(tickCount / maxTicks));\n\t\t}\n\n\t\tfor (i = 0; i < tickCount; i++) {\n\t\t\ttick = ticks[i];\n\n\t\t\tif (skipRatio > 1 && i % skipRatio > 0) {\n\t\t\t\t// leave tick in place but make sure it's not displayed (#4635)\n\t\t\t\tdelete tick.label;\n\t\t\t}\n\t\t\tresult.push(tick);\n\t\t}\n\t\treturn result;\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_tickSize: function() {\n\t\tvar me = this;\n\t\tvar isHorizontal = me.isHorizontal();\n\t\tvar optionTicks = me.options.ticks.minor;\n\n\t\t// Calculate space needed by label in axis direction.\n\t\tvar rot = helpers$1.toRadians(me.labelRotation);\n\t\tvar cos = Math.abs(Math.cos(rot));\n\t\tvar sin = Math.abs(Math.sin(rot));\n\n\t\tvar padding = optionTicks.autoSkipPadding || 0;\n\t\tvar w = (me.longestLabelWidth + padding) || 0;\n\n\t\tvar tickFont = helpers$1.options._parseFont(optionTicks);\n\t\tvar h = (me._maxLabelLines * tickFont.lineHeight + padding) || 0;\n\n\t\t// Calculate space needed for 1 tick in axis direction.\n\t\treturn isHorizontal\n\t\t\t? h * cos > w * sin ? w / cos : h / sin\n\t\t\t: h * sin < w * cos ? h / cos : w / sin;\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_isVisible: function() {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar display = me.options.display;\n\t\tvar i, ilen, meta;\n\n\t\tif (display !== 'auto') {\n\t\t\treturn !!display;\n\t\t}\n\n\t\t// When 'auto', the scale is visible if at least one associated dataset is visible.\n\t\tfor (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n\t\t\tif (chart.isDatasetVisible(i)) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tif (meta.xAxisID === me.id || meta.yAxisID === me.id) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t/**\n\t * Actually draw the scale on the canvas\n\t * @param {object} chartArea - the area of the chart to draw full grid lines on\n\t */\n\tdraw: function(chartArea) {\n\t\tvar me = this;\n\t\tvar options = me.options;\n\n\t\tif (!me._isVisible()) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar chart = me.chart;\n\t\tvar context = me.ctx;\n\t\tvar globalDefaults = core_defaults.global;\n\t\tvar defaultFontColor = globalDefaults.defaultFontColor;\n\t\tvar optionTicks = options.ticks.minor;\n\t\tvar optionMajorTicks = options.ticks.major || optionTicks;\n\t\tvar gridLines = options.gridLines;\n\t\tvar scaleLabel = options.scaleLabel;\n\t\tvar position = options.position;\n\n\t\tvar isRotated = me.labelRotation !== 0;\n\t\tvar isMirrored = optionTicks.mirror;\n\t\tvar isHorizontal = me.isHorizontal();\n\n\t\tvar parseFont = helpers$1.options._parseFont;\n\t\tvar ticks = optionTicks.display && optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();\n\t\tvar tickFontColor = valueOrDefault$9(optionTicks.fontColor, defaultFontColor);\n\t\tvar tickFont = parseFont(optionTicks);\n\t\tvar lineHeight = tickFont.lineHeight;\n\t\tvar majorTickFontColor = valueOrDefault$9(optionMajorTicks.fontColor, defaultFontColor);\n\t\tvar majorTickFont = parseFont(optionMajorTicks);\n\t\tvar tickPadding = optionTicks.padding;\n\t\tvar labelOffset = optionTicks.labelOffset;\n\n\t\tvar tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n\n\t\tvar scaleLabelFontColor = valueOrDefault$9(scaleLabel.fontColor, defaultFontColor);\n\t\tvar scaleLabelFont = parseFont(scaleLabel);\n\t\tvar scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);\n\t\tvar labelRotationRadians = helpers$1.toRadians(me.labelRotation);\n\n\t\tvar itemsToDraw = [];\n\n\t\tvar axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;\n\t\tvar alignPixel = helpers$1._alignPixel;\n\t\tvar borderValue, tickStart, tickEnd;\n\n\t\tif (position === 'top') {\n\t\t\tborderValue = alignPixel(chart, me.bottom, axisWidth);\n\t\t\ttickStart = me.bottom - tl;\n\t\t\ttickEnd = borderValue - axisWidth / 2;\n\t\t} else if (position === 'bottom') {\n\t\t\tborderValue = alignPixel(chart, me.top, axisWidth);\n\t\t\ttickStart = borderValue + axisWidth / 2;\n\t\t\ttickEnd = me.top + tl;\n\t\t} else if (position === 'left') {\n\t\t\tborderValue = alignPixel(chart, me.right, axisWidth);\n\t\t\ttickStart = me.right - tl;\n\t\t\ttickEnd = borderValue - axisWidth / 2;\n\t\t} else {\n\t\t\tborderValue = alignPixel(chart, me.left, axisWidth);\n\t\t\ttickStart = borderValue + axisWidth / 2;\n\t\t\ttickEnd = me.left + tl;\n\t\t}\n\n\t\tvar epsilon = 0.0000001; // 0.0000001 is margin in pixels for Accumulated error.\n\n\t\thelpers$1.each(ticks, function(tick, index) {\n\t\t\t// autoskipper skipped this tick (#4635)\n\t\t\tif (helpers$1.isNullOrUndef(tick.label)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar label = tick.label;\n\t\t\tvar lineWidth, lineColor, borderDash, borderDashOffset;\n\t\t\tif (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {\n\t\t\t\t// Draw the first index specially\n\t\t\t\tlineWidth = gridLines.zeroLineWidth;\n\t\t\t\tlineColor = gridLines.zeroLineColor;\n\t\t\t\tborderDash = gridLines.zeroLineBorderDash || [];\n\t\t\t\tborderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;\n\t\t\t} else {\n\t\t\t\tlineWidth = valueAtIndexOrDefault(gridLines.lineWidth, index);\n\t\t\t\tlineColor = valueAtIndexOrDefault(gridLines.color, index);\n\t\t\t\tborderDash = gridLines.borderDash || [];\n\t\t\t\tborderDashOffset = gridLines.borderDashOffset || 0.0;\n\t\t\t}\n\n\t\t\t// Common properties\n\t\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY, textOffset, textAlign;\n\t\t\tvar labelCount = helpers$1.isArray(label) ? label.length : 1;\n\t\t\tvar lineValue = getPixelForGridLine(me, index, gridLines.offsetGridLines);\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tvar labelYOffset = tl + tickPadding;\n\n\t\t\t\tif (lineValue < me.left - epsilon) {\n\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\n\t\t\t\t}\n\n\t\t\t\ttx1 = tx2 = x1 = x2 = alignPixel(chart, lineValue, lineWidth);\n\t\t\t\tty1 = tickStart;\n\t\t\t\tty2 = tickEnd;\n\t\t\t\tlabelX = me.getPixelForTick(index) + labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\n\t\t\t\tif (position === 'top') {\n\t\t\t\t\ty1 = alignPixel(chart, chartArea.top, axisWidth) + axisWidth / 2;\n\t\t\t\t\ty2 = chartArea.bottom;\n\t\t\t\t\ttextOffset = ((!isRotated ? 0.5 : 1) - labelCount) * lineHeight;\n\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'left';\n\t\t\t\t\tlabelY = me.bottom - labelYOffset;\n\t\t\t\t} else {\n\t\t\t\t\ty1 = chartArea.top;\n\t\t\t\t\ty2 = alignPixel(chart, chartArea.bottom, axisWidth) - axisWidth / 2;\n\t\t\t\t\ttextOffset = (!isRotated ? 0.5 : 0) * lineHeight;\n\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'right';\n\t\t\t\t\tlabelY = me.top + labelYOffset;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar labelXOffset = (isMirrored ? 0 : tl) + tickPadding;\n\n\t\t\t\tif (lineValue < me.top - epsilon) {\n\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\n\t\t\t\t}\n\n\t\t\t\ttx1 = tickStart;\n\t\t\t\ttx2 = tickEnd;\n\t\t\t\tty1 = ty2 = y1 = y2 = alignPixel(chart, lineValue, lineWidth);\n\t\t\t\tlabelY = me.getPixelForTick(index) + labelOffset;\n\t\t\t\ttextOffset = (1 - labelCount) * lineHeight / 2;\n\n\t\t\t\tif (position === 'left') {\n\t\t\t\t\tx1 = alignPixel(chart, chartArea.left, axisWidth) + axisWidth / 2;\n\t\t\t\t\tx2 = chartArea.right;\n\t\t\t\t\ttextAlign = isMirrored ? 'left' : 'right';\n\t\t\t\t\tlabelX = me.right - labelXOffset;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = chartArea.left;\n\t\t\t\t\tx2 = alignPixel(chart, chartArea.right, axisWidth) - axisWidth / 2;\n\t\t\t\t\ttextAlign = isMirrored ? 'right' : 'left';\n\t\t\t\t\tlabelX = me.left + labelXOffset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titemsToDraw.push({\n\t\t\t\ttx1: tx1,\n\t\t\t\tty1: ty1,\n\t\t\t\ttx2: tx2,\n\t\t\t\tty2: ty2,\n\t\t\t\tx1: x1,\n\t\t\t\ty1: y1,\n\t\t\t\tx2: x2,\n\t\t\t\ty2: y2,\n\t\t\t\tlabelX: labelX,\n\t\t\t\tlabelY: labelY,\n\t\t\t\tglWidth: lineWidth,\n\t\t\t\tglColor: lineColor,\n\t\t\t\tglBorderDash: borderDash,\n\t\t\t\tglBorderDashOffset: borderDashOffset,\n\t\t\t\trotation: -1 * labelRotationRadians,\n\t\t\t\tlabel: label,\n\t\t\t\tmajor: tick.major,\n\t\t\t\ttextOffset: textOffset,\n\t\t\t\ttextAlign: textAlign\n\t\t\t});\n\t\t});\n\n\t\t// Draw all of the tick labels, tick marks, and grid lines at the correct places\n\t\thelpers$1.each(itemsToDraw, function(itemToDraw) {\n\t\t\tvar glWidth = itemToDraw.glWidth;\n\t\t\tvar glColor = itemToDraw.glColor;\n\n\t\t\tif (gridLines.display && glWidth && glColor) {\n\t\t\t\tcontext.save();\n\t\t\t\tcontext.lineWidth = glWidth;\n\t\t\t\tcontext.strokeStyle = glColor;\n\t\t\t\tif (context.setLineDash) {\n\t\t\t\t\tcontext.setLineDash(itemToDraw.glBorderDash);\n\t\t\t\t\tcontext.lineDashOffset = itemToDraw.glBorderDashOffset;\n\t\t\t\t}\n\n\t\t\t\tcontext.beginPath();\n\n\t\t\t\tif (gridLines.drawTicks) {\n\t\t\t\t\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n\t\t\t\t\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n\t\t\t\t}\n\n\t\t\t\tif (gridLines.drawOnChartArea) {\n\t\t\t\t\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);\n\t\t\t\t\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);\n\t\t\t\t}\n\n\t\t\t\tcontext.stroke();\n\t\t\t\tcontext.restore();\n\t\t\t}\n\n\t\t\tif (optionTicks.display) {\n\t\t\t\t// Make sure we draw text in the correct color and font\n\t\t\t\tcontext.save();\n\t\t\t\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);\n\t\t\t\tcontext.rotate(itemToDraw.rotation);\n\t\t\t\tcontext.font = itemToDraw.major ? majorTickFont.string : tickFont.string;\n\t\t\t\tcontext.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;\n\t\t\t\tcontext.textBaseline = 'middle';\n\t\t\t\tcontext.textAlign = itemToDraw.textAlign;\n\n\t\t\t\tvar label = itemToDraw.label;\n\t\t\t\tvar y = itemToDraw.textOffset;\n\t\t\t\tif (helpers$1.isArray(label)) {\n\t\t\t\t\tfor (var i = 0; i < label.length; ++i) {\n\t\t\t\t\t\t// We just make sure the multiline element is a string here..\n\t\t\t\t\t\tcontext.fillText('' + label[i], 0, y);\n\t\t\t\t\t\ty += lineHeight;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontext.fillText(label, 0, y);\n\t\t\t\t}\n\t\t\t\tcontext.restore();\n\t\t\t}\n\t\t});\n\n\t\tif (scaleLabel.display) {\n\t\t\t// Draw the scale label\n\t\t\tvar scaleLabelX;\n\t\t\tvar scaleLabelY;\n\t\t\tvar rotation = 0;\n\t\t\tvar halfLineHeight = scaleLabelFont.lineHeight / 2;\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tscaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\n\t\t\t\tscaleLabelY = position === 'bottom'\n\t\t\t\t\t? me.bottom - halfLineHeight - scaleLabelPadding.bottom\n\t\t\t\t\t: me.top + halfLineHeight + scaleLabelPadding.top;\n\t\t\t} else {\n\t\t\t\tvar isLeft = position === 'left';\n\t\t\t\tscaleLabelX = isLeft\n\t\t\t\t\t? me.left + halfLineHeight + scaleLabelPadding.top\n\t\t\t\t\t: me.right - halfLineHeight - scaleLabelPadding.top;\n\t\t\t\tscaleLabelY = me.top + ((me.bottom - me.top) / 2);\n\t\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n\t\t\t}\n\n\t\t\tcontext.save();\n\t\t\tcontext.translate(scaleLabelX, scaleLabelY);\n\t\t\tcontext.rotate(rotation);\n\t\t\tcontext.textAlign = 'center';\n\t\t\tcontext.textBaseline = 'middle';\n\t\t\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour\n\t\t\tcontext.font = scaleLabelFont.string;\n\t\t\tcontext.fillText(scaleLabel.labelString, 0, 0);\n\t\t\tcontext.restore();\n\t\t}\n\n\t\tif (axisWidth) {\n\t\t\t// Draw the line at the edge of the axis\n\t\t\tvar firstLineWidth = axisWidth;\n\t\t\tvar lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, ticks.length - 1, 0);\n\t\t\tvar x1, x2, y1, y2;\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tx1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;\n\t\t\t\tx2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;\n\t\t\t\ty1 = y2 = borderValue;\n\t\t\t} else {\n\t\t\t\ty1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;\n\t\t\t\ty2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;\n\t\t\t\tx1 = x2 = borderValue;\n\t\t\t}\n\n\t\t\tcontext.lineWidth = axisWidth;\n\t\t\tcontext.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);\n\t\t\tcontext.beginPath();\n\t\t\tcontext.moveTo(x1, y1);\n\t\t\tcontext.lineTo(x2, y2);\n\t\t\tcontext.stroke();\n\t\t}\n\t}\n});\n\nvar defaultConfig = {\n\tposition: 'bottom'\n};\n\nvar scale_category = core_scale.extend({\n\t/**\n\t* Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those\n\t* else fall back to data.labels\n\t* @private\n\t*/\n\tgetLabels: function() {\n\t\tvar data = this.chart.data;\n\t\treturn this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;\n\t},\n\n\tdetermineDataLimits: function() {\n\t\tvar me = this;\n\t\tvar labels = me.getLabels();\n\t\tme.minIndex = 0;\n\t\tme.maxIndex = labels.length - 1;\n\t\tvar findIndex;\n\n\t\tif (me.options.ticks.min !== undefined) {\n\t\t\t// user specified min value\n\t\t\tfindIndex = labels.indexOf(me.options.ticks.min);\n\t\t\tme.minIndex = findIndex !== -1 ? findIndex : me.minIndex;\n\t\t}\n\n\t\tif (me.options.ticks.max !== undefined) {\n\t\t\t// user specified max value\n\t\t\tfindIndex = labels.indexOf(me.options.ticks.max);\n\t\t\tme.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;\n\t\t}\n\n\t\tme.min = labels[me.minIndex];\n\t\tme.max = labels[me.maxIndex];\n\t},\n\n\tbuildTicks: function() {\n\t\tvar me = this;\n\t\tvar labels = me.getLabels();\n\t\t// If we are viewing some subset of labels, slice the original array\n\t\tme.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);\n\t},\n\n\tgetLabelForIndex: function(index, datasetIndex) {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\n\t\tif (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {\n\t\t\treturn me.getRightValue(chart.data.datasets[datasetIndex].data[index]);\n\t\t}\n\n\t\treturn me.ticks[index - me.minIndex];\n\t},\n\n\t// Used to get data value locations.  Value can either be an index or a numerical value\n\tgetPixelForValue: function(value, index) {\n\t\tvar me = this;\n\t\tvar offset = me.options.offset;\n\t\t// 1 is added because we need the length but we have the indexes\n\t\tvar offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);\n\n\t\t// If value is a data object, then index is the index in the data array,\n\t\t// not the index of the scale. We need to change that.\n\t\tvar valueCategory;\n\t\tif (value !== undefined && value !== null) {\n\t\t\tvalueCategory = me.isHorizontal() ? value.x : value.y;\n\t\t}\n\t\tif (valueCategory !== undefined || (value !== undefined && isNaN(index))) {\n\t\t\tvar labels = me.getLabels();\n\t\t\tvalue = valueCategory || value;\n\t\t\tvar idx = labels.indexOf(value);\n\t\t\tindex = idx !== -1 ? idx : index;\n\t\t}\n\n\t\tif (me.isHorizontal()) {\n\t\t\tvar valueWidth = me.width / offsetAmt;\n\t\t\tvar widthOffset = (valueWidth * (index - me.minIndex));\n\n\t\t\tif (offset) {\n\t\t\t\twidthOffset += (valueWidth / 2);\n\t\t\t}\n\n\t\t\treturn me.left + widthOffset;\n\t\t}\n\t\tvar valueHeight = me.height / offsetAmt;\n\t\tvar heightOffset = (valueHeight * (index - me.minIndex));\n\n\t\tif (offset) {\n\t\t\theightOffset += (valueHeight / 2);\n\t\t}\n\n\t\treturn me.top + heightOffset;\n\t},\n\n\tgetPixelForTick: function(index) {\n\t\treturn this.getPixelForValue(this.ticks[index], index + this.minIndex, null);\n\t},\n\n\tgetValueForPixel: function(pixel) {\n\t\tvar me = this;\n\t\tvar offset = me.options.offset;\n\t\tvar value;\n\t\tvar offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n\t\tvar horz = me.isHorizontal();\n\t\tvar valueDimension = (horz ? me.width : me.height) / offsetAmt;\n\n\t\tpixel -= horz ? me.left : me.top;\n\n\t\tif (offset) {\n\t\t\tpixel -= (valueDimension / 2);\n\t\t}\n\n\t\tif (pixel <= 0) {\n\t\t\tvalue = 0;\n\t\t} else {\n\t\t\tvalue = Math.round(pixel / valueDimension);\n\t\t}\n\n\t\treturn value + me.minIndex;\n\t},\n\n\tgetBasePixel: function() {\n\t\treturn this.bottom;\n\t}\n});\n\n// INTERNAL: static default options, registered in src/index.js\nvar _defaults = defaultConfig;\nscale_category._defaults = _defaults;\n\nvar noop = helpers$1.noop;\nvar isNullOrUndef = helpers$1.isNullOrUndef;\n\n/**\n * Generate a set of linear ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {number[]} array of tick values\n */\nfunction generateTicks(generationOptions, dataRange) {\n\tvar ticks = [];\n\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\n\t// \"nice number\" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n\t// for details.\n\n\tvar MIN_SPACING = 1e-14;\n\tvar stepSize = generationOptions.stepSize;\n\tvar unit = stepSize || 1;\n\tvar maxNumSpaces = generationOptions.maxTicks - 1;\n\tvar min = generationOptions.min;\n\tvar max = generationOptions.max;\n\tvar precision = generationOptions.precision;\n\tvar rmin = dataRange.min;\n\tvar rmax = dataRange.max;\n\tvar spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;\n\tvar factor, niceMin, niceMax, numSpaces;\n\n\t// Beyond MIN_SPACING floating point numbers being to lose precision\n\t// such that we can't do the math necessary to generate ticks\n\tif (spacing < MIN_SPACING && isNullOrUndef(min) && isNullOrUndef(max)) {\n\t\treturn [rmin, rmax];\n\t}\n\n\tnumSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n\tif (numSpaces > maxNumSpaces) {\n\t\t// If the calculated num of spaces exceeds maxNumSpaces, recalculate it\n\t\tspacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;\n\t}\n\n\tif (stepSize || isNullOrUndef(precision)) {\n\t\t// If a precision is not specified, calculate factor based on spacing\n\t\tfactor = Math.pow(10, helpers$1._decimalPlaces(spacing));\n\t} else {\n\t\t// If the user specified a precision, round to that number of decimal places\n\t\tfactor = Math.pow(10, precision);\n\t\tspacing = Math.ceil(spacing * factor) / factor;\n\t}\n\n\tniceMin = Math.floor(rmin / spacing) * spacing;\n\tniceMax = Math.ceil(rmax / spacing) * spacing;\n\n\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\n\tif (stepSize) {\n\t\t// If very close to our whole number, use it.\n\t\tif (!isNullOrUndef(min) && helpers$1.almostWhole(min / spacing, spacing / 1000)) {\n\t\t\tniceMin = min;\n\t\t}\n\t\tif (!isNullOrUndef(max) && helpers$1.almostWhole(max / spacing, spacing / 1000)) {\n\t\t\tniceMax = max;\n\t\t}\n\t}\n\n\tnumSpaces = (niceMax - niceMin) / spacing;\n\t// If very close to our rounded value, use it.\n\tif (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\tnumSpaces = Math.round(numSpaces);\n\t} else {\n\t\tnumSpaces = Math.ceil(numSpaces);\n\t}\n\n\tniceMin = Math.round(niceMin * factor) / factor;\n\tniceMax = Math.round(niceMax * factor) / factor;\n\tticks.push(isNullOrUndef(min) ? niceMin : min);\n\tfor (var j = 1; j < numSpaces; ++j) {\n\t\tticks.push(Math.round((niceMin + j * spacing) * factor) / factor);\n\t}\n\tticks.push(isNullOrUndef(max) ? niceMax : max);\n\n\treturn ticks;\n}\n\nvar scale_linearbase = core_scale.extend({\n\tgetRightValue: function(value) {\n\t\tif (typeof value === 'string') {\n\t\t\treturn +value;\n\t\t}\n\t\treturn core_scale.prototype.getRightValue.call(this, value);\n\t},\n\n\thandleTickRangeOptions: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar tickOpts = opts.ticks;\n\n\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart\n\t\t// axis, they can manually override it\n\t\tif (tickOpts.beginAtZero) {\n\t\t\tvar minSign = helpers$1.sign(me.min);\n\t\t\tvar maxSign = helpers$1.sign(me.max);\n\n\t\t\tif (minSign < 0 && maxSign < 0) {\n\t\t\t\t// move the top up to 0\n\t\t\t\tme.max = 0;\n\t\t\t} else if (minSign > 0 && maxSign > 0) {\n\t\t\t\t// move the bottom down to 0\n\t\t\t\tme.min = 0;\n\t\t\t}\n\t\t}\n\n\t\tvar setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\n\t\tvar setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\n\n\t\tif (tickOpts.min !== undefined) {\n\t\t\tme.min = tickOpts.min;\n\t\t} else if (tickOpts.suggestedMin !== undefined) {\n\t\t\tif (me.min === null) {\n\t\t\t\tme.min = tickOpts.suggestedMin;\n\t\t\t} else {\n\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\n\t\t\t}\n\t\t}\n\n\t\tif (tickOpts.max !== undefined) {\n\t\t\tme.max = tickOpts.max;\n\t\t} else if (tickOpts.suggestedMax !== undefined) {\n\t\t\tif (me.max === null) {\n\t\t\t\tme.max = tickOpts.suggestedMax;\n\t\t\t} else {\n\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);\n\t\t\t}\n\t\t}\n\n\t\tif (setMin !== setMax) {\n\t\t\t// We set the min or the max but not both.\n\t\t\t// So ensure that our range is good\n\t\t\t// Inverted or 0 length range can happen when\n\t\t\t// ticks.min is set, and no datasets are visible\n\t\t\tif (me.min >= me.max) {\n\t\t\t\tif (setMin) {\n\t\t\t\t\tme.max = me.min + 1;\n\t\t\t\t} else {\n\t\t\t\t\tme.min = me.max - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (me.min === me.max) {\n\t\t\tme.max++;\n\n\t\t\tif (!tickOpts.beginAtZero) {\n\t\t\t\tme.min--;\n\t\t\t}\n\t\t}\n\t},\n\n\tgetTickLimit: function() {\n\t\tvar me = this;\n\t\tvar tickOpts = me.options.ticks;\n\t\tvar stepSize = tickOpts.stepSize;\n\t\tvar maxTicksLimit = tickOpts.maxTicksLimit;\n\t\tvar maxTicks;\n\n\t\tif (stepSize) {\n\t\t\tmaxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;\n\t\t} else {\n\t\t\tmaxTicks = me._computeTickLimit();\n\t\t\tmaxTicksLimit = maxTicksLimit || 11;\n\t\t}\n\n\t\tif (maxTicksLimit) {\n\t\t\tmaxTicks = Math.min(maxTicksLimit, maxTicks);\n\t\t}\n\n\t\treturn maxTicks;\n\t},\n\n\t_computeTickLimit: function() {\n\t\treturn Number.POSITIVE_INFINITY;\n\t},\n\n\thandleDirectionalChanges: noop,\n\n\tbuildTicks: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar tickOpts = opts.ticks;\n\n\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 40\n\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t// the graph. Make sure we always have at least 2 ticks\n\t\tvar maxTicks = me.getTickLimit();\n\t\tmaxTicks = Math.max(2, maxTicks);\n\n\t\tvar numericGeneratorOptions = {\n\t\t\tmaxTicks: maxTicks,\n\t\t\tmin: tickOpts.min,\n\t\t\tmax: tickOpts.max,\n\t\t\tprecision: tickOpts.precision,\n\t\t\tstepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n\t\t};\n\t\tvar ticks = me.ticks = generateTicks(numericGeneratorOptions, me);\n\n\t\tme.handleDirectionalChanges();\n\n\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t// range of the scale\n\t\tme.max = helpers$1.max(ticks);\n\t\tme.min = helpers$1.min(ticks);\n\n\t\tif (tickOpts.reverse) {\n\t\t\tticks.reverse();\n\n\t\t\tme.start = me.max;\n\t\t\tme.end = me.min;\n\t\t} else {\n\t\t\tme.start = me.min;\n\t\t\tme.end = me.max;\n\t\t}\n\t},\n\n\tconvertTicksToLabels: function() {\n\t\tvar me = this;\n\t\tme.ticksAsNumbers = me.ticks.slice();\n\t\tme.zeroLineIndex = me.ticks.indexOf(0);\n\n\t\tcore_scale.prototype.convertTicksToLabels.call(me);\n\t}\n});\n\nvar defaultConfig$1 = {\n\tposition: 'left',\n\tticks: {\n\t\tcallback: core_ticks.formatters.linear\n\t}\n};\n\nvar scale_linear = scale_linearbase.extend({\n\tdetermineDataLimits: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar chart = me.chart;\n\t\tvar data = chart.data;\n\t\tvar datasets = data.datasets;\n\t\tvar isHorizontal = me.isHorizontal();\n\t\tvar DEFAULT_MIN = 0;\n\t\tvar DEFAULT_MAX = 1;\n\n\t\tfunction IDMatches(meta) {\n\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t}\n\n\t\t// First Calculate the range\n\t\tme.min = null;\n\t\tme.max = null;\n\n\t\tvar hasStacks = opts.stacked;\n\t\tif (hasStacks === undefined) {\n\t\t\thelpers$1.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\tif (hasStacks) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\thasStacks = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (opts.stacked || hasStacks) {\n\t\t\tvar valuesPerStack = {};\n\n\t\t\thelpers$1.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\tvar key = [\n\t\t\t\t\tmeta.type,\n\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\tmeta.stack\n\t\t\t\t].join('.');\n\n\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\tvaluesPerStack[key] = {\n\t\t\t\t\t\tpositiveValues: [],\n\t\t\t\t\t\tnegativeValues: []\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Store these per type\n\t\t\t\tvar positiveValues = valuesPerStack[key].positiveValues;\n\t\t\t\tvar negativeValues = valuesPerStack[key].negativeValues;\n\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\thelpers$1.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpositiveValues[index] = positiveValues[index] || 0;\n\t\t\t\t\t\tnegativeValues[index] = negativeValues[index] || 0;\n\n\t\t\t\t\t\tif (opts.relativePoints) {\n\t\t\t\t\t\t\tpositiveValues[index] = 100;\n\t\t\t\t\t\t} else if (value < 0) {\n\t\t\t\t\t\t\tnegativeValues[index] += value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpositiveValues[index] += value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\thelpers$1.each(valuesPerStack, function(valuesForType) {\n\t\t\t\tvar values = valuesForType.positiveValues.concat(valuesForType.negativeValues);\n\t\t\t\tvar minVal = helpers$1.min(values);\n\t\t\t\tvar maxVal = helpers$1.max(values);\n\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t});\n\n\t\t} else {\n\t\t\thelpers$1.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\thelpers$1.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tme.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;\n\t\tme.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;\n\n\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\tthis.handleTickRangeOptions();\n\t},\n\n\t// Returns the maximum number of ticks based on the scale dimension\n\t_computeTickLimit: function() {\n\t\tvar me = this;\n\t\tvar tickFont;\n\n\t\tif (me.isHorizontal()) {\n\t\t\treturn Math.ceil(me.width / 40);\n\t\t}\n\t\ttickFont = helpers$1.options._parseFont(me.options.ticks);\n\t\treturn Math.ceil(me.height / tickFont.lineHeight);\n\t},\n\n\t// Called after the ticks are built. We need\n\thandleDirectionalChanges: function() {\n\t\tif (!this.isHorizontal()) {\n\t\t\t// We are in a vertical orientation. The top value is the highest. So reverse the array\n\t\t\tthis.ticks.reverse();\n\t\t}\n\t},\n\n\tgetLabelForIndex: function(index, datasetIndex) {\n\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t},\n\n\t// Utils\n\tgetPixelForValue: function(value) {\n\t\t// This must be called after fit has been run so that\n\t\t// this.left, this.top, this.right, and this.bottom have been defined\n\t\tvar me = this;\n\t\tvar start = me.start;\n\n\t\tvar rightValue = +me.getRightValue(value);\n\t\tvar pixel;\n\t\tvar range = me.end - start;\n\n\t\tif (me.isHorizontal()) {\n\t\t\tpixel = me.left + (me.width / range * (rightValue - start));\n\t\t} else {\n\t\t\tpixel = me.bottom - (me.height / range * (rightValue - start));\n\t\t}\n\t\treturn pixel;\n\t},\n\n\tgetValueForPixel: function(pixel) {\n\t\tvar me = this;\n\t\tvar isHorizontal = me.isHorizontal();\n\t\tvar innerDimension = isHorizontal ? me.width : me.height;\n\t\tvar offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;\n\t\treturn me.start + ((me.end - me.start) * offset);\n\t},\n\n\tgetPixelForTick: function(index) {\n\t\treturn this.getPixelForValue(this.ticksAsNumbers[index]);\n\t}\n});\n\n// INTERNAL: static default options, registered in src/index.js\nvar _defaults$1 = defaultConfig$1;\nscale_linear._defaults = _defaults$1;\n\nvar valueOrDefault$a = helpers$1.valueOrDefault;\n\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {number[]} array of tick values\n */\nfunction generateTicks$1(generationOptions, dataRange) {\n\tvar ticks = [];\n\n\tvar tickVal = valueOrDefault$a(generationOptions.min, Math.pow(10, Math.floor(helpers$1.log10(dataRange.min))));\n\n\tvar endExp = Math.floor(helpers$1.log10(dataRange.max));\n\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n\tvar exp, significand;\n\n\tif (tickVal === 0) {\n\t\texp = Math.floor(helpers$1.log10(dataRange.minNotZero));\n\t\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n\n\t\tticks.push(tickVal);\n\t\ttickVal = significand * Math.pow(10, exp);\n\t} else {\n\t\texp = Math.floor(helpers$1.log10(tickVal));\n\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\n\t}\n\tvar precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n\n\tdo {\n\t\tticks.push(tickVal);\n\n\t\t++significand;\n\t\tif (significand === 10) {\n\t\t\tsignificand = 1;\n\t\t\t++exp;\n\t\t\tprecision = exp >= 0 ? 1 : precision;\n\t\t}\n\n\t\ttickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\n\n\tvar lastTick = valueOrDefault$a(generationOptions.max, tickVal);\n\tticks.push(lastTick);\n\n\treturn ticks;\n}\n\nvar defaultConfig$2 = {\n\tposition: 'left',\n\n\t// label settings\n\tticks: {\n\t\tcallback: core_ticks.formatters.logarithmic\n\t}\n};\n\n// TODO(v3): change this to positiveOrDefault\nfunction nonNegativeOrDefault(value, defaultValue) {\n\treturn helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;\n}\n\nvar scale_logarithmic = core_scale.extend({\n\tdetermineDataLimits: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar chart = me.chart;\n\t\tvar data = chart.data;\n\t\tvar datasets = data.datasets;\n\t\tvar isHorizontal = me.isHorizontal();\n\t\tfunction IDMatches(meta) {\n\t\t\treturn isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;\n\t\t}\n\n\t\t// Calculate Range\n\t\tme.min = null;\n\t\tme.max = null;\n\t\tme.minNotZero = null;\n\n\t\tvar hasStacks = opts.stacked;\n\t\tif (hasStacks === undefined) {\n\t\t\thelpers$1.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\tif (hasStacks) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&\n\t\t\t\t\tmeta.stack !== undefined) {\n\t\t\t\t\thasStacks = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (opts.stacked || hasStacks) {\n\t\t\tvar valuesPerStack = {};\n\n\t\t\thelpers$1.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\tvar key = [\n\t\t\t\t\tmeta.type,\n\t\t\t\t\t// we have a separate stack for stack=undefined datasets when the opts.stacked is undefined\n\t\t\t\t\t((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),\n\t\t\t\t\tmeta.stack\n\t\t\t\t].join('.');\n\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\tif (valuesPerStack[key] === undefined) {\n\t\t\t\t\t\tvaluesPerStack[key] = [];\n\t\t\t\t\t}\n\n\t\t\t\t\thelpers$1.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\tvar values = valuesPerStack[key];\n\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t// invalid, hidden and negative values are ignored\n\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalues[index] = values[index] || 0;\n\t\t\t\t\t\tvalues[index] += value;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\thelpers$1.each(valuesPerStack, function(valuesForType) {\n\t\t\t\tif (valuesForType.length > 0) {\n\t\t\t\t\tvar minVal = helpers$1.min(valuesForType);\n\t\t\t\t\tvar maxVal = helpers$1.max(valuesForType);\n\t\t\t\t\tme.min = me.min === null ? minVal : Math.min(me.min, minVal);\n\t\t\t\t\tme.max = me.max === null ? maxVal : Math.max(me.max, maxVal);\n\t\t\t\t}\n\t\t\t});\n\n\t\t} else {\n\t\t\thelpers$1.each(datasets, function(dataset, datasetIndex) {\n\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\t\t\t\tif (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {\n\t\t\t\t\thelpers$1.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\t\t// invalid, hidden and negative values are ignored\n\t\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden || value < 0) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (me.min === null) {\n\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t} else if (value < me.min) {\n\t\t\t\t\t\t\tme.min = value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (me.max === null) {\n\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t} else if (value > me.max) {\n\t\t\t\t\t\t\tme.max = value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {\n\t\t\t\t\t\t\tme.minNotZero = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Common base implementation to handle ticks.min, ticks.max\n\t\tthis.handleTickRangeOptions();\n\t},\n\n\thandleTickRangeOptions: function() {\n\t\tvar me = this;\n\t\tvar tickOpts = me.options.ticks;\n\t\tvar DEFAULT_MIN = 1;\n\t\tvar DEFAULT_MAX = 10;\n\n\t\tme.min = nonNegativeOrDefault(tickOpts.min, me.min);\n\t\tme.max = nonNegativeOrDefault(tickOpts.max, me.max);\n\n\t\tif (me.min === me.max) {\n\t\t\tif (me.min !== 0 && me.min !== null) {\n\t\t\t\tme.min = Math.pow(10, Math.floor(helpers$1.log10(me.min)) - 1);\n\t\t\t\tme.max = Math.pow(10, Math.floor(helpers$1.log10(me.max)) + 1);\n\t\t\t} else {\n\t\t\t\tme.min = DEFAULT_MIN;\n\t\t\t\tme.max = DEFAULT_MAX;\n\t\t\t}\n\t\t}\n\t\tif (me.min === null) {\n\t\t\tme.min = Math.pow(10, Math.floor(helpers$1.log10(me.max)) - 1);\n\t\t}\n\t\tif (me.max === null) {\n\t\t\tme.max = me.min !== 0\n\t\t\t\t? Math.pow(10, Math.floor(helpers$1.log10(me.min)) + 1)\n\t\t\t\t: DEFAULT_MAX;\n\t\t}\n\t\tif (me.minNotZero === null) {\n\t\t\tif (me.min > 0) {\n\t\t\t\tme.minNotZero = me.min;\n\t\t\t} else if (me.max < 1) {\n\t\t\t\tme.minNotZero = Math.pow(10, Math.floor(helpers$1.log10(me.max)));\n\t\t\t} else {\n\t\t\t\tme.minNotZero = DEFAULT_MIN;\n\t\t\t}\n\t\t}\n\t},\n\n\tbuildTicks: function() {\n\t\tvar me = this;\n\t\tvar tickOpts = me.options.ticks;\n\t\tvar reverse = !me.isHorizontal();\n\n\t\tvar generationOptions = {\n\t\t\tmin: nonNegativeOrDefault(tickOpts.min),\n\t\t\tmax: nonNegativeOrDefault(tickOpts.max)\n\t\t};\n\t\tvar ticks = me.ticks = generateTicks$1(generationOptions, me);\n\n\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t// range of the scale\n\t\tme.max = helpers$1.max(ticks);\n\t\tme.min = helpers$1.min(ticks);\n\n\t\tif (tickOpts.reverse) {\n\t\t\treverse = !reverse;\n\t\t\tme.start = me.max;\n\t\t\tme.end = me.min;\n\t\t} else {\n\t\t\tme.start = me.min;\n\t\t\tme.end = me.max;\n\t\t}\n\t\tif (reverse) {\n\t\t\tticks.reverse();\n\t\t}\n\t},\n\n\tconvertTicksToLabels: function() {\n\t\tthis.tickValues = this.ticks.slice();\n\n\t\tcore_scale.prototype.convertTicksToLabels.call(this);\n\t},\n\n\t// Get the correct tooltip label\n\tgetLabelForIndex: function(index, datasetIndex) {\n\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t},\n\n\tgetPixelForTick: function(index) {\n\t\treturn this.getPixelForValue(this.tickValues[index]);\n\t},\n\n\t/**\n\t * Returns the value of the first tick.\n\t * @param {number} value - The minimum not zero value.\n\t * @return {number} The first tick value.\n\t * @private\n\t */\n\t_getFirstTickValue: function(value) {\n\t\tvar exp = Math.floor(helpers$1.log10(value));\n\t\tvar significand = Math.floor(value / Math.pow(10, exp));\n\n\t\treturn significand * Math.pow(10, exp);\n\t},\n\n\tgetPixelForValue: function(value) {\n\t\tvar me = this;\n\t\tvar tickOpts = me.options.ticks;\n\t\tvar reverse = tickOpts.reverse;\n\t\tvar log10 = helpers$1.log10;\n\t\tvar firstTickValue = me._getFirstTickValue(me.minNotZero);\n\t\tvar offset = 0;\n\t\tvar innerDimension, pixel, start, end, sign;\n\n\t\tvalue = +me.getRightValue(value);\n\t\tif (reverse) {\n\t\t\tstart = me.end;\n\t\t\tend = me.start;\n\t\t\tsign = -1;\n\t\t} else {\n\t\t\tstart = me.start;\n\t\t\tend = me.end;\n\t\t\tsign = 1;\n\t\t}\n\t\tif (me.isHorizontal()) {\n\t\t\tinnerDimension = me.width;\n\t\t\tpixel = reverse ? me.right : me.left;\n\t\t} else {\n\t\t\tinnerDimension = me.height;\n\t\t\tsign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)\n\t\t\tpixel = reverse ? me.top : me.bottom;\n\t\t}\n\t\tif (value !== start) {\n\t\t\tif (start === 0) { // include zero tick\n\t\t\t\toffset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);\n\t\t\t\tinnerDimension -= offset;\n\t\t\t\tstart = firstTickValue;\n\t\t\t}\n\t\t\tif (value !== 0) {\n\t\t\t\toffset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));\n\t\t\t}\n\t\t\tpixel += sign * offset;\n\t\t}\n\t\treturn pixel;\n\t},\n\n\tgetValueForPixel: function(pixel) {\n\t\tvar me = this;\n\t\tvar tickOpts = me.options.ticks;\n\t\tvar reverse = tickOpts.reverse;\n\t\tvar log10 = helpers$1.log10;\n\t\tvar firstTickValue = me._getFirstTickValue(me.minNotZero);\n\t\tvar innerDimension, start, end, value;\n\n\t\tif (reverse) {\n\t\t\tstart = me.end;\n\t\t\tend = me.start;\n\t\t} else {\n\t\t\tstart = me.start;\n\t\t\tend = me.end;\n\t\t}\n\t\tif (me.isHorizontal()) {\n\t\t\tinnerDimension = me.width;\n\t\t\tvalue = reverse ? me.right - pixel : pixel - me.left;\n\t\t} else {\n\t\t\tinnerDimension = me.height;\n\t\t\tvalue = reverse ? pixel - me.top : me.bottom - pixel;\n\t\t}\n\t\tif (value !== start) {\n\t\t\tif (start === 0) { // include zero tick\n\t\t\t\tvar offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);\n\t\t\t\tvalue -= offset;\n\t\t\t\tinnerDimension -= offset;\n\t\t\t\tstart = firstTickValue;\n\t\t\t}\n\t\t\tvalue *= log10(end) - log10(start);\n\t\t\tvalue /= innerDimension;\n\t\t\tvalue = Math.pow(10, log10(start) + value);\n\t\t}\n\t\treturn value;\n\t}\n});\n\n// INTERNAL: static default options, registered in src/index.js\nvar _defaults$2 = defaultConfig$2;\nscale_logarithmic._defaults = _defaults$2;\n\nvar valueOrDefault$b = helpers$1.valueOrDefault;\nvar valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;\nvar resolve$7 = helpers$1.options.resolve;\n\nvar defaultConfig$3 = {\n\tdisplay: true,\n\n\t// Boolean - Whether to animate scaling the chart from the centre\n\tanimate: true,\n\tposition: 'chartArea',\n\n\tangleLines: {\n\t\tdisplay: true,\n\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\tlineWidth: 1,\n\t\tborderDash: [],\n\t\tborderDashOffset: 0.0\n\t},\n\n\tgridLines: {\n\t\tcircular: false\n\t},\n\n\t// label settings\n\tticks: {\n\t\t// Boolean - Show a backdrop to the scale label\n\t\tshowLabelBackdrop: true,\n\n\t\t// String - The colour of the label backdrop\n\t\tbackdropColor: 'rgba(255,255,255,0.75)',\n\n\t\t// Number - The backdrop padding above & below the label in pixels\n\t\tbackdropPaddingY: 2,\n\n\t\t// Number - The backdrop padding to the side of the label in pixels\n\t\tbackdropPaddingX: 2,\n\n\t\tcallback: core_ticks.formatters.linear\n\t},\n\n\tpointLabels: {\n\t\t// Boolean - if true, show point labels\n\t\tdisplay: true,\n\n\t\t// Number - Point label font size in pixels\n\t\tfontSize: 10,\n\n\t\t// Function - Used to convert point labels\n\t\tcallback: function(label) {\n\t\t\treturn label;\n\t\t}\n\t}\n};\n\nfunction getValueCount(scale) {\n\tvar opts = scale.options;\n\treturn opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;\n}\n\nfunction getTickBackdropHeight(opts) {\n\tvar tickOpts = opts.ticks;\n\n\tif (tickOpts.display && opts.display) {\n\t\treturn valueOrDefault$b(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;\n\t}\n\treturn 0;\n}\n\nfunction measureLabelSize(ctx, lineHeight, label) {\n\tif (helpers$1.isArray(label)) {\n\t\treturn {\n\t\t\tw: helpers$1.longestText(ctx, ctx.font, label),\n\t\t\th: label.length * lineHeight\n\t\t};\n\t}\n\n\treturn {\n\t\tw: ctx.measureText(label).width,\n\t\th: lineHeight\n\t};\n}\n\nfunction determineLimits(angle, pos, size, min, max) {\n\tif (angle === min || angle === max) {\n\t\treturn {\n\t\t\tstart: pos - (size / 2),\n\t\t\tend: pos + (size / 2)\n\t\t};\n\t} else if (angle < min || angle > max) {\n\t\treturn {\n\t\t\tstart: pos - size,\n\t\t\tend: pos\n\t\t};\n\t}\n\n\treturn {\n\t\tstart: pos,\n\t\tend: pos + size\n\t};\n}\n\n/**\n * Helper function to fit a radial linear scale with point labels\n */\nfunction fitWithPointLabels(scale) {\n\n\t// Right, this is really confusing and there is a lot of maths going on here\n\t// The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n\t//\n\t// Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n\t//\n\t// Solution:\n\t//\n\t// We assume the radius of the polygon is half the size of the canvas at first\n\t// at each index we check if the text overlaps.\n\t//\n\t// Where it does, we store that angle and that index.\n\t//\n\t// After finding the largest index and angle we calculate how much we need to remove\n\t// from the shape radius to move the point inwards by that x.\n\t//\n\t// We average the left and right distances to get the maximum shape radius that can fit in the box\n\t// along with labels.\n\t//\n\t// Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n\t// on each side, removing that from the size, halving it and adding the left x protrusion width.\n\t//\n\t// This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n\t// and position it in the most space efficient manner\n\t//\n\t// https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\n\tvar plFont = helpers$1.options._parseFont(scale.options.pointLabels);\n\n\t// Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n\t// Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n\tvar furthestLimits = {\n\t\tl: 0,\n\t\tr: scale.width,\n\t\tt: 0,\n\t\tb: scale.height - scale.paddingTop\n\t};\n\tvar furthestAngles = {};\n\tvar i, textSize, pointPosition;\n\n\tscale.ctx.font = plFont.string;\n\tscale._pointLabelSizes = [];\n\n\tvar valueCount = getValueCount(scale);\n\tfor (i = 0; i < valueCount; i++) {\n\t\tpointPosition = scale.getPointPosition(i, scale.drawingArea + 5);\n\t\ttextSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');\n\t\tscale._pointLabelSizes[i] = textSize;\n\n\t\t// Add quarter circle to make degree 0 mean top of circle\n\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\tvar angle = helpers$1.toDegrees(angleRadians) % 360;\n\t\tvar hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n\t\tvar vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n\n\t\tif (hLimits.start < furthestLimits.l) {\n\t\t\tfurthestLimits.l = hLimits.start;\n\t\t\tfurthestAngles.l = angleRadians;\n\t\t}\n\n\t\tif (hLimits.end > furthestLimits.r) {\n\t\t\tfurthestLimits.r = hLimits.end;\n\t\t\tfurthestAngles.r = angleRadians;\n\t\t}\n\n\t\tif (vLimits.start < furthestLimits.t) {\n\t\t\tfurthestLimits.t = vLimits.start;\n\t\t\tfurthestAngles.t = angleRadians;\n\t\t}\n\n\t\tif (vLimits.end > furthestLimits.b) {\n\t\t\tfurthestLimits.b = vLimits.end;\n\t\t\tfurthestAngles.b = angleRadians;\n\t\t}\n\t}\n\n\tscale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);\n}\n\nfunction getTextAlignForAngle(angle) {\n\tif (angle === 0 || angle === 180) {\n\t\treturn 'center';\n\t} else if (angle < 180) {\n\t\treturn 'left';\n\t}\n\n\treturn 'right';\n}\n\nfunction fillText(ctx, text, position, lineHeight) {\n\tvar y = position.y + lineHeight / 2;\n\tvar i, ilen;\n\n\tif (helpers$1.isArray(text)) {\n\t\tfor (i = 0, ilen = text.length; i < ilen; ++i) {\n\t\t\tctx.fillText(text[i], position.x, y);\n\t\t\ty += lineHeight;\n\t\t}\n\t} else {\n\t\tctx.fillText(text, position.x, y);\n\t}\n}\n\nfunction adjustPointPositionForLabelHeight(angle, textSize, position) {\n\tif (angle === 90 || angle === 270) {\n\t\tposition.y -= (textSize.h / 2);\n\t} else if (angle > 270 || angle < 90) {\n\t\tposition.y -= textSize.h;\n\t}\n}\n\nfunction drawPointLabels(scale) {\n\tvar ctx = scale.ctx;\n\tvar opts = scale.options;\n\tvar angleLineOpts = opts.angleLines;\n\tvar gridLineOpts = opts.gridLines;\n\tvar pointLabelOpts = opts.pointLabels;\n\tvar lineWidth = valueOrDefault$b(angleLineOpts.lineWidth, gridLineOpts.lineWidth);\n\tvar lineColor = valueOrDefault$b(angleLineOpts.color, gridLineOpts.color);\n\tvar tickBackdropHeight = getTickBackdropHeight(opts);\n\n\tctx.save();\n\tctx.lineWidth = lineWidth;\n\tctx.strokeStyle = lineColor;\n\tif (ctx.setLineDash) {\n\t\tctx.setLineDash(resolve$7([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));\n\t\tctx.lineDashOffset = resolve$7([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0]);\n\t}\n\n\tvar outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);\n\n\t// Point Label Font\n\tvar plFont = helpers$1.options._parseFont(pointLabelOpts);\n\n\tctx.font = plFont.string;\n\tctx.textBaseline = 'middle';\n\n\tfor (var i = getValueCount(scale) - 1; i >= 0; i--) {\n\t\tif (angleLineOpts.display && lineWidth && lineColor) {\n\t\t\tvar outerPosition = scale.getPointPosition(i, outerDistance);\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(scale.xCenter, scale.yCenter);\n\t\t\tctx.lineTo(outerPosition.x, outerPosition.y);\n\t\t\tctx.stroke();\n\t\t}\n\n\t\tif (pointLabelOpts.display) {\n\t\t\t// Extra pixels out for some label spacing\n\t\t\tvar extra = (i === 0 ? tickBackdropHeight / 2 : 0);\n\t\t\tvar pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5);\n\n\t\t\t// Keep this in loop since we may support array properties here\n\t\t\tvar pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);\n\t\t\tctx.fillStyle = pointLabelFontColor;\n\n\t\t\tvar angleRadians = scale.getIndexAngle(i);\n\t\t\tvar angle = helpers$1.toDegrees(angleRadians);\n\t\t\tctx.textAlign = getTextAlignForAngle(angle);\n\t\t\tadjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);\n\t\t\tfillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);\n\t\t}\n\t}\n\tctx.restore();\n}\n\nfunction drawRadiusLine(scale, gridLineOpts, radius, index) {\n\tvar ctx = scale.ctx;\n\tvar circular = gridLineOpts.circular;\n\tvar valueCount = getValueCount(scale);\n\tvar lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);\n\tvar lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);\n\tvar pointPosition;\n\n\tif ((!circular && !valueCount) || !lineColor || !lineWidth) {\n\t\treturn;\n\t}\n\n\tctx.save();\n\tctx.strokeStyle = lineColor;\n\tctx.lineWidth = lineWidth;\n\tif (ctx.setLineDash) {\n\t\tctx.setLineDash(gridLineOpts.borderDash || []);\n\t\tctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;\n\t}\n\n\tctx.beginPath();\n\tif (circular) {\n\t\t// Draw circular arcs between the points\n\t\tctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);\n\t} else {\n\t\t// Draw straight lines connecting each index\n\t\tpointPosition = scale.getPointPosition(0, radius);\n\t\tctx.moveTo(pointPosition.x, pointPosition.y);\n\n\t\tfor (var i = 1; i < valueCount; i++) {\n\t\t\tpointPosition = scale.getPointPosition(i, radius);\n\t\t\tctx.lineTo(pointPosition.x, pointPosition.y);\n\t\t}\n\t}\n\tctx.closePath();\n\tctx.stroke();\n\tctx.restore();\n}\n\nfunction numberOrZero(param) {\n\treturn helpers$1.isNumber(param) ? param : 0;\n}\n\nvar scale_radialLinear = scale_linearbase.extend({\n\tsetDimensions: function() {\n\t\tvar me = this;\n\n\t\t// Set the unconstrained dimension before label rotation\n\t\tme.width = me.maxWidth;\n\t\tme.height = me.maxHeight;\n\t\tme.paddingTop = getTickBackdropHeight(me.options) / 2;\n\t\tme.xCenter = Math.floor(me.width / 2);\n\t\tme.yCenter = Math.floor((me.height - me.paddingTop) / 2);\n\t\tme.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;\n\t},\n\n\tdetermineDataLimits: function() {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar min = Number.POSITIVE_INFINITY;\n\t\tvar max = Number.NEGATIVE_INFINITY;\n\n\t\thelpers$1.each(chart.data.datasets, function(dataset, datasetIndex) {\n\t\t\tif (chart.isDatasetVisible(datasetIndex)) {\n\t\t\t\tvar meta = chart.getDatasetMeta(datasetIndex);\n\n\t\t\t\thelpers$1.each(dataset.data, function(rawValue, index) {\n\t\t\t\t\tvar value = +me.getRightValue(rawValue);\n\t\t\t\t\tif (isNaN(value) || meta.data[index].hidden) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tmin = Math.min(value, min);\n\t\t\t\t\tmax = Math.max(value, max);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tme.min = (min === Number.POSITIVE_INFINITY ? 0 : min);\n\t\tme.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);\n\n\t\t// Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero\n\t\tme.handleTickRangeOptions();\n\t},\n\n\t// Returns the maximum number of ticks based on the scale dimension\n\t_computeTickLimit: function() {\n\t\treturn Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n\t},\n\n\tconvertTicksToLabels: function() {\n\t\tvar me = this;\n\n\t\tscale_linearbase.prototype.convertTicksToLabels.call(me);\n\n\t\t// Point labels\n\t\tme.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);\n\t},\n\n\tgetLabelForIndex: function(index, datasetIndex) {\n\t\treturn +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);\n\t},\n\n\tfit: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\n\t\tif (opts.display && opts.pointLabels.display) {\n\t\t\tfitWithPointLabels(me);\n\t\t} else {\n\t\t\tme.setCenterPoint(0, 0, 0, 0);\n\t\t}\n\t},\n\n\t/**\n\t * Set radius reductions and determine new radius and center point\n\t * @private\n\t */\n\tsetReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {\n\t\tvar me = this;\n\t\tvar radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);\n\t\tvar radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);\n\t\tvar radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);\n\t\tvar radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);\n\n\t\tradiusReductionLeft = numberOrZero(radiusReductionLeft);\n\t\tradiusReductionRight = numberOrZero(radiusReductionRight);\n\t\tradiusReductionTop = numberOrZero(radiusReductionTop);\n\t\tradiusReductionBottom = numberOrZero(radiusReductionBottom);\n\n\t\tme.drawingArea = Math.min(\n\t\t\tMath.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),\n\t\t\tMath.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));\n\t\tme.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);\n\t},\n\n\tsetCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {\n\t\tvar me = this;\n\t\tvar maxRight = me.width - rightMovement - me.drawingArea;\n\t\tvar maxLeft = leftMovement + me.drawingArea;\n\t\tvar maxTop = topMovement + me.drawingArea;\n\t\tvar maxBottom = (me.height - me.paddingTop) - bottomMovement - me.drawingArea;\n\n\t\tme.xCenter = Math.floor(((maxLeft + maxRight) / 2) + me.left);\n\t\tme.yCenter = Math.floor(((maxTop + maxBottom) / 2) + me.top + me.paddingTop);\n\t},\n\n\tgetIndexAngle: function(index) {\n\t\tvar angleMultiplier = (Math.PI * 2) / getValueCount(this);\n\t\tvar startAngle = this.chart.options && this.chart.options.startAngle ?\n\t\t\tthis.chart.options.startAngle :\n\t\t\t0;\n\n\t\tvar startAngleRadians = startAngle * Math.PI * 2 / 360;\n\n\t\t// Start from the top instead of right, so remove a quarter of the circle\n\t\treturn index * angleMultiplier + startAngleRadians;\n\t},\n\n\tgetDistanceFromCenterForValue: function(value) {\n\t\tvar me = this;\n\n\t\tif (value === null) {\n\t\t\treturn 0; // null always in center\n\t\t}\n\n\t\t// Take into account half font size + the yPadding of the top value\n\t\tvar scalingFactor = me.drawingArea / (me.max - me.min);\n\t\tif (me.options.ticks.reverse) {\n\t\t\treturn (me.max - value) * scalingFactor;\n\t\t}\n\t\treturn (value - me.min) * scalingFactor;\n\t},\n\n\tgetPointPosition: function(index, distanceFromCenter) {\n\t\tvar me = this;\n\t\tvar thisAngle = me.getIndexAngle(index) - (Math.PI / 2);\n\t\treturn {\n\t\t\tx: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,\n\t\t\ty: Math.sin(thisAngle) * distanceFromCenter + me.yCenter\n\t\t};\n\t},\n\n\tgetPointPositionForValue: function(index, value) {\n\t\treturn this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n\t},\n\n\tgetBasePosition: function() {\n\t\tvar me = this;\n\t\tvar min = me.min;\n\t\tvar max = me.max;\n\n\t\treturn me.getPointPositionForValue(0,\n\t\t\tme.beginAtZero ? 0 :\n\t\t\tmin < 0 && max < 0 ? max :\n\t\t\tmin > 0 && max > 0 ? min :\n\t\t\t0);\n\t},\n\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar gridLineOpts = opts.gridLines;\n\t\tvar tickOpts = opts.ticks;\n\n\t\tif (opts.display) {\n\t\t\tvar ctx = me.ctx;\n\t\t\tvar startAngle = this.getIndexAngle(0);\n\t\t\tvar tickFont = helpers$1.options._parseFont(tickOpts);\n\n\t\t\tif (opts.angleLines.display || opts.pointLabels.display) {\n\t\t\t\tdrawPointLabels(me);\n\t\t\t}\n\n\t\t\thelpers$1.each(me.ticks, function(label, index) {\n\t\t\t\t// Don't draw a centre value (if it is minimum)\n\t\t\t\tif (index > 0 || tickOpts.reverse) {\n\t\t\t\t\tvar yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);\n\n\t\t\t\t\t// Draw circular lines around the scale\n\t\t\t\t\tif (gridLineOpts.display && index !== 0) {\n\t\t\t\t\t\tdrawRadiusLine(me, gridLineOpts, yCenterOffset, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tickOpts.display) {\n\t\t\t\t\t\tvar tickFontColor = valueOrDefault$b(tickOpts.fontColor, core_defaults.global.defaultFontColor);\n\t\t\t\t\t\tctx.font = tickFont.string;\n\n\t\t\t\t\t\tctx.save();\n\t\t\t\t\t\tctx.translate(me.xCenter, me.yCenter);\n\t\t\t\t\t\tctx.rotate(startAngle);\n\n\t\t\t\t\t\tif (tickOpts.showLabelBackdrop) {\n\t\t\t\t\t\t\tvar labelWidth = ctx.measureText(label).width;\n\t\t\t\t\t\t\tctx.fillStyle = tickOpts.backdropColor;\n\t\t\t\t\t\t\tctx.fillRect(\n\t\t\t\t\t\t\t\t-labelWidth / 2 - tickOpts.backdropPaddingX,\n\t\t\t\t\t\t\t\t-yCenterOffset - tickFont.size / 2 - tickOpts.backdropPaddingY,\n\t\t\t\t\t\t\t\tlabelWidth + tickOpts.backdropPaddingX * 2,\n\t\t\t\t\t\t\t\ttickFont.size + tickOpts.backdropPaddingY * 2\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\t\t\tctx.fillStyle = tickFontColor;\n\t\t\t\t\t\tctx.fillText(label, 0, -yCenterOffset);\n\t\t\t\t\t\tctx.restore();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n});\n\n// INTERNAL: static default options, registered in src/index.js\nvar _defaults$3 = defaultConfig$3;\nscale_radialLinear._defaults = _defaults$3;\n\nvar valueOrDefault$c = helpers$1.valueOrDefault;\n\n// Integer constants are from the ES6 spec.\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\nvar INTERVALS = {\n\tmillisecond: {\n\t\tcommon: true,\n\t\tsize: 1,\n\t\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n\t},\n\tsecond: {\n\t\tcommon: true,\n\t\tsize: 1000,\n\t\tsteps: [1, 2, 5, 10, 15, 30]\n\t},\n\tminute: {\n\t\tcommon: true,\n\t\tsize: 60000,\n\t\tsteps: [1, 2, 5, 10, 15, 30]\n\t},\n\thour: {\n\t\tcommon: true,\n\t\tsize: 3600000,\n\t\tsteps: [1, 2, 3, 6, 12]\n\t},\n\tday: {\n\t\tcommon: true,\n\t\tsize: 86400000,\n\t\tsteps: [1, 2, 5]\n\t},\n\tweek: {\n\t\tcommon: false,\n\t\tsize: 604800000,\n\t\tsteps: [1, 2, 3, 4]\n\t},\n\tmonth: {\n\t\tcommon: true,\n\t\tsize: 2.628e9,\n\t\tsteps: [1, 2, 3]\n\t},\n\tquarter: {\n\t\tcommon: false,\n\t\tsize: 7.884e9,\n\t\tsteps: [1, 2, 3, 4]\n\t},\n\tyear: {\n\t\tcommon: true,\n\t\tsize: 3.154e10\n\t}\n};\n\nvar UNITS = Object.keys(INTERVALS);\n\nfunction sorter(a, b) {\n\treturn a - b;\n}\n\nfunction arrayUnique(items) {\n\tvar hash = {};\n\tvar out = [];\n\tvar i, ilen, item;\n\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\titem = items[i];\n\t\tif (!hash[item]) {\n\t\t\thash[item] = true;\n\t\t\tout.push(item);\n\t\t}\n\t}\n\n\treturn out;\n}\n\n/**\n * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n * extremity (left + width or top + height). Note that it would be more optimized to directly\n * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n *\n * @param {number[]} timestamps - timestamps sorted from lowest to highest.\n * @param {string} distribution - If 'linear', timestamps will be spread linearly along the min\n * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.\n * If 'series', timestamps will be positioned at the same distance from each other. In this\n * case, only timestamps that break the time linearity are registered, meaning that in the\n * best case, all timestamps are linear, the table contains only min and max.\n */\nfunction buildLookupTable(timestamps, min, max, distribution) {\n\tif (distribution === 'linear' || !timestamps.length) {\n\t\treturn [\n\t\t\t{time: min, pos: 0},\n\t\t\t{time: max, pos: 1}\n\t\t];\n\t}\n\n\tvar table = [];\n\tvar items = [min];\n\tvar i, ilen, prev, curr, next;\n\n\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\tcurr = timestamps[i];\n\t\tif (curr > min && curr < max) {\n\t\t\titems.push(curr);\n\t\t}\n\t}\n\n\titems.push(max);\n\n\tfor (i = 0, ilen = items.length; i < ilen; ++i) {\n\t\tnext = items[i + 1];\n\t\tprev = items[i - 1];\n\t\tcurr = items[i];\n\n\t\t// only add points that breaks the scale linearity\n\t\tif (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {\n\t\t\ttable.push({time: curr, pos: i / (ilen - 1)});\n\t\t}\n\t}\n\n\treturn table;\n}\n\n// @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/\nfunction lookup(table, key, value) {\n\tvar lo = 0;\n\tvar hi = table.length - 1;\n\tvar mid, i0, i1;\n\n\twhile (lo >= 0 && lo <= hi) {\n\t\tmid = (lo + hi) >> 1;\n\t\ti0 = table[mid - 1] || null;\n\t\ti1 = table[mid];\n\n\t\tif (!i0) {\n\t\t\t// given value is outside table (before first item)\n\t\t\treturn {lo: null, hi: i1};\n\t\t} else if (i1[key] < value) {\n\t\t\tlo = mid + 1;\n\t\t} else if (i0[key] > value) {\n\t\t\thi = mid - 1;\n\t\t} else {\n\t\t\treturn {lo: i0, hi: i1};\n\t\t}\n\t}\n\n\t// given value is outside table (after last item)\n\treturn {lo: i1, hi: null};\n}\n\n/**\n * Linearly interpolates the given source `value` using the table items `skey` values and\n * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')\n * returns the position for a timestamp equal to 42. If value is out of bounds, values at\n * index [0, 1] or [n - 1, n] are used for the interpolation.\n */\nfunction interpolate$1(table, skey, sval, tkey) {\n\tvar range = lookup(table, skey, sval);\n\n\t// Note: the lookup table ALWAYS contains at least 2 items (min and max)\n\tvar prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;\n\tvar next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;\n\n\tvar span = next[skey] - prev[skey];\n\tvar ratio = span ? (sval - prev[skey]) / span : 0;\n\tvar offset = (next[tkey] - prev[tkey]) * ratio;\n\n\treturn prev[tkey] + offset;\n}\n\nfunction toTimestamp(scale, input) {\n\tvar adapter = scale._adapter;\n\tvar options = scale.options.time;\n\tvar parser = options.parser;\n\tvar format = parser || options.format;\n\tvar value = input;\n\n\tif (typeof parser === 'function') {\n\t\tvalue = parser(value);\n\t}\n\n\t// Only parse if its not a timestamp already\n\tif (!helpers$1.isFinite(value)) {\n\t\tvalue = typeof format === 'string'\n\t\t\t? adapter.parse(value, format)\n\t\t\t: adapter.parse(value);\n\t}\n\n\tif (value !== null) {\n\t\treturn +value;\n\t}\n\n\t// Labels are in an incompatible format and no `parser` has been provided.\n\t// The user might still use the deprecated `format` option for parsing.\n\tif (!parser && typeof format === 'function') {\n\t\tvalue = format(input);\n\n\t\t// `format` could return something else than a timestamp, if so, parse it\n\t\tif (!helpers$1.isFinite(value)) {\n\t\t\tvalue = adapter.parse(value);\n\t\t}\n\t}\n\n\treturn value;\n}\n\nfunction parse(scale, input) {\n\tif (helpers$1.isNullOrUndef(input)) {\n\t\treturn null;\n\t}\n\n\tvar options = scale.options.time;\n\tvar value = toTimestamp(scale, scale.getRightValue(input));\n\tif (value === null) {\n\t\treturn value;\n\t}\n\n\tif (options.round) {\n\t\tvalue = +scale._adapter.startOf(value, options.round);\n\t}\n\n\treturn value;\n}\n\n/**\n * Returns the number of unit to skip to be able to display up to `capacity` number of ticks\n * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.\n */\nfunction determineStepSize(min, max, unit, capacity) {\n\tvar range = max - min;\n\tvar interval = INTERVALS[unit];\n\tvar milliseconds = interval.size;\n\tvar steps = interval.steps;\n\tvar i, ilen, factor;\n\n\tif (!steps) {\n\t\treturn Math.ceil(range / (capacity * milliseconds));\n\t}\n\n\tfor (i = 0, ilen = steps.length; i < ilen; ++i) {\n\t\tfactor = steps[i];\n\t\tif (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn factor;\n}\n\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n */\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n\tvar ilen = UNITS.length;\n\tvar i, interval, factor;\n\n\tfor (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n\t\tinterval = INTERVALS[UNITS[i]];\n\t\tfactor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;\n\n\t\tif (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n\t\t\treturn UNITS[i];\n\t\t}\n\t}\n\n\treturn UNITS[ilen - 1];\n}\n\n/**\n * Figures out what unit to format a set of ticks with\n */\nfunction determineUnitForFormatting(scale, ticks, minUnit, min, max) {\n\tvar ilen = UNITS.length;\n\tvar i, unit;\n\n\tfor (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {\n\t\tunit = UNITS[i];\n\t\tif (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= ticks.length) {\n\t\t\treturn unit;\n\t\t}\n\t}\n\n\treturn UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\nfunction determineMajorUnit(unit) {\n\tfor (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n\t\tif (INTERVALS[UNITS[i]].common) {\n\t\t\treturn UNITS[i];\n\t\t}\n\t}\n}\n\n/**\n * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n * `minor` unit, aligned on the `major` unit and using the given scale time `options`.\n * Important: this method can return ticks outside the min and max range, it's the\n * responsibility of the calling code to clamp values if needed.\n */\nfunction generate(scale, min, max, capacity) {\n\tvar adapter = scale._adapter;\n\tvar options = scale.options;\n\tvar timeOpts = options.time;\n\tvar minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n\tvar major = determineMajorUnit(minor);\n\tvar stepSize = valueOrDefault$c(timeOpts.stepSize, timeOpts.unitStepSize);\n\tvar weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n\tvar majorTicksEnabled = options.ticks.major.enabled;\n\tvar interval = INTERVALS[minor];\n\tvar first = min;\n\tvar last = max;\n\tvar ticks = [];\n\tvar time;\n\n\tif (!stepSize) {\n\t\tstepSize = determineStepSize(min, max, minor, capacity);\n\t}\n\n\t// For 'week' unit, handle the first day of week option\n\tif (weekday) {\n\t\tfirst = +adapter.startOf(first, 'isoWeek', weekday);\n\t\tlast = +adapter.startOf(last, 'isoWeek', weekday);\n\t}\n\n\t// Align first/last ticks on unit\n\tfirst = +adapter.startOf(first, weekday ? 'day' : minor);\n\tlast = +adapter.startOf(last, weekday ? 'day' : minor);\n\n\t// Make sure that the last tick include max\n\tif (last < max) {\n\t\tlast = +adapter.add(last, 1, minor);\n\t}\n\n\ttime = first;\n\n\tif (majorTicksEnabled && major && !weekday && !timeOpts.round) {\n\t\t// Align the first tick on the previous `minor` unit aligned on the `major` unit:\n\t\t// we first aligned time on the previous `major` unit then add the number of full\n\t\t// stepSize there is between first and the previous major time.\n\t\ttime = +adapter.startOf(time, major);\n\t\ttime = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n\t}\n\n\tfor (; time < last; time = +adapter.add(time, stepSize, minor)) {\n\t\tticks.push(+time);\n\t}\n\n\tticks.push(+time);\n\n\treturn ticks;\n}\n\n/**\n * Returns the start and end offsets from edges in the form of {start, end}\n * where each value is a relative width to the scale and ranges between 0 and 1.\n * They add extra margins on the both sides by scaling down the original scale.\n * Offsets are added when the `offset` option is true.\n */\nfunction computeOffsets(table, ticks, min, max, options) {\n\tvar start = 0;\n\tvar end = 0;\n\tvar first, last;\n\n\tif (options.offset && ticks.length) {\n\t\tif (!options.time.min) {\n\t\t\tfirst = interpolate$1(table, 'time', ticks[0], 'pos');\n\t\t\tif (ticks.length === 1) {\n\t\t\t\tstart = 1 - first;\n\t\t\t} else {\n\t\t\t\tstart = (interpolate$1(table, 'time', ticks[1], 'pos') - first) / 2;\n\t\t\t}\n\t\t}\n\t\tif (!options.time.max) {\n\t\t\tlast = interpolate$1(table, 'time', ticks[ticks.length - 1], 'pos');\n\t\t\tif (ticks.length === 1) {\n\t\t\t\tend = last;\n\t\t\t} else {\n\t\t\t\tend = (last - interpolate$1(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {start: start, end: end};\n}\n\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n\tvar ticks = [];\n\tvar i, ilen, value, major;\n\n\tfor (i = 0, ilen = values.length; i < ilen; ++i) {\n\t\tvalue = values[i];\n\t\tmajor = majorUnit ? value === +scale._adapter.startOf(value, majorUnit) : false;\n\n\t\tticks.push({\n\t\t\tvalue: value,\n\t\t\tmajor: major\n\t\t});\n\t}\n\n\treturn ticks;\n}\n\nvar defaultConfig$4 = {\n\tposition: 'bottom',\n\n\t/**\n\t * Data distribution along the scale:\n\t * - 'linear': data are spread according to their time (distances can vary),\n\t * - 'series': data are spread at the same distance from each other.\n\t * @see https://github.com/chartjs/Chart.js/pull/4507\n\t * @since 2.7.0\n\t */\n\tdistribution: 'linear',\n\n\t/**\n\t * Scale boundary strategy (bypassed by min/max time options)\n\t * - `data`: make sure data are fully visible, ticks outside are removed\n\t * - `ticks`: make sure ticks are fully visible, data outside are truncated\n\t * @see https://github.com/chartjs/Chart.js/pull/4556\n\t * @since 2.7.0\n\t */\n\tbounds: 'data',\n\n\tadapters: {},\n\ttime: {\n\t\tparser: false, // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n\t\tformat: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from https://momentjs.com/docs/#/parsing/string-format/\n\t\tunit: false, // false == automatic or override with week, month, year, etc.\n\t\tround: false, // none, or override with week, month, year, etc.\n\t\tdisplayFormat: false, // DEPRECATED\n\t\tisoWeekday: false, // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/\n\t\tminUnit: 'millisecond',\n\t\tdisplayFormats: {}\n\t},\n\tticks: {\n\t\tautoSkip: false,\n\n\t\t/**\n\t\t * Ticks generation input values:\n\t\t * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n\t\t * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n\t\t * - 'labels': generates ticks from user given `data.labels` values ONLY.\n\t\t * @see https://github.com/chartjs/Chart.js/pull/4507\n\t\t * @since 2.7.0\n\t\t */\n\t\tsource: 'auto',\n\n\t\tmajor: {\n\t\t\tenabled: false\n\t\t}\n\t}\n};\n\nvar scale_time = core_scale.extend({\n\tinitialize: function() {\n\t\tthis.mergeTicksOptions();\n\t\tcore_scale.prototype.initialize.call(this);\n\t},\n\n\tupdate: function() {\n\t\tvar me = this;\n\t\tvar options = me.options;\n\t\tvar time = options.time || (options.time = {});\n\t\tvar adapter = me._adapter = new core_adapters._date(options.adapters.date);\n\n\t\t// DEPRECATIONS: output a message only one time per update\n\t\tif (time.format) {\n\t\t\tconsole.warn('options.time.format is deprecated and replaced by options.time.parser.');\n\t\t}\n\n\t\t// Backward compatibility: before introducing adapter, `displayFormats` was\n\t\t// supposed to contain *all* unit/string pairs but this can't be resolved\n\t\t// when loading the scale (adapters are loaded afterward), so let's populate\n\t\t// missing formats on update\n\t\thelpers$1.mergeIf(time.displayFormats, adapter.formats());\n\n\t\treturn core_scale.prototype.update.apply(me, arguments);\n\t},\n\n\t/**\n\t * Allows data to be referenced via 't' attribute\n\t */\n\tgetRightValue: function(rawValue) {\n\t\tif (rawValue && rawValue.t !== undefined) {\n\t\t\trawValue = rawValue.t;\n\t\t}\n\t\treturn core_scale.prototype.getRightValue.call(this, rawValue);\n\t},\n\n\tdetermineDataLimits: function() {\n\t\tvar me = this;\n\t\tvar chart = me.chart;\n\t\tvar adapter = me._adapter;\n\t\tvar timeOpts = me.options.time;\n\t\tvar unit = timeOpts.unit || 'day';\n\t\tvar min = MAX_INTEGER;\n\t\tvar max = MIN_INTEGER;\n\t\tvar timestamps = [];\n\t\tvar datasets = [];\n\t\tvar labels = [];\n\t\tvar i, j, ilen, jlen, data, timestamp;\n\t\tvar dataLabels = chart.data.labels || [];\n\n\t\t// Convert labels to timestamps\n\t\tfor (i = 0, ilen = dataLabels.length; i < ilen; ++i) {\n\t\t\tlabels.push(parse(me, dataLabels[i]));\n\t\t}\n\n\t\t// Convert data to timestamps\n\t\tfor (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {\n\t\t\tif (chart.isDatasetVisible(i)) {\n\t\t\t\tdata = chart.data.datasets[i].data;\n\n\t\t\t\t// Let's consider that all data have the same format.\n\t\t\t\tif (helpers$1.isObject(data[0])) {\n\t\t\t\t\tdatasets[i] = [];\n\n\t\t\t\t\tfor (j = 0, jlen = data.length; j < jlen; ++j) {\n\t\t\t\t\t\ttimestamp = parse(me, data[j]);\n\t\t\t\t\t\ttimestamps.push(timestamp);\n\t\t\t\t\t\tdatasets[i][j] = timestamp;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (j = 0, jlen = labels.length; j < jlen; ++j) {\n\t\t\t\t\t\ttimestamps.push(labels[j]);\n\t\t\t\t\t}\n\t\t\t\t\tdatasets[i] = labels.slice(0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdatasets[i] = [];\n\t\t\t}\n\t\t}\n\n\t\tif (labels.length) {\n\t\t\t// Sort labels **after** data have been converted\n\t\t\tlabels = arrayUnique(labels).sort(sorter);\n\t\t\tmin = Math.min(min, labels[0]);\n\t\t\tmax = Math.max(max, labels[labels.length - 1]);\n\t\t}\n\n\t\tif (timestamps.length) {\n\t\t\ttimestamps = arrayUnique(timestamps).sort(sorter);\n\t\t\tmin = Math.min(min, timestamps[0]);\n\t\t\tmax = Math.max(max, timestamps[timestamps.length - 1]);\n\t\t}\n\n\t\tmin = parse(me, timeOpts.min) || min;\n\t\tmax = parse(me, timeOpts.max) || max;\n\n\t\t// In case there is no valid min/max, set limits based on unit time option\n\t\tmin = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;\n\t\tmax = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max;\n\n\t\t// Make sure that max is strictly higher than min (required by the lookup table)\n\t\tme.min = Math.min(min, max);\n\t\tme.max = Math.max(min + 1, max);\n\n\t\t// PRIVATE\n\t\tme._horizontal = me.isHorizontal();\n\t\tme._table = [];\n\t\tme._timestamps = {\n\t\t\tdata: timestamps,\n\t\t\tdatasets: datasets,\n\t\t\tlabels: labels\n\t\t};\n\t},\n\n\tbuildTicks: function() {\n\t\tvar me = this;\n\t\tvar min = me.min;\n\t\tvar max = me.max;\n\t\tvar options = me.options;\n\t\tvar timeOpts = options.time;\n\t\tvar timestamps = [];\n\t\tvar ticks = [];\n\t\tvar i, ilen, timestamp;\n\n\t\tswitch (options.ticks.source) {\n\t\tcase 'data':\n\t\t\ttimestamps = me._timestamps.data;\n\t\t\tbreak;\n\t\tcase 'labels':\n\t\t\ttimestamps = me._timestamps.labels;\n\t\t\tbreak;\n\t\tcase 'auto':\n\t\tdefault:\n\t\t\ttimestamps = generate(me, min, max, me.getLabelCapacity(min), options);\n\t\t}\n\n\t\tif (options.bounds === 'ticks' && timestamps.length) {\n\t\t\tmin = timestamps[0];\n\t\t\tmax = timestamps[timestamps.length - 1];\n\t\t}\n\n\t\t// Enforce limits with user min/max options\n\t\tmin = parse(me, timeOpts.min) || min;\n\t\tmax = parse(me, timeOpts.max) || max;\n\n\t\t// Remove ticks outside the min/max range\n\t\tfor (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n\t\t\ttimestamp = timestamps[i];\n\t\t\tif (timestamp >= min && timestamp <= max) {\n\t\t\t\tticks.push(timestamp);\n\t\t\t}\n\t\t}\n\n\t\tme.min = min;\n\t\tme.max = max;\n\n\t\t// PRIVATE\n\t\tme._unit = timeOpts.unit || determineUnitForFormatting(me, ticks, timeOpts.minUnit, me.min, me.max);\n\t\tme._majorUnit = determineMajorUnit(me._unit);\n\t\tme._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);\n\t\tme._offsets = computeOffsets(me._table, ticks, min, max, options);\n\n\t\tif (options.ticks.reverse) {\n\t\t\tticks.reverse();\n\t\t}\n\n\t\treturn ticksFromTimestamps(me, ticks, me._majorUnit);\n\t},\n\n\tgetLabelForIndex: function(index, datasetIndex) {\n\t\tvar me = this;\n\t\tvar adapter = me._adapter;\n\t\tvar data = me.chart.data;\n\t\tvar timeOpts = me.options.time;\n\t\tvar label = data.labels && index < data.labels.length ? data.labels[index] : '';\n\t\tvar value = data.datasets[datasetIndex].data[index];\n\n\t\tif (helpers$1.isObject(value)) {\n\t\t\tlabel = me.getRightValue(value);\n\t\t}\n\t\tif (timeOpts.tooltipFormat) {\n\t\t\treturn adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);\n\t\t}\n\t\tif (typeof label === 'string') {\n\t\t\treturn label;\n\t\t}\n\t\treturn adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);\n\t},\n\n\t/**\n\t * Function to format an individual tick mark\n\t * @private\n\t */\n\ttickFormatFunction: function(time, index, ticks, format) {\n\t\tvar me = this;\n\t\tvar adapter = me._adapter;\n\t\tvar options = me.options;\n\t\tvar formats = options.time.displayFormats;\n\t\tvar minorFormat = formats[me._unit];\n\t\tvar majorUnit = me._majorUnit;\n\t\tvar majorFormat = formats[majorUnit];\n\t\tvar majorTime = +adapter.startOf(time, majorUnit);\n\t\tvar majorTickOpts = options.ticks.major;\n\t\tvar major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;\n\t\tvar label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);\n\t\tvar tickOpts = major ? majorTickOpts : options.ticks.minor;\n\t\tvar formatter = valueOrDefault$c(tickOpts.callback, tickOpts.userCallback);\n\n\t\treturn formatter ? formatter(label, index, ticks) : label;\n\t},\n\n\tconvertTicksToLabels: function(ticks) {\n\t\tvar labels = [];\n\t\tvar i, ilen;\n\n\t\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\t\tlabels.push(this.tickFormatFunction(ticks[i].value, i, ticks));\n\t\t}\n\n\t\treturn labels;\n\t},\n\n\t/**\n\t * @private\n\t */\n\tgetPixelForOffset: function(time) {\n\t\tvar me = this;\n\t\tvar isReverse = me.options.ticks.reverse;\n\t\tvar size = me._horizontal ? me.width : me.height;\n\t\tvar start = me._horizontal ? isReverse ? me.right : me.left : isReverse ? me.bottom : me.top;\n\t\tvar pos = interpolate$1(me._table, 'time', time, 'pos');\n\t\tvar offset = size * (me._offsets.start + pos) / (me._offsets.start + 1 + me._offsets.end);\n\n\t\treturn isReverse ? start - offset : start + offset;\n\t},\n\n\tgetPixelForValue: function(value, index, datasetIndex) {\n\t\tvar me = this;\n\t\tvar time = null;\n\n\t\tif (index !== undefined && datasetIndex !== undefined) {\n\t\t\ttime = me._timestamps.datasets[datasetIndex][index];\n\t\t}\n\n\t\tif (time === null) {\n\t\t\ttime = parse(me, value);\n\t\t}\n\n\t\tif (time !== null) {\n\t\t\treturn me.getPixelForOffset(time);\n\t\t}\n\t},\n\n\tgetPixelForTick: function(index) {\n\t\tvar ticks = this.getTicks();\n\t\treturn index >= 0 && index < ticks.length ?\n\t\t\tthis.getPixelForOffset(ticks[index].value) :\n\t\t\tnull;\n\t},\n\n\tgetValueForPixel: function(pixel) {\n\t\tvar me = this;\n\t\tvar size = me._horizontal ? me.width : me.height;\n\t\tvar start = me._horizontal ? me.left : me.top;\n\t\tvar pos = (size ? (pixel - start) / size : 0) * (me._offsets.start + 1 + me._offsets.start) - me._offsets.end;\n\t\tvar time = interpolate$1(me._table, 'pos', pos, 'time');\n\n\t\t// DEPRECATION, we should return time directly\n\t\treturn me._adapter._create(time);\n\t},\n\n\t/**\n\t * Crude approximation of what the label width might be\n\t * @private\n\t */\n\tgetLabelWidth: function(label) {\n\t\tvar me = this;\n\t\tvar ticksOpts = me.options.ticks;\n\t\tvar tickLabelWidth = me.ctx.measureText(label).width;\n\t\tvar angle = helpers$1.toRadians(ticksOpts.maxRotation);\n\t\tvar cosRotation = Math.cos(angle);\n\t\tvar sinRotation = Math.sin(angle);\n\t\tvar tickFontSize = valueOrDefault$c(ticksOpts.fontSize, core_defaults.global.defaultFontSize);\n\n\t\treturn (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);\n\t},\n\n\t/**\n\t * @private\n\t */\n\tgetLabelCapacity: function(exampleTime) {\n\t\tvar me = this;\n\n\t\t// pick the longest format (milliseconds) for guestimation\n\t\tvar format = me.options.time.displayFormats.millisecond;\n\t\tvar exampleLabel = me.tickFormatFunction(exampleTime, 0, [], format);\n\t\tvar tickLabelWidth = me.getLabelWidth(exampleLabel);\n\t\tvar innerWidth = me.isHorizontal() ? me.width : me.height;\n\t\tvar capacity = Math.floor(innerWidth / tickLabelWidth);\n\n\t\treturn capacity > 0 ? capacity : 1;\n\t}\n});\n\n// INTERNAL: static default options, registered in src/index.js\nvar _defaults$4 = defaultConfig$4;\nscale_time._defaults = _defaults$4;\n\nvar scales = {\n\tcategory: scale_category,\n\tlinear: scale_linear,\n\tlogarithmic: scale_logarithmic,\n\tradialLinear: scale_radialLinear,\n\ttime: scale_time\n};\n\nvar FORMATS = {\n\tdatetime: 'MMM D, YYYY, h:mm:ss a',\n\tmillisecond: 'h:mm:ss.SSS a',\n\tsecond: 'h:mm:ss a',\n\tminute: 'h:mm a',\n\thour: 'hA',\n\tday: 'MMM D',\n\tweek: 'll',\n\tmonth: 'MMM YYYY',\n\tquarter: '[Q]Q - YYYY',\n\tyear: 'YYYY'\n};\n\ncore_adapters._date.override(typeof moment === 'function' ? {\n\t_id: 'moment', // DEBUG ONLY\n\n\tformats: function() {\n\t\treturn FORMATS;\n\t},\n\n\tparse: function(value, format) {\n\t\tif (typeof value === 'string' && typeof format === 'string') {\n\t\t\tvalue = moment(value, format);\n\t\t} else if (!(value instanceof moment)) {\n\t\t\tvalue = moment(value);\n\t\t}\n\t\treturn value.isValid() ? value.valueOf() : null;\n\t},\n\n\tformat: function(time, format) {\n\t\treturn moment(time).format(format);\n\t},\n\n\tadd: function(time, amount, unit) {\n\t\treturn moment(time).add(amount, unit).valueOf();\n\t},\n\n\tdiff: function(max, min, unit) {\n\t\treturn moment.duration(moment(max).diff(moment(min))).as(unit);\n\t},\n\n\tstartOf: function(time, unit, weekday) {\n\t\ttime = moment(time);\n\t\tif (unit === 'isoWeek') {\n\t\t\treturn time.isoWeekday(weekday).valueOf();\n\t\t}\n\t\treturn time.startOf(unit).valueOf();\n\t},\n\n\tendOf: function(time, unit) {\n\t\treturn moment(time).endOf(unit).valueOf();\n\t},\n\n\t// DEPRECATIONS\n\n\t/**\n\t * Provided for backward compatibility with scale.getValueForPixel().\n\t * @deprecated since version 2.8.0\n\t * @todo remove at version 3\n\t * @private\n\t */\n\t_create: function(time) {\n\t\treturn moment(time);\n\t},\n} : {});\n\ncore_defaults._set('global', {\n\tplugins: {\n\t\tfiller: {\n\t\t\tpropagate: true\n\t\t}\n\t}\n});\n\nvar mappers = {\n\tdataset: function(source) {\n\t\tvar index = source.fill;\n\t\tvar chart = source.chart;\n\t\tvar meta = chart.getDatasetMeta(index);\n\t\tvar visible = meta && chart.isDatasetVisible(index);\n\t\tvar points = (visible && meta.dataset._children) || [];\n\t\tvar length = points.length || 0;\n\n\t\treturn !length ? null : function(point, i) {\n\t\t\treturn (i < length && points[i]._view) || null;\n\t\t};\n\t},\n\n\tboundary: function(source) {\n\t\tvar boundary = source.boundary;\n\t\tvar x = boundary ? boundary.x : null;\n\t\tvar y = boundary ? boundary.y : null;\n\n\t\treturn function(point) {\n\t\t\treturn {\n\t\t\t\tx: x === null ? point.x : x,\n\t\t\t\ty: y === null ? point.y : y,\n\t\t\t};\n\t\t};\n\t}\n};\n\n// @todo if (fill[0] === '#')\nfunction decodeFill(el, index, count) {\n\tvar model = el._model || {};\n\tvar fill = model.fill;\n\tvar target;\n\n\tif (fill === undefined) {\n\t\tfill = !!model.backgroundColor;\n\t}\n\n\tif (fill === false || fill === null) {\n\t\treturn false;\n\t}\n\n\tif (fill === true) {\n\t\treturn 'origin';\n\t}\n\n\ttarget = parseFloat(fill, 10);\n\tif (isFinite(target) && Math.floor(target) === target) {\n\t\tif (fill[0] === '-' || fill[0] === '+') {\n\t\t\ttarget = index + target;\n\t\t}\n\n\t\tif (target === index || target < 0 || target >= count) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn target;\n\t}\n\n\tswitch (fill) {\n\t// compatibility\n\tcase 'bottom':\n\t\treturn 'start';\n\tcase 'top':\n\t\treturn 'end';\n\tcase 'zero':\n\t\treturn 'origin';\n\t// supported boundaries\n\tcase 'origin':\n\tcase 'start':\n\tcase 'end':\n\t\treturn fill;\n\t// invalid fill values\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nfunction computeBoundary(source) {\n\tvar model = source.el._model || {};\n\tvar scale = source.el._scale || {};\n\tvar fill = source.fill;\n\tvar target = null;\n\tvar horizontal;\n\n\tif (isFinite(fill)) {\n\t\treturn null;\n\t}\n\n\t// Backward compatibility: until v3, we still need to support boundary values set on\n\t// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and\n\t// controllers might still use it (e.g. the Smith chart).\n\n\tif (fill === 'start') {\n\t\ttarget = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\n\t} else if (fill === 'end') {\n\t\ttarget = model.scaleTop === undefined ? scale.top : model.scaleTop;\n\t} else if (model.scaleZero !== undefined) {\n\t\ttarget = model.scaleZero;\n\t} else if (scale.getBasePosition) {\n\t\ttarget = scale.getBasePosition();\n\t} else if (scale.getBasePixel) {\n\t\ttarget = scale.getBasePixel();\n\t}\n\n\tif (target !== undefined && target !== null) {\n\t\tif (target.x !== undefined && target.y !== undefined) {\n\t\t\treturn target;\n\t\t}\n\n\t\tif (helpers$1.isFinite(target)) {\n\t\t\thorizontal = scale.isHorizontal();\n\t\t\treturn {\n\t\t\t\tx: horizontal ? target : null,\n\t\t\t\ty: horizontal ? null : target\n\t\t\t};\n\t\t}\n\t}\n\n\treturn null;\n}\n\nfunction resolveTarget(sources, index, propagate) {\n\tvar source = sources[index];\n\tvar fill = source.fill;\n\tvar visited = [index];\n\tvar target;\n\n\tif (!propagate) {\n\t\treturn fill;\n\t}\n\n\twhile (fill !== false && visited.indexOf(fill) === -1) {\n\t\tif (!isFinite(fill)) {\n\t\t\treturn fill;\n\t\t}\n\n\t\ttarget = sources[fill];\n\t\tif (!target) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (target.visible) {\n\t\t\treturn fill;\n\t\t}\n\n\t\tvisited.push(fill);\n\t\tfill = target.fill;\n\t}\n\n\treturn false;\n}\n\nfunction createMapper(source) {\n\tvar fill = source.fill;\n\tvar type = 'dataset';\n\n\tif (fill === false) {\n\t\treturn null;\n\t}\n\n\tif (!isFinite(fill)) {\n\t\ttype = 'boundary';\n\t}\n\n\treturn mappers[type](source);\n}\n\nfunction isDrawable(point) {\n\treturn point && !point.skip;\n}\n\nfunction drawArea(ctx, curve0, curve1, len0, len1) {\n\tvar i;\n\n\tif (!len0 || !len1) {\n\t\treturn;\n\t}\n\n\t// building first area curve (normal)\n\tctx.moveTo(curve0[0].x, curve0[0].y);\n\tfor (i = 1; i < len0; ++i) {\n\t\thelpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);\n\t}\n\n\t// joining the two area curves\n\tctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);\n\n\t// building opposite area curve (reverse)\n\tfor (i = len1 - 1; i > 0; --i) {\n\t\thelpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);\n\t}\n}\n\nfunction doFill(ctx, points, mapper, view, color, loop) {\n\tvar count = points.length;\n\tvar span = view.spanGaps;\n\tvar curve0 = [];\n\tvar curve1 = [];\n\tvar len0 = 0;\n\tvar len1 = 0;\n\tvar i, ilen, index, p0, p1, d0, d1;\n\n\tctx.beginPath();\n\n\tfor (i = 0, ilen = (count + !!loop); i < ilen; ++i) {\n\t\tindex = i % count;\n\t\tp0 = points[index]._view;\n\t\tp1 = mapper(p0, index, view);\n\t\td0 = isDrawable(p0);\n\t\td1 = isDrawable(p1);\n\n\t\tif (d0 && d1) {\n\t\t\tlen0 = curve0.push(p0);\n\t\t\tlen1 = curve1.push(p1);\n\t\t} else if (len0 && len1) {\n\t\t\tif (!span) {\n\t\t\t\tdrawArea(ctx, curve0, curve1, len0, len1);\n\t\t\t\tlen0 = len1 = 0;\n\t\t\t\tcurve0 = [];\n\t\t\t\tcurve1 = [];\n\t\t\t} else {\n\t\t\t\tif (d0) {\n\t\t\t\t\tcurve0.push(p0);\n\t\t\t\t}\n\t\t\t\tif (d1) {\n\t\t\t\t\tcurve1.push(p1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdrawArea(ctx, curve0, curve1, len0, len1);\n\n\tctx.closePath();\n\tctx.fillStyle = color;\n\tctx.fill();\n}\n\nvar plugin_filler = {\n\tid: 'filler',\n\n\tafterDatasetsUpdate: function(chart, options) {\n\t\tvar count = (chart.data.datasets || []).length;\n\t\tvar propagate = options.propagate;\n\t\tvar sources = [];\n\t\tvar meta, i, el, source;\n\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\tel = meta.dataset;\n\t\t\tsource = null;\n\n\t\t\tif (el && el._model && el instanceof elements.Line) {\n\t\t\t\tsource = {\n\t\t\t\t\tvisible: chart.isDatasetVisible(i),\n\t\t\t\t\tfill: decodeFill(el, i, count),\n\t\t\t\t\tchart: chart,\n\t\t\t\t\tel: el\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tmeta.$filler = source;\n\t\t\tsources.push(source);\n\t\t}\n\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tsource = sources[i];\n\t\t\tif (!source) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsource.fill = resolveTarget(sources, i, propagate);\n\t\t\tsource.boundary = computeBoundary(source);\n\t\t\tsource.mapper = createMapper(source);\n\t\t}\n\t},\n\n\tbeforeDatasetDraw: function(chart, args) {\n\t\tvar meta = args.meta.$filler;\n\t\tif (!meta) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ctx = chart.ctx;\n\t\tvar el = meta.el;\n\t\tvar view = el._view;\n\t\tvar points = el._children || [];\n\t\tvar mapper = meta.mapper;\n\t\tvar color = view.backgroundColor || core_defaults.global.defaultColor;\n\n\t\tif (mapper && color && points.length) {\n\t\t\thelpers$1.canvas.clipArea(ctx, chart.chartArea);\n\t\t\tdoFill(ctx, points, mapper, view, color, el._loop);\n\t\t\thelpers$1.canvas.unclipArea(ctx);\n\t\t}\n\t}\n};\n\nvar noop$1 = helpers$1.noop;\nvar valueOrDefault$d = helpers$1.valueOrDefault;\n\ncore_defaults._set('global', {\n\tlegend: {\n\t\tdisplay: true,\n\t\tposition: 'top',\n\t\tfullWidth: true,\n\t\treverse: false,\n\t\tweight: 1000,\n\n\t\t// a callback that will handle\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.datasetIndex;\n\t\t\tvar ci = this.chart;\n\t\t\tvar meta = ci.getDatasetMeta(index);\n\n\t\t\t// See controller.isDatasetVisible comment\n\t\t\tmeta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;\n\n\t\t\t// We hid a dataset ... rerender the chart\n\t\t\tci.update();\n\t\t},\n\n\t\tonHover: null,\n\t\tonLeave: null,\n\n\t\tlabels: {\n\t\t\tboxWidth: 40,\n\t\t\tpadding: 10,\n\t\t\t// Generates labels shown in the legend\n\t\t\t// Valid properties to return:\n\t\t\t// text : text to display\n\t\t\t// fillStyle : fill of coloured box\n\t\t\t// strokeStyle: stroke of coloured box\n\t\t\t// hidden : if this legend item refers to a hidden item\n\t\t\t// lineCap : cap style for line\n\t\t\t// lineDash\n\t\t\t// lineDashOffset :\n\t\t\t// lineJoin :\n\t\t\t// lineWidth :\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\treturn helpers$1.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: dataset.label,\n\t\t\t\t\t\tfillStyle: (!helpers$1.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\n\t\t\t\t\t\thidden: !chart.isDatasetVisible(i),\n\t\t\t\t\t\tlineCap: dataset.borderCapStyle,\n\t\t\t\t\t\tlineDash: dataset.borderDash,\n\t\t\t\t\t\tlineDashOffset: dataset.borderDashOffset,\n\t\t\t\t\t\tlineJoin: dataset.borderJoinStyle,\n\t\t\t\t\t\tlineWidth: dataset.borderWidth,\n\t\t\t\t\t\tstrokeStyle: dataset.borderColor,\n\t\t\t\t\t\tpointStyle: dataset.pointStyle,\n\n\t\t\t\t\t\t// Below is extra data used for toggling the datasets\n\t\t\t\t\t\tdatasetIndex: i\n\t\t\t\t\t};\n\t\t\t\t}, this) : [];\n\t\t\t}\n\t\t}\n\t},\n\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\tfor (var i = 0; i < chart.data.datasets.length; i++) {\n\t\t\ttext.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n\t\t\tif (chart.data.datasets[i].label) {\n\t\t\t\ttext.push(chart.data.datasets[i].label);\n\t\t\t}\n\t\t\ttext.push('</li>');\n\t\t}\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t}\n});\n\n/**\n * Helper function to get the box width based on the usePointStyle option\n * @param {object} labelopts - the label options on the legend\n * @param {number} fontSize - the label font size\n * @return {number} width of the color box area\n */\nfunction getBoxWidth(labelOpts, fontSize) {\n\treturn labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ?\n\t\tfontSize :\n\t\tlabelOpts.boxWidth;\n}\n\n/**\n * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\n */\nvar Legend = core_element.extend({\n\n\tinitialize: function(config) {\n\t\thelpers$1.extend(this, config);\n\n\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\tthis.legendHitBoxes = [];\n\n\t\t/**\n \t\t * @private\n \t\t */\n\t\tthis._hoveredItem = null;\n\n\t\t// Are we in doughnut mode which has a different data type\n\t\tthis.doughnutMode = false;\n\t},\n\n\t// These methods are ordered by lifecycle. Utilities then follow.\n\t// Any function defined here is inherited by all legend types.\n\t// Any function can be extended by the legend type\n\n\tbeforeUpdate: noop$1,\n\tupdate: function(maxWidth, maxHeight, margins) {\n\t\tvar me = this;\n\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\tme.beforeUpdate();\n\n\t\t// Absorb the master measurements\n\t\tme.maxWidth = maxWidth;\n\t\tme.maxHeight = maxHeight;\n\t\tme.margins = margins;\n\n\t\t// Dimensions\n\t\tme.beforeSetDimensions();\n\t\tme.setDimensions();\n\t\tme.afterSetDimensions();\n\t\t// Labels\n\t\tme.beforeBuildLabels();\n\t\tme.buildLabels();\n\t\tme.afterBuildLabels();\n\n\t\t// Fit\n\t\tme.beforeFit();\n\t\tme.fit();\n\t\tme.afterFit();\n\t\t//\n\t\tme.afterUpdate();\n\n\t\treturn me.minSize;\n\t},\n\tafterUpdate: noop$1,\n\n\t//\n\n\tbeforeSetDimensions: noop$1,\n\tsetDimensions: function() {\n\t\tvar me = this;\n\t\t// Set the unconstrained dimension before label rotation\n\t\tif (me.isHorizontal()) {\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.left = 0;\n\t\t\tme.right = me.width;\n\t\t} else {\n\t\t\tme.height = me.maxHeight;\n\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.top = 0;\n\t\t\tme.bottom = me.height;\n\t\t}\n\n\t\t// Reset padding\n\t\tme.paddingLeft = 0;\n\t\tme.paddingTop = 0;\n\t\tme.paddingRight = 0;\n\t\tme.paddingBottom = 0;\n\n\t\t// Reset minSize\n\t\tme.minSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t},\n\tafterSetDimensions: noop$1,\n\n\t//\n\n\tbeforeBuildLabels: noop$1,\n\tbuildLabels: function() {\n\t\tvar me = this;\n\t\tvar labelOpts = me.options.labels || {};\n\t\tvar legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];\n\n\t\tif (labelOpts.filter) {\n\t\t\tlegendItems = legendItems.filter(function(item) {\n\t\t\t\treturn labelOpts.filter(item, me.chart.data);\n\t\t\t});\n\t\t}\n\n\t\tif (me.options.reverse) {\n\t\t\tlegendItems.reverse();\n\t\t}\n\n\t\tme.legendItems = legendItems;\n\t},\n\tafterBuildLabels: noop$1,\n\n\t//\n\n\tbeforeFit: noop$1,\n\tfit: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar labelOpts = opts.labels;\n\t\tvar display = opts.display;\n\n\t\tvar ctx = me.ctx;\n\n\t\tvar labelFont = helpers$1.options._parseFont(labelOpts);\n\t\tvar fontSize = labelFont.size;\n\n\t\t// Reset hit boxes\n\t\tvar hitboxes = me.legendHitBoxes = [];\n\n\t\tvar minSize = me.minSize;\n\t\tvar isHorizontal = me.isHorizontal();\n\n\t\tif (isHorizontal) {\n\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\tminSize.height = display ? 10 : 0;\n\t\t} else {\n\t\t\tminSize.width = display ? 10 : 0;\n\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t}\n\n\t\t// Increase sizes here\n\t\tif (display) {\n\t\t\tctx.font = labelFont.string;\n\n\t\t\tif (isHorizontal) {\n\t\t\t\t// Labels\n\n\t\t\t\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n\t\t\t\tvar lineWidths = me.lineWidths = [0];\n\t\t\t\tvar totalHeight = 0;\n\n\t\t\t\tctx.textAlign = 'left';\n\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\thelpers$1.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\tif (i === 0 || lineWidths[lineWidths.length - 1] + width + labelOpts.padding > minSize.width) {\n\t\t\t\t\t\ttotalHeight += fontSize + labelOpts.padding;\n\t\t\t\t\t\tlineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = labelOpts.padding;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t};\n\n\t\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n\t\t\t\t});\n\n\t\t\t\tminSize.height += totalHeight;\n\n\t\t\t} else {\n\t\t\t\tvar vPadding = labelOpts.padding;\n\t\t\t\tvar columnWidths = me.columnWidths = [];\n\t\t\t\tvar totalWidth = labelOpts.padding;\n\t\t\t\tvar currentColWidth = 0;\n\t\t\t\tvar currentColHeight = 0;\n\t\t\t\tvar itemHeight = fontSize + vPadding;\n\n\t\t\t\thelpers$1.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t// If too tall, go to new column\n\t\t\t\t\tif (i > 0 && currentColHeight + itemHeight > minSize.height - vPadding) {\n\t\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\n\t\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width\n\n\t\t\t\t\t\tcurrentColWidth = 0;\n\t\t\t\t\t\tcurrentColHeight = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Get max width\n\t\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\n\t\t\t\t\tcurrentColHeight += itemHeight;\n\n\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\twidth: itemWidth,\n\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\ttotalWidth += currentColWidth;\n\t\t\t\tcolumnWidths.push(currentColWidth);\n\t\t\t\tminSize.width += totalWidth;\n\t\t\t}\n\t\t}\n\n\t\tme.width = minSize.width;\n\t\tme.height = minSize.height;\n\t},\n\tafterFit: noop$1,\n\n\t// Shared Methods\n\tisHorizontal: function() {\n\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t},\n\n\t// Actually draw the legend on the canvas\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar labelOpts = opts.labels;\n\t\tvar globalDefaults = core_defaults.global;\n\t\tvar defaultColor = globalDefaults.defaultColor;\n\t\tvar lineDefault = globalDefaults.elements.line;\n\t\tvar legendWidth = me.width;\n\t\tvar lineWidths = me.lineWidths;\n\n\t\tif (opts.display) {\n\t\t\tvar ctx = me.ctx;\n\t\t\tvar fontColor = valueOrDefault$d(labelOpts.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar labelFont = helpers$1.options._parseFont(labelOpts);\n\t\t\tvar fontSize = labelFont.size;\n\t\t\tvar cursor;\n\n\t\t\t// Canvas setup\n\t\t\tctx.textAlign = 'left';\n\t\t\tctx.textBaseline = 'middle';\n\t\t\tctx.lineWidth = 0.5;\n\t\t\tctx.strokeStyle = fontColor; // for strikethrough effect\n\t\t\tctx.fillStyle = fontColor; // render in correct colour\n\t\t\tctx.font = labelFont.string;\n\n\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\tvar hitboxes = me.legendHitBoxes;\n\n\t\t\t// current position\n\t\t\tvar drawLegendBox = function(x, y, legendItem) {\n\t\t\t\tif (isNaN(boxWidth) || boxWidth <= 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Set the ctx for the box\n\t\t\t\tctx.save();\n\n\t\t\t\tvar lineWidth = valueOrDefault$d(legendItem.lineWidth, lineDefault.borderWidth);\n\t\t\t\tctx.fillStyle = valueOrDefault$d(legendItem.fillStyle, defaultColor);\n\t\t\t\tctx.lineCap = valueOrDefault$d(legendItem.lineCap, lineDefault.borderCapStyle);\n\t\t\t\tctx.lineDashOffset = valueOrDefault$d(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n\t\t\t\tctx.lineJoin = valueOrDefault$d(legendItem.lineJoin, lineDefault.borderJoinStyle);\n\t\t\t\tctx.lineWidth = lineWidth;\n\t\t\t\tctx.strokeStyle = valueOrDefault$d(legendItem.strokeStyle, defaultColor);\n\n\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\t// IE 9 and 10 do not support line dash\n\t\t\t\t\tctx.setLineDash(valueOrDefault$d(legendItem.lineDash, lineDefault.borderDash));\n\t\t\t\t}\n\n\t\t\t\tif (opts.labels && opts.labels.usePointStyle) {\n\t\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\n\t\t\t\t\t// x and y to be center of figure (instead of top left)\n\t\t\t\t\tvar radius = boxWidth * Math.SQRT2 / 2;\n\t\t\t\t\tvar centerX = x + boxWidth / 2;\n\t\t\t\t\tvar centerY = y + fontSize / 2;\n\n\t\t\t\t\t// Draw pointStyle as legend symbol\n\t\t\t\t\thelpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n\t\t\t\t} else {\n\t\t\t\t\t// Draw box as legend symbol\n\t\t\t\t\tif (lineWidth !== 0) {\n\t\t\t\t\t\tctx.strokeRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t}\n\t\t\t\t\tctx.fillRect(x, y, boxWidth, fontSize);\n\t\t\t\t}\n\n\t\t\t\tctx.restore();\n\t\t\t};\n\t\t\tvar fillText = function(x, y, legendItem, textWidth) {\n\t\t\t\tvar halfFontSize = fontSize / 2;\n\t\t\t\tvar xLeft = boxWidth + halfFontSize + x;\n\t\t\t\tvar yMiddle = y + halfFontSize;\n\n\t\t\t\tctx.fillText(legendItem.text, xLeft, yMiddle);\n\n\t\t\t\tif (legendItem.hidden) {\n\t\t\t\t\t// Strikethrough the text if hidden\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\tctx.moveTo(xLeft, yMiddle);\n\t\t\t\t\tctx.lineTo(xLeft + textWidth, yMiddle);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Horizontal\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tif (isHorizontal) {\n\t\t\t\tcursor = {\n\t\t\t\t\tx: me.left + ((legendWidth - lineWidths[0]) / 2) + labelOpts.padding,\n\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\tline: 0\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tcursor = {\n\t\t\t\t\tx: me.left + labelOpts.padding,\n\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\tline: 0\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar itemHeight = fontSize + labelOpts.padding;\n\t\t\thelpers$1.each(me.legendItems, function(legendItem, i) {\n\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width;\n\t\t\t\tvar width = boxWidth + (fontSize / 2) + textWidth;\n\t\t\t\tvar x = cursor.x;\n\t\t\t\tvar y = cursor.y;\n\n\t\t\t\t// Use (me.left + me.minSize.width) and (me.top + me.minSize.height)\n\t\t\t\t// instead of me.right and me.bottom because me.width and me.height\n\t\t\t\t// may have been changed since me.minSize was calculated\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tif (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {\n\t\t\t\t\t\ty = cursor.y += itemHeight;\n\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2) + labelOpts.padding;\n\t\t\t\t\t}\n\t\t\t\t} else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {\n\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n\t\t\t\t\ty = cursor.y = me.top + labelOpts.padding;\n\t\t\t\t\tcursor.line++;\n\t\t\t\t}\n\n\t\t\t\tdrawLegendBox(x, y, legendItem);\n\n\t\t\t\thitboxes[i].left = x;\n\t\t\t\thitboxes[i].top = y;\n\n\t\t\t\t// Fill the actual label\n\t\t\t\tfillText(x, y, legendItem, textWidth);\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tcursor.x += width + labelOpts.padding;\n\t\t\t\t} else {\n\t\t\t\t\tcursor.y += itemHeight;\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * @private\n\t */\n\t_getLegendItemAt: function(x, y) {\n\t\tvar me = this;\n\t\tvar i, hitBox, lh;\n\n\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n\t\t\t// See if we are touching one of the dataset boxes\n\t\t\tlh = me.legendHitBoxes;\n\t\t\tfor (i = 0; i < lh.length; ++i) {\n\t\t\t\thitBox = lh[i];\n\n\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n\t\t\t\t\t// Touching an element\n\t\t\t\t\treturn me.legendItems[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\n\t/**\n\t * Handle an event\n\t * @private\n\t * @param {IEvent} event - The event to handle\n\t */\n\thandleEvent: function(e) {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar type = e.type === 'mouseup' ? 'click' : e.type;\n\t\tvar hoveredItem;\n\n\t\tif (type === 'mousemove') {\n\t\t\tif (!opts.onHover && !opts.onLeave) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (type === 'click') {\n\t\t\tif (!opts.onClick) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\n\t\t// Chart event already has relative position in it\n\t\thoveredItem = me._getLegendItemAt(e.x, e.y);\n\n\t\tif (type === 'click') {\n\t\t\tif (hoveredItem && opts.onClick) {\n\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\topts.onClick.call(me, e.native, hoveredItem);\n\t\t\t}\n\t\t} else {\n\t\t\tif (opts.onLeave && hoveredItem !== me._hoveredItem) {\n\t\t\t\tif (me._hoveredItem) {\n\t\t\t\t\topts.onLeave.call(me, e.native, me._hoveredItem);\n\t\t\t\t}\n\t\t\t\tme._hoveredItem = hoveredItem;\n\t\t\t}\n\n\t\t\tif (opts.onHover && hoveredItem) {\n\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\topts.onHover.call(me, e.native, hoveredItem);\n\t\t\t}\n\t\t}\n\t}\n});\n\nfunction createNewLegendAndAttach(chart, legendOpts) {\n\tvar legend = new Legend({\n\t\tctx: chart.ctx,\n\t\toptions: legendOpts,\n\t\tchart: chart\n\t});\n\n\tcore_layouts.configure(chart, legend, legendOpts);\n\tcore_layouts.addBox(chart, legend);\n\tchart.legend = legend;\n}\n\nvar plugin_legend = {\n\tid: 'legend',\n\n\t/**\n\t * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making\n\t * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of\n\t * the plugin, which one will be re-exposed in the chart.js file.\n\t * https://github.com/chartjs/Chart.js/pull/2640\n\t * @private\n\t */\n\t_element: Legend,\n\n\tbeforeInit: function(chart) {\n\t\tvar legendOpts = chart.options.legend;\n\n\t\tif (legendOpts) {\n\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t}\n\t},\n\n\tbeforeUpdate: function(chart) {\n\t\tvar legendOpts = chart.options.legend;\n\t\tvar legend = chart.legend;\n\n\t\tif (legendOpts) {\n\t\t\thelpers$1.mergeIf(legendOpts, core_defaults.global.legend);\n\n\t\t\tif (legend) {\n\t\t\t\tcore_layouts.configure(chart, legend, legendOpts);\n\t\t\t\tlegend.options = legendOpts;\n\t\t\t} else {\n\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t\t}\n\t\t} else if (legend) {\n\t\t\tcore_layouts.removeBox(chart, legend);\n\t\t\tdelete chart.legend;\n\t\t}\n\t},\n\n\tafterEvent: function(chart, e) {\n\t\tvar legend = chart.legend;\n\t\tif (legend) {\n\t\t\tlegend.handleEvent(e);\n\t\t}\n\t}\n};\n\nvar noop$2 = helpers$1.noop;\n\ncore_defaults._set('global', {\n\ttitle: {\n\t\tdisplay: false,\n\t\tfontStyle: 'bold',\n\t\tfullWidth: true,\n\t\tpadding: 10,\n\t\tposition: 'top',\n\t\ttext: '',\n\t\tweight: 2000         // by default greater than legend (1000) to be above\n\t}\n});\n\n/**\n * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!\n */\nvar Title = core_element.extend({\n\tinitialize: function(config) {\n\t\tvar me = this;\n\t\thelpers$1.extend(me, config);\n\n\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\tme.legendHitBoxes = [];\n\t},\n\n\t// These methods are ordered by lifecycle. Utilities then follow.\n\n\tbeforeUpdate: noop$2,\n\tupdate: function(maxWidth, maxHeight, margins) {\n\t\tvar me = this;\n\n\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\tme.beforeUpdate();\n\n\t\t// Absorb the master measurements\n\t\tme.maxWidth = maxWidth;\n\t\tme.maxHeight = maxHeight;\n\t\tme.margins = margins;\n\n\t\t// Dimensions\n\t\tme.beforeSetDimensions();\n\t\tme.setDimensions();\n\t\tme.afterSetDimensions();\n\t\t// Labels\n\t\tme.beforeBuildLabels();\n\t\tme.buildLabels();\n\t\tme.afterBuildLabels();\n\n\t\t// Fit\n\t\tme.beforeFit();\n\t\tme.fit();\n\t\tme.afterFit();\n\t\t//\n\t\tme.afterUpdate();\n\n\t\treturn me.minSize;\n\n\t},\n\tafterUpdate: noop$2,\n\n\t//\n\n\tbeforeSetDimensions: noop$2,\n\tsetDimensions: function() {\n\t\tvar me = this;\n\t\t// Set the unconstrained dimension before label rotation\n\t\tif (me.isHorizontal()) {\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.width = me.maxWidth;\n\t\t\tme.left = 0;\n\t\t\tme.right = me.width;\n\t\t} else {\n\t\t\tme.height = me.maxHeight;\n\n\t\t\t// Reset position before calculating rotation\n\t\t\tme.top = 0;\n\t\t\tme.bottom = me.height;\n\t\t}\n\n\t\t// Reset padding\n\t\tme.paddingLeft = 0;\n\t\tme.paddingTop = 0;\n\t\tme.paddingRight = 0;\n\t\tme.paddingBottom = 0;\n\n\t\t// Reset minSize\n\t\tme.minSize = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t},\n\tafterSetDimensions: noop$2,\n\n\t//\n\n\tbeforeBuildLabels: noop$2,\n\tbuildLabels: noop$2,\n\tafterBuildLabels: noop$2,\n\n\t//\n\n\tbeforeFit: noop$2,\n\tfit: function() {\n\t\tvar me = this;\n\t\tvar opts = me.options;\n\t\tvar display = opts.display;\n\t\tvar minSize = me.minSize;\n\t\tvar lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;\n\t\tvar fontOpts = helpers$1.options._parseFont(opts);\n\t\tvar textSize = display ? (lineCount * fontOpts.lineHeight) + (opts.padding * 2) : 0;\n\n\t\tif (me.isHorizontal()) {\n\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\tminSize.height = textSize;\n\t\t} else {\n\t\t\tminSize.width = textSize;\n\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t}\n\n\t\tme.width = minSize.width;\n\t\tme.height = minSize.height;\n\n\t},\n\tafterFit: noop$2,\n\n\t// Shared Methods\n\tisHorizontal: function() {\n\t\tvar pos = this.options.position;\n\t\treturn pos === 'top' || pos === 'bottom';\n\t},\n\n\t// Actually draw the title block on the canvas\n\tdraw: function() {\n\t\tvar me = this;\n\t\tvar ctx = me.ctx;\n\t\tvar opts = me.options;\n\n\t\tif (opts.display) {\n\t\t\tvar fontOpts = helpers$1.options._parseFont(opts);\n\t\t\tvar lineHeight = fontOpts.lineHeight;\n\t\t\tvar offset = lineHeight / 2 + opts.padding;\n\t\t\tvar rotation = 0;\n\t\t\tvar top = me.top;\n\t\t\tvar left = me.left;\n\t\t\tvar bottom = me.bottom;\n\t\t\tvar right = me.right;\n\t\t\tvar maxWidth, titleX, titleY;\n\n\t\t\tctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor); // render in correct colour\n\t\t\tctx.font = fontOpts.string;\n\n\t\t\t// Horizontal\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\ttitleX = left + ((right - left) / 2); // midpoint of the width\n\t\t\t\ttitleY = top + offset;\n\t\t\t\tmaxWidth = right - left;\n\t\t\t} else {\n\t\t\t\ttitleX = opts.position === 'left' ? left + offset : right - offset;\n\t\t\t\ttitleY = top + ((bottom - top) / 2);\n\t\t\t\tmaxWidth = bottom - top;\n\t\t\t\trotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);\n\t\t\t}\n\n\t\t\tctx.save();\n\t\t\tctx.translate(titleX, titleY);\n\t\t\tctx.rotate(rotation);\n\t\t\tctx.textAlign = 'center';\n\t\t\tctx.textBaseline = 'middle';\n\n\t\t\tvar text = opts.text;\n\t\t\tif (helpers$1.isArray(text)) {\n\t\t\t\tvar y = 0;\n\t\t\t\tfor (var i = 0; i < text.length; ++i) {\n\t\t\t\t\tctx.fillText(text[i], 0, y, maxWidth);\n\t\t\t\t\ty += lineHeight;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tctx.fillText(text, 0, 0, maxWidth);\n\t\t\t}\n\n\t\t\tctx.restore();\n\t\t}\n\t}\n});\n\nfunction createNewTitleBlockAndAttach(chart, titleOpts) {\n\tvar title = new Title({\n\t\tctx: chart.ctx,\n\t\toptions: titleOpts,\n\t\tchart: chart\n\t});\n\n\tcore_layouts.configure(chart, title, titleOpts);\n\tcore_layouts.addBox(chart, title);\n\tchart.titleBlock = title;\n}\n\nvar plugin_title = {\n\tid: 'title',\n\n\t/**\n\t * Backward compatibility: since 2.1.5, the title is registered as a plugin, making\n\t * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of\n\t * the plugin, which one will be re-exposed in the chart.js file.\n\t * https://github.com/chartjs/Chart.js/pull/2640\n\t * @private\n\t */\n\t_element: Title,\n\n\tbeforeInit: function(chart) {\n\t\tvar titleOpts = chart.options.title;\n\n\t\tif (titleOpts) {\n\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t}\n\t},\n\n\tbeforeUpdate: function(chart) {\n\t\tvar titleOpts = chart.options.title;\n\t\tvar titleBlock = chart.titleBlock;\n\n\t\tif (titleOpts) {\n\t\t\thelpers$1.mergeIf(titleOpts, core_defaults.global.title);\n\n\t\t\tif (titleBlock) {\n\t\t\t\tcore_layouts.configure(chart, titleBlock, titleOpts);\n\t\t\t\ttitleBlock.options = titleOpts;\n\t\t\t} else {\n\t\t\t\tcreateNewTitleBlockAndAttach(chart, titleOpts);\n\t\t\t}\n\t\t} else if (titleBlock) {\n\t\t\tcore_layouts.removeBox(chart, titleBlock);\n\t\t\tdelete chart.titleBlock;\n\t\t}\n\t}\n};\n\nvar plugins = {};\nvar filler = plugin_filler;\nvar legend = plugin_legend;\nvar title = plugin_title;\nplugins.filler = filler;\nplugins.legend = legend;\nplugins.title = title;\n\n/**\n * @namespace Chart\n */\n\n\ncore_controller.helpers = helpers$1;\n\n// @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!\ncore_helpers(core_controller);\n\ncore_controller._adapters = core_adapters;\ncore_controller.Animation = core_animation;\ncore_controller.animationService = core_animations;\ncore_controller.controllers = controllers;\ncore_controller.DatasetController = core_datasetController;\ncore_controller.defaults = core_defaults;\ncore_controller.Element = core_element;\ncore_controller.elements = elements;\ncore_controller.Interaction = core_interaction;\ncore_controller.layouts = core_layouts;\ncore_controller.platform = platform;\ncore_controller.plugins = core_plugins;\ncore_controller.Scale = core_scale;\ncore_controller.scaleService = core_scaleService;\ncore_controller.Ticks = core_ticks;\ncore_controller.Tooltip = core_tooltip;\n\n// Register built-in scales\n\ncore_controller.helpers.each(scales, function(scale, type) {\n\tcore_controller.scaleService.registerScaleType(type, scale, scale._defaults);\n});\n\n// Load to register built-in adapters (as side effects)\n\n\n// Loading built-in plugins\n\nfor (var k in plugins) {\n\tif (plugins.hasOwnProperty(k)) {\n\t\tcore_controller.plugins.register(plugins[k]);\n\t}\n}\n\ncore_controller.platform.initialize();\n\nvar src = core_controller;\nif (typeof window !== 'undefined') {\n\twindow.Chart = core_controller;\n}\n\n// DEPRECATIONS\n\n/**\n * Provided for backward compatibility, not available anymore\n * @namespace Chart.Chart\n * @deprecated since version 2.8.0\n * @todo remove at version 3\n * @private\n */\ncore_controller.Chart = core_controller;\n\n/**\n * Provided for backward compatibility, not available anymore\n * @namespace Chart.Legend\n * @deprecated since version 2.1.5\n * @todo remove at version 3\n * @private\n */\ncore_controller.Legend = plugins.legend._element;\n\n/**\n * Provided for backward compatibility, not available anymore\n * @namespace Chart.Title\n * @deprecated since version 2.1.5\n * @todo remove at version 3\n * @private\n */\ncore_controller.Title = plugins.title._element;\n\n/**\n * Provided for backward compatibility, use Chart.plugins instead\n * @namespace Chart.pluginService\n * @deprecated since version 2.1.5\n * @todo remove at version 3\n * @private\n */\ncore_controller.pluginService = core_controller.plugins;\n\n/**\n * Provided for backward compatibility, inheriting from Chart.PlugingBase has no\n * effect, instead simply create/register plugins via plain JavaScript objects.\n * @interface Chart.PluginBase\n * @deprecated since version 2.5.0\n * @todo remove at version 3\n * @private\n */\ncore_controller.PluginBase = core_controller.Element.extend({});\n\n/**\n * Provided for backward compatibility, use Chart.helpers.canvas instead.\n * @namespace Chart.canvasHelpers\n * @deprecated since version 2.6.0\n * @todo remove at version 3\n * @private\n */\ncore_controller.canvasHelpers = core_controller.helpers.canvas;\n\n/**\n * Provided for backward compatibility, use Chart.layouts instead.\n * @namespace Chart.layoutService\n * @deprecated since version 2.7.3\n * @todo remove at version 3\n * @private\n */\ncore_controller.layoutService = core_controller.layouts;\n\n/**\n * Provided for backward compatibility, not available anymore.\n * @namespace Chart.LinearScaleBase\n * @deprecated since version 2.8\n * @todo remove at version 3\n * @private\n */\ncore_controller.LinearScaleBase = scale_linearbase;\n\n/**\n * Provided for backward compatibility, instead we should create a new Chart\n * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).\n * @deprecated since version 2.8.0\n * @todo remove at version 3\n */\ncore_controller.helpers.each(\n\t[\n\t\t'Bar',\n\t\t'Bubble',\n\t\t'Doughnut',\n\t\t'Line',\n\t\t'PolarArea',\n\t\t'Radar',\n\t\t'Scatter'\n\t],\n\tfunction(klass) {\n\t\tcore_controller[klass] = function(ctx, cfg) {\n\t\t\treturn new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {\n\t\t\t\ttype: klass.charAt(0).toLowerCase() + klass.slice(1)\n\t\t\t}));\n\t\t};\n\t}\n);\n\nreturn src;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/chart.js/dist/Chart.js\n// module id = 245\n// module chunks = 35783957827783","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_DataView.js\n// module id = 360\n// module chunks = 35783957827783","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_Hash.js\n// module id = 361\n// module chunks = 35783957827783","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_Promise.js\n// module id = 362\n// module chunks = 35783957827783","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_Set.js\n// module id = 363\n// module chunks = 35783957827783","var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_SetCache.js\n// module id = 364\n// module chunks = 35783957827783","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_Uint8Array.js\n// module id = 365\n// module chunks = 35783957827783","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_WeakMap.js\n// module id = 366\n// module chunks = 35783957827783","/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayAggregator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_arrayAggregator.js\n// module id = 367\n// module chunks = 35783957827783","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_arrayFilter.js\n// module id = 368\n// module chunks = 35783957827783","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_arrayLikeKeys.js\n// module id = 369\n// module chunks = 35783957827783","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_arrayMap.js\n// module id = 370\n// module chunks = 35783957827783","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_arrayPush.js\n// module id = 371\n// module chunks = 35783957827783","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_arraySome.js\n// module id = 372\n// module chunks = 35783957827783","var baseEach = require('./_baseEach');\n\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  baseEach(collection, function(value, key, collection) {\n    setter(accumulator, value, iteratee(value), collection);\n  });\n  return accumulator;\n}\n\nmodule.exports = baseAggregator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseAggregator.js\n// module id = 373\n// module chunks = 35783957827783","var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseAssignValue.js\n// module id = 374\n// module chunks = 35783957827783","var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseEach.js\n// module id = 375\n// module chunks = 35783957827783","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseFor.js\n// module id = 376\n// module chunks = 35783957827783","var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseForOwn.js\n// module id = 377\n// module chunks = 35783957827783","var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseGetAllKeys.js\n// module id = 378\n// module chunks = 35783957827783","/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseHasIn.js\n// module id = 379\n// module chunks = 35783957827783","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseIsArguments.js\n// module id = 380\n// module chunks = 35783957827783","var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseIsEqualDeep.js\n// module id = 381\n// module chunks = 35783957827783","var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseIsMatch.js\n// module id = 382\n// module chunks = 35783957827783","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseIsNative.js\n// module id = 383\n// module chunks = 35783957827783","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseIsTypedArray.js\n// module id = 384\n// module chunks = 35783957827783","var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseIteratee.js\n// module id = 385\n// module chunks = 35783957827783","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseKeys.js\n// module id = 386\n// module chunks = 35783957827783","var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseMatches.js\n// module id = 387\n// module chunks = 35783957827783","var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseMatchesProperty.js\n// module id = 388\n// module chunks = 35783957827783","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseProperty.js\n// module id = 389\n// module chunks = 35783957827783","var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_basePropertyDeep.js\n// module id = 390\n// module chunks = 35783957827783","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseTimes.js\n// module id = 391\n// module chunks = 35783957827783","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseToString.js\n// module id = 392\n// module chunks = 35783957827783","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_baseUnary.js\n// module id = 393\n// module chunks = 35783957827783","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_cacheHas.js\n// module id = 394\n// module chunks = 35783957827783","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_coreJsData.js\n// module id = 395\n// module chunks = 35783957827783","var arrayAggregator = require('./_arrayAggregator'),\n    baseAggregator = require('./_baseAggregator'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray');\n\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = isArray(collection) ? arrayAggregator : baseAggregator,\n        accumulator = initializer ? initializer() : {};\n\n    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\n  };\n}\n\nmodule.exports = createAggregator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_createAggregator.js\n// module id = 396\n// module chunks = 35783957827783","var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_createBaseEach.js\n// module id = 397\n// module chunks = 35783957827783","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_createBaseFor.js\n// module id = 398\n// module chunks = 35783957827783","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_defineProperty.js\n// module id = 399\n// module chunks = 35783957827783","var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_equalByTag.js\n// module id = 400\n// module chunks = 35783957827783","var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_equalObjects.js\n// module id = 401\n// module chunks = 35783957827783","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_getAllKeys.js\n// module id = 402\n// module chunks = 35783957827783","var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_getMatchData.js\n// module id = 403\n// module chunks = 35783957827783","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_getRawTag.js\n// module id = 404\n// module chunks = 35783957827783","var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_getSymbols.js\n// module id = 405\n// module chunks = 35783957827783","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_getTag.js\n// module id = 406\n// module chunks = 35783957827783","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_getValue.js\n// module id = 407\n// module chunks = 35783957827783","var castPath = require('./_castPath'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isIndex = require('./_isIndex'),\n    isLength = require('./isLength'),\n    toKey = require('./_toKey');\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_hasPath.js\n// module id = 408\n// module chunks = 35783957827783","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_hashClear.js\n// module id = 409\n// module chunks = 35783957827783","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_hashDelete.js\n// module id = 410\n// module chunks = 35783957827783","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_hashGet.js\n// module id = 411\n// module chunks = 35783957827783","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_hashHas.js\n// module id = 412\n// module chunks = 35783957827783","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_hashSet.js\n// module id = 413\n// module chunks = 35783957827783","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_isKeyable.js\n// module id = 414\n// module chunks = 35783957827783","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_isMasked.js\n// module id = 415\n// module chunks = 35783957827783","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_isPrototype.js\n// module id = 416\n// module chunks = 35783957827783","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_listCacheClear.js\n// module id = 417\n// module chunks = 35783957827783","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_listCacheDelete.js\n// module id = 418\n// module chunks = 35783957827783","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_listCacheGet.js\n// module id = 419\n// module chunks = 35783957827783","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_listCacheHas.js\n// module id = 420\n// module chunks = 35783957827783","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_listCacheSet.js\n// module id = 421\n// module chunks = 35783957827783","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_mapCacheClear.js\n// module id = 422\n// module chunks = 35783957827783","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_mapCacheDelete.js\n// module id = 423\n// module chunks = 35783957827783","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_mapCacheGet.js\n// module id = 424\n// module chunks = 35783957827783","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_mapCacheHas.js\n// module id = 425\n// module chunks = 35783957827783","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_mapCacheSet.js\n// module id = 426\n// module chunks = 35783957827783","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_mapToArray.js\n// module id = 427\n// module chunks = 35783957827783","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_memoizeCapped.js\n// module id = 428\n// module chunks = 35783957827783","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_nativeKeys.js\n// module id = 429\n// module chunks = 35783957827783","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_nodeUtil.js\n// module id = 430\n// module chunks = 35783957827783","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_objectToString.js\n// module id = 431\n// module chunks = 35783957827783","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_overArg.js\n// module id = 432\n// module chunks = 35783957827783","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_setCacheAdd.js\n// module id = 433\n// module chunks = 35783957827783","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_setCacheHas.js\n// module id = 434\n// module chunks = 35783957827783","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_setToArray.js\n// module id = 435\n// module chunks = 35783957827783","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_stackClear.js\n// module id = 436\n// module chunks = 35783957827783","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_stackDelete.js\n// module id = 437\n// module chunks = 35783957827783","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_stackGet.js\n// module id = 438\n// module chunks = 35783957827783","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_stackHas.js\n// module id = 439\n// module chunks = 35783957827783","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_stackSet.js\n// module id = 440\n// module chunks = 35783957827783","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/_stringToPath.js\n// module id = 441\n// module chunks = 35783957827783","var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/get.js\n// module id = 442\n// module chunks = 35783957827783","var baseHasIn = require('./_baseHasIn'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/hasIn.js\n// module id = 443\n// module chunks = 35783957827783","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/identity.js\n// module id = 444\n// module chunks = 35783957827783","var baseIsEqual = require('./_baseIsEqual');\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\nmodule.exports = isEqual;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/isEqual.js\n// module id = 445\n// module chunks = 35783957827783","var baseAssignValue = require('./_baseAssignValue'),\n    createAggregator = require('./_createAggregator');\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The corresponding value of\n * each key is the last element responsible for generating the key. The\n * iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * var array = [\n *   { 'dir': 'left', 'code': 97 },\n *   { 'dir': 'right', 'code': 100 }\n * ];\n *\n * _.keyBy(array, function(o) {\n *   return String.fromCharCode(o.code);\n * });\n * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n *\n * _.keyBy(array, 'dir');\n * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n */\nvar keyBy = createAggregator(function(result, value, key) {\n  baseAssignValue(result, key, value);\n});\n\nmodule.exports = keyBy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/keyBy.js\n// module id = 446\n// module chunks = 35783957827783","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/memoize.js\n// module id = 447\n// module chunks = 35783957827783","var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/property.js\n// module id = 448\n// module chunks = 35783957827783","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/stubArray.js\n// module id = 449\n// module chunks = 35783957827783","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/stubFalse.js\n// module id = 450\n// module chunks = 35783957827783","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lodash/toString.js\n// module id = 451\n// module chunks = 35783957827783","//! moment.js\n\n;(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    global.moment = factory()\n}(this, (function () { 'use strict';\n\n    var hookCallback;\n\n    function hooks () {\n        return hookCallback.apply(null, arguments);\n    }\n\n    // This is done to register the method called with moment()\n    // without creating circular dependencies.\n    function setHookCallback (callback) {\n        hookCallback = callback;\n    }\n\n    function isArray(input) {\n        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n    }\n\n    function isObject(input) {\n        // IE8 will treat undefined and null as object if it wasn't for\n        // input != null\n        return input != null && Object.prototype.toString.call(input) === '[object Object]';\n    }\n\n    function isObjectEmpty(obj) {\n        if (Object.getOwnPropertyNames) {\n            return (Object.getOwnPropertyNames(obj).length === 0);\n        } else {\n            var k;\n            for (k in obj) {\n                if (obj.hasOwnProperty(k)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    function isUndefined(input) {\n        return input === void 0;\n    }\n\n    function isNumber(input) {\n        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n    }\n\n    function isDate(input) {\n        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n    }\n\n    function map(arr, fn) {\n        var res = [], i;\n        for (i = 0; i < arr.length; ++i) {\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n\n    function extend(a, b) {\n        for (var i in b) {\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n\n        if (hasOwnProp(b, 'toString')) {\n            a.toString = b.toString;\n        }\n\n        if (hasOwnProp(b, 'valueOf')) {\n            a.valueOf = b.valueOf;\n        }\n\n        return a;\n    }\n\n    function createUTC (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\n    }\n\n    function defaultParsingFlags() {\n        // We need to deep clone this object.\n        return {\n            empty           : false,\n            unusedTokens    : [],\n            unusedInput     : [],\n            overflow        : -2,\n            charsLeftOver   : 0,\n            nullInput       : false,\n            invalidMonth    : null,\n            invalidFormat   : false,\n            userInvalidated : false,\n            iso             : false,\n            parsedDateParts : [],\n            meridiem        : null,\n            rfc2822         : false,\n            weekdayMismatch : false\n        };\n    }\n\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n\n    var some;\n    if (Array.prototype.some) {\n        some = Array.prototype.some;\n    } else {\n        some = function (fun) {\n            var t = Object(this);\n            var len = t.length >>> 0;\n\n            for (var i = 0; i < len; i++) {\n                if (i in t && fun.call(this, t[i], i, t)) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    }\n\n    function isValid(m) {\n        if (m._isValid == null) {\n            var flags = getParsingFlags(m);\n            var parsedParts = some.call(flags.parsedDateParts, function (i) {\n                return i != null;\n            });\n            var isNowValid = !isNaN(m._d.getTime()) &&\n                flags.overflow < 0 &&\n                !flags.empty &&\n                !flags.invalidMonth &&\n                !flags.invalidWeekday &&\n                !flags.weekdayMismatch &&\n                !flags.nullInput &&\n                !flags.invalidFormat &&\n                !flags.userInvalidated &&\n                (!flags.meridiem || (flags.meridiem && parsedParts));\n\n            if (m._strict) {\n                isNowValid = isNowValid &&\n                    flags.charsLeftOver === 0 &&\n                    flags.unusedTokens.length === 0 &&\n                    flags.bigHour === undefined;\n            }\n\n            if (Object.isFrozen == null || !Object.isFrozen(m)) {\n                m._isValid = isNowValid;\n            }\n            else {\n                return isNowValid;\n            }\n        }\n        return m._isValid;\n    }\n\n    function createInvalid (flags) {\n        var m = createUTC(NaN);\n        if (flags != null) {\n            extend(getParsingFlags(m), flags);\n        }\n        else {\n            getParsingFlags(m).userInvalidated = true;\n        }\n\n        return m;\n    }\n\n    // Plugins that add properties should also add the key here (null value),\n    // so we can properly clone ourselves.\n    var momentProperties = hooks.momentProperties = [];\n\n    function copyConfig(to, from) {\n        var i, prop, val;\n\n        if (!isUndefined(from._isAMomentObject)) {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (!isUndefined(from._i)) {\n            to._i = from._i;\n        }\n        if (!isUndefined(from._f)) {\n            to._f = from._f;\n        }\n        if (!isUndefined(from._l)) {\n            to._l = from._l;\n        }\n        if (!isUndefined(from._strict)) {\n            to._strict = from._strict;\n        }\n        if (!isUndefined(from._tzm)) {\n            to._tzm = from._tzm;\n        }\n        if (!isUndefined(from._isUTC)) {\n            to._isUTC = from._isUTC;\n        }\n        if (!isUndefined(from._offset)) {\n            to._offset = from._offset;\n        }\n        if (!isUndefined(from._pf)) {\n            to._pf = getParsingFlags(from);\n        }\n        if (!isUndefined(from._locale)) {\n            to._locale = from._locale;\n        }\n\n        if (momentProperties.length > 0) {\n            for (i = 0; i < momentProperties.length; i++) {\n                prop = momentProperties[i];\n                val = from[prop];\n                if (!isUndefined(val)) {\n                    to[prop] = val;\n                }\n            }\n        }\n\n        return to;\n    }\n\n    var updateInProgress = false;\n\n    // Moment prototype object\n    function Moment(config) {\n        copyConfig(this, config);\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        if (!this.isValid()) {\n            this._d = new Date(NaN);\n        }\n        // Prevent infinite loop in case updateOffset creates new moment\n        // objects.\n        if (updateInProgress === false) {\n            updateInProgress = true;\n            hooks.updateOffset(this);\n            updateInProgress = false;\n        }\n    }\n\n    function isMoment (obj) {\n        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n    }\n\n    function absFloor (number) {\n        if (number < 0) {\n            // -0 -> 0\n            return Math.ceil(number) || 0;\n        } else {\n            return Math.floor(number);\n        }\n    }\n\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion,\n            value = 0;\n\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value = absFloor(coercedNumber);\n        }\n\n        return value;\n    }\n\n    // compare two arrays, return the number of differences\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length),\n            lengthDiff = Math.abs(array1.length - array2.length),\n            diffs = 0,\n            i;\n        for (i = 0; i < len; i++) {\n            if ((dontConvert && array1[i] !== array2[i]) ||\n                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n\n    function warn(msg) {\n        if (hooks.suppressDeprecationWarnings === false &&\n                (typeof console !==  'undefined') && console.warn) {\n            console.warn('Deprecation warning: ' + msg);\n        }\n    }\n\n    function deprecate(msg, fn) {\n        var firstTime = true;\n\n        return extend(function () {\n            if (hooks.deprecationHandler != null) {\n                hooks.deprecationHandler(null, msg);\n            }\n            if (firstTime) {\n                var args = [];\n                var arg;\n                for (var i = 0; i < arguments.length; i++) {\n                    arg = '';\n                    if (typeof arguments[i] === 'object') {\n                        arg += '\\n[' + i + '] ';\n                        for (var key in arguments[0]) {\n                            arg += key + ': ' + arguments[0][key] + ', ';\n                        }\n                        arg = arg.slice(0, -2); // Remove trailing comma and space\n                    } else {\n                        arg = arguments[i];\n                    }\n                    args.push(arg);\n                }\n                warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + (new Error()).stack);\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n\n    var deprecations = {};\n\n    function deprecateSimple(name, msg) {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(name, msg);\n        }\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n\n    hooks.suppressDeprecationWarnings = false;\n    hooks.deprecationHandler = null;\n\n    function isFunction(input) {\n        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n    }\n\n    function set (config) {\n        var prop, i;\n        for (i in config) {\n            prop = config[i];\n            if (isFunction(prop)) {\n                this[i] = prop;\n            } else {\n                this['_' + i] = prop;\n            }\n        }\n        this._config = config;\n        // Lenient ordinal parsing accepts just a number in addition to\n        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        this._dayOfMonthOrdinalParseLenient = new RegExp(\n            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\n                '|' + (/\\d{1,2}/).source);\n    }\n\n    function mergeConfigs(parentConfig, childConfig) {\n        var res = extend({}, parentConfig), prop;\n        for (prop in childConfig) {\n            if (hasOwnProp(childConfig, prop)) {\n                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                    res[prop] = {};\n                    extend(res[prop], parentConfig[prop]);\n                    extend(res[prop], childConfig[prop]);\n                } else if (childConfig[prop] != null) {\n                    res[prop] = childConfig[prop];\n                } else {\n                    delete res[prop];\n                }\n            }\n        }\n        for (prop in parentConfig) {\n            if (hasOwnProp(parentConfig, prop) &&\n                    !hasOwnProp(childConfig, prop) &&\n                    isObject(parentConfig[prop])) {\n                // make sure changes to properties don't modify parent config\n                res[prop] = extend({}, res[prop]);\n            }\n        }\n        return res;\n    }\n\n    function Locale(config) {\n        if (config != null) {\n            this.set(config);\n        }\n    }\n\n    var keys;\n\n    if (Object.keys) {\n        keys = Object.keys;\n    } else {\n        keys = function (obj) {\n            var i, res = [];\n            for (i in obj) {\n                if (hasOwnProp(obj, i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        };\n    }\n\n    var defaultCalendar = {\n        sameDay : '[Today at] LT',\n        nextDay : '[Tomorrow at] LT',\n        nextWeek : 'dddd [at] LT',\n        lastDay : '[Yesterday at] LT',\n        lastWeek : '[Last] dddd [at] LT',\n        sameElse : 'L'\n    };\n\n    function calendar (key, mom, now) {\n        var output = this._calendar[key] || this._calendar['sameElse'];\n        return isFunction(output) ? output.call(mom, now) : output;\n    }\n\n    var defaultLongDateFormat = {\n        LTS  : 'h:mm:ss A',\n        LT   : 'h:mm A',\n        L    : 'MM/DD/YYYY',\n        LL   : 'MMMM D, YYYY',\n        LLL  : 'MMMM D, YYYY h:mm A',\n        LLLL : 'dddd, MMMM D, YYYY h:mm A'\n    };\n\n    function longDateFormat (key) {\n        var format = this._longDateFormat[key],\n            formatUpper = this._longDateFormat[key.toUpperCase()];\n\n        if (format || !formatUpper) {\n            return format;\n        }\n\n        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n            return val.slice(1);\n        });\n\n        return this._longDateFormat[key];\n    }\n\n    var defaultInvalidDate = 'Invalid date';\n\n    function invalidDate () {\n        return this._invalidDate;\n    }\n\n    var defaultOrdinal = '%d';\n    var defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\n    function ordinal (number) {\n        return this._ordinal.replace('%d', number);\n    }\n\n    var defaultRelativeTime = {\n        future : 'in %s',\n        past   : '%s ago',\n        s  : 'a few seconds',\n        ss : '%d seconds',\n        m  : 'a minute',\n        mm : '%d minutes',\n        h  : 'an hour',\n        hh : '%d hours',\n        d  : 'a day',\n        dd : '%d days',\n        M  : 'a month',\n        MM : '%d months',\n        y  : 'a year',\n        yy : '%d years'\n    };\n\n    function relativeTime (number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n        return (isFunction(output)) ?\n            output(number, withoutSuffix, string, isFuture) :\n            output.replace(/%d/i, number);\n    }\n\n    function pastFuture (diff, output) {\n        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n    }\n\n    var aliases = {};\n\n    function addUnitAlias (unit, shorthand) {\n        var lowerCase = unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n    }\n\n    function normalizeUnits(units) {\n        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n    }\n\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {},\n            normalizedProp,\n            prop;\n\n        for (prop in inputObject) {\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n\n        return normalizedInput;\n    }\n\n    var priorities = {};\n\n    function addUnitPriority(unit, priority) {\n        priorities[unit] = priority;\n    }\n\n    function getPrioritizedUnits(unitsObj) {\n        var units = [];\n        for (var u in unitsObj) {\n            units.push({unit: u, priority: priorities[u]});\n        }\n        units.sort(function (a, b) {\n            return a.priority - b.priority;\n        });\n        return units;\n    }\n\n    function zeroFill(number, targetLength, forceSign) {\n        var absNumber = '' + Math.abs(number),\n            zerosToFill = targetLength - absNumber.length,\n            sign = number >= 0;\n        return (sign ? (forceSign ? '+' : '') : '-') +\n            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n    }\n\n    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\n    var localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\n    var formatFunctions = {};\n\n    var formatTokenFunctions = {};\n\n    // token:    'M'\n    // padded:   ['MM', 2]\n    // ordinal:  'Mo'\n    // callback: function () { this.month() + 1 }\n    function addFormatToken (token, padded, ordinal, callback) {\n        var func = callback;\n        if (typeof callback === 'string') {\n            func = function () {\n                return this[callback]();\n            };\n        }\n        if (token) {\n            formatTokenFunctions[token] = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]] = function () {\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal] = function () {\n                return this.localeData().ordinal(func.apply(this, arguments), token);\n            };\n        }\n    }\n\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, '');\n        }\n        return input.replace(/\\\\/g, '');\n    }\n\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens), i, length;\n\n        for (i = 0, length = array.length; i < length; i++) {\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n\n        return function (mom) {\n            var output = '', i;\n            for (i = 0; i < length; i++) {\n                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n            }\n            return output;\n        };\n    }\n\n    // format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\n        return formatFunctions[format](m);\n    }\n\n    function expandFormat(format, locale) {\n        var i = 5;\n\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n\n        localFormattingTokens.lastIndex = 0;\n        while (i >= 0 && localFormattingTokens.test(format)) {\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n\n        return format;\n    }\n\n    var match1         = /\\d/;            //       0 - 9\n    var match2         = /\\d\\d/;          //      00 - 99\n    var match3         = /\\d{3}/;         //     000 - 999\n    var match4         = /\\d{4}/;         //    0000 - 9999\n    var match6         = /[+-]?\\d{6}/;    // -999999 - 999999\n    var match1to2      = /\\d\\d?/;         //       0 - 99\n    var match3to4      = /\\d\\d\\d\\d?/;     //     999 - 9999\n    var match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999\n    var match1to3      = /\\d{1,3}/;       //       0 - 999\n    var match1to4      = /\\d{1,4}/;       //       0 - 9999\n    var match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\n    var matchUnsigned  = /\\d+/;           //       0 - inf\n    var matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\n    var matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\n    var matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n\n    var matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\n    // any word (or two) characters or numbers including two/three word month in arabic.\n    // includes scottish gaelic two word and hyphenated months\n    var matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i;\n\n    var regexes = {};\n\n    function addRegexToken (token, regex, strictRegex) {\n        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n            return (isStrict && strictRegex) ? strictRegex : regex;\n        };\n    }\n\n    function getParseRegexForToken (token, config) {\n        if (!hasOwnProp(regexes, token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n\n        return regexes[token](config._strict, config._locale);\n    }\n\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function unescapeFormat(s) {\n        return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n            return p1 || p2 || p3 || p4;\n        }));\n    }\n\n    function regexEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    }\n\n    var tokens = {};\n\n    function addParseToken (token, callback) {\n        var i, func = callback;\n        if (typeof token === 'string') {\n            token = [token];\n        }\n        if (isNumber(callback)) {\n            func = function (input, array) {\n                array[callback] = toInt(input);\n            };\n        }\n        for (i = 0; i < token.length; i++) {\n            tokens[token[i]] = func;\n        }\n    }\n\n    function addWeekParseToken (token, callback) {\n        addParseToken(token, function (input, array, config, token) {\n            config._w = config._w || {};\n            callback(input, config._w, config, token);\n        });\n    }\n\n    function addTimeToArrayFromToken(token, input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n            tokens[token](input, config._a, config, token);\n        }\n    }\n\n    var YEAR = 0;\n    var MONTH = 1;\n    var DATE = 2;\n    var HOUR = 3;\n    var MINUTE = 4;\n    var SECOND = 5;\n    var MILLISECOND = 6;\n    var WEEK = 7;\n    var WEEKDAY = 8;\n\n    // FORMATTING\n\n    addFormatToken('Y', 0, 0, function () {\n        var y = this.year();\n        return y <= 9999 ? '' + y : '+' + y;\n    });\n\n    addFormatToken(0, ['YY', 2], 0, function () {\n        return this.year() % 100;\n    });\n\n    addFormatToken(0, ['YYYY',   4],       0, 'year');\n    addFormatToken(0, ['YYYYY',  5],       0, 'year');\n    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n    // ALIASES\n\n    addUnitAlias('year', 'y');\n\n    // PRIORITIES\n\n    addUnitPriority('year', 1);\n\n    // PARSING\n\n    addRegexToken('Y',      matchSigned);\n    addRegexToken('YY',     match1to2, match2);\n    addRegexToken('YYYY',   match1to4, match4);\n    addRegexToken('YYYYY',  match1to6, match6);\n    addRegexToken('YYYYYY', match1to6, match6);\n\n    addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n    addParseToken('YYYY', function (input, array) {\n        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n    addParseToken('YY', function (input, array) {\n        array[YEAR] = hooks.parseTwoDigitYear(input);\n    });\n    addParseToken('Y', function (input, array) {\n        array[YEAR] = parseInt(input, 10);\n    });\n\n    // HELPERS\n\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n\n    function isLeapYear(year) {\n        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n    }\n\n    // HOOKS\n\n    hooks.parseTwoDigitYear = function (input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n\n    // MOMENTS\n\n    var getSetYear = makeGetSet('FullYear', true);\n\n    function getIsLeapYear () {\n        return isLeapYear(this.year());\n    }\n\n    function makeGetSet (unit, keepTime) {\n        return function (value) {\n            if (value != null) {\n                set$1(this, unit, value);\n                hooks.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return get(this, unit);\n            }\n        };\n    }\n\n    function get (mom, unit) {\n        return mom.isValid() ?\n            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n    }\n\n    function set$1 (mom, unit, value) {\n        if (mom.isValid() && !isNaN(value)) {\n            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));\n            }\n            else {\n                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function stringGet (units) {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units]();\n        }\n        return this;\n    }\n\n\n    function stringSet (units, value) {\n        if (typeof units === 'object') {\n            units = normalizeObjectUnits(units);\n            var prioritized = getPrioritizedUnits(units);\n            for (var i = 0; i < prioritized.length; i++) {\n                this[prioritized[i].unit](units[prioritized[i].unit]);\n            }\n        } else {\n            units = normalizeUnits(units);\n            if (isFunction(this[units])) {\n                return this[units](value);\n            }\n        }\n        return this;\n    }\n\n    function mod(n, x) {\n        return ((n % x) + x) % x;\n    }\n\n    var indexOf;\n\n    if (Array.prototype.indexOf) {\n        indexOf = Array.prototype.indexOf;\n    } else {\n        indexOf = function (o) {\n            // I know\n            var i;\n            for (i = 0; i < this.length; ++i) {\n                if (this[i] === o) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n    }\n\n    function daysInMonth(year, month) {\n        if (isNaN(year) || isNaN(month)) {\n            return NaN;\n        }\n        var modMonth = mod(month, 12);\n        year += (month - modMonth) / 12;\n        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);\n    }\n\n    // FORMATTING\n\n    addFormatToken('M', ['MM', 2], 'Mo', function () {\n        return this.month() + 1;\n    });\n\n    addFormatToken('MMM', 0, 0, function (format) {\n        return this.localeData().monthsShort(this, format);\n    });\n\n    addFormatToken('MMMM', 0, 0, function (format) {\n        return this.localeData().months(this, format);\n    });\n\n    // ALIASES\n\n    addUnitAlias('month', 'M');\n\n    // PRIORITY\n\n    addUnitPriority('month', 8);\n\n    // PARSING\n\n    addRegexToken('M',    match1to2);\n    addRegexToken('MM',   match1to2, match2);\n    addRegexToken('MMM',  function (isStrict, locale) {\n        return locale.monthsShortRegex(isStrict);\n    });\n    addRegexToken('MMMM', function (isStrict, locale) {\n        return locale.monthsRegex(isStrict);\n    });\n\n    addParseToken(['M', 'MM'], function (input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n\n    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n        var month = config._locale.monthsParse(input, token, config._strict);\n        // if we didn't find a month name, mark the date as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n        } else {\n            getParsingFlags(config).invalidMonth = input;\n        }\n    });\n\n    // LOCALES\n\n    var MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/;\n    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\n    function localeMonths (m, format) {\n        if (!m) {\n            return isArray(this._months) ? this._months :\n                this._months['standalone'];\n        }\n        return isArray(this._months) ? this._months[m.month()] :\n            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n    }\n\n    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\n    function localeMonthsShort (m, format) {\n        if (!m) {\n            return isArray(this._monthsShort) ? this._monthsShort :\n                this._monthsShort['standalone'];\n        }\n        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\n            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n    }\n\n    function handleStrictParse(monthName, format, strict) {\n        var i, ii, mom, llc = monthName.toLocaleLowerCase();\n        if (!this._monthsParse) {\n            // this is not used\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n            for (i = 0; i < 12; ++i) {\n                mom = createUTC([2000, i]);\n                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'MMM') {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeMonthsParse (monthName, format, strict) {\n        var i, mom, regex;\n\n        if (this._monthsParseExact) {\n            return handleStrictParse.call(this, monthName, format, strict);\n        }\n\n        if (!this._monthsParse) {\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n        }\n\n        // TODO: add sorting\n        // Sorting makes sure if one month (or abbr) is a prefix of another\n        // see sorting in computeMonthsParse\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            if (strict && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n            }\n            if (!strict && !this._monthsParse[i]) {\n                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function setMonth (mom, value) {\n        var dayOfMonth;\n\n        if (!mom.isValid()) {\n            // No op\n            return mom;\n        }\n\n        if (typeof value === 'string') {\n            if (/^\\d+$/.test(value)) {\n                value = toInt(value);\n            } else {\n                value = mom.localeData().monthsParse(value);\n                // TODO: Another silent failure?\n                if (!isNumber(value)) {\n                    return mom;\n                }\n            }\n        }\n\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n        return mom;\n    }\n\n    function getSetMonth (value) {\n        if (value != null) {\n            setMonth(this, value);\n            hooks.updateOffset(this, true);\n            return this;\n        } else {\n            return get(this, 'Month');\n        }\n    }\n\n    function getDaysInMonth () {\n        return daysInMonth(this.year(), this.month());\n    }\n\n    var defaultMonthsShortRegex = matchWord;\n    function monthsShortRegex (isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsShortStrictRegex;\n            } else {\n                return this._monthsShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsShortRegex')) {\n                this._monthsShortRegex = defaultMonthsShortRegex;\n            }\n            return this._monthsShortStrictRegex && isStrict ?\n                this._monthsShortStrictRegex : this._monthsShortRegex;\n        }\n    }\n\n    var defaultMonthsRegex = matchWord;\n    function monthsRegex (isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsStrictRegex;\n            } else {\n                return this._monthsRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_monthsRegex')) {\n                this._monthsRegex = defaultMonthsRegex;\n            }\n            return this._monthsStrictRegex && isStrict ?\n                this._monthsStrictRegex : this._monthsRegex;\n        }\n    }\n\n    function computeMonthsParse () {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var shortPieces = [], longPieces = [], mixedPieces = [],\n            i, mom;\n        for (i = 0; i < 12; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, i]);\n            shortPieces.push(this.monthsShort(mom, ''));\n            longPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.months(mom, ''));\n            mixedPieces.push(this.monthsShort(mom, ''));\n        }\n        // Sorting makes sure if one month (or abbr) is a prefix of another it\n        // will match the longer piece.\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 12; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n        }\n        for (i = 0; i < 24; i++) {\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n\n        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._monthsShortRegex = this._monthsRegex;\n        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n    }\n\n    function createDate (y, m, d, h, M, s, ms) {\n        // can't just apply() to create a date:\n        // https://stackoverflow.com/q/181348\n        var date;\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            date = new Date(y + 400, m, d, h, M, s, ms);\n            if (isFinite(date.getFullYear())) {\n                date.setFullYear(y);\n            }\n        } else {\n            date = new Date(y, m, d, h, M, s, ms);\n        }\n\n        return date;\n    }\n\n    function createUTCDate (y) {\n        var date;\n        // the Date.UTC function remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            var args = Array.prototype.slice.call(arguments);\n            // preserve leap years using a full 400 year cycle, then reset\n            args[0] = y + 400;\n            date = new Date(Date.UTC.apply(null, args));\n            if (isFinite(date.getUTCFullYear())) {\n                date.setUTCFullYear(y);\n            }\n        } else {\n            date = new Date(Date.UTC.apply(null, arguments));\n        }\n\n        return date;\n    }\n\n    // start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n            fwd = 7 + dow - doy,\n            // first-week day local weekday -- which local weekday is fwd\n            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\n        return -fwdlw + fwd - 1;\n    }\n\n    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n        var localWeekday = (7 + weekday - dow) % 7,\n            weekOffset = firstWeekOffset(year, dow, doy),\n            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n            resYear, resDayOfYear;\n\n        if (dayOfYear <= 0) {\n            resYear = year - 1;\n            resDayOfYear = daysInYear(resYear) + dayOfYear;\n        } else if (dayOfYear > daysInYear(year)) {\n            resYear = year + 1;\n            resDayOfYear = dayOfYear - daysInYear(year);\n        } else {\n            resYear = year;\n            resDayOfYear = dayOfYear;\n        }\n\n        return {\n            year: resYear,\n            dayOfYear: resDayOfYear\n        };\n    }\n\n    function weekOfYear(mom, dow, doy) {\n        var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n            resWeek, resYear;\n\n        if (week < 1) {\n            resYear = mom.year() - 1;\n            resWeek = week + weeksInYear(resYear, dow, doy);\n        } else if (week > weeksInYear(mom.year(), dow, doy)) {\n            resWeek = week - weeksInYear(mom.year(), dow, doy);\n            resYear = mom.year() + 1;\n        } else {\n            resYear = mom.year();\n            resWeek = week;\n        }\n\n        return {\n            week: resWeek,\n            year: resYear\n        };\n    }\n\n    function weeksInYear(year, dow, doy) {\n        var weekOffset = firstWeekOffset(year, dow, doy),\n            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n    }\n\n    // FORMATTING\n\n    addFormatToken('w', ['ww', 2], 'wo', 'week');\n    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n    // ALIASES\n\n    addUnitAlias('week', 'w');\n    addUnitAlias('isoWeek', 'W');\n\n    // PRIORITIES\n\n    addUnitPriority('week', 5);\n    addUnitPriority('isoWeek', 5);\n\n    // PARSING\n\n    addRegexToken('w',  match1to2);\n    addRegexToken('ww', match1to2, match2);\n    addRegexToken('W',  match1to2);\n    addRegexToken('WW', match1to2, match2);\n\n    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n        week[token.substr(0, 1)] = toInt(input);\n    });\n\n    // HELPERS\n\n    // LOCALES\n\n    function localeWeek (mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    }\n\n    var defaultLocaleWeek = {\n        dow : 0, // Sunday is the first day of the week.\n        doy : 6  // The week that contains Jan 6th is the first week of the year.\n    };\n\n    function localeFirstDayOfWeek () {\n        return this._week.dow;\n    }\n\n    function localeFirstDayOfYear () {\n        return this._week.doy;\n    }\n\n    // MOMENTS\n\n    function getSetWeek (input) {\n        var week = this.localeData().week(this);\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    function getSetISOWeek (input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input == null ? week : this.add((input - week) * 7, 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('d', 0, 'do', 'day');\n\n    addFormatToken('dd', 0, 0, function (format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n\n    addFormatToken('ddd', 0, 0, function (format) {\n        return this.localeData().weekdaysShort(this, format);\n    });\n\n    addFormatToken('dddd', 0, 0, function (format) {\n        return this.localeData().weekdays(this, format);\n    });\n\n    addFormatToken('e', 0, 0, 'weekday');\n    addFormatToken('E', 0, 0, 'isoWeekday');\n\n    // ALIASES\n\n    addUnitAlias('day', 'd');\n    addUnitAlias('weekday', 'e');\n    addUnitAlias('isoWeekday', 'E');\n\n    // PRIORITY\n    addUnitPriority('day', 11);\n    addUnitPriority('weekday', 11);\n    addUnitPriority('isoWeekday', 11);\n\n    // PARSING\n\n    addRegexToken('d',    match1to2);\n    addRegexToken('e',    match1to2);\n    addRegexToken('E',    match1to2);\n    addRegexToken('dd',   function (isStrict, locale) {\n        return locale.weekdaysMinRegex(isStrict);\n    });\n    addRegexToken('ddd',   function (isStrict, locale) {\n        return locale.weekdaysShortRegex(isStrict);\n    });\n    addRegexToken('dddd',   function (isStrict, locale) {\n        return locale.weekdaysRegex(isStrict);\n    });\n\n    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n        var weekday = config._locale.weekdaysParse(input, token, config._strict);\n        // if we didn't get a weekday name, mark the date as invalid\n        if (weekday != null) {\n            week.d = weekday;\n        } else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n    });\n\n    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n        week[token] = toInt(input);\n    });\n\n    // HELPERS\n\n    function parseWeekday(input, locale) {\n        if (typeof input !== 'string') {\n            return input;\n        }\n\n        if (!isNaN(input)) {\n            return parseInt(input, 10);\n        }\n\n        input = locale.weekdaysParse(input);\n        if (typeof input === 'number') {\n            return input;\n        }\n\n        return null;\n    }\n\n    function parseIsoWeekday(input, locale) {\n        if (typeof input === 'string') {\n            return locale.weekdaysParse(input) % 7 || 7;\n        }\n        return isNaN(input) ? null : input;\n    }\n\n    // LOCALES\n    function shiftWeekdays (ws, n) {\n        return ws.slice(n, 7).concat(ws.slice(0, n));\n    }\n\n    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\n    function localeWeekdays (m, format) {\n        var weekdays = isArray(this._weekdays) ? this._weekdays :\n            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];\n        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)\n            : (m) ? weekdays[m.day()] : weekdays;\n    }\n\n    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\n    function localeWeekdaysShort (m) {\n        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)\n            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n    }\n\n    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\n    function localeWeekdaysMin (m) {\n        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)\n            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n    }\n\n    function handleStrictParse$1(weekdayName, format, strict) {\n        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._minWeekdaysParse = [];\n\n            for (i = 0; i < 7; ++i) {\n                mom = createUTC([2000, 1]).day(i);\n                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n            }\n        }\n\n        if (strict) {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === 'dddd') {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === 'ddd') {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n\n    function localeWeekdaysParse (weekdayName, format, strict) {\n        var i, mom, regex;\n\n        if (this._weekdaysParseExact) {\n            return handleStrictParse$1.call(this, weekdayName, format, strict);\n        }\n\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._minWeekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._fullWeekdaysParse = [];\n        }\n\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n\n            mom = createUTC([2000, 1]).day(i);\n            if (strict && !this._fullWeekdaysParse[i]) {\n                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\\\.?') + '$', 'i');\n                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\\\.?') + '$', 'i');\n                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\\\.?') + '$', 'i');\n            }\n            if (!this._weekdaysParse[i]) {\n                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n            }\n            // test the regex\n            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n                return i;\n            }\n        }\n    }\n\n    // MOMENTS\n\n    function getSetDayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n        if (input != null) {\n            input = parseWeekday(input, this.localeData());\n            return this.add(input - day, 'd');\n        } else {\n            return day;\n        }\n    }\n\n    function getSetLocaleDayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n        return input == null ? weekday : this.add(input - weekday, 'd');\n    }\n\n    function getSetISODayOfWeek (input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n\n        // behaves the same as moment#day except\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the previous week.\n\n        if (input != null) {\n            var weekday = parseIsoWeekday(input, this.localeData());\n            return this.day(this.day() % 7 ? weekday : weekday - 7);\n        } else {\n            return this.day() || 7;\n        }\n    }\n\n    var defaultWeekdaysRegex = matchWord;\n    function weekdaysRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysStrictRegex;\n            } else {\n                return this._weekdaysRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                this._weekdaysRegex = defaultWeekdaysRegex;\n            }\n            return this._weekdaysStrictRegex && isStrict ?\n                this._weekdaysStrictRegex : this._weekdaysRegex;\n        }\n    }\n\n    var defaultWeekdaysShortRegex = matchWord;\n    function weekdaysShortRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysShortStrictRegex;\n            } else {\n                return this._weekdaysShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n            }\n            return this._weekdaysShortStrictRegex && isStrict ?\n                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n        }\n    }\n\n    var defaultWeekdaysMinRegex = matchWord;\n    function weekdaysMinRegex (isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, '_weekdaysRegex')) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysMinStrictRegex;\n            } else {\n                return this._weekdaysMinRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n            }\n            return this._weekdaysMinStrictRegex && isStrict ?\n                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n        }\n    }\n\n\n    function computeWeekdaysParse () {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n\n        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\n            i, mom, minp, shortp, longp;\n        for (i = 0; i < 7; i++) {\n            // make the regex if we don't have it already\n            mom = createUTC([2000, 1]).day(i);\n            minp = this.weekdaysMin(mom, '');\n            shortp = this.weekdaysShort(mom, '');\n            longp = this.weekdays(mom, '');\n            minPieces.push(minp);\n            shortPieces.push(shortp);\n            longPieces.push(longp);\n            mixedPieces.push(minp);\n            mixedPieces.push(shortp);\n            mixedPieces.push(longp);\n        }\n        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n        // will match the longer piece.\n        minPieces.sort(cmpLenRev);\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for (i = 0; i < 7; i++) {\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n\n        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n        this._weekdaysShortRegex = this._weekdaysRegex;\n        this._weekdaysMinRegex = this._weekdaysRegex;\n\n        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n    }\n\n    // FORMATTING\n\n    function hFormat() {\n        return this.hours() % 12 || 12;\n    }\n\n    function kFormat() {\n        return this.hours() || 24;\n    }\n\n    addFormatToken('H', ['HH', 2], 0, 'hour');\n    addFormatToken('h', ['hh', 2], 0, hFormat);\n    addFormatToken('k', ['kk', 2], 0, kFormat);\n\n    addFormatToken('hmm', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('hmmss', 0, 0, function () {\n        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2);\n    });\n\n    addFormatToken('Hmm', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2);\n    });\n\n    addFormatToken('Hmmss', 0, 0, function () {\n        return '' + this.hours() + zeroFill(this.minutes(), 2) +\n            zeroFill(this.seconds(), 2);\n    });\n\n    function meridiem (token, lowercase) {\n        addFormatToken(token, 0, 0, function () {\n            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n        });\n    }\n\n    meridiem('a', true);\n    meridiem('A', false);\n\n    // ALIASES\n\n    addUnitAlias('hour', 'h');\n\n    // PRIORITY\n    addUnitPriority('hour', 13);\n\n    // PARSING\n\n    function matchMeridiem (isStrict, locale) {\n        return locale._meridiemParse;\n    }\n\n    addRegexToken('a',  matchMeridiem);\n    addRegexToken('A',  matchMeridiem);\n    addRegexToken('H',  match1to2);\n    addRegexToken('h',  match1to2);\n    addRegexToken('k',  match1to2);\n    addRegexToken('HH', match1to2, match2);\n    addRegexToken('hh', match1to2, match2);\n    addRegexToken('kk', match1to2, match2);\n\n    addRegexToken('hmm', match3to4);\n    addRegexToken('hmmss', match5to6);\n    addRegexToken('Hmm', match3to4);\n    addRegexToken('Hmmss', match5to6);\n\n    addParseToken(['H', 'HH'], HOUR);\n    addParseToken(['k', 'kk'], function (input, array, config) {\n        var kInput = toInt(input);\n        array[HOUR] = kInput === 24 ? 0 : kInput;\n    });\n    addParseToken(['a', 'A'], function (input, array, config) {\n        config._isPm = config._locale.isPM(input);\n        config._meridiem = input;\n    });\n    addParseToken(['h', 'hh'], function (input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('hmmss', function (input, array, config) {\n        var pos1 = input.length - 4;\n        var pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken('Hmm', function (input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n    });\n    addParseToken('Hmmss', function (input, array, config) {\n        var pos1 = input.length - 4;\n        var pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n    });\n\n    // LOCALES\n\n    function localeIsPM (input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n        // Using charAt should be more compatible.\n        return ((input + '').toLowerCase().charAt(0) === 'p');\n    }\n\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\n    function localeMeridiem (hours, minutes, isLower) {\n        if (hours > 11) {\n            return isLower ? 'pm' : 'PM';\n        } else {\n            return isLower ? 'am' : 'AM';\n        }\n    }\n\n\n    // MOMENTS\n\n    // Setting the hour should keep the time, because the user explicitly\n    // specified which hour they want. So trying to maintain the same hour (in\n    // a new timezone) makes sense. Adding/subtracting hours does not follow\n    // this rule.\n    var getSetHour = makeGetSet('Hours', true);\n\n    var baseConfig = {\n        calendar: defaultCalendar,\n        longDateFormat: defaultLongDateFormat,\n        invalidDate: defaultInvalidDate,\n        ordinal: defaultOrdinal,\n        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n        relativeTime: defaultRelativeTime,\n\n        months: defaultLocaleMonths,\n        monthsShort: defaultLocaleMonthsShort,\n\n        week: defaultLocaleWeek,\n\n        weekdays: defaultLocaleWeekdays,\n        weekdaysMin: defaultLocaleWeekdaysMin,\n        weekdaysShort: defaultLocaleWeekdaysShort,\n\n        meridiemParse: defaultLocaleMeridiemParse\n    };\n\n    // internal storage for locale config files\n    var locales = {};\n    var localeFamilies = {};\n    var globalLocale;\n\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace('_', '-') : key;\n    }\n\n    // pick the locale from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0, j, next, locale, split;\n\n        while (i < names.length) {\n            split = normalizeLocale(names[i]).split('-');\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split('-') : null;\n            while (j > 0) {\n                locale = loadLocale(split.slice(0, j).join('-'));\n                if (locale) {\n                    return locale;\n                }\n                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n                    //the next array item is better than a shallower substring of this one\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return globalLocale;\n    }\n\n    function loadLocale(name) {\n        var oldLocale = null;\n        // TODO: Find a better way to register and load all the locales in Node\n        if (!locales[name] && (typeof module !== 'undefined') &&\n                module && module.exports) {\n            try {\n                oldLocale = globalLocale._abbr;\n                var aliasedRequire = require;\n                aliasedRequire('./locale/' + name);\n                getSetGlobalLocale(oldLocale);\n            } catch (e) {}\n        }\n        return locales[name];\n    }\n\n    // This function will load locale and then set the global locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    function getSetGlobalLocale (key, values) {\n        var data;\n        if (key) {\n            if (isUndefined(values)) {\n                data = getLocale(key);\n            }\n            else {\n                data = defineLocale(key, values);\n            }\n\n            if (data) {\n                // moment.duration._locale = moment._locale = data;\n                globalLocale = data;\n            }\n            else {\n                if ((typeof console !==  'undefined') && console.warn) {\n                    //warn user if arguments are passed but the locale could not be set\n                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');\n                }\n            }\n        }\n\n        return globalLocale._abbr;\n    }\n\n    function defineLocale (name, config) {\n        if (config !== null) {\n            var locale, parentConfig = baseConfig;\n            config.abbr = name;\n            if (locales[name] != null) {\n                deprecateSimple('defineLocaleOverride',\n                        'use moment.updateLocale(localeName, config) to change ' +\n                        'an existing locale. moment.defineLocale(localeName, ' +\n                        'config) should only be used for creating a new locale ' +\n                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n                parentConfig = locales[name]._config;\n            } else if (config.parentLocale != null) {\n                if (locales[config.parentLocale] != null) {\n                    parentConfig = locales[config.parentLocale]._config;\n                } else {\n                    locale = loadLocale(config.parentLocale);\n                    if (locale != null) {\n                        parentConfig = locale._config;\n                    } else {\n                        if (!localeFamilies[config.parentLocale]) {\n                            localeFamilies[config.parentLocale] = [];\n                        }\n                        localeFamilies[config.parentLocale].push({\n                            name: name,\n                            config: config\n                        });\n                        return null;\n                    }\n                }\n            }\n            locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\n            if (localeFamilies[name]) {\n                localeFamilies[name].forEach(function (x) {\n                    defineLocale(x.name, x.config);\n                });\n            }\n\n            // backwards compat for now: also set the locale\n            // make sure we set the locale AFTER all child locales have been\n            // created, so we won't end up with the child locale set.\n            getSetGlobalLocale(name);\n\n\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    }\n\n    function updateLocale(name, config) {\n        if (config != null) {\n            var locale, tmpLocale, parentConfig = baseConfig;\n            // MERGE\n            tmpLocale = loadLocale(name);\n            if (tmpLocale != null) {\n                parentConfig = tmpLocale._config;\n            }\n            config = mergeConfigs(parentConfig, config);\n            locale = new Locale(config);\n            locale.parentLocale = locales[name];\n            locales[name] = locale;\n\n            // backwards compat for now: also set the locale\n            getSetGlobalLocale(name);\n        } else {\n            // pass null for config to unupdate, useful for tests\n            if (locales[name] != null) {\n                if (locales[name].parentLocale != null) {\n                    locales[name] = locales[name].parentLocale;\n                } else if (locales[name] != null) {\n                    delete locales[name];\n                }\n            }\n        }\n        return locales[name];\n    }\n\n    // returns locale data\n    function getLocale (key) {\n        var locale;\n\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n\n        if (!key) {\n            return globalLocale;\n        }\n\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [key];\n        }\n\n        return chooseLocale(key);\n    }\n\n    function listLocales() {\n        return keys(locales);\n    }\n\n    function checkOverflow (m) {\n        var overflow;\n        var a = m._a;\n\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow =\n                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n                -1;\n\n            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n                overflow = DATE;\n            }\n            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n                overflow = WEEK;\n            }\n            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n                overflow = WEEKDAY;\n            }\n\n            getParsingFlags(m).overflow = overflow;\n        }\n\n        return m;\n    }\n\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n\n    function currentDateArray(config) {\n        // hooks is actually the exported moment object\n        var nowValue = new Date(hooks.now());\n        if (config._useUTC) {\n            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n        }\n        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n    }\n\n    // convert an array to a date.\n    // the array should mirror the parameters below\n    // note: all values past the year are optional and will default to the lowest possible value.\n    // [year, month, day , hour, minute, second, millisecond]\n    function configFromArray (config) {\n        var i, date, input = [], currentDate, expectedWeekday, yearToUse;\n\n        if (config._d) {\n            return;\n        }\n\n        currentDate = currentDateArray(config);\n\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear != null) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n            }\n\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for (i = 0; i < 3 && config._a[i] == null; ++i) {\n            config._a[i] = input[i] = currentDate[i];\n        }\n\n        // Zero out whatever was not defaulted, including time\n        for (; i < 7; i++) {\n            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n        }\n\n        // Check for 24:00:00.000\n        if (config._a[HOUR] === 24 &&\n                config._a[MINUTE] === 0 &&\n                config._a[SECOND] === 0 &&\n                config._a[MILLISECOND] === 0) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\n\n        // Apply timezone offset from input. The actual utcOffset can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        }\n\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n\n        // check for mismatching day of week\n        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {\n            getParsingFlags(config).weekdayMismatch = true;\n        }\n    }\n\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\n\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n            week = defaults(w.W, 1);\n            weekday = defaults(w.E, 1);\n            if (weekday < 1 || weekday > 7) {\n                weekdayOverflow = true;\n            }\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n\n            var curWeek = weekOfYear(createLocal(), dow, doy);\n\n            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\n            // Default to current week.\n            week = defaults(w.w, curWeek.week);\n\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < 0 || weekday > 6) {\n                    weekdayOverflow = true;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from beginning of week\n                weekday = w.e + dow;\n                if (w.e < 0 || w.e > 6) {\n                    weekdayOverflow = true;\n                }\n            } else {\n                // default to beginning of week\n                weekday = dow;\n            }\n        }\n        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n            getParsingFlags(config)._overflowWeeks = true;\n        } else if (weekdayOverflow != null) {\n            getParsingFlags(config)._overflowWeekday = true;\n        } else {\n            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n            config._a[YEAR] = temp.year;\n            config._dayOfYear = temp.dayOfYear;\n        }\n    }\n\n    // iso 8601 regex\n    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n    var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n    var basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\n    var tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\n\n    var isoDates = [\n        ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n        ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n        ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n        ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n        ['YYYY-DDD', /\\d{4}-\\d{3}/],\n        ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n        ['YYYYYYMMDD', /[+-]\\d{10}/],\n        ['YYYYMMDD', /\\d{8}/],\n        // YYYYMM is NOT allowed by the standard\n        ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n        ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n        ['YYYYDDD', /\\d{7}/]\n    ];\n\n    // iso time formats and regexes\n    var isoTimes = [\n        ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n        ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n        ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n        ['HH:mm', /\\d\\d:\\d\\d/],\n        ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n        ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n        ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n        ['HHmm', /\\d\\d\\d\\d/],\n        ['HH', /\\d\\d/]\n    ];\n\n    var aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\n    // date from iso format\n    function configFromISO(config) {\n        var i, l,\n            string = config._i,\n            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n            allowTime, dateFormat, timeFormat, tzFormat;\n\n        if (match) {\n            getParsingFlags(config).iso = true;\n\n            for (i = 0, l = isoDates.length; i < l; i++) {\n                if (isoDates[i][1].exec(match[1])) {\n                    dateFormat = isoDates[i][0];\n                    allowTime = isoDates[i][2] !== false;\n                    break;\n                }\n            }\n            if (dateFormat == null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[3]) {\n                for (i = 0, l = isoTimes.length; i < l; i++) {\n                    if (isoTimes[i][1].exec(match[3])) {\n                        // match[2] should be 'T' or space\n                        timeFormat = (match[2] || ' ') + isoTimes[i][0];\n                        break;\n                    }\n                }\n                if (timeFormat == null) {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            if (!allowTime && timeFormat != null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[4]) {\n                if (tzRegex.exec(match[4])) {\n                    tzFormat = 'Z';\n                } else {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n            configFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/;\n\n    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n        var result = [\n            untruncateYear(yearStr),\n            defaultLocaleMonthsShort.indexOf(monthStr),\n            parseInt(dayStr, 10),\n            parseInt(hourStr, 10),\n            parseInt(minuteStr, 10)\n        ];\n\n        if (secondStr) {\n            result.push(parseInt(secondStr, 10));\n        }\n\n        return result;\n    }\n\n    function untruncateYear(yearStr) {\n        var year = parseInt(yearStr, 10);\n        if (year <= 49) {\n            return 2000 + year;\n        } else if (year <= 999) {\n            return 1900 + year;\n        }\n        return year;\n    }\n\n    function preprocessRFC2822(s) {\n        // Remove comments and folding whitespace and replace multiple-spaces with a single space\n        return s.replace(/\\([^)]*\\)|[\\n\\t]/g, ' ').replace(/(\\s\\s+)/g, ' ').replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    }\n\n    function checkWeekday(weekdayStr, parsedInput, config) {\n        if (weekdayStr) {\n            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.\n            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\n            if (weekdayProvided !== weekdayActual) {\n                getParsingFlags(config).weekdayMismatch = true;\n                config._isValid = false;\n                return false;\n            }\n        }\n        return true;\n    }\n\n    var obsOffsets = {\n        UT: 0,\n        GMT: 0,\n        EDT: -4 * 60,\n        EST: -5 * 60,\n        CDT: -5 * 60,\n        CST: -6 * 60,\n        MDT: -6 * 60,\n        MST: -7 * 60,\n        PDT: -7 * 60,\n        PST: -8 * 60\n    };\n\n    function calculateOffset(obsOffset, militaryOffset, numOffset) {\n        if (obsOffset) {\n            return obsOffsets[obsOffset];\n        } else if (militaryOffset) {\n            // the only allowed military tz is Z\n            return 0;\n        } else {\n            var hm = parseInt(numOffset, 10);\n            var m = hm % 100, h = (hm - m) / 100;\n            return h * 60 + m;\n        }\n    }\n\n    // date and time from ref 2822 format\n    function configFromRFC2822(config) {\n        var match = rfc2822.exec(preprocessRFC2822(config._i));\n        if (match) {\n            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\n            if (!checkWeekday(match[1], parsedArray, config)) {\n                return;\n            }\n\n            config._a = parsedArray;\n            config._tzm = calculateOffset(match[8], match[9], match[10]);\n\n            config._d = createUTCDate.apply(null, config._a);\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\n            getParsingFlags(config).rfc2822 = true;\n        } else {\n            config._isValid = false;\n        }\n    }\n\n    // date from iso format or fallback\n    function configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n\n        if (matched !== null) {\n            config._d = new Date(+matched[1]);\n            return;\n        }\n\n        configFromISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        configFromRFC2822(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n\n        // Final attempt, use Input Fallback\n        hooks.createFromInputFallback(config);\n    }\n\n    hooks.createFromInputFallback = deprecate(\n        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n        'discouraged and will be removed in an upcoming major release. Please refer to ' +\n        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n        function (config) {\n            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n        }\n    );\n\n    // constant that refers to the ISO standard\n    hooks.ISO_8601 = function () {};\n\n    // constant that refers to the RFC 2822 form\n    hooks.RFC_2822 = function () {};\n\n    // date from string and format string\n    function configFromStringAndFormat(config) {\n        // TODO: Move this to another part of the creation flow to prevent circular deps\n        if (config._f === hooks.ISO_8601) {\n            configFromISO(config);\n            return;\n        }\n        if (config._f === hooks.RFC_2822) {\n            configFromRFC2822(config);\n            return;\n        }\n        config._a = [];\n        getParsingFlags(config).empty = true;\n\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = '' + config._i,\n            i, parsedInput, tokens, token, skipped,\n            stringLength = string.length,\n            totalParsedInputLength = 0;\n\n        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n            // console.log('token', token, 'parsedInput', parsedInput,\n            //         'regex', getParseRegexForToken(token, config));\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n                }\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty = false;\n                }\n                else {\n                    getParsingFlags(config).unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            }\n            else if (config._strict && !parsedInput) {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n        }\n\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n        }\n\n        // clear _12h flag if hour is <= 12\n        if (config._a[HOUR] <= 12 &&\n            getParsingFlags(config).bigHour === true &&\n            config._a[HOUR] > 0) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n\n        getParsingFlags(config).parsedDateParts = config._a.slice(0);\n        getParsingFlags(config).meridiem = config._meridiem;\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\n        configFromArray(config);\n        checkOverflow(config);\n    }\n\n\n    function meridiemFixWrap (locale, hour, meridiem) {\n        var isPm;\n\n        if (meridiem == null) {\n            // nothing to do\n            return hour;\n        }\n        if (locale.meridiemHour != null) {\n            return locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null) {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if (isPm && hour < 12) {\n                hour += 12;\n            }\n            if (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return hour;\n        } else {\n            // this is not supposed to happen\n            return hour;\n        }\n    }\n\n    // date from string and array of format strings\n    function configFromStringAndArray(config) {\n        var tempConfig,\n            bestMoment,\n\n            scoreToBeat,\n            i,\n            currentScore;\n\n        if (config._f.length === 0) {\n            getParsingFlags(config).invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n\n        for (i = 0; i < config._f.length; i++) {\n            currentScore = 0;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n\n            if (!isValid(tempConfig)) {\n                continue;\n            }\n\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n            //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n            getParsingFlags(tempConfig).score = currentScore;\n\n            if (scoreToBeat == null || currentScore < scoreToBeat) {\n                scoreToBeat = currentScore;\n                bestMoment = tempConfig;\n            }\n        }\n\n        extend(config, bestMoment || tempConfig);\n    }\n\n    function configFromObject(config) {\n        if (config._d) {\n            return;\n        }\n\n        var i = normalizeObjectUnits(config._i);\n        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n            return obj && parseInt(obj, 10);\n        });\n\n        configFromArray(config);\n    }\n\n    function createFromConfig (config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, 'd');\n            res._nextDay = undefined;\n        }\n\n        return res;\n    }\n\n    function prepareConfig (config) {\n        var input = config._i,\n            format = config._f;\n\n        config._locale = config._locale || getLocale(config._l);\n\n        if (input === null || (format === undefined && input === '')) {\n            return createInvalid({nullInput: true});\n        }\n\n        if (typeof input === 'string') {\n            config._i = input = config._locale.preparse(input);\n        }\n\n        if (isMoment(input)) {\n            return new Moment(checkOverflow(input));\n        } else if (isDate(input)) {\n            config._d = input;\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n        } else if (format) {\n            configFromStringAndFormat(config);\n        }  else {\n            configFromInput(config);\n        }\n\n        if (!isValid(config)) {\n            config._d = null;\n        }\n\n        return config;\n    }\n\n    function configFromInput(config) {\n        var input = config._i;\n        if (isUndefined(input)) {\n            config._d = new Date(hooks.now());\n        } else if (isDate(input)) {\n            config._d = new Date(input.valueOf());\n        } else if (typeof input === 'string') {\n            configFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function (obj) {\n                return parseInt(obj, 10);\n            });\n            configFromArray(config);\n        } else if (isObject(input)) {\n            configFromObject(config);\n        } else if (isNumber(input)) {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            hooks.createFromInputFallback(config);\n        }\n    }\n\n    function createLocalOrUTC (input, format, locale, strict, isUTC) {\n        var c = {};\n\n        if (locale === true || locale === false) {\n            strict = locale;\n            locale = undefined;\n        }\n\n        if ((isObject(input) && isObjectEmpty(input)) ||\n                (isArray(input) && input.length === 0)) {\n            input = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n\n        return createFromConfig(c);\n    }\n\n    function createLocal (input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, false);\n    }\n\n    var prototypeMin = deprecate(\n        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n        function () {\n            var other = createLocal.apply(null, arguments);\n            if (this.isValid() && other.isValid()) {\n                return other < this ? this : other;\n            } else {\n                return createInvalid();\n            }\n        }\n    );\n\n    var prototypeMax = deprecate(\n        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n        function () {\n            var other = createLocal.apply(null, arguments);\n            if (this.isValid() && other.isValid()) {\n                return other > this ? this : other;\n            } else {\n                return createInvalid();\n            }\n        }\n    );\n\n    // Pick a moment m from moments so that m[fn](other) is true for all\n    // other. This relies on the function fn to be transitive.\n    //\n    // moments should either be an array of moment objects or an array, whose\n    // first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return createLocal();\n        }\n        res = moments[0];\n        for (i = 1; i < moments.length; ++i) {\n            if (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n\n    // TODO: Use [].sort instead?\n    function min () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isBefore', args);\n    }\n\n    function max () {\n        var args = [].slice.call(arguments, 0);\n\n        return pickBy('isAfter', args);\n    }\n\n    var now = function () {\n        return Date.now ? Date.now() : +(new Date());\n    };\n\n    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\n\n    function isDurationValid(m) {\n        for (var key in m) {\n            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n                return false;\n            }\n        }\n\n        var unitHasDecimal = false;\n        for (var i = 0; i < ordering.length; ++i) {\n            if (m[ordering[i]]) {\n                if (unitHasDecimal) {\n                    return false; // only allow non-integers for smallest unit\n                }\n                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                    unitHasDecimal = true;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function isValid$1() {\n        return this._isValid;\n    }\n\n    function createInvalid$1() {\n        return createDuration(NaN);\n    }\n\n    function Duration (duration) {\n        var normalizedInput = normalizeObjectUnits(duration),\n            years = normalizedInput.year || 0,\n            quarters = normalizedInput.quarter || 0,\n            months = normalizedInput.month || 0,\n            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,\n            days = normalizedInput.day || 0,\n            hours = normalizedInput.hour || 0,\n            minutes = normalizedInput.minute || 0,\n            seconds = normalizedInput.second || 0,\n            milliseconds = normalizedInput.millisecond || 0;\n\n        this._isValid = isDurationValid(normalizedInput);\n\n        // representation for dateAddRemove\n        this._milliseconds = +milliseconds +\n            seconds * 1e3 + // 1000\n            minutes * 6e4 + // 1000 * 60\n            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days +\n            weeks * 7;\n        // It is impossible to translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months +\n            quarters * 3 +\n            years * 12;\n\n        this._data = {};\n\n        this._locale = getLocale();\n\n        this._bubble();\n    }\n\n    function isDuration (obj) {\n        return obj instanceof Duration;\n    }\n\n    function absRound (number) {\n        if (number < 0) {\n            return Math.round(-1 * number) * -1;\n        } else {\n            return Math.round(number);\n        }\n    }\n\n    // FORMATTING\n\n    function offset (token, separator) {\n        addFormatToken(token, 0, 0, function () {\n            var offset = this.utcOffset();\n            var sign = '+';\n            if (offset < 0) {\n                offset = -offset;\n                sign = '-';\n            }\n            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n        });\n    }\n\n    offset('Z', ':');\n    offset('ZZ', '');\n\n    // PARSING\n\n    addRegexToken('Z',  matchShortOffset);\n    addRegexToken('ZZ', matchShortOffset);\n    addParseToken(['Z', 'ZZ'], function (input, array, config) {\n        config._useUTC = true;\n        config._tzm = offsetFromString(matchShortOffset, input);\n    });\n\n    // HELPERS\n\n    // timezone chunker\n    // '+10:00' > ['10',  '00']\n    // '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\n    function offsetFromString(matcher, string) {\n        var matches = (string || '').match(matcher);\n\n        if (matches === null) {\n            return null;\n        }\n\n        var chunk   = matches[matches.length - 1] || [];\n        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n        var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n        return minutes === 0 ?\n          0 :\n          parts[0] === '+' ? minutes : -minutes;\n    }\n\n    // Return a moment from input, that is local/utc/zone equivalent to model.\n    function cloneWithOffset(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(res._d.valueOf() + diff);\n            hooks.updateOffset(res, false);\n            return res;\n        } else {\n            return createLocal(input).local();\n        }\n    }\n\n    function getDateOffset (m) {\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n    }\n\n    // HOOKS\n\n    // This function will be called whenever a moment is mutated.\n    // It is intended to keep the offset in sync with the timezone.\n    hooks.updateOffset = function () {};\n\n    // MOMENTS\n\n    // keepLocalTime = true means only change the timezone, without\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n    // +0200, so we adjust the time as needed, to be valid.\n    //\n    // Keeping the time actually adds/subtracts (one hour)\n    // from the actual represented time. That is why we call updateOffset\n    // a second time. In case it wants us to change the offset again\n    // _changeInProgress == true case, then we have to adjust, because\n    // there is no such time in the given timezone.\n    function getSetOffset (input, keepLocalTime, keepMinutes) {\n        var offset = this._offset || 0,\n            localAdjust;\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        if (input != null) {\n            if (typeof input === 'string') {\n                input = offsetFromString(matchShortOffset, input);\n                if (input === null) {\n                    return this;\n                }\n            } else if (Math.abs(input) < 16 && !keepMinutes) {\n                input = input * 60;\n            }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC = true;\n            if (localAdjust != null) {\n                this.add(localAdjust, 'm');\n            }\n            if (offset !== input) {\n                if (!keepLocalTime || this._changeInProgress) {\n                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n                } else if (!this._changeInProgress) {\n                    this._changeInProgress = true;\n                    hooks.updateOffset(this, true);\n                    this._changeInProgress = null;\n                }\n            }\n            return this;\n        } else {\n            return this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n\n    function getSetZone (input, keepLocalTime) {\n        if (input != null) {\n            if (typeof input !== 'string') {\n                input = -input;\n            }\n\n            this.utcOffset(input, keepLocalTime);\n\n            return this;\n        } else {\n            return -this.utcOffset();\n        }\n    }\n\n    function setOffsetToUTC (keepLocalTime) {\n        return this.utcOffset(0, keepLocalTime);\n    }\n\n    function setOffsetToLocal (keepLocalTime) {\n        if (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC = false;\n\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this), 'm');\n            }\n        }\n        return this;\n    }\n\n    function setOffsetToParsedOffset () {\n        if (this._tzm != null) {\n            this.utcOffset(this._tzm, false, true);\n        } else if (typeof this._i === 'string') {\n            var tZone = offsetFromString(matchOffset, this._i);\n            if (tZone != null) {\n                this.utcOffset(tZone);\n            }\n            else {\n                this.utcOffset(0, true);\n            }\n        }\n        return this;\n    }\n\n    function hasAlignedHourOffset (input) {\n        if (!this.isValid()) {\n            return false;\n        }\n        input = input ? createLocal(input).utcOffset() : 0;\n\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n\n    function isDaylightSavingTime () {\n        return (\n            this.utcOffset() > this.clone().month(0).utcOffset() ||\n            this.utcOffset() > this.clone().month(5).utcOffset()\n        );\n    }\n\n    function isDaylightSavingTimeShifted () {\n        if (!isUndefined(this._isDSTShifted)) {\n            return this._isDSTShifted;\n        }\n\n        var c = {};\n\n        copyConfig(c, this);\n        c = prepareConfig(c);\n\n        if (c._a) {\n            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n            this._isDSTShifted = this.isValid() &&\n                compareArrays(c._a, other.toArray()) > 0;\n        } else {\n            this._isDSTShifted = false;\n        }\n\n        return this._isDSTShifted;\n    }\n\n    function isLocal () {\n        return this.isValid() ? !this._isUTC : false;\n    }\n\n    function isUtcOffset () {\n        return this.isValid() ? this._isUTC : false;\n    }\n\n    function isUtc () {\n        return this.isValid() ? this._isUTC && this._offset === 0 : false;\n    }\n\n    // ASP.NET json date format regex\n    var aspNetRegex = /^(\\-|\\+)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)(\\.\\d*)?)?$/;\n\n    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n    // and further modified to allow for strings containing both week and day\n    var isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n    function createDuration (input, key) {\n        var duration = input,\n            // matching against regexp is expensive, do it on demand\n            match = null,\n            sign,\n            ret,\n            diffRes;\n\n        if (isDuration(input)) {\n            duration = {\n                ms : input._milliseconds,\n                d  : input._days,\n                M  : input._months\n            };\n        } else if (isNumber(input)) {\n            duration = {};\n            if (key) {\n                duration[key] = input;\n            } else {\n                duration.milliseconds = input;\n            }\n        } else if (!!(match = aspNetRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n                y  : 0,\n                d  : toInt(match[DATE])                         * sign,\n                h  : toInt(match[HOUR])                         * sign,\n                m  : toInt(match[MINUTE])                       * sign,\n                s  : toInt(match[SECOND])                       * sign,\n                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\n            };\n        } else if (!!(match = isoRegex.exec(input))) {\n            sign = (match[1] === '-') ? -1 : 1;\n            duration = {\n                y : parseIso(match[2], sign),\n                M : parseIso(match[3], sign),\n                w : parseIso(match[4], sign),\n                d : parseIso(match[5], sign),\n                h : parseIso(match[6], sign),\n                m : parseIso(match[7], sign),\n                s : parseIso(match[8], sign)\n            };\n        } else if (duration == null) {// checks for null or undefined\n            duration = {};\n        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n\n        ret = new Duration(duration);\n\n        if (isDuration(input) && hasOwnProp(input, '_locale')) {\n            ret._locale = input._locale;\n        }\n\n        return ret;\n    }\n\n    createDuration.fn = Duration.prototype;\n    createDuration.invalid = createInvalid$1;\n\n    function parseIso (inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(',', '.'));\n        // apply sign while we're at it\n        return (isNaN(res) ? 0 : res) * sign;\n    }\n\n    function positiveMomentsDifference(base, other) {\n        var res = {};\n\n        res.months = other.month() - base.month() +\n            (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, 'M').isAfter(other)) {\n            --res.months;\n        }\n\n        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\n        return res;\n    }\n\n    function momentsDifference(base, other) {\n        var res;\n        if (!(base.isValid() && other.isValid())) {\n            return {milliseconds: 0, months: 0};\n        }\n\n        other = cloneWithOffset(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n\n        return res;\n    }\n\n    // TODO: remove 'name' arg after deprecation is removed\n    function createAdder(direction, name) {\n        return function (val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +\n                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n                tmp = val; val = period; period = tmp;\n            }\n\n            val = typeof val === 'string' ? +val : val;\n            dur = createDuration(val, period);\n            addSubtract(this, dur, direction);\n            return this;\n        };\n    }\n\n    function addSubtract (mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds,\n            days = absRound(duration._days),\n            months = absRound(duration._months);\n\n        if (!mom.isValid()) {\n            // No op\n            return;\n        }\n\n        updateOffset = updateOffset == null ? true : updateOffset;\n\n        if (months) {\n            setMonth(mom, get(mom, 'Month') + months * isAdding);\n        }\n        if (days) {\n            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n        }\n        if (milliseconds) {\n            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n        }\n        if (updateOffset) {\n            hooks.updateOffset(mom, days || months);\n        }\n    }\n\n    var add      = createAdder(1, 'add');\n    var subtract = createAdder(-1, 'subtract');\n\n    function getCalendarFormat(myMoment, now) {\n        var diff = myMoment.diff(now, 'days', true);\n        return diff < -6 ? 'sameElse' :\n                diff < -1 ? 'lastWeek' :\n                diff < 0 ? 'lastDay' :\n                diff < 1 ? 'sameDay' :\n                diff < 2 ? 'nextDay' :\n                diff < 7 ? 'nextWeek' : 'sameElse';\n    }\n\n    function calendar$1 (time, formats) {\n        // We want to compare the start of today, vs this.\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\n        var now = time || createLocal(),\n            sod = cloneWithOffset(now, this).startOf('day'),\n            format = hooks.calendarFormat(this, sod) || 'sameElse';\n\n        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n\n        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n    }\n\n    function clone () {\n        return new Moment(this);\n    }\n\n    function isAfter (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || 'millisecond';\n        if (units === 'millisecond') {\n            return this.valueOf() > localInput.valueOf();\n        } else {\n            return localInput.valueOf() < this.clone().startOf(units).valueOf();\n        }\n    }\n\n    function isBefore (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || 'millisecond';\n        if (units === 'millisecond') {\n            return this.valueOf() < localInput.valueOf();\n        } else {\n            return this.clone().endOf(units).valueOf() < localInput.valueOf();\n        }\n    }\n\n    function isBetween (from, to, units, inclusivity) {\n        var localFrom = isMoment(from) ? from : createLocal(from),\n            localTo = isMoment(to) ? to : createLocal(to);\n        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {\n            return false;\n        }\n        inclusivity = inclusivity || '()';\n        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&\n            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));\n    }\n\n    function isSame (input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input),\n            inputMs;\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || 'millisecond';\n        if (units === 'millisecond') {\n            return this.valueOf() === localInput.valueOf();\n        } else {\n            inputMs = localInput.valueOf();\n            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n        }\n    }\n\n    function isSameOrAfter (input, units) {\n        return this.isSame(input, units) || this.isAfter(input, units);\n    }\n\n    function isSameOrBefore (input, units) {\n        return this.isSame(input, units) || this.isBefore(input, units);\n    }\n\n    function diff (input, units, asFloat) {\n        var that,\n            zoneDelta,\n            output;\n\n        if (!this.isValid()) {\n            return NaN;\n        }\n\n        that = cloneWithOffset(input, this);\n\n        if (!that.isValid()) {\n            return NaN;\n        }\n\n        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\n        units = normalizeUnits(units);\n\n        switch (units) {\n            case 'year': output = monthDiff(this, that) / 12; break;\n            case 'month': output = monthDiff(this, that); break;\n            case 'quarter': output = monthDiff(this, that) / 3; break;\n            case 'second': output = (this - that) / 1e3; break; // 1000\n            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60\n            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60\n            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst\n            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst\n            default: output = this - that;\n        }\n\n        return asFloat ? output : absFloor(output);\n    }\n\n    function monthDiff (a, b) {\n        // difference in months\n        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n            // b is in (anchor - 1 month, anchor + 1 month)\n            anchor = a.clone().add(wholeMonthDiff, 'months'),\n            anchor2, adjust;\n\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n\n        //check for negative zero, return zero if negative zero\n        return -(wholeMonthDiff + adjust) || 0;\n    }\n\n    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\n    function toString () {\n        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n    }\n\n    function toISOString(keepOffset) {\n        if (!this.isValid()) {\n            return null;\n        }\n        var utc = keepOffset !== true;\n        var m = utc ? this.clone().utc() : this;\n        if (m.year() < 0 || m.year() > 9999) {\n            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');\n        }\n        if (isFunction(Date.prototype.toISOString)) {\n            // native implementation is ~50x faster, use it when we can\n            if (utc) {\n                return this.toDate().toISOString();\n            } else {\n                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));\n            }\n        }\n        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');\n    }\n\n    /**\n     * Return a human readable representation of a moment that can\n     * also be evaluated to get a new moment which is the same\n     *\n     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n     */\n    function inspect () {\n        if (!this.isValid()) {\n            return 'moment.invalid(/* ' + this._i + ' */)';\n        }\n        var func = 'moment';\n        var zone = '';\n        if (!this.isLocal()) {\n            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n            zone = 'Z';\n        }\n        var prefix = '[' + func + '(\"]';\n        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\n        var datetime = '-MM-DD[T]HH:mm:ss.SSS';\n        var suffix = zone + '[\")]';\n\n        return this.format(prefix + year + datetime + suffix);\n    }\n\n    function format (inputString) {\n        if (!inputString) {\n            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n        }\n        var output = formatMoment(this, inputString);\n        return this.localeData().postformat(output);\n    }\n\n    function from (time, withoutSuffix) {\n        if (this.isValid() &&\n                ((isMoment(time) && time.isValid()) ||\n                 createLocal(time).isValid())) {\n            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function fromNow (withoutSuffix) {\n        return this.from(createLocal(), withoutSuffix);\n    }\n\n    function to (time, withoutSuffix) {\n        if (this.isValid() &&\n                ((isMoment(time) && time.isValid()) ||\n                 createLocal(time).isValid())) {\n            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n\n    function toNow (withoutSuffix) {\n        return this.to(createLocal(), withoutSuffix);\n    }\n\n    // If passed a locale key, it will set the locale for this\n    // instance.  Otherwise, it will return the locale configuration\n    // variables for this instance.\n    function locale (key) {\n        var newLocaleData;\n\n        if (key === undefined) {\n            return this._locale._abbr;\n        } else {\n            newLocaleData = getLocale(key);\n            if (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n            return this;\n        }\n    }\n\n    var lang = deprecate(\n        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n        function (key) {\n            if (key === undefined) {\n                return this.localeData();\n            } else {\n                return this.locale(key);\n            }\n        }\n    );\n\n    function localeData () {\n        return this._locale;\n    }\n\n    var MS_PER_SECOND = 1000;\n    var MS_PER_MINUTE = 60 * MS_PER_SECOND;\n    var MS_PER_HOUR = 60 * MS_PER_MINUTE;\n    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;\n\n    // actual modulo - handles negative numbers (for dates before 1970):\n    function mod$1(dividend, divisor) {\n        return (dividend % divisor + divisor) % divisor;\n    }\n\n    function localStartOfDate(y, m, d) {\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            return new Date(y + 400, m, d) - MS_PER_400_YEARS;\n        } else {\n            return new Date(y, m, d).valueOf();\n        }\n    }\n\n    function utcStartOfDate(y, m, d) {\n        // Date.UTC remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;\n        } else {\n            return Date.UTC(y, m, d);\n        }\n    }\n\n    function startOf (units) {\n        var time;\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond' || !this.isValid()) {\n            return this;\n        }\n\n        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n\n        switch (units) {\n            case 'year':\n                time = startOfDate(this.year(), 0, 1);\n                break;\n            case 'quarter':\n                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);\n                break;\n            case 'month':\n                time = startOfDate(this.year(), this.month(), 1);\n                break;\n            case 'week':\n                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());\n                break;\n            case 'isoWeek':\n                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));\n                break;\n            case 'day':\n            case 'date':\n                time = startOfDate(this.year(), this.month(), this.date());\n                break;\n            case 'hour':\n                time = this._d.valueOf();\n                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);\n                break;\n            case 'minute':\n                time = this._d.valueOf();\n                time -= mod$1(time, MS_PER_MINUTE);\n                break;\n            case 'second':\n                time = this._d.valueOf();\n                time -= mod$1(time, MS_PER_SECOND);\n                break;\n        }\n\n        this._d.setTime(time);\n        hooks.updateOffset(this, true);\n        return this;\n    }\n\n    function endOf (units) {\n        var time;\n        units = normalizeUnits(units);\n        if (units === undefined || units === 'millisecond' || !this.isValid()) {\n            return this;\n        }\n\n        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n\n        switch (units) {\n            case 'year':\n                time = startOfDate(this.year() + 1, 0, 1) - 1;\n                break;\n            case 'quarter':\n                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;\n                break;\n            case 'month':\n                time = startOfDate(this.year(), this.month() + 1, 1) - 1;\n                break;\n            case 'week':\n                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;\n                break;\n            case 'isoWeek':\n                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;\n                break;\n            case 'day':\n            case 'date':\n                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;\n                break;\n            case 'hour':\n                time = this._d.valueOf();\n                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;\n                break;\n            case 'minute':\n                time = this._d.valueOf();\n                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;\n                break;\n            case 'second':\n                time = this._d.valueOf();\n                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;\n                break;\n        }\n\n        this._d.setTime(time);\n        hooks.updateOffset(this, true);\n        return this;\n    }\n\n    function valueOf () {\n        return this._d.valueOf() - ((this._offset || 0) * 60000);\n    }\n\n    function unix () {\n        return Math.floor(this.valueOf() / 1000);\n    }\n\n    function toDate () {\n        return new Date(this.valueOf());\n    }\n\n    function toArray () {\n        var m = this;\n        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n    }\n\n    function toObject () {\n        var m = this;\n        return {\n            years: m.year(),\n            months: m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes: m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds()\n        };\n    }\n\n    function toJSON () {\n        // new Date(NaN).toJSON() === null\n        return this.isValid() ? this.toISOString() : null;\n    }\n\n    function isValid$2 () {\n        return isValid(this);\n    }\n\n    function parsingFlags () {\n        return extend({}, getParsingFlags(this));\n    }\n\n    function invalidAt () {\n        return getParsingFlags(this).overflow;\n    }\n\n    function creationData() {\n        return {\n            input: this._i,\n            format: this._f,\n            locale: this._locale,\n            isUTC: this._isUTC,\n            strict: this._strict\n        };\n    }\n\n    // FORMATTING\n\n    addFormatToken(0, ['gg', 2], 0, function () {\n        return this.weekYear() % 100;\n    });\n\n    addFormatToken(0, ['GG', 2], 0, function () {\n        return this.isoWeekYear() % 100;\n    });\n\n    function addWeekYearFormatToken (token, getter) {\n        addFormatToken(0, [token, token.length], 0, getter);\n    }\n\n    addWeekYearFormatToken('gggg',     'weekYear');\n    addWeekYearFormatToken('ggggg',    'weekYear');\n    addWeekYearFormatToken('GGGG',  'isoWeekYear');\n    addWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n    // ALIASES\n\n    addUnitAlias('weekYear', 'gg');\n    addUnitAlias('isoWeekYear', 'GG');\n\n    // PRIORITY\n\n    addUnitPriority('weekYear', 1);\n    addUnitPriority('isoWeekYear', 1);\n\n\n    // PARSING\n\n    addRegexToken('G',      matchSigned);\n    addRegexToken('g',      matchSigned);\n    addRegexToken('GG',     match1to2, match2);\n    addRegexToken('gg',     match1to2, match2);\n    addRegexToken('GGGG',   match1to4, match4);\n    addRegexToken('gggg',   match1to4, match4);\n    addRegexToken('GGGGG',  match1to6, match6);\n    addRegexToken('ggggg',  match1to6, match6);\n\n    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n        week[token.substr(0, 2)] = toInt(input);\n    });\n\n    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n        week[token] = hooks.parseTwoDigitYear(input);\n    });\n\n    // MOMENTS\n\n    function getSetWeekYear (input) {\n        return getSetWeekYearHelper.call(this,\n                input,\n                this.week(),\n                this.weekday(),\n                this.localeData()._week.dow,\n                this.localeData()._week.doy);\n    }\n\n    function getSetISOWeekYear (input) {\n        return getSetWeekYearHelper.call(this,\n                input, this.isoWeek(), this.isoWeekday(), 1, 4);\n    }\n\n    function getISOWeeksInYear () {\n        return weeksInYear(this.year(), 1, 4);\n    }\n\n    function getWeeksInYear () {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n\n    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n        var weeksTarget;\n        if (input == null) {\n            return weekOfYear(this, dow, doy).year;\n        } else {\n            weeksTarget = weeksInYear(input, dow, doy);\n            if (week > weeksTarget) {\n                week = weeksTarget;\n            }\n            return setWeekAll.call(this, input, week, weekday, dow, doy);\n        }\n    }\n\n    function setWeekAll(weekYear, week, weekday, dow, doy) {\n        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\n        this.year(date.getUTCFullYear());\n        this.month(date.getUTCMonth());\n        this.date(date.getUTCDate());\n        return this;\n    }\n\n    // FORMATTING\n\n    addFormatToken('Q', 0, 'Qo', 'quarter');\n\n    // ALIASES\n\n    addUnitAlias('quarter', 'Q');\n\n    // PRIORITY\n\n    addUnitPriority('quarter', 7);\n\n    // PARSING\n\n    addRegexToken('Q', match1);\n    addParseToken('Q', function (input, array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n\n    // MOMENTS\n\n    function getSetQuarter (input) {\n        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n    }\n\n    // FORMATTING\n\n    addFormatToken('D', ['DD', 2], 'Do', 'date');\n\n    // ALIASES\n\n    addUnitAlias('date', 'D');\n\n    // PRIORITY\n    addUnitPriority('date', 9);\n\n    // PARSING\n\n    addRegexToken('D',  match1to2);\n    addRegexToken('DD', match1to2, match2);\n    addRegexToken('Do', function (isStrict, locale) {\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        return isStrict ?\n          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\n          locale._dayOfMonthOrdinalParseLenient;\n    });\n\n    addParseToken(['D', 'DD'], DATE);\n    addParseToken('Do', function (input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0]);\n    });\n\n    // MOMENTS\n\n    var getSetDayOfMonth = makeGetSet('Date', true);\n\n    // FORMATTING\n\n    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n    // ALIASES\n\n    addUnitAlias('dayOfYear', 'DDD');\n\n    // PRIORITY\n    addUnitPriority('dayOfYear', 4);\n\n    // PARSING\n\n    addRegexToken('DDD',  match1to3);\n    addRegexToken('DDDD', match3);\n    addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n        config._dayOfYear = toInt(input);\n    });\n\n    // HELPERS\n\n    // MOMENTS\n\n    function getSetDayOfYear (input) {\n        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n    }\n\n    // FORMATTING\n\n    addFormatToken('m', ['mm', 2], 0, 'minute');\n\n    // ALIASES\n\n    addUnitAlias('minute', 'm');\n\n    // PRIORITY\n\n    addUnitPriority('minute', 14);\n\n    // PARSING\n\n    addRegexToken('m',  match1to2);\n    addRegexToken('mm', match1to2, match2);\n    addParseToken(['m', 'mm'], MINUTE);\n\n    // MOMENTS\n\n    var getSetMinute = makeGetSet('Minutes', false);\n\n    // FORMATTING\n\n    addFormatToken('s', ['ss', 2], 0, 'second');\n\n    // ALIASES\n\n    addUnitAlias('second', 's');\n\n    // PRIORITY\n\n    addUnitPriority('second', 15);\n\n    // PARSING\n\n    addRegexToken('s',  match1to2);\n    addRegexToken('ss', match1to2, match2);\n    addParseToken(['s', 'ss'], SECOND);\n\n    // MOMENTS\n\n    var getSetSecond = makeGetSet('Seconds', false);\n\n    // FORMATTING\n\n    addFormatToken('S', 0, 0, function () {\n        return ~~(this.millisecond() / 100);\n    });\n\n    addFormatToken(0, ['SS', 2], 0, function () {\n        return ~~(this.millisecond() / 10);\n    });\n\n    addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n    addFormatToken(0, ['SSSS', 4], 0, function () {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0, ['SSSSS', 5], 0, function () {\n        return this.millisecond() * 100;\n    });\n    addFormatToken(0, ['SSSSSS', 6], 0, function () {\n        return this.millisecond() * 1000;\n    });\n    addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n        return this.millisecond() * 10000;\n    });\n    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n        return this.millisecond() * 1000000;\n    });\n\n\n    // ALIASES\n\n    addUnitAlias('millisecond', 'ms');\n\n    // PRIORITY\n\n    addUnitPriority('millisecond', 16);\n\n    // PARSING\n\n    addRegexToken('S',    match1to3, match1);\n    addRegexToken('SS',   match1to3, match2);\n    addRegexToken('SSS',  match1to3, match3);\n\n    var token;\n    for (token = 'SSSS'; token.length <= 9; token += 'S') {\n        addRegexToken(token, matchUnsigned);\n    }\n\n    function parseMs(input, array) {\n        array[MILLISECOND] = toInt(('0.' + input) * 1000);\n    }\n\n    for (token = 'S'; token.length <= 9; token += 'S') {\n        addParseToken(token, parseMs);\n    }\n    // MOMENTS\n\n    var getSetMillisecond = makeGetSet('Milliseconds', false);\n\n    // FORMATTING\n\n    addFormatToken('z',  0, 0, 'zoneAbbr');\n    addFormatToken('zz', 0, 0, 'zoneName');\n\n    // MOMENTS\n\n    function getZoneAbbr () {\n        return this._isUTC ? 'UTC' : '';\n    }\n\n    function getZoneName () {\n        return this._isUTC ? 'Coordinated Universal Time' : '';\n    }\n\n    var proto = Moment.prototype;\n\n    proto.add               = add;\n    proto.calendar          = calendar$1;\n    proto.clone             = clone;\n    proto.diff              = diff;\n    proto.endOf             = endOf;\n    proto.format            = format;\n    proto.from              = from;\n    proto.fromNow           = fromNow;\n    proto.to                = to;\n    proto.toNow             = toNow;\n    proto.get               = stringGet;\n    proto.invalidAt         = invalidAt;\n    proto.isAfter           = isAfter;\n    proto.isBefore          = isBefore;\n    proto.isBetween         = isBetween;\n    proto.isSame            = isSame;\n    proto.isSameOrAfter     = isSameOrAfter;\n    proto.isSameOrBefore    = isSameOrBefore;\n    proto.isValid           = isValid$2;\n    proto.lang              = lang;\n    proto.locale            = locale;\n    proto.localeData        = localeData;\n    proto.max               = prototypeMax;\n    proto.min               = prototypeMin;\n    proto.parsingFlags      = parsingFlags;\n    proto.set               = stringSet;\n    proto.startOf           = startOf;\n    proto.subtract          = subtract;\n    proto.toArray           = toArray;\n    proto.toObject          = toObject;\n    proto.toDate            = toDate;\n    proto.toISOString       = toISOString;\n    proto.inspect           = inspect;\n    proto.toJSON            = toJSON;\n    proto.toString          = toString;\n    proto.unix              = unix;\n    proto.valueOf           = valueOf;\n    proto.creationData      = creationData;\n    proto.year       = getSetYear;\n    proto.isLeapYear = getIsLeapYear;\n    proto.weekYear    = getSetWeekYear;\n    proto.isoWeekYear = getSetISOWeekYear;\n    proto.quarter = proto.quarters = getSetQuarter;\n    proto.month       = getSetMonth;\n    proto.daysInMonth = getDaysInMonth;\n    proto.week           = proto.weeks        = getSetWeek;\n    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\n    proto.weeksInYear    = getWeeksInYear;\n    proto.isoWeeksInYear = getISOWeeksInYear;\n    proto.date       = getSetDayOfMonth;\n    proto.day        = proto.days             = getSetDayOfWeek;\n    proto.weekday    = getSetLocaleDayOfWeek;\n    proto.isoWeekday = getSetISODayOfWeek;\n    proto.dayOfYear  = getSetDayOfYear;\n    proto.hour = proto.hours = getSetHour;\n    proto.minute = proto.minutes = getSetMinute;\n    proto.second = proto.seconds = getSetSecond;\n    proto.millisecond = proto.milliseconds = getSetMillisecond;\n    proto.utcOffset            = getSetOffset;\n    proto.utc                  = setOffsetToUTC;\n    proto.local                = setOffsetToLocal;\n    proto.parseZone            = setOffsetToParsedOffset;\n    proto.hasAlignedHourOffset = hasAlignedHourOffset;\n    proto.isDST                = isDaylightSavingTime;\n    proto.isLocal              = isLocal;\n    proto.isUtcOffset          = isUtcOffset;\n    proto.isUtc                = isUtc;\n    proto.isUTC                = isUtc;\n    proto.zoneAbbr = getZoneAbbr;\n    proto.zoneName = getZoneName;\n    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\n    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\n    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\n    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\n    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n\n    function createUnix (input) {\n        return createLocal(input * 1000);\n    }\n\n    function createInZone () {\n        return createLocal.apply(null, arguments).parseZone();\n    }\n\n    function preParsePostFormat (string) {\n        return string;\n    }\n\n    var proto$1 = Locale.prototype;\n\n    proto$1.calendar        = calendar;\n    proto$1.longDateFormat  = longDateFormat;\n    proto$1.invalidDate     = invalidDate;\n    proto$1.ordinal         = ordinal;\n    proto$1.preparse        = preParsePostFormat;\n    proto$1.postformat      = preParsePostFormat;\n    proto$1.relativeTime    = relativeTime;\n    proto$1.pastFuture      = pastFuture;\n    proto$1.set             = set;\n\n    proto$1.months            =        localeMonths;\n    proto$1.monthsShort       =        localeMonthsShort;\n    proto$1.monthsParse       =        localeMonthsParse;\n    proto$1.monthsRegex       = monthsRegex;\n    proto$1.monthsShortRegex  = monthsShortRegex;\n    proto$1.week = localeWeek;\n    proto$1.firstDayOfYear = localeFirstDayOfYear;\n    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n\n    proto$1.weekdays       =        localeWeekdays;\n    proto$1.weekdaysMin    =        localeWeekdaysMin;\n    proto$1.weekdaysShort  =        localeWeekdaysShort;\n    proto$1.weekdaysParse  =        localeWeekdaysParse;\n\n    proto$1.weekdaysRegex       =        weekdaysRegex;\n    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;\n    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;\n\n    proto$1.isPM = localeIsPM;\n    proto$1.meridiem = localeMeridiem;\n\n    function get$1 (format, index, field, setter) {\n        var locale = getLocale();\n        var utc = createUTC().set(setter, index);\n        return locale[field](utc, format);\n    }\n\n    function listMonthsImpl (format, index, field) {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n\n        if (index != null) {\n            return get$1(format, index, field, 'month');\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < 12; i++) {\n            out[i] = get$1(format, i, field, 'month');\n        }\n        return out;\n    }\n\n    // ()\n    // (5)\n    // (fmt, 5)\n    // (fmt)\n    // (true)\n    // (true, 5)\n    // (true, fmt, 5)\n    // (true, fmt)\n    function listWeekdaysImpl (localeSorted, format, index, field) {\n        if (typeof localeSorted === 'boolean') {\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        } else {\n            format = localeSorted;\n            index = format;\n            localeSorted = false;\n\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n\n            format = format || '';\n        }\n\n        var locale = getLocale(),\n            shift = localeSorted ? locale._week.dow : 0;\n\n        if (index != null) {\n            return get$1(format, (index + shift) % 7, field, 'day');\n        }\n\n        var i;\n        var out = [];\n        for (i = 0; i < 7; i++) {\n            out[i] = get$1(format, (i + shift) % 7, field, 'day');\n        }\n        return out;\n    }\n\n    function listMonths (format, index) {\n        return listMonthsImpl(format, index, 'months');\n    }\n\n    function listMonthsShort (format, index) {\n        return listMonthsImpl(format, index, 'monthsShort');\n    }\n\n    function listWeekdays (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n    }\n\n    function listWeekdaysShort (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n    }\n\n    function listWeekdaysMin (localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n    }\n\n    getSetGlobalLocale('en', {\n        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal : function (number) {\n            var b = number % 10,\n                output = (toInt(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n            return number + output;\n        }\n    });\n\n    // Side effect imports\n\n    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\n    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n\n    var mathAbs = Math.abs;\n\n    function abs () {\n        var data           = this._data;\n\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days         = mathAbs(this._days);\n        this._months       = mathAbs(this._months);\n\n        data.milliseconds  = mathAbs(data.milliseconds);\n        data.seconds       = mathAbs(data.seconds);\n        data.minutes       = mathAbs(data.minutes);\n        data.hours         = mathAbs(data.hours);\n        data.months        = mathAbs(data.months);\n        data.years         = mathAbs(data.years);\n\n        return this;\n    }\n\n    function addSubtract$1 (duration, input, value, direction) {\n        var other = createDuration(input, value);\n\n        duration._milliseconds += direction * other._milliseconds;\n        duration._days         += direction * other._days;\n        duration._months       += direction * other._months;\n\n        return duration._bubble();\n    }\n\n    // supports only 2.0-style add(1, 's') or add(duration)\n    function add$1 (input, value) {\n        return addSubtract$1(this, input, value, 1);\n    }\n\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n    function subtract$1 (input, value) {\n        return addSubtract$1(this, input, value, -1);\n    }\n\n    function absCeil (number) {\n        if (number < 0) {\n            return Math.floor(number);\n        } else {\n            return Math.ceil(number);\n        }\n    }\n\n    function bubble () {\n        var milliseconds = this._milliseconds;\n        var days         = this._days;\n        var months       = this._months;\n        var data         = this._data;\n        var seconds, minutes, hours, years, monthsFromDays;\n\n        // if we have a mix of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n                (milliseconds <= 0 && days <= 0 && months <= 0))) {\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n\n        seconds           = absFloor(milliseconds / 1000);\n        data.seconds      = seconds % 60;\n\n        minutes           = absFloor(seconds / 60);\n        data.minutes      = minutes % 60;\n\n        hours             = absFloor(minutes / 60);\n        data.hours        = hours % 24;\n\n        days += absFloor(hours / 24);\n\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n        months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n\n        data.days   = days;\n        data.months = months;\n        data.years  = years;\n\n        return this;\n    }\n\n    function daysToMonths (days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        // 400 years have 12 months === 4800\n        return days * 4800 / 146097;\n    }\n\n    function monthsToDays (months) {\n        // the reverse of daysToMonths\n        return months * 146097 / 4800;\n    }\n\n    function as (units) {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        var days;\n        var months;\n        var milliseconds = this._milliseconds;\n\n        units = normalizeUnits(units);\n\n        if (units === 'month' || units === 'quarter' || units === 'year') {\n            days = this._days + milliseconds / 864e5;\n            months = this._months + daysToMonths(days);\n            switch (units) {\n                case 'month':   return months;\n                case 'quarter': return months / 3;\n                case 'year':    return months / 12;\n            }\n        } else {\n            // handle milliseconds separately because of floating point math errors (issue #1867)\n            days = this._days + Math.round(monthsToDays(this._months));\n            switch (units) {\n                case 'week'   : return days / 7     + milliseconds / 6048e5;\n                case 'day'    : return days         + milliseconds / 864e5;\n                case 'hour'   : return days * 24    + milliseconds / 36e5;\n                case 'minute' : return days * 1440  + milliseconds / 6e4;\n                case 'second' : return days * 86400 + milliseconds / 1000;\n                // Math.floor prevents floating point math errors here\n                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n                default: throw new Error('Unknown unit ' + units);\n            }\n        }\n    }\n\n    // TODO: Use this.as('ms')?\n    function valueOf$1 () {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        return (\n            this._milliseconds +\n            this._days * 864e5 +\n            (this._months % 12) * 2592e6 +\n            toInt(this._months / 12) * 31536e6\n        );\n    }\n\n    function makeAs (alias) {\n        return function () {\n            return this.as(alias);\n        };\n    }\n\n    var asMilliseconds = makeAs('ms');\n    var asSeconds      = makeAs('s');\n    var asMinutes      = makeAs('m');\n    var asHours        = makeAs('h');\n    var asDays         = makeAs('d');\n    var asWeeks        = makeAs('w');\n    var asMonths       = makeAs('M');\n    var asQuarters     = makeAs('Q');\n    var asYears        = makeAs('y');\n\n    function clone$1 () {\n        return createDuration(this);\n    }\n\n    function get$2 (units) {\n        units = normalizeUnits(units);\n        return this.isValid() ? this[units + 's']() : NaN;\n    }\n\n    function makeGetter(name) {\n        return function () {\n            return this.isValid() ? this._data[name] : NaN;\n        };\n    }\n\n    var milliseconds = makeGetter('milliseconds');\n    var seconds      = makeGetter('seconds');\n    var minutes      = makeGetter('minutes');\n    var hours        = makeGetter('hours');\n    var days         = makeGetter('days');\n    var months       = makeGetter('months');\n    var years        = makeGetter('years');\n\n    function weeks () {\n        return absFloor(this.days() / 7);\n    }\n\n    var round = Math.round;\n    var thresholds = {\n        ss: 44,         // a few seconds to seconds\n        s : 45,         // seconds to minute\n        m : 45,         // minutes to hour\n        h : 22,         // hours to day\n        d : 26,         // days to month\n        M : 11          // months to year\n    };\n\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n\n    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {\n        var duration = createDuration(posNegDuration).abs();\n        var seconds  = round(duration.as('s'));\n        var minutes  = round(duration.as('m'));\n        var hours    = round(duration.as('h'));\n        var days     = round(duration.as('d'));\n        var months   = round(duration.as('M'));\n        var years    = round(duration.as('y'));\n\n        var a = seconds <= thresholds.ss && ['s', seconds]  ||\n                seconds < thresholds.s   && ['ss', seconds] ||\n                minutes <= 1             && ['m']           ||\n                minutes < thresholds.m   && ['mm', minutes] ||\n                hours   <= 1             && ['h']           ||\n                hours   < thresholds.h   && ['hh', hours]   ||\n                days    <= 1             && ['d']           ||\n                days    < thresholds.d   && ['dd', days]    ||\n                months  <= 1             && ['M']           ||\n                months  < thresholds.M   && ['MM', months]  ||\n                years   <= 1             && ['y']           || ['yy', years];\n\n        a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null, a);\n    }\n\n    // This function allows you to set the rounding function for relative time strings\n    function getSetRelativeTimeRounding (roundingFunction) {\n        if (roundingFunction === undefined) {\n            return round;\n        }\n        if (typeof(roundingFunction) === 'function') {\n            round = roundingFunction;\n            return true;\n        }\n        return false;\n    }\n\n    // This function allows you to set a threshold for relative time strings\n    function getSetRelativeTimeThreshold (threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        if (threshold === 's') {\n            thresholds.ss = limit - 1;\n        }\n        return true;\n    }\n\n    function humanize (withSuffix) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var locale = this.localeData();\n        var output = relativeTime$1(this, !withSuffix, locale);\n\n        if (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n\n        return locale.postformat(output);\n    }\n\n    var abs$1 = Math.abs;\n\n    function sign(x) {\n        return ((x > 0) - (x < 0)) || +x;\n    }\n\n    function toISOString$1() {\n        // for ISO strings we do not use the normal bubbling rules:\n        //  * milliseconds bubble up until they become hours\n        //  * days do not bubble at all\n        //  * months bubble up until they become years\n        // This is because there is no context-free conversion between hours and days\n        // (think of clock changes)\n        // and also not between days and months (28-31 days per month)\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n\n        var seconds = abs$1(this._milliseconds) / 1000;\n        var days         = abs$1(this._days);\n        var months       = abs$1(this._months);\n        var minutes, hours, years;\n\n        // 3600 seconds -> 60 minutes -> 1 hour\n        minutes           = absFloor(seconds / 60);\n        hours             = absFloor(minutes / 60);\n        seconds %= 60;\n        minutes %= 60;\n\n        // 12 months -> 1 year\n        years  = absFloor(months / 12);\n        months %= 12;\n\n\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n        var Y = years;\n        var M = months;\n        var D = days;\n        var h = hours;\n        var m = minutes;\n        var s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\n        var total = this.asSeconds();\n\n        if (!total) {\n            // this is the same as C#'s (Noda) and python (isodate)...\n            // but not other JS (goog.date)\n            return 'P0D';\n        }\n\n        var totalSign = total < 0 ? '-' : '';\n        var ymSign = sign(this._months) !== sign(total) ? '-' : '';\n        var daysSign = sign(this._days) !== sign(total) ? '-' : '';\n        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\n\n        return totalSign + 'P' +\n            (Y ? ymSign + Y + 'Y' : '') +\n            (M ? ymSign + M + 'M' : '') +\n            (D ? daysSign + D + 'D' : '') +\n            ((h || m || s) ? 'T' : '') +\n            (h ? hmsSign + h + 'H' : '') +\n            (m ? hmsSign + m + 'M' : '') +\n            (s ? hmsSign + s + 'S' : '');\n    }\n\n    var proto$2 = Duration.prototype;\n\n    proto$2.isValid        = isValid$1;\n    proto$2.abs            = abs;\n    proto$2.add            = add$1;\n    proto$2.subtract       = subtract$1;\n    proto$2.as             = as;\n    proto$2.asMilliseconds = asMilliseconds;\n    proto$2.asSeconds      = asSeconds;\n    proto$2.asMinutes      = asMinutes;\n    proto$2.asHours        = asHours;\n    proto$2.asDays         = asDays;\n    proto$2.asWeeks        = asWeeks;\n    proto$2.asMonths       = asMonths;\n    proto$2.asQuarters     = asQuarters;\n    proto$2.asYears        = asYears;\n    proto$2.valueOf        = valueOf$1;\n    proto$2._bubble        = bubble;\n    proto$2.clone          = clone$1;\n    proto$2.get            = get$2;\n    proto$2.milliseconds   = milliseconds;\n    proto$2.seconds        = seconds;\n    proto$2.minutes        = minutes;\n    proto$2.hours          = hours;\n    proto$2.days           = days;\n    proto$2.weeks          = weeks;\n    proto$2.months         = months;\n    proto$2.years          = years;\n    proto$2.humanize       = humanize;\n    proto$2.toISOString    = toISOString$1;\n    proto$2.toString       = toISOString$1;\n    proto$2.toJSON         = toISOString$1;\n    proto$2.locale         = locale;\n    proto$2.localeData     = localeData;\n\n    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\n    proto$2.lang = lang;\n\n    // Side effect imports\n\n    // FORMATTING\n\n    addFormatToken('X', 0, 0, 'unix');\n    addFormatToken('x', 0, 0, 'valueOf');\n\n    // PARSING\n\n    addRegexToken('x', matchSigned);\n    addRegexToken('X', matchTimestamp);\n    addParseToken('X', function (input, array, config) {\n        config._d = new Date(parseFloat(input, 10) * 1000);\n    });\n    addParseToken('x', function (input, array, config) {\n        config._d = new Date(toInt(input));\n    });\n\n    // Side effect imports\n\n\n    hooks.version = '2.24.0';\n\n    setHookCallback(createLocal);\n\n    hooks.fn                    = proto;\n    hooks.min                   = min;\n    hooks.max                   = max;\n    hooks.now                   = now;\n    hooks.utc                   = createUTC;\n    hooks.unix                  = createUnix;\n    hooks.months                = listMonths;\n    hooks.isDate                = isDate;\n    hooks.locale                = getSetGlobalLocale;\n    hooks.invalid               = createInvalid;\n    hooks.duration              = createDuration;\n    hooks.isMoment              = isMoment;\n    hooks.weekdays              = listWeekdays;\n    hooks.parseZone             = createInZone;\n    hooks.localeData            = getLocale;\n    hooks.isDuration            = isDuration;\n    hooks.monthsShort           = listMonthsShort;\n    hooks.weekdaysMin           = listWeekdaysMin;\n    hooks.defineLocale          = defineLocale;\n    hooks.updateLocale          = updateLocale;\n    hooks.locales               = listLocales;\n    hooks.weekdaysShort         = listWeekdaysShort;\n    hooks.normalizeUnits        = normalizeUnits;\n    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;\n    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n    hooks.calendarFormat        = getCalendarFormat;\n    hooks.prototype             = proto;\n\n    // currently HTML5 input type only supports 24-hour formats\n    hooks.HTML5_FMT = {\n        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type=\"datetime-local\" />\n        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type=\"datetime-local\" step=\"1\" />\n        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type=\"datetime-local\" step=\"0.001\" />\n        DATE: 'YYYY-MM-DD',                             // <input type=\"date\" />\n        TIME: 'HH:mm',                                  // <input type=\"time\" />\n        TIME_SECONDS: 'HH:mm:ss',                       // <input type=\"time\" step=\"1\" />\n        TIME_MS: 'HH:mm:ss.SSS',                        // <input type=\"time\" step=\"0.001\" />\n        WEEK: 'GGGG-[W]WW',                             // <input type=\"week\" />\n        MONTH: 'YYYY-MM'                                // <input type=\"month\" />\n    };\n\n    return hooks;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/moment/moment.js\n// module id = 453\n// module chunks = 35783957827783","'use strict';\n\nexports.__esModule = true;\nexports.Chart = exports.defaults = exports.Scatter = exports.Bubble = exports.Polar = exports.Radar = exports.HorizontalBar = exports.Bar = exports.Line = exports.Pie = exports.Doughnut = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _chart = require('chart.js');\n\nvar _chart2 = _interopRequireDefault(_chart);\n\nvar _isEqual = require('lodash/isEqual');\n\nvar _isEqual2 = _interopRequireDefault(_isEqual);\n\nvar _keyBy = require('lodash/keyBy');\n\nvar _keyBy2 = _interopRequireDefault(_keyBy);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar NODE_ENV = typeof process !== 'undefined' && process.env && process.env.NODE_ENV;\n\nvar ChartComponent = function (_React$Component) {\n  _inherits(ChartComponent, _React$Component);\n\n  function ChartComponent() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, ChartComponent);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleOnClick = function (event) {\n      var instance = _this.chartInstance;\n\n      var _this$props = _this.props,\n          getDatasetAtEvent = _this$props.getDatasetAtEvent,\n          getElementAtEvent = _this$props.getElementAtEvent,\n          getElementsAtEvent = _this$props.getElementsAtEvent,\n          onElementsClick = _this$props.onElementsClick;\n\n\n      getDatasetAtEvent && getDatasetAtEvent(instance.getDatasetAtEvent(event), event);\n      getElementAtEvent && getElementAtEvent(instance.getElementAtEvent(event), event);\n      getElementsAtEvent && getElementsAtEvent(instance.getElementsAtEvent(event), event);\n      onElementsClick && onElementsClick(instance.getElementsAtEvent(event), event); // Backward compatibility\n    }, _this.ref = function (element) {\n      _this.element = element;\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  ChartComponent.prototype.componentWillMount = function componentWillMount() {\n    this.chartInstance = undefined;\n  };\n\n  ChartComponent.prototype.componentDidMount = function componentDidMount() {\n    this.renderChart();\n  };\n\n  ChartComponent.prototype.componentDidUpdate = function componentDidUpdate() {\n    if (this.props.redraw) {\n      this.destroyChart();\n      this.renderChart();\n      return;\n    }\n\n    this.updateChart();\n  };\n\n  ChartComponent.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {\n    var _props = this.props,\n        redraw = _props.redraw,\n        type = _props.type,\n        options = _props.options,\n        plugins = _props.plugins,\n        legend = _props.legend,\n        height = _props.height,\n        width = _props.width;\n\n\n    if (nextProps.redraw === true) {\n      return true;\n    }\n\n    if (height !== nextProps.height || width !== nextProps.width) {\n      return true;\n    }\n\n    if (type !== nextProps.type) {\n      return true;\n    }\n\n    if (!(0, _isEqual2.default)(legend, nextProps.legend)) {\n      return true;\n    }\n\n    if (!(0, _isEqual2.default)(options, nextProps.options)) {\n      return true;\n    }\n\n    var nextData = this.transformDataProp(nextProps);\n\n    if (!(0, _isEqual2.default)(this.shadowDataProp, nextData)) {\n      return true;\n    }\n\n    return !(0, _isEqual2.default)(plugins, nextProps.plugins);\n  };\n\n  ChartComponent.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.destroyChart();\n  };\n\n  ChartComponent.prototype.transformDataProp = function transformDataProp(props) {\n    var data = props.data;\n\n    if (typeof data == 'function') {\n      var node = this.element;\n      return data(node);\n    } else {\n      return data;\n    }\n  };\n\n  // Chart.js directly mutates the data.dataset objects by adding _meta proprerty\n  // this makes impossible to compare the current and next data changes\n  // therefore we memoize the data prop while sending a fake to Chart.js for mutation.\n  // see https://github.com/chartjs/Chart.js/blob/master/src/core/core.controller.js#L615-L617\n\n\n  ChartComponent.prototype.memoizeDataProps = function memoizeDataProps() {\n    if (!this.props.data) {\n      return;\n    }\n\n    var data = this.transformDataProp(this.props);\n\n    this.shadowDataProp = _extends({}, data, {\n      datasets: data.datasets && data.datasets.map(function (set) {\n        return _extends({}, set);\n      })\n    });\n\n    this.saveCurrentDatasets(); // to remove the dataset metadata from this chart when the chart is destroyed\n\n    return data;\n  };\n\n  ChartComponent.prototype.checkDatasets = function checkDatasets(datasets) {\n    var isDev = NODE_ENV !== 'production' && NODE_ENV !== 'prod';\n    var usingCustomKeyProvider = this.props.datasetKeyProvider !== ChartComponent.getLabelAsKey;\n    var multipleDatasets = datasets.length > 1;\n\n    if (isDev && multipleDatasets && !usingCustomKeyProvider) {\n      var shouldWarn = false;\n      datasets.forEach(function (dataset) {\n        if (!dataset.label) {\n          shouldWarn = true;\n        }\n      });\n\n      if (shouldWarn) {\n        console.error('[react-chartjs-2] Warning: Each dataset needs a unique key. By default, the \"label\" property on each dataset is used. Alternatively, you may provide a \"datasetKeyProvider\" as a prop that returns a unique key.');\n      }\n    }\n  };\n\n  ChartComponent.prototype.getCurrentDatasets = function getCurrentDatasets() {\n    return this.chartInstance && this.chartInstance.config.data && this.chartInstance.config.data.datasets || [];\n  };\n\n  ChartComponent.prototype.saveCurrentDatasets = function saveCurrentDatasets() {\n    var _this2 = this;\n\n    this.datasets = this.datasets || {};\n    var currentDatasets = this.getCurrentDatasets();\n    currentDatasets.forEach(function (d) {\n      _this2.datasets[_this2.props.datasetKeyProvider(d)] = d;\n    });\n  };\n\n  ChartComponent.prototype.updateChart = function updateChart() {\n    var _this3 = this;\n\n    var options = this.props.options;\n\n\n    var data = this.memoizeDataProps(this.props);\n\n    if (!this.chartInstance) return;\n\n    if (options) {\n      this.chartInstance.options = _chart2.default.helpers.configMerge(this.chartInstance.options, options);\n    }\n\n    // Pipe datasets to chart instance datasets enabling\n    // seamless transitions\n    var currentDatasets = this.getCurrentDatasets();\n    var nextDatasets = data.datasets || [];\n    this.checkDatasets(currentDatasets);\n\n    var currentDatasetsIndexed = (0, _keyBy2.default)(currentDatasets, this.props.datasetKeyProvider);\n\n    // We can safely replace the dataset array, as long as we retain the _meta property\n    // on each dataset.\n    this.chartInstance.config.data.datasets = nextDatasets.map(function (next) {\n      var current = currentDatasetsIndexed[_this3.props.datasetKeyProvider(next)];\n\n      if (current && current.type === next.type) {\n        // The data array must be edited in place. As chart.js adds listeners to it.\n        current.data.splice(next.data.length);\n        next.data.forEach(function (point, pid) {\n          current.data[pid] = next.data[pid];\n        });\n\n        var _data = next.data,\n            otherProps = _objectWithoutProperties(next, ['data']);\n        // Merge properties. Notice a weakness here. If a property is removed\n        // from next, it will be retained by current and never disappears.\n        // Workaround is to set value to null or undefined in next.\n\n\n        return _extends({}, current, otherProps);\n      } else {\n        return next;\n      }\n    });\n\n    var datasets = data.datasets,\n        rest = _objectWithoutProperties(data, ['datasets']);\n\n    this.chartInstance.config.data = _extends({}, this.chartInstance.config.data, rest);\n\n    this.chartInstance.update();\n  };\n\n  ChartComponent.prototype.renderChart = function renderChart() {\n    var _props2 = this.props,\n        options = _props2.options,\n        legend = _props2.legend,\n        type = _props2.type,\n        plugins = _props2.plugins;\n\n    var node = this.element;\n    var data = this.memoizeDataProps();\n\n    if (typeof legend !== 'undefined' && !(0, _isEqual2.default)(ChartComponent.defaultProps.legend, legend)) {\n      options.legend = legend;\n    }\n\n    this.chartInstance = new _chart2.default(node, {\n      type: type,\n      data: data,\n      options: options,\n      plugins: plugins\n    });\n  };\n\n  ChartComponent.prototype.destroyChart = function destroyChart() {\n    // Put all of the datasets that have existed in the chart back on the chart\n    // so that the metadata associated with this chart get destroyed.\n    // This allows the datasets to be used in another chart. This can happen,\n    // for example, in a tabbed UI where the chart gets created each time the\n    // tab gets switched to the chart and uses the same data).\n    this.saveCurrentDatasets();\n    var datasets = Object.values(this.datasets);\n    this.chartInstance.config.data.datasets = datasets;\n\n    this.chartInstance.destroy();\n  };\n\n  ChartComponent.prototype.render = function render() {\n    var _props3 = this.props,\n        height = _props3.height,\n        width = _props3.width,\n        id = _props3.id;\n\n\n    return _react2.default.createElement('canvas', {\n      ref: this.ref,\n      height: height,\n      width: width,\n      id: id,\n      onClick: this.handleOnClick\n    });\n  };\n\n  return ChartComponent;\n}(_react2.default.Component);\n\nChartComponent.getLabelAsKey = function (d) {\n  return d.label;\n};\n\nChartComponent.propTypes = {\n  data: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.func]).isRequired,\n  getDatasetAtEvent: _propTypes2.default.func,\n  getElementAtEvent: _propTypes2.default.func,\n  getElementsAtEvent: _propTypes2.default.func,\n  height: _propTypes2.default.number,\n  legend: _propTypes2.default.object,\n  onElementsClick: _propTypes2.default.func,\n  options: _propTypes2.default.object,\n  plugins: _propTypes2.default.arrayOf(_propTypes2.default.object),\n  redraw: _propTypes2.default.bool,\n  type: function type(props, propName, componentName) {\n    if (!_chart2.default.controllers[props[propName]]) {\n      return new Error('Invalid chart type `' + props[propName] + '` supplied to' + ' `' + componentName + '`.');\n    }\n  },\n  width: _propTypes2.default.number,\n  datasetKeyProvider: _propTypes2.default.func\n};\nChartComponent.defaultProps = {\n  legend: {\n    display: true,\n    position: 'bottom'\n  },\n  type: 'doughnut',\n  height: 150,\n  width: 300,\n  redraw: false,\n  options: {},\n  datasetKeyProvider: ChartComponent.getLabelAsKey\n};\nexports.default = ChartComponent;\n\nvar Doughnut = exports.Doughnut = function (_React$Component2) {\n  _inherits(Doughnut, _React$Component2);\n\n  function Doughnut() {\n    _classCallCheck(this, Doughnut);\n\n    return _possibleConstructorReturn(this, _React$Component2.apply(this, arguments));\n  }\n\n  Doughnut.prototype.render = function render() {\n    var _this5 = this;\n\n    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n      ref: function ref(_ref) {\n        return _this5.chartInstance = _ref && _ref.chartInstance;\n      },\n      type: 'doughnut'\n    }));\n  };\n\n  return Doughnut;\n}(_react2.default.Component);\n\nvar Pie = exports.Pie = function (_React$Component3) {\n  _inherits(Pie, _React$Component3);\n\n  function Pie() {\n    _classCallCheck(this, Pie);\n\n    return _possibleConstructorReturn(this, _React$Component3.apply(this, arguments));\n  }\n\n  Pie.prototype.render = function render() {\n    var _this7 = this;\n\n    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n      ref: function ref(_ref2) {\n        return _this7.chartInstance = _ref2 && _ref2.chartInstance;\n      },\n      type: 'pie'\n    }));\n  };\n\n  return Pie;\n}(_react2.default.Component);\n\nvar Line = exports.Line = function (_React$Component4) {\n  _inherits(Line, _React$Component4);\n\n  function Line() {\n    _classCallCheck(this, Line);\n\n    return _possibleConstructorReturn(this, _React$Component4.apply(this, arguments));\n  }\n\n  Line.prototype.render = function render() {\n    var _this9 = this;\n\n    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n      ref: function ref(_ref3) {\n        return _this9.chartInstance = _ref3 && _ref3.chartInstance;\n      },\n      type: 'line'\n    }));\n  };\n\n  return Line;\n}(_react2.default.Component);\n\nvar Bar = exports.Bar = function (_React$Component5) {\n  _inherits(Bar, _React$Component5);\n\n  function Bar() {\n    _classCallCheck(this, Bar);\n\n    return _possibleConstructorReturn(this, _React$Component5.apply(this, arguments));\n  }\n\n  Bar.prototype.render = function render() {\n    var _this11 = this;\n\n    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n      ref: function ref(_ref4) {\n        return _this11.chartInstance = _ref4 && _ref4.chartInstance;\n      },\n      type: 'bar'\n    }));\n  };\n\n  return Bar;\n}(_react2.default.Component);\n\nvar HorizontalBar = exports.HorizontalBar = function (_React$Component6) {\n  _inherits(HorizontalBar, _React$Component6);\n\n  function HorizontalBar() {\n    _classCallCheck(this, HorizontalBar);\n\n    return _possibleConstructorReturn(this, _React$Component6.apply(this, arguments));\n  }\n\n  HorizontalBar.prototype.render = function render() {\n    var _this13 = this;\n\n    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n      ref: function ref(_ref5) {\n        return _this13.chartInstance = _ref5 && _ref5.chartInstance;\n      },\n      type: 'horizontalBar'\n    }));\n  };\n\n  return HorizontalBar;\n}(_react2.default.Component);\n\nvar Radar = exports.Radar = function (_React$Component7) {\n  _inherits(Radar, _React$Component7);\n\n  function Radar() {\n    _classCallCheck(this, Radar);\n\n    return _possibleConstructorReturn(this, _React$Component7.apply(this, arguments));\n  }\n\n  Radar.prototype.render = function render() {\n    var _this15 = this;\n\n    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n      ref: function ref(_ref6) {\n        return _this15.chartInstance = _ref6 && _ref6.chartInstance;\n      },\n      type: 'radar'\n    }));\n  };\n\n  return Radar;\n}(_react2.default.Component);\n\nvar Polar = exports.Polar = function (_React$Component8) {\n  _inherits(Polar, _React$Component8);\n\n  function Polar() {\n    _classCallCheck(this, Polar);\n\n    return _possibleConstructorReturn(this, _React$Component8.apply(this, arguments));\n  }\n\n  Polar.prototype.render = function render() {\n    var _this17 = this;\n\n    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n      ref: function ref(_ref7) {\n        return _this17.chartInstance = _ref7 && _ref7.chartInstance;\n      },\n      type: 'polarArea'\n    }));\n  };\n\n  return Polar;\n}(_react2.default.Component);\n\nvar Bubble = exports.Bubble = function (_React$Component9) {\n  _inherits(Bubble, _React$Component9);\n\n  function Bubble() {\n    _classCallCheck(this, Bubble);\n\n    return _possibleConstructorReturn(this, _React$Component9.apply(this, arguments));\n  }\n\n  Bubble.prototype.render = function render() {\n    var _this19 = this;\n\n    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n      ref: function ref(_ref8) {\n        return _this19.chartInstance = _ref8 && _ref8.chartInstance;\n      },\n      type: 'bubble'\n    }));\n  };\n\n  return Bubble;\n}(_react2.default.Component);\n\nvar Scatter = exports.Scatter = function (_React$Component10) {\n  _inherits(Scatter, _React$Component10);\n\n  function Scatter() {\n    _classCallCheck(this, Scatter);\n\n    return _possibleConstructorReturn(this, _React$Component10.apply(this, arguments));\n  }\n\n  Scatter.prototype.render = function render() {\n    var _this21 = this;\n\n    return _react2.default.createElement(ChartComponent, _extends({}, this.props, {\n      ref: function ref(_ref9) {\n        return _this21.chartInstance = _ref9 && _ref9.chartInstance;\n      },\n      type: 'scatter'\n    }));\n  };\n\n  return Scatter;\n}(_react2.default.Component);\n\nvar defaults = exports.defaults = _chart2.default.defaults;\nexports.Chart = _chart2.default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/react-chartjs-2/lib/index.js\n// module id = 457\n// module chunks = 35783957827783"],"sourceRoot":""}